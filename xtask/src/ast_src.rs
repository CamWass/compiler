//! Defines input for code generation process.

pub(crate) struct KindsSrc<'a> {
    pub(crate) punct: &'a [(&'a str, &'a str)],
    pub(crate) keywords: &'a [(&'a str, &'a str)],
    pub(crate) literals: &'a [&'a str],
    pub(crate) tokens: &'a [&'a str],
    pub(crate) nodes: &'a [&'a str],
}

pub(crate) const KINDS_SRC: KindsSrc<'_> = KindsSrc {
    punct: &[
        ("{", "OpenBraceToken"),
        ("}", "CloseBraceToken"),
        ("(", "OpenParenToken"),
        (")", "CloseParenToken"),
        ("[", "OpenBracketToken"),
        ("]", "CloseBracketToken"),
        (".", "DotToken"),
        ("...", "DotDotDotToken"),
        (";", "SemicolonToken"),
        (",", "CommaToken"),
        ("<", "LessThanToken"),
        (">", "GreaterThanToken"),
        ("<=", "LessThanEqualsToken"),
        (">=", "GreaterThanEqualsToken"),
        ("==", "EqualsEqualsToken"),
        ("!=", "ExclamationEqualsToken"),
        ("===", "EqualsEqualsEqualsToken"),
        ("!==", "ExclamationEqualsEqualsToken"),
        ("=>", "EqualsGreaterThanToken"),
        ("+", "PlusToken"),
        ("-", "MinusToken"),
        ("**", "AsteriskAsteriskToken"),
        ("*", "AsteriskToken"),
        ("/", "SlashToken"),
        ("%", "PercentToken"),
        ("++", "PlusPlusToken"),
        ("--", "MinusMinusToken"),
        ("<<", "LessThanLessThanToken"),
        ("</", "LessThanSlashToken"),
        (">>", "GreaterThanGreaterThanToken"),
        (">>>", "GreaterThanGreaterThanGreaterThanToken"),
        ("&", "AmpersandToken"),
        ("|", "BarToken"),
        ("^", "CaretToken"),
        ("!", "ExclamationToken"),
        ("~", "TildeToken"),
        ("&&", "AmpersandAmpersandToken"),
        ("||", "BarBarToken"),
        ("?", "QuestionToken"),
        ("??", "QuestionQuestionToken"),
        ("?.", "QuestionDotToken"),
        (":", "ColonToken"),
        ("=", "EqualsToken"),
        ("+=", "PlusEqualsToken"),
        ("-=", "MinusEqualsToken"),
        ("*=", "AsteriskEqualsToken"),
        ("**=", "AsteriskAsteriskEqualsToken"),
        ("/=", "SlashEqualsToken"),
        ("%=", "PercentEqualsToken"),
        ("<<=", "LessThanLessThanEqualsToken"),
        (">>=", "GreaterThanGreaterThanEqualsToken"),
        (">>>=", "GreaterThanGreaterThanGreaterThanEqualsToken"),
        ("&=", "AmpersandEqualsToken"),
        ("|=", "BarEqualsToken"),
        ("^=", "CaretEqualsToken"),
        ("||=", "BarBarEqualsToken"),
        ("&&=", "AmpersandAmpersandEqualsToken"),
        ("??=", "QuestionQuestionEqualsToken"),
        ("@", "AtToken"),
        ("#", "HashToken"),
        ("`", "BacktickToken"),
    ],
    keywords: &[
        ("abstract", "AbstractKeyword"),
        ("any", "AnyKeyword"),
        ("as", "AsKeyword"),
        ("asserts", "AssertsKeyword"),
        ("assert", "AssertKeyword"),
        ("bigint", "BigIntKeyword"),
        ("boolean", "BooleanKeyword"),
        ("break", "BreakKeyword"),
        ("case", "CaseKeyword"),
        ("catch", "CatchKeyword"),
        ("class", "ClassKeyword"),
        ("continue", "ContinueKeyword"),
        ("const", "ConstKeyword"),
        ("constructor", "ConstructorKeyword"),
        ("debugger", "DebuggerKeyword"),
        ("declare", "DeclareKeyword"),
        ("default", "DefaultKeyword"),
        ("delete", "DeleteKeyword"),
        ("do", "DoKeyword"),
        ("else", "ElseKeyword"),
        ("enum", "EnumKeyword"),
        ("export", "ExportKeyword"),
        ("extends", "ExtendsKeyword"),
        ("false", "FalseKeyword"),
        ("finally", "FinallyKeyword"),
        ("for", "ForKeyword"),
        ("from", "FromKeyword"),
        ("function", "FunctionKeyword"),
        ("get", "GetKeyword"),
        ("if", "IfKeyword"),
        ("implements", "ImplementsKeyword"),
        ("import", "ImportKeyword"),
        ("in", "InKeyword"),
        ("infer", "InferKeyword"),
        ("instanceof", "InstanceOfKeyword"),
        ("interface", "InterfaceKeyword"),
        ("intrinsic", "IntrinsicKeyword"),
        ("is", "IsKeyword"),
        ("keyof", "KeyOfKeyword"),
        ("let", "LetKeyword"),
        ("module", "ModuleKeyword"),
        ("namespace", "NamespaceKeyword"),
        ("never", "NeverKeyword"),
        ("new", "NewKeyword"),
        ("null", "NullKeyword"),
        ("number", "NumberKeyword"),
        ("object", "ObjectKeyword"),
        ("package", "PackageKeyword"),
        ("private", "PrivateKeyword"),
        ("protected", "ProtectedKeyword"),
        ("public", "PublicKeyword"),
        ("override", "OverrideKeyword"),
        ("readonly", "ReadonlyKeyword"),
        ("require", "RequireKeyword"),
        ("global", "GlobalKeyword"),
        ("return", "ReturnKeyword"),
        ("set", "SetKeyword"),
        ("static", "StaticKeyword"),
        ("string", "StringKeyword"),
        ("super", "SuperKeyword"),
        ("switch", "SwitchKeyword"),
        ("symbol", "SymbolKeyword"),
        ("this", "ThisKeyword"),
        ("throw", "ThrowKeyword"),
        ("true", "TrueKeyword"),
        ("try", "TryKeyword"),
        ("type", "TypeKeyword"),
        ("typeof", "TypeOfKeyword"),
        ("undefined", "UndefinedKeyword"),
        ("unique", "UniqueKeyword"),
        ("unknown", "UnknownKeyword"),
        ("var", "VarKeyword"),
        ("void", "VoidKeyword"),
        ("while", "WhileKeyword"),
        ("with", "WithKeyword"),
        ("yield", "YieldKeyword"),
        ("async", "AsyncKeyword"),
        ("await", "AwaitKeyword"),
        ("of", "OfKeyword"),
    ],
    literals: &[
        "NumericLiteral",
        "BigIntLiteral",
        "StringLiteral",
        "JsxText",
        "JsxTextAllWhiteSpaces",
        "RegularExpressionLiteral",
        "NoSubstitutionTemplateLiteral",
        // Pseudo-literals
        "TemplateHead",
        "TemplateMiddle",
        "TemplateTail",
    ],
    tokens: &[
        "Unknown",
        "EndOfFileToken",
        "SingleLineCommentTrivia",
        "MultiLineCommentTrivia",
        "NewLineTrivia",
        "WhitespaceTrivia",
        // We detect and preserve #! on the first line
        "ShebangTrivia",
        // We detect and provide better error recovery when we encounter a git merge marker.  This
        // allows us to edit files with git-conflict markers in them in a much more pleasant manner.
        "ConflictMarkerTrivia",
        // Identifiers and PrivateIdentifiers
        "Identifier",
        "PrivateIdentifier",
    ],
    nodes: &[
        // Names
        "QualifiedName",
        "ComputedPropertyName",
        // Signature elements
        "TypeParameter",
        "Parameter",
        "Decorator",
        // TypeMember
        "PropertySignature",
        "PropertyDeclaration",
        "MethodSignature",
        "MethodDeclaration",
        "ClassStaticBlockDeclaration",
        "Constructor",
        "GetAccessor",
        "SetAccessor",
        "CallSignature",
        "ConstructSignature",
        "IndexSignature",
        // Type
        "TypePredicate",
        "TypeReference",
        "FunctionType",
        "ConstructorType",
        "TypeQuery",
        "TypeLiteral",
        "ArrayType",
        "TupleType",
        "OptionalType",
        "RestType",
        "UnionType",
        "IntersectionType",
        "ConditionalType",
        "InferType",
        "ParenthesizedType",
        "ThisType",
        "TypeOperator",
        "IndexedAccessType",
        "MappedType",
        "LiteralType",
        "NamedTupleMember",
        "TemplateLiteralType",
        "TemplateLiteralTypeSpan",
        "ImportType",
        // Binding patterns
        "ObjectBindingPattern",
        "ArrayBindingPattern",
        "BindingElement",
        // Expression
        "ArrayLiteralExpression",
        "ObjectLiteralExpression",
        "PropertyAccessExpression",
        "ElementAccessExpression",
        "CallExpression",
        "NewExpression",
        "TaggedTemplateExpression",
        "TypeAssertionExpression",
        "ParenthesizedExpression",
        "FunctionExpression",
        "ArrowFunction",
        "DeleteExpression",
        "TypeOfExpression",
        "VoidExpression",
        "AwaitExpression",
        "PrefixUnaryExpression",
        "PostfixUnaryExpression",
        "BinaryExpression",
        "ConditionalExpression",
        "TemplateExpression",
        "YieldExpression",
        "SpreadElement",
        "ClassExpression",
        "OmittedExpression",
        "ExpressionWithTypeArguments",
        "AsExpression",
        "NonNullExpression",
        "MetaProperty",
        "SyntheticExpression",
        // Misc
        "TemplateSpan",
        "SemicolonClassElement",
        // Element
        "Block",
        "EmptyStatement",
        "VariableStatement",
        "ExpressionStatement",
        "IfStatement",
        "DoStatement",
        "WhileStatement",
        "ForStatement",
        "ForInStatement",
        "ForOfStatement",
        "ContinueStatement",
        "BreakStatement",
        "ReturnStatement",
        "WithStatement",
        "SwitchStatement",
        "LabeledStatement",
        "ThrowStatement",
        "TryStatement",
        "DebuggerStatement",
        "VariableDeclaration",
        "VariableDeclarationList",
        "FunctionDeclaration",
        "ClassDeclaration",
        "InterfaceDeclaration",
        "TypeAliasDeclaration",
        "EnumDeclaration",
        "ModuleDeclaration",
        "ModuleBlock",
        "CaseBlock",
        "NamespaceExportDeclaration",
        "ImportEqualsDeclaration",
        "ImportDeclaration",
        "ImportClause",
        "NamespaceImport",
        "NamedImports",
        "ImportSpecifier",
        "ExportAssignment",
        "ExportDeclaration",
        "NamedExports",
        "NamespaceExport",
        "ExportSpecifier",
        "MissingDeclaration",
        // Module references
        "ExternalModuleReference",
        // JSX
        "JsxElement",
        "JsxSelfClosingElement",
        "JsxOpeningElement",
        "JsxClosingElement",
        "JsxFragment",
        "JsxOpeningFragment",
        "JsxClosingFragment",
        "JsxAttribute",
        "JsxAttributes",
        "JsxSpreadAttribute",
        "JsxExpression",
        // Clauses
        "CaseClause",
        "DefaultClause",
        "HeritageClause",
        "CatchClause",
        "AssertClause",
        "AssertEntry",
        // Property assignments
        "PropertyAssignment",
        "ShorthandPropertyAssignment",
        "SpreadAssignment",
        // Enum
        "EnumMember",
        // Unparsed
        "UnparsedPrologue",
        "UnparsedPrepend",
        "UnparsedText",
        "UnparsedInternalText",
        "UnparsedSyntheticReference",
        // Top-level nodes
        "SourceFile",
        "Bundle",
        "UnparsedSource",
        "InputFiles",
        // JSDoc nodes
        "JSDocTypeExpression",
        "JSDocNameReference",
        "JSDocMemberName",  // C#p
        "JSDocAllType",     // The * type
        "JSDocUnknownType", // The ? type
        "JSDocNullableType",
        "JSDocNonNullableType",
        "JSDocOptionalType",
        "JSDocFunctionType",
        "JSDocVariadicType",
        "JSDocNamepathType", // https://jsdoc.app/about-namepaths.html
        "JSDocComment",
        "JSDocText",
        "JSDocTypeLiteral",
        "JSDocSignature",
        "JSDocLink",
        "JSDocLinkCode",
        "JSDocLinkPlain",
        "JSDocTag",
        "JSDocAugmentsTag",
        "JSDocImplementsTag",
        "JSDocAuthorTag",
        "JSDocDeprecatedTag",
        "JSDocClassTag",
        "JSDocPublicTag",
        "JSDocPrivateTag",
        "JSDocProtectedTag",
        "JSDocReadonlyTag",
        "JSDocOverrideTag",
        "JSDocCallbackTag",
        "JSDocEnumTag",
        "JSDocParameterTag",
        "JSDocReturnTag",
        "JSDocThisTag",
        "JSDocTypeTag",
        "JSDocTemplateTag",
        "JSDocTypedefTag",
        "JSDocSeeTag",
        "JSDocPropertyTag",
        // Synthesized list
        "SyntaxList",
        // Transformation nodes
        "NotEmittedStatement",
        "PartiallyEmittedExpression",
        "CommaListExpression",
        "MergeDeclarationMarker",
        "EndOfDeclarationMarker",
        "SyntheticReferenceExpression",
    ],
};

#[derive(Default, Debug)]
pub(crate) struct AstSrc {
    pub(crate) nodes: Vec<AstNodeSrc>,
    pub(crate) enums: Vec<AstEnumSrc>,
}

#[derive(Debug)]
pub(crate) struct AstNodeSrc {
    pub(crate) doc: Vec<String>,
    pub(crate) name: String,
    pub(crate) traits: Vec<String>,
    pub(crate) fields: Vec<Field>,
}

#[derive(Debug, Eq, PartialEq)]
pub(crate) enum Field {
    Token(String),
    Node {
        name: String,
        ty: String,
        cardinality: Cardinality,
    },
}

#[derive(Debug, Eq, PartialEq)]
pub(crate) enum Cardinality {
    Optional,
    Many,
}

#[derive(Debug)]
pub(crate) struct AstEnumSrc {
    pub(crate) doc: Vec<String>,
    pub(crate) name: String,
    pub(crate) traits: Vec<String>,
    pub(crate) variants: Vec<String>,
}
