mod flow;
mod index_set;
mod node_builder;

use crate::ast;
use crate::binder::Binder;
use crate::convert::{ecma_number_to_string, ecma_string_to_number, is_numeric_literal_name};
use crate::node::*;
use crate::types::*;
use crate::types_composition::*;
use crate::utils::*;
use crate::CompilerOptions;
use crate::TypeCheckerHost;
use crate::{Visit, VisitWith};
use ahash::{AHashMap, AHashSet};
use bitflags::bitflags;
use global_common::integer_decode::{integer_decode, DecodedF64};
use index::vec::IndexVec;
use index_set::IndexSet;
use std::cmp;
use std::collections::hash_map::Entry;
use std::convert::TryFrom;
use std::hash::Hash;
use std::hash::Hasher;
use std::iter::FromIterator;
use std::mem;
use std::rc::Rc;
use swc_atoms::{js_word, JsWord};

// fn with_table<T: Default, F, Ret>(table: &mut T, op: F) -> Ret
// where
//     F: FnOnce(&mut T) -> Ret,
// {
//     let mut t = mem::take(table);
//     let res = op(&mut t);
//     *table = t;
//     res
// }

macro_rules! with_table {
    ($ident:ident = $table:expr, $block:block) => {{
        let $ident = mem::take($table);
        let res = $block;
        *$table = $ident;
        res
    }};
}

pub struct Checker {
    //////////////////// TSC: /////////////////////
    // typeCount: usize,
    // symbolCount: usize,
    // enumCount: usize,
    // totalInstantiationCount: usize,
    instantiationCount: usize,
    instantiationDepth: usize,
    inlineLevel: usize,
    currentNode: Option<BoundNode>,

    emptySymbols: SymbolTableId,
    // const arrayVariances = [VarianceFlags.Covariant];
    compilerOptions: CompilerOptions,
    languageVersion: ScriptTarget,
    // moduleKind = getEmitModuleKind(compilerOptions);
    useDefineForClassFields: bool,
    allowSyntheticDefaultImports: bool,
    strictNullChecks: bool,
    strictFunctionTypes: bool,
    strictBindCallApply: bool,
    strictPropertyInitialization: bool,
    noImplicitAny: bool,
    noImplicitThis: bool,
    useUnknownInCatchVariables: bool,
    keyofStringsOnly: bool,
    freshObjectLiteralFlag: ObjectFlags,
    exactOptionalPropertyTypes: bool,

    // const checkBinaryExpression = createCheckBinaryExpression();
    // const emitResolver = createResolver();
    // const nodeBuilder = createNodeBuilder();
    globals: SymbolTableId,
    undefinedSymbol: SymbolId,

    globalThisSymbol: SymbolId,

    argumentsSymbol: SymbolId,
    requireSymbol: SymbolId,

    /// This will be set during calls to `getResolvedSignature` where services determines an apparent number of arguments greater than what is actually provided.
    apparentArgumentCount: Option<usize>,

    // function getResolvedSignatureWorker(nodeIn: CallLikeExpression, candidatesOutArray: Signature[] | undefined, argumentCount: number | undefined, checkMode: CheckMode): Signature | undefined {
    //     const node = getParseTreeNode(nodeIn, isCallLikeExpression);
    //     apparentArgumentCount = argumentCount;
    //     const res = node ? getResolvedSignature(node, candidatesOutArray, checkMode) : undefined;
    //     apparentArgumentCount = undefined;
    //     return res;
    // }
    tupleTypes: AHashMap<TupleTypeKey, TypeId>,
    unionTypes: AHashMap<UnionTypeKey, TypeId>,
    intersectionTypes: AHashMap<IntersectionTypeKey, TypeId>,
    stringLiteralTypes: AHashMap<JsWord, TypeId>,
    numberLiteralTypes: AHashMap<DecodedF64, TypeId>,
    // const bigIntLiteralTypes = new Map<string, BigIntLiteralType>();
    // const enumLiteralTypes = new Map<string, LiteralType>();
    // const indexedAccessTypes = new Map<string, IndexedAccessType>();
    // const templateLiteralTypes = new Map<string, TemplateLiteralType>();
    // const stringMappingTypes = new Map<string, StringMappingType>();
    substitutionTypes: AHashMap<SubstitutionTypeKey, TypeId>,
    subtypeReductionCache: AHashMap<TypeList, Vec<TypeId>>,
    // const evolvingArrayTypes: EvolvingArrayType[] = [];
    undefinedProperties: SymbolTable,
    unknownSymbol: SymbolId,
    resolvingSymbol: SymbolId,
    // const unresolvedSymbols = new Map<string, TransientSymbol>();
    // const errorTypes = new Map<string, Type>();
    pub anyType: TypeId,
    autoType: TypeId,
    wildcardType: TypeId,
    errorType: TypeId,
    unresolvedType: TypeId,
    nonInferrableAnyType: TypeId,
    intrinsicMarkerType: TypeId,
    pub unknownType: TypeId,
    nonNullUnknownType: TypeId,
    undefinedType: TypeId,
    undefinedWideningType: TypeId,
    optionalType: TypeId,
    missingType: TypeId,
    pub nullType: TypeId,
    nullWideningType: TypeId,
    pub stringType: TypeId,
    pub numberType: TypeId,
    pub bigintType: TypeId,
    pub falseType: TypeId,
    pub regularFalseType: TypeId,
    pub trueType: TypeId,
    pub regularTrueType: TypeId,
    booleanType: Option<TypeId>,
    pub esSymbolType: TypeId,
    pub voidType: TypeId,
    neverType: TypeId,
    silentNeverType: TypeId,
    nonInferrableType: TypeId,
    implicitNeverType: TypeId,
    unreachableNeverType: TypeId,
    pub nonPrimitiveType: TypeId,
    // const stringOrNumberType = getUnionType([stringType, numberType]);
    stringNumberSymbolType: Option<TypeId>,
    keyofConstraintType: Option<TypeId>,
    // const numberOrBigIntType = getUnionType([numberType, bigintType]);
    // const templateConstraintType = getUnionType([stringType, numberType, booleanType, bigintType, nullType, undefinedType]) as UnionType;

    // const restrictiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags::TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t);
    // const permissiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags::TypeParameter ? wildcardType : t);
    emptyObjectType: TypeId,
    // const emptyJsxObjectType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
    emptyTypeLiteralSymbol: SymbolId,
    emptyTypeLiteralType: TypeId,
    emptyGenericType: TypeId,

    anyFunctionType: TypeId,
    noConstraintType: TypeId,
    circularConstraintType: TypeId,
    resolvingDefaultType: TypeId,

    // const markerSuperType = createTypeParameter();
    // const markerSubType = createTypeParameter();
    // markerSubType.constraint = markerSuperType;
    // const markerOtherType = createTypeParameter();
    noTypePredicate: TypePredicate,
    anySignature: SignatureId,
    unknownSignature: SignatureId,
    resolvingSignature: SignatureId,
    silentNeverSignature: SignatureId,

    enumNumberIndexInfo: IndexInfoId,

    // const iterationTypesCache = new Map<string, IterationTypes>(); // cache for common IterationTypes instances
    // const noIterationTypes: IterationTypes = {
    //     get yieldType(): Type { return Debug.fail("Not supported"); },
    //     get returnType(): Type { return Debug.fail("Not supported"); },
    //     get nextType(): Type { return Debug.fail("Not supported"); },
    // };

    // const anyIterationTypes = createIterationTypes(anyType, anyType, anyType);
    // const anyIterationTypesExceptNext = createIterationTypes(anyType, anyType, unknownType);
    // const defaultIterationTypes = createIterationTypes(neverType, anyType, undefinedType); // default iteration types for `Iterator`.

    // const asyncIterationTypesResolver: IterationTypesResolver = {
    //     iterableCacheKey: "iterationTypesOfAsyncIterable",
    //     iteratorCacheKey: "iterationTypesOfAsyncIterator",
    //     iteratorSymbolName: "asyncIterator",
    //     getGlobalIteratorType: getGlobalAsyncIteratorType,
    //     getGlobalIterableType: getGlobalAsyncIterableType,
    //     getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,
    //     getGlobalGeneratorType: getGlobalAsyncGeneratorType,
    //     resolveIterationType: getAwaitedType,
    //     mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,
    //     mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
    //     mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
    // };

    // const syncIterationTypesResolver: IterationTypesResolver = {
    //     iterableCacheKey: "iterationTypesOfIterable",
    //     iteratorCacheKey: "iterationTypesOfIterator",
    //     iteratorSymbolName: "iterator",
    //     getGlobalIteratorType,
    //     getGlobalIterableType,
    //     getGlobalIterableIteratorType,
    //     getGlobalGeneratorType,
    //     resolveIterationType: (type, _errorNode) => type,
    //     mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,
    //     mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
    //     mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
    // };

    // interface DuplicateInfoForSymbol {
    //     readonly firstFileLocations: Declaration[];
    //     readonly secondFileLocations: Declaration[];
    //     readonly isBlockScoped: boolean;
    // }
    // interface DuplicateInfoForFiles {
    //     readonly firstFile: SourceFile;
    //     readonly secondFile: SourceFile;
    //     /** Key is symbol name. */
    //     readonly conflictingSymbols: ESMap<string, DuplicateInfoForSymbol>;
    // }
    // /** Key is "/path/to/a.ts|/path/to/b.ts". */
    // let amalgamatedDuplicates: ESMap<string, DuplicateInfoForFiles> | undefined;
    // const reverseMappedCache = new Map<string, Type | undefined>();
    // let inInferTypeForHomomorphicMappedType = false;
    // let ambientModulesCache: Symbol[] | undefined;
    // /**
    //  * List of every ambient module with a "*" wildcard.
    //  * Unlike other ambient modules, these can't be stored in `globals` because symbol tables only deal with exact matches.
    //  * This is only used if there is no exact match.
    //  */
    // let patternAmbientModules: PatternAmbientModule[];
    // let patternAmbientModuleAugmentations: ESMap<string, Symbol> | undefined;
    globalObjectType: Option<TypeId>,
    globalFunctionType: Option<TypeId>,
    globalCallableFunctionType: Option<TypeId>,
    globalNewableFunctionType: Option<TypeId>,
    globalArrayType: Option<TypeId>,
    globalReadonlyArrayType: Option<TypeId>,
    globalStringType: Option<TypeId>,
    globalNumberType: Option<TypeId>,
    globalBooleanType: Option<TypeId>,
    globalRegExpType: Option<TypeId>,
    globalThisType: Option<TypeId>,
    anyArrayType: Option<TypeId>,
    autoArrayType: Option<TypeId>,
    anyReadonlyArrayType: Option<TypeId>,
    deferredGlobalNonNullableTypeAlias: Option<SymbolId>,

    // // The library files are only loaded when the feature is used.
    // // This allows users to just specify library files they want to used through --lib
    // // and they will not get an error from not having unrelated library files
    // let deferredGlobalESSymbolConstructorSymbol: Symbol | undefined;
    // let deferredGlobalESSymbolConstructorTypeSymbol: Symbol | undefined;
    // let deferredGlobalESSymbolType: ObjectType | undefined;
    // let deferredGlobalTypedPropertyDescriptorType: GenericType;
    // let deferredGlobalPromiseType: GenericType | undefined;
    // let deferredGlobalPromiseLikeType: GenericType | undefined;
    // let deferredGlobalPromiseConstructorSymbol: Symbol | undefined;
    // let deferredGlobalPromiseConstructorLikeType: ObjectType | undefined;
    // let deferredGlobalIterableType: GenericType | undefined;
    // let deferredGlobalIteratorType: GenericType | undefined;
    // let deferredGlobalIterableIteratorType: GenericType | undefined;
    // let deferredGlobalGeneratorType: GenericType | undefined;
    // let deferredGlobalIteratorYieldResultType: GenericType | undefined;
    // let deferredGlobalIteratorReturnResultType: GenericType | undefined;
    // let deferredGlobalAsyncIterableType: GenericType | undefined;
    // let deferredGlobalAsyncIteratorType: GenericType | undefined;
    // let deferredGlobalAsyncIterableIteratorType: GenericType | undefined;
    // let deferredGlobalAsyncGeneratorType: GenericType | undefined;
    // let deferredGlobalTemplateStringsArrayType: ObjectType | undefined;
    // let deferredGlobalImportMetaType: ObjectType;
    // let deferredGlobalImportMetaExpressionType: ObjectType;
    // let deferredGlobalImportCallOptionsType: ObjectType | undefined;
    // let deferredGlobalExtractSymbol: Symbol | undefined;
    // let deferredGlobalOmitSymbol: Symbol | undefined;
    // let deferredGlobalAwaitedSymbol: Symbol | undefined;
    // let deferredGlobalBigIntType: ObjectType | undefined;

    // const allPotentiallyUnusedIdentifiers = new Map<Path, PotentiallyUnusedIdentifier[]>(); // key is file name
    flowLoopStart: usize,
    flowLoopCount: usize,
    sharedFlowCount: usize,
    flowAnalysisDisabled: bool,
    flowInvocationCount: usize,
    lastFlowNode: Option<FlowNodeId>,
    lastFlowNodeReachable: bool,
    flowTypeCache: AHashMap<BoundNode, TypeId>,

    // const emptyStringType = getStringLiteralType("");
    // const zeroType = getNumberLiteralType(0);
    // const zeroBigIntType = getBigIntLiteralType({ negative: false, base10Value: "0" });
    resolutionTargets: Vec<TypeSystemEntity>,
    resolutionResults: Vec<bool>,
    resolutionPropertyNames: Vec<TypeSystemPropertyName>,

    // let suggestionCount = 0;
    // const maximumSuggestionCount = 10;
    mergedSymbols: IndexVec<SymbolMergeId, SymbolId>,
    symbolLinks: AHashMap<SymbolId, SymbolLinks>,
    nodeLinks: AHashMap<BoundNode, NodeLinks>,
    // const flowLoopCaches: ESMap<string, Type>[] = [];
    // const flowLoopNodes: FlowNode[] = [];
    // const flowLoopKeys: string[] = [];
    // const flowLoopTypes: Type[][] = [];
    sharedFlowNodes: Vec<FlowNodeId>,
    sharedFlowTypes: Vec<FlowType>,
    // const flowNodeReachable: (boolean | undefined)[] = [];
    flowNodePostSuper: AHashMap<FlowNodeId, bool>,
    // const potentialThisCollisions: Node[] = [];
    // const potentialNewTargetCollisions: Node[] = [];
    // const potentialWeakMapSetCollisions: Node[] = [];
    // const potentialReflectCollisions: Node[] = [];
    // const awaitedTypeStack: number[] = [];

    // const diagnostics = createDiagnosticCollection();
    // const suggestionDiagnostics = createDiagnosticCollection();

    // const typeofTypesByName: ReadonlyESMap<string, Type> = new Map(getEntries({
    //     string: stringType,
    //     number: numberType,
    //     bigint: bigintType,
    //     boolean: booleanType,
    //     symbol: esSymbolType,
    //     undefined: undefinedType
    // }));
    // const typeofType = createTypeofType();

    // let _jsxNamespace: __String;
    // let _jsxFactoryEntity: EntityName | undefined;
    // let outofbandVarianceMarkerHandler: ((onlyUnreliable: boolean) => void) | undefined;
    subtypeRelation: TypeRelationTableId,
    strictSubtypeRelation: TypeRelationTableId,
    assignableRelation: TypeRelationTableId,
    comparableRelation: TypeRelationTableId,
    identityRelation: TypeRelationTableId,
    enumRelation: TypeRelationTableId,
    builtinGlobals: SymbolTableId,
    ///////////////////////////////////////////////

    //////////////////// Ours: ////////////////////
    node_data: AHashMap<BoundNode, NodeData>,
    flow_nodes: IndexVec<FlowNodeId, FlowNode>,
    pub symbols: IndexVec<SymbolId, Symbol>,

    pub types: IndexVec<TypeId, Type>,
    host: TypeCheckerHost,
    signatures: IndexVec<SignatureId, Signature>,
    pub symbol_tables: IndexVec<SymbolTableId, SymbolTable>,
    // TODO: maybe rename to index_info?
    index_infos: IndexVec<IndexInfoId, IndexInfo>,
    produceDiagnostics: bool,
    type_relations: IndexVec<TypeRelationTableId, TypeRelationTable>,
    pub inference_contexts: IndexVec<InferenceContextId, InferenceContext>,
    // ConditionalRoots need to be hashed, but contain a hashmap, so they can't impl Hash.
    // To get around this, we use an IndexVec, and hash the IDs.
    conditional_roots: IndexVec<ConditionalRootId, ConditionalRoot>,
    widening_contexts: IndexVec<WideningContextId, WideningContext>,
    ///////////////////////////////////////////////
}

impl Checker {
    pub fn new(mut host: TypeCheckerHost, produceDiagnostics: bool) -> Self {
        // TODO: comment from tsc
        let mut bind_res = Binder::bind_source_files(&mut host.files);

        // const getPackagesMap = memoize(() => {
        //     // A package name maps to true when we detect it has .d.ts files.
        //     // This is useful as an approximation of whether a package bundles its own types.
        //     // Note: we only look at files already found by module resolution,
        //     // so there may be files we did not consider.
        //     const map = new Map<string, boolean>();
        //     host.getSourceFiles().forEach(sf => {
        //         if (!sf.resolvedModules) return;

        //         sf.resolvedModules.forEach(r => {
        //             if (r && r.packageId) map.set(r.packageId.name, r.extension === Extension.Dts || !!map.get(r.packageId.name));
        //         });
        //     });
        //     return map;
        // });

        // // Cancellation that controls whether or not we can cancel in the middle of type checking.
        // // In general cancelling is *not* safe for the type checker.  We might be in the middle of
        // // computing something, and we will leave our internals in an inconsistent state.  Callers
        // // who set the cancellation token should catch if a cancellation exception occurs, and
        // // should throw away and create a new TypeChecker.
        // //
        // // Currently we only support setting the cancellation token when getting diagnostics.  This
        // // is because diagnostics can be quite expensive, and we want to allow hosts to bail out if
        // // they no longer need the information (for example, if the user started editing again).
        // let cancellationToken: CancellationToken | undefined;
        // let requestedExternalEmitHelpers: ExternalEmitHelpers;
        // let externalHelpersModule: Symbol;

        // const Symbol = objectAllocator.getSymbolConstructor();
        // const Type = objectAllocator.getTypeConstructor();
        // const Signature = objectAllocator.getSignatureConstructor();

        // let typeCount = 0;
        // let symbolCount = 0;
        // let enumCount = 0;
        // let totalInstantiationCount = 0;

        let emptySymbols = bind_res.symbol_tables.push(SymbolTable::default());
        // const arrayVariances = [VarianceFlags.Covariant];

        let compilerOptions = host.compiler_options;
        let languageVersion = compilerOptions.getEmitScriptTarget();
        // let moduleKind = compilerOptions.getEmitModuleKind();
        let useDefineForClassFields = compilerOptions.getUseDefineForClassFields();
        let allowSyntheticDefaultImports = compilerOptions.getAllowSyntheticDefaultImports();
        let strictNullChecks = compilerOptions.getStrictOptionValue("strictNullChecks");
        let strictFunctionTypes = compilerOptions.getStrictOptionValue("strictFunctionTypes");
        let strictBindCallApply = compilerOptions.getStrictOptionValue("strictBindCallApply");
        let strictPropertyInitialization =
            compilerOptions.getStrictOptionValue("strictPropertyInitialization");
        let noImplicitAny = compilerOptions.getStrictOptionValue("noImplicitAny");
        let noImplicitThis = compilerOptions.getStrictOptionValue("noImplicitThis");
        let useUnknownInCatchVariables =
            compilerOptions.getStrictOptionValue("useUnknownInCatchVariables");
        let keyofStringsOnly = !!compilerOptions.keyofStringsOnly;
        let freshObjectLiteralFlag = if compilerOptions.suppressExcessPropertyErrors {
            ObjectFlags::empty()
        } else {
            ObjectFlags::FreshLiteral
        };
        let exactOptionalPropertyTypes = compilerOptions.exactOptionalPropertyTypes();

        // const checkBinaryExpression = createCheckBinaryExpression();
        // const emitResolver = createResolver();
        // const nodeBuilder = createNodeBuilder();

        macro_rules! create_symbol {
            ($flags:expr, $name:expr) => {
                create_symbol!($flags, $name, Default::default())
            };
            ($flags:expr, $name:expr, $check_flags:expr) => {{
                let transient_symbol = Symbol::new_transient_symbol(
                    $flags | SymbolFlags::Transient,
                    $name,
                    $check_flags,
                );
                bind_res.symbols.push(transient_symbol)
            }};
        }

        let undefinedSymbol = create_symbol!(SymbolFlags::Property, "undefined".into());

        let globalThisSymbol = create_symbol!(
            SymbolFlags::Module,
            "globalThis".into(),
            CheckFlags::Readonly
        );
        let globals = new_ahash_map![(JsWord::from("globalThis"), globalThisSymbol,)];
        let globals = bind_res.symbol_tables.push(globals);
        *bind_res.symbols[globalThisSymbol].exports_mut() = Some(globals);

        let argumentsSymbol = create_symbol!(SymbolFlags::Property, "arguments".into());
        let requireSymbol = create_symbol!(SymbolFlags::Property, "require".into());

        // function getResolvedSignatureWorker(nodeIn: CallLikeExpression, candidatesOutArray: Signature[] | undefined, argumentCount: number | undefined, checkMode: CheckMode): Signature | undefined {
        //     const node = getParseTreeNode(nodeIn, isCallLikeExpression);
        //     apparentArgumentCount = argumentCount;
        //     const res = node ? getResolvedSignature(node, candidatesOutArray, checkMode) : undefined;
        //     apparentArgumentCount = undefined;
        //     return res;
        // }

        // TODO: use with_capacity:
        let tupleTypes = Default::default();
        let unionTypes = Default::default();
        let intersectionTypes = Default::default();
        let stringLiteralTypes = Default::default();
        let numberLiteralTypes = Default::default();
        // const bigIntLiteralTypes = new Map<string, BigIntLiteralType>();
        // const enumLiteralTypes = new Map<string, LiteralType>();
        // const indexedAccessTypes = new Map<string, IndexedAccessType>();
        // const templateLiteralTypes = new Map<string, TemplateLiteralType>();
        // const stringMappingTypes = new Map<string, StringMappingType>();
        let substitutionTypes = Default::default();
        let subtypeReductionCache = Default::default();
        // const evolvingArrayTypes: EvolvingArrayType[] = [];
        let undefinedProperties = SymbolTable::new();

        let unknownSymbol = create_symbol!(SymbolFlags::Property, "unknown".into());
        let resolvingSymbol =
            create_symbol!(SymbolFlags::default(), InternalSymbolName::Resolving.into());
        // const unresolvedSymbols = new Map<string, TransientSymbol>();
        // const errorTypes = new Map<string, Type>();

        let mut types = IndexVec::new();

        macro_rules! create_intrinsic_type {
            ($flags:expr, $intrinsic_name:literal) => {
                create_intrinsic_type!($flags, $intrinsic_name, ObjectFlags::empty())
            };
            ($flags:expr, $intrinsic_name:literal, $object_flags:expr) => {{
                let ty = Type::IntrinsicType(IntrinsicType {
                    type_base: TypeBase::new($flags, None),
                    intrinsic_type_base: IntrinsicTypeBase {
                        intrinsicName: $intrinsic_name.into(),
                        objectFlags: $object_flags,
                    },
                });
                types.push(ty)
            }};
        }

        macro_rules! create_freshable_bool_types {
            ($flags:expr, $intrinsic_name:literal) => {{
                let regular_id = types.next_index();
                let fresh_id = regular_id + 1;

                let regular_ty = Type::FreshableIntrinsicType(FreshableIntrinsicType {
                    intrinsic_type_base: IntrinsicTypeBase {
                        intrinsicName: $intrinsic_name.into(),
                        objectFlags: ObjectFlags::empty(),
                    },
                    type_base: TypeBase::new($flags, None),
                    regularType: regular_id,
                    freshType: fresh_id,
                });

                let fresh_ty = Type::FreshableIntrinsicType(FreshableIntrinsicType {
                    intrinsic_type_base: IntrinsicTypeBase {
                        intrinsicName: $intrinsic_name.into(),
                        objectFlags: ObjectFlags::empty(),
                    },
                    type_base: TypeBase::new($flags, None),
                    regularType: regular_id,
                    freshType: fresh_id,
                });

                (types.push(regular_ty), types.push(fresh_ty))
            }};
        }

        let anyType = create_intrinsic_type!(TypeFlags::Any, "any");
        let autoType = create_intrinsic_type!(TypeFlags::Any, "any");
        let wildcardType = create_intrinsic_type!(TypeFlags::Any, "any");
        let errorType = create_intrinsic_type!(TypeFlags::Any, "error");
        let unresolvedType = create_intrinsic_type!(TypeFlags::Any, "unresolved");
        let nonInferrableAnyType =
            create_intrinsic_type!(TypeFlags::Any, "any", ObjectFlags::ContainsWideningType);
        let intrinsicMarkerType = create_intrinsic_type!(TypeFlags::Any, "intrinsic");
        let unknownType = create_intrinsic_type!(TypeFlags::Unknown, "unknown");
        let nonNullUnknownType = create_intrinsic_type!(TypeFlags::Unknown, "unknown");
        let undefinedType = create_intrinsic_type!(TypeFlags::Undefined, "undefined");
        let undefinedWideningType = if strictNullChecks {
            undefinedType
        } else {
            create_intrinsic_type!(
                TypeFlags::Undefined,
                "undefined",
                ObjectFlags::ContainsWideningType
            )
        };
        let optionalType = create_intrinsic_type!(TypeFlags::Undefined, "undefined");
        let missingType = if exactOptionalPropertyTypes {
            create_intrinsic_type!(TypeFlags::Undefined, "undefined")
        } else {
            undefinedType
        };
        let nullType = create_intrinsic_type!(TypeFlags::Null, "null");
        let nullWideningType = if strictNullChecks {
            nullType
        } else {
            create_intrinsic_type!(TypeFlags::Null, "null", ObjectFlags::ContainsWideningType)
        };
        let stringType = create_intrinsic_type!(TypeFlags::String, "string");
        let numberType = create_intrinsic_type!(TypeFlags::Number, "number");
        let bigintType = create_intrinsic_type!(TypeFlags::BigInt, "bigint");
        let (regularFalseType, falseType) =
            create_freshable_bool_types!(TypeFlags::BooleanLiteral, "false");
        let (regularTrueType, trueType) =
            create_freshable_bool_types!(TypeFlags::BooleanLiteral, "true");
        let esSymbolType = create_intrinsic_type!(TypeFlags::ESSymbol, "symbol");
        let voidType = create_intrinsic_type!(TypeFlags::Void, "void");
        let neverType = create_intrinsic_type!(TypeFlags::Never, "never");
        let silentNeverType = create_intrinsic_type!(TypeFlags::Never, "never");
        let nonInferrableType =
            create_intrinsic_type!(TypeFlags::Never, "never", ObjectFlags::NonInferrableType);
        let implicitNeverType = create_intrinsic_type!(TypeFlags::Never, "never");
        let unreachableNeverType = create_intrinsic_type!(TypeFlags::Never, "never");
        let nonPrimitiveType = create_intrinsic_type!(TypeFlags::NonPrimitive, "object");
        // const stringOrNumberType = getUnionType([stringType, numberType]);
        // const numberOrBigIntType = getUnionType([numberType, bigintType]);
        // const templateConstraintType = getUnionType([stringType, numberType, booleanType, bigintType, nullType, undefinedType]) as UnionType;

        // const restrictiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags::TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t);
        // const permissiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags::TypeParameter ? wildcardType : t);

        macro_rules! create_anonymous_type {
            ($symbol:expr $(, $extra_object_flags:path)?) => {{
                let ty = Type::ResolvedType(ResolvedType::new(
                    $symbol, ObjectFlags::Anonymous $(| $extra_object_flags)?, emptySymbols
                ));

                types.push(ty)
            }};
        }

        let emptyObjectType = create_anonymous_type!(None);
        let emptyJsxObjectType = create_anonymous_type!(None, ObjectFlags::JsxAttributes);

        let emptyTypeLiteralSymbol =
            create_symbol!(SymbolFlags::TypeLiteral, InternalSymbolName::Type.into());
        let emptyTypeLiteralType = create_anonymous_type!(Some(emptyTypeLiteralSymbol));

        let emptyGenericType = {
            let ty = Type::GenericType(GenericType::new(
                InterfaceTypeBase::default(),
                TypeReferenceBase::default(),
                ObjectTypeBase::new(ObjectFlags::Anonymous),
                TypeBase::new(TypeFlags::Object, None),
            ));

            types.push(ty)
        };

        // The anyFunctionType contains the anyFunctionType by definition. The flag is further propagated
        // in getPropagatingFlagsOfTypes, and it is checked in inferFromTypes.
        let anyFunctionType = create_anonymous_type!(None, ObjectFlags::NonInferrableType);

        let noConstraintType = create_anonymous_type!(None);
        let circularConstraintType = create_anonymous_type!(None);
        let resolvingDefaultType = create_anonymous_type!(None);

        // const markerSuperType = createTypeParameter();
        // const markerSubType = createTypeParameter();
        // markerSubType.constraint = markerSuperType;
        // const markerOtherType = createTypeParameter();

        let noTypePredicate =
            TypePredicate::new_identifier_type_predicate("<<unresolved>>".into(), 0, anyType);

        let mut signatures = IndexVec::default();

        let anySignature = signatures.push(Signature {
            resolvedReturnType: Some(anyType),
            ..Default::default()
        });
        let unknownSignature = signatures.push(Signature {
            resolvedReturnType: Some(errorType),
            ..Default::default()
        });
        let resolvingSignature = signatures.push(Signature {
            resolvedReturnType: Some(anyType),
            ..Default::default()
        });
        let silentNeverSignature = signatures.push(Signature {
            resolvedReturnType: Some(silentNeverType),
            ..Default::default()
        });

        let mut index_infos = IndexVec::default();

        let enumNumberIndexInfo = index_infos.push(IndexInfo {
            keyType: numberType,
            ty: stringType,
            isReadonly: true,
            declaration: None,
        });

        // const iterationTypesCache = new Map<string, IterationTypes>(); // cache for common IterationTypes instances
        // const noIterationTypes: IterationTypes = {
        //     get yieldType(): Type { return Debug.fail("Not supported"); },
        //     get returnType(): Type { return Debug.fail("Not supported"); },
        //     get nextType(): Type { return Debug.fail("Not supported"); },
        // };

        // const anyIterationTypes = createIterationTypes(anyType, anyType, anyType);
        // const anyIterationTypesExceptNext = createIterationTypes(anyType, anyType, unknownType);
        // const defaultIterationTypes = createIterationTypes(neverType, anyType, undefinedType); // default iteration types for `Iterator`.

        // const asyncIterationTypesResolver: IterationTypesResolver = {
        //     iterableCacheKey: "iterationTypesOfAsyncIterable",
        //     iteratorCacheKey: "iterationTypesOfAsyncIterator",
        //     iteratorSymbolName: "asyncIterator",
        //     getGlobalIteratorType: getGlobalAsyncIteratorType,
        //     getGlobalIterableType: getGlobalAsyncIterableType,
        //     getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,
        //     getGlobalGeneratorType: getGlobalAsyncGeneratorType,
        //     resolveIterationType: getAwaitedType,
        //     mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,
        //     mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
        //     mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
        // };

        // const syncIterationTypesResolver: IterationTypesResolver = {
        //     iterableCacheKey: "iterationTypesOfIterable",
        //     iteratorCacheKey: "iterationTypesOfIterator",
        //     iteratorSymbolName: "iterator",
        //     getGlobalIteratorType,
        //     getGlobalIterableType,
        //     getGlobalIterableIteratorType,
        //     getGlobalGeneratorType,
        //     resolveIterationType: (type, _errorNode) => type,
        //     mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,
        //     mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
        //     mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
        // };

        // interface DuplicateInfoForSymbol {
        //     readonly firstFileLocations: Declaration[];
        //     readonly secondFileLocations: Declaration[];
        //     readonly isBlockScoped: boolean;
        // }
        // interface DuplicateInfoForFiles {
        //     readonly firstFile: SourceFile;
        //     readonly secondFile: SourceFile;
        //     /** Key is symbol name. */
        //     readonly conflictingSymbols: ESMap<string, DuplicateInfoForSymbol>;
        // }
        // /** Key is "/path/to/a.ts|/path/to/b.ts". */
        // let amalgamatedDuplicates: ESMap<string, DuplicateInfoForFiles> | undefined;
        // const reverseMappedCache = new Map<string, Type | undefined>();
        // let inInferTypeForHomomorphicMappedType = false;
        // let ambientModulesCache: Symbol[] | undefined;
        // /**
        //  * List of every ambient module with a "*" wildcard.
        //  * Unlike other ambient modules, these can't be stored in `globals` because symbol tables only deal with exact matches.
        //  * This is only used if there is no exact match.
        //  */
        // let patternAmbientModules: PatternAmbientModule[];
        // let patternAmbientModuleAugmentations: ESMap<string, Symbol> | undefined;

        // // The library files are only loaded when the feature is used.
        // // This allows users to just specify library files they want to used through --lib
        // // and they will not get an error from not having unrelated library files
        // let deferredGlobalESSymbolConstructorSymbol: Symbol | undefined;
        // let deferredGlobalESSymbolConstructorTypeSymbol: Symbol | undefined;
        // let deferredGlobalESSymbolType: ObjectType | undefined;
        // let deferredGlobalTypedPropertyDescriptorType: GenericType;
        // let deferredGlobalPromiseType: GenericType | undefined;
        // let deferredGlobalPromiseLikeType: GenericType | undefined;
        // let deferredGlobalPromiseConstructorSymbol: Symbol | undefined;
        // let deferredGlobalPromiseConstructorLikeType: ObjectType | undefined;
        // let deferredGlobalIterableType: GenericType | undefined;
        // let deferredGlobalIteratorType: GenericType | undefined;
        // let deferredGlobalIterableIteratorType: GenericType | undefined;
        // let deferredGlobalGeneratorType: GenericType | undefined;
        // let deferredGlobalIteratorYieldResultType: GenericType | undefined;
        // let deferredGlobalIteratorReturnResultType: GenericType | undefined;
        // let deferredGlobalAsyncIterableType: GenericType | undefined;
        // let deferredGlobalAsyncIteratorType: GenericType | undefined;
        // let deferredGlobalAsyncIterableIteratorType: GenericType | undefined;
        // let deferredGlobalAsyncGeneratorType: GenericType | undefined;
        // let deferredGlobalTemplateStringsArrayType: ObjectType | undefined;
        // let deferredGlobalImportMetaType: ObjectType;
        // let deferredGlobalImportMetaExpressionType: ObjectType;
        // let deferredGlobalImportCallOptionsType: ObjectType | undefined;
        // let deferredGlobalExtractSymbol: Symbol | undefined;
        // let deferredGlobalOmitSymbol: Symbol | undefined;
        // let deferredGlobalAwaitedSymbol: Symbol | undefined;
        // let deferredGlobalBigIntType: ObjectType | undefined;

        // const allPotentiallyUnusedIdentifiers = new Map<Path, PotentiallyUnusedIdentifier[]>(); // key is file name

        // const emptyStringType = getStringLiteralType("");
        // const zeroType = getNumberLiteralType(0);
        // const zeroBigIntType = getBigIntLiteralType({ negative: false, base10Value: "0" });

        // let suggestionCount = 0;
        // const maximumSuggestionCount = 10;
        // const flowLoopCaches: ESMap<string, Type>[] = [];
        // const flowLoopNodes: FlowNode[] = [];
        // const flowLoopKeys: string[] = [];
        // const flowLoopTypes: Type[][] = [];
        // const flowNodeReachable: (boolean | undefined)[] = [];
        // const potentialThisCollisions: Node[] = [];
        // const potentialNewTargetCollisions: Node[] = [];
        // const potentialWeakMapSetCollisions: Node[] = [];
        // const potentialReflectCollisions: Node[] = [];
        // const awaitedTypeStack: number[] = [];

        // const diagnostics = createDiagnosticCollection();
        // const suggestionDiagnostics = createDiagnosticCollection();

        // const typeofTypesByName: ReadonlyESMap<string, Type> = new Map(getEntries({
        //     string: stringType,
        //     number: numberType,
        //     bigint: bigintType,
        //     boolean: booleanType,
        //     symbol: esSymbolType,
        //     undefined: undefinedType
        // }));
        // const typeofType = createTypeofType();

        // let _jsxNamespace: __String;
        // let _jsxFactoryEntity: EntityName | undefined;
        // let outofbandVarianceMarkerHandler: ((onlyUnreliable: boolean) => void) | undefined;

        let mut type_relations = IndexVec::with_capacity(6);

        let subtypeRelation = type_relations.push(Default::default());
        let strictSubtypeRelation = type_relations.push(Default::default());
        let assignableRelation = type_relations.push(Default::default());
        let comparableRelation = type_relations.push(Default::default());
        let identityRelation = type_relations.push(Default::default());
        let enumRelation = type_relations.push(Default::default());

        let builtinGlobals = new_ahash_map![("undefined".into(), undefinedSymbol,)];
        let builtinGlobals = bind_res.symbol_tables.push(builtinGlobals);

        let mut checker = Checker {
            // typeCount: usize,
            // symbolCount: usize,
            // enumCount: usize,
            // totalInstantiationCount: usize,
            instantiationCount: 0,
            instantiationDepth: 0,
            inlineLevel: 0,
            currentNode: None,

            emptySymbols,
            // const arrayVariances = [VarianceFlags.Covariant];
            compilerOptions,
            languageVersion,
            // moduleKind,
            useDefineForClassFields,
            allowSyntheticDefaultImports,
            strictNullChecks,
            strictFunctionTypes,
            strictBindCallApply,
            strictPropertyInitialization,
            noImplicitAny,
            noImplicitThis,
            useUnknownInCatchVariables,
            keyofStringsOnly,
            freshObjectLiteralFlag,
            exactOptionalPropertyTypes,

            // const checkBinaryExpression = createCheckBinaryExpression();
            // const emitResolver = createResolver();
            // const nodeBuilder = createNodeBuilder();
            globals,
            undefinedSymbol,

            globalThisSymbol,

            argumentsSymbol,
            requireSymbol,

            apparentArgumentCount: None,

            tupleTypes,
            unionTypes,
            intersectionTypes,
            stringLiteralTypes,
            numberLiteralTypes,
            // const bigIntLiteralTypes = new Map<string, BigIntLiteralType>();
            // const enumLiteralTypes = new Map<string, LiteralType>();
            // const indexedAccessTypes = new Map<string, IndexedAccessType>();
            // const templateLiteralTypes = new Map<string, TemplateLiteralType>();
            // const stringMappingTypes = new Map<string, StringMappingType>();
            substitutionTypes,
            subtypeReductionCache,
            // const evolvingArrayTypes: EvolvingArrayType[] = [];
            undefinedProperties,
            unknownSymbol,
            resolvingSymbol,
            // const unresolvedSymbols = new Map<string, TransientSymbol>();
            // const errorTypes = new Map<string, Type>();
            anyType,
            autoType,
            wildcardType,
            errorType,
            unresolvedType,
            nonInferrableAnyType,
            intrinsicMarkerType,
            unknownType,
            nonNullUnknownType,
            undefinedType,
            undefinedWideningType,
            optionalType,
            missingType,
            nullType,
            nullWideningType,
            stringType,
            numberType,
            bigintType,
            falseType,
            regularFalseType,
            trueType,
            regularTrueType,
            booleanType: None,
            esSymbolType,
            voidType,
            neverType,
            silentNeverType,
            nonInferrableType,
            implicitNeverType,
            unreachableNeverType,
            nonPrimitiveType,
            // const stringOrNumberType = getUnionType([stringType, numberType]);
            stringNumberSymbolType: None,
            keyofConstraintType: None,
            // const numberOrBigIntType = getUnionType([numberType, bigintType]);
            // const templateConstraintType = getUnionType([stringType, numberType, booleanType, bigintType, nullType, undefinedType]) as UnionType;

            // const restrictiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags::TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t);
            // const permissiveMapper: TypeMapper = makeFunctionTypeMapper(t => t.flags & TypeFlags::TypeParameter ? wildcardType : t);
            emptyObjectType,
            // const emptyJsxObjectType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, emptyArray);
            emptyTypeLiteralSymbol,
            emptyTypeLiteralType,
            emptyGenericType,
            anyFunctionType,
            noConstraintType,
            circularConstraintType,
            resolvingDefaultType,

            // const markerSuperType = createTypeParameter();
            // const markerSubType = createTypeParameter();
            // const markerOtherType = createTypeParameter();
            noTypePredicate,
            anySignature,
            unknownSignature,
            resolvingSignature,
            silentNeverSignature,

            enumNumberIndexInfo,

            // const iterationTypesCache = new Map<string, IterationTypes>(); // cache for common IterationTypes instances
            // const noIterationTypes: IterationTypes = {
            //     get yieldType(): Type { return Debug.fail("Not supported"); },
            //     get returnType(): Type { return Debug.fail("Not supported"); },
            //     get nextType(): Type { return Debug.fail("Not supported"); },
            // };

            // const anyIterationTypes = createIterationTypes(anyType, anyType, anyType);
            // const anyIterationTypesExceptNext = createIterationTypes(anyType, anyType, unknownType);
            // const defaultIterationTypes = createIterationTypes(neverType, anyType, undefinedType); // default iteration types for `Iterator`.

            // const asyncIterationTypesResolver: IterationTypesResolver = {
            //     iterableCacheKey: "iterationTypesOfAsyncIterable",
            //     iteratorCacheKey: "iterationTypesOfAsyncIterator",
            //     iteratorSymbolName: "asyncIterator",
            //     getGlobalIteratorType: getGlobalAsyncIteratorType,
            //     getGlobalIterableType: getGlobalAsyncIterableType,
            //     getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,
            //     getGlobalGeneratorType: getGlobalAsyncGeneratorType,
            //     resolveIterationType: getAwaitedType,
            //     mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,
            //     mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
            //     mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
            // };

            // const syncIterationTypesResolver: IterationTypesResolver = {
            //     iterableCacheKey: "iterationTypesOfIterable",
            //     iteratorCacheKey: "iterationTypesOfIterator",
            //     iteratorSymbolName: "iterator",
            //     getGlobalIteratorType,
            //     getGlobalIterableType,
            //     getGlobalIterableIteratorType,
            //     getGlobalGeneratorType,
            //     resolveIterationType: (type, _errorNode) => type,
            //     mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,
            //     mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
            //     mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
            // };

            // let amalgamatedDuplicates: ESMap<string, DuplicateInfoForFiles> | undefined;
            // const reverseMappedCache = new Map<string, Type | undefined>();
            // let inInferTypeForHomomorphicMappedType = false;
            // let ambientModulesCache: Symbol[] | undefined;

            // let patternAmbientModules: PatternAmbientModule[];
            // let patternAmbientModuleAugmentations: ESMap<string, Symbol> | undefined;
            globalObjectType: None,
            globalFunctionType: None,
            globalCallableFunctionType: None,
            globalNewableFunctionType: None,
            globalArrayType: None,
            globalReadonlyArrayType: None,
            globalStringType: None,
            globalNumberType: None,
            globalBooleanType: None,
            globalRegExpType: None,
            globalThisType: None,
            anyArrayType: None,
            autoArrayType: None,
            anyReadonlyArrayType: None,
            deferredGlobalNonNullableTypeAlias: None,

            // let deferredGlobalESSymbolConstructorSymbol: Symbol | undefined;
            // let deferredGlobalESSymbolConstructorTypeSymbol: Symbol | undefined;
            // let deferredGlobalESSymbolType: ObjectType | undefined;
            // let deferredGlobalTypedPropertyDescriptorType: GenericType;
            // let deferredGlobalPromiseType: GenericType | undefined;
            // let deferredGlobalPromiseLikeType: GenericType | undefined;
            // let deferredGlobalPromiseConstructorSymbol: Symbol | undefined;
            // let deferredGlobalPromiseConstructorLikeType: ObjectType | undefined;
            // let deferredGlobalIterableType: GenericType | undefined;
            // let deferredGlobalIteratorType: GenericType | undefined;
            // let deferredGlobalIterableIteratorType: GenericType | undefined;
            // let deferredGlobalGeneratorType: GenericType | undefined;
            // let deferredGlobalIteratorYieldResultType: GenericType | undefined;
            // let deferredGlobalIteratorReturnResultType: GenericType | undefined;
            // let deferredGlobalAsyncIterableType: GenericType | undefined;
            // let deferredGlobalAsyncIteratorType: GenericType | undefined;
            // let deferredGlobalAsyncIterableIteratorType: GenericType | undefined;
            // let deferredGlobalAsyncGeneratorType: GenericType | undefined;
            // let deferredGlobalTemplateStringsArrayType: ObjectType | undefined;
            // let deferredGlobalImportMetaType: ObjectType;
            // let deferredGlobalImportMetaExpressionType: ObjectType;
            // let deferredGlobalImportCallOptionsType: ObjectType | undefined;
            // let deferredGlobalExtractSymbol: Symbol | undefined;
            // let deferredGlobalOmitSymbol: Symbol | undefined;
            // let deferredGlobalAwaitedSymbol: Symbol | undefined;
            // let deferredGlobalBigIntType: ObjectType | undefined;

            // const allPotentiallyUnusedIdentifiers = new Map<Path, PotentiallyUnusedIdentifier[]>(); // key is file name
            flowLoopStart: 0,
            flowLoopCount: 0,
            sharedFlowCount: 0,
            flowAnalysisDisabled: false,
            flowInvocationCount: 0,
            lastFlowNode: None,
            lastFlowNodeReachable: false,
            flowTypeCache: Default::default(),

            // const emptyStringType = getStringLiteralType("");
            // const zeroType = getNumberLiteralType(0);
            // const zeroBigIntType = getBigIntLiteralType({ negative: false, base10Value: "0" });
            resolutionTargets: Vec::new(),
            resolutionResults: Vec::new(),
            resolutionPropertyNames: Vec::new(),

            // let suggestionCount = 0;
            // const maximumSuggestionCount = 10;
            mergedSymbols: IndexVec::default(),
            symbolLinks: AHashMap::default(),
            nodeLinks: AHashMap::default(),
            // const flowLoopCaches: ESMap<string, Type>[] = [];
            // const flowLoopNodes: FlowNode[] = [];
            // const flowLoopKeys: string[] = [];
            // const flowLoopTypes: Type[][] = [];
            sharedFlowNodes: Vec::new(),
            sharedFlowTypes: Vec::new(),
            // const flowNodeReachable: (boolean | undefined)[] = [];
            flowNodePostSuper: AHashMap::default(),
            // const potentialThisCollisions: Node[] = [];
            // const potentialNewTargetCollisions: Node[] = [];
            // const potentialWeakMapSetCollisions: Node[] = [];
            // const potentialReflectCollisions: Node[] = [];
            // const awaitedTypeStack: number[] = [];

            // const diagnostics = createDiagnosticCollection();
            // const suggestionDiagnostics = createDiagnosticCollection();

            // const typeofTypesByName: ReadonlyESMap<string, Type> = new Map(getEntries({
            //     string: stringType,
            //     number: numberType,
            //     bigint: bigintType,
            //     boolean: booleanType,
            //     symbol: esSymbolType,
            //     undefined: undefinedType
            // }));
            // const typeofType = createTypeofType();

            // let _jsxNamespace: __String;
            // let _jsxFactoryEntity: EntityName | undefined;
            // let outofbandVarianceMarkerHandler: ((onlyUnreliable: boolean) => void) | undefined;
            type_relations,
            subtypeRelation,
            strictSubtypeRelation,
            assignableRelation,
            comparableRelation,
            identityRelation,
            enumRelation,
            builtinGlobals,

            node_data: bind_res.node_data,
            flow_nodes: bind_res.flow_nodes,
            symbols: bind_res.symbols,

            types,
            host,
            signatures,
            symbol_tables: bind_res.symbol_tables,
            index_infos,
            produceDiagnostics,
            inference_contexts: IndexVec::default(),
            conditional_roots: IndexVec::default(),
            widening_contexts: IndexVec::default(),
        };

        checker.initializeTypeChecker();

        checker
    }

    // getNodeCount: () => sum(host.getSourceFiles(), "nodeCount"),
    // getIdentifierCount: () => sum(host.getSourceFiles(), "identifierCount"),
    // getSymbolCount: () => sum(host.getSourceFiles(), "symbolCount") + symbolCount,
    // getTypeCount: () => typeCount,
    // getInstantiationCount: () => totalInstantiationCount,
    // getRelationCacheSizes: () => ({
    //     assignable: assignableRelation.size,
    //     identity: identityRelation.size,
    //     subtype: subtypeRelation.size,
    //     strictSubtype: strictSubtypeRelation.size,
    // }),
    // isUndefinedSymbol: symbol => symbol === undefinedSymbol,
    // isArgumentsSymbol: symbol => symbol === argumentsSymbol,
    // isUnknownSymbol: symbol => symbol === unknownSymbol,
    // getMergedSymbol,
    // getDiagnostics,
    // getGlobalDiagnostics,
    // getRecursionIdentity,
    // getUnmatchedProperties,
    // getTypeOfSymbolAtLocation: (symbol, locationIn) => {
    //     let location = getParseTreeNode(locationIn);
    //     return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;
    // },
    // getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => {
    //     let parameter = getParseTreeNode(parameterIn, isParameter);
    //     if (parameter === undefined) return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");
    //     return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName));
    // },
    // getDeclaredTypeOfSymbol,
    // getPropertiesOfType,
    // getPropertyOfType: (type, name) => getPropertyOfType(type, escapeLeadingUnderscores(name)),
    // getPrivateIdentifierPropertyOfType: (leftType: Type, name: string, location: Node) => {
    //     let node = getParseTreeNode(location);
    //     if (!node) {
    //         return undefined;
    //     }
    //     let propName = escapeLeadingUnderscores(name);
    //     let lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);
    //     return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;
    // },
    // getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name)),
    // getIndexInfoOfType: (type, kind) => getIndexInfoOfType(type, kind === IndexKind.String ? stringType : numberType),
    // getIndexInfosOfType,
    // getSignaturesOfType,
    // getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === IndexKind.String ? stringType : numberType),
    pub fn pubGetBaseTypes(&mut self, ty: TypeId) -> Option<Rc<Vec<TypeId>>> {
        if self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::ClassOrInterface)
        {
            Some(self.getBaseTypes(ty))
        } else {
            None
        }
    }
    // getBaseTypes,
    // getBaseTypeOfLiteralType,
    // getWidenedType,
    // getTypeFromTypeNode: nodeIn => {
    //     let node = getParseTreeNode(nodeIn, isTypeNode);
    //     return node ? getTypeFromTypeNode(node) : errorType;
    // },
    // getParameterType: getTypeAtPosition,
    // getParameterIdentifierNameAtPosition,
    // getPromisedTypeOfPromise,
    // getAwaitedType: type => getAwaitedType(type),
    // getReturnTypeOfSignature,
    // isNullableType,
    // getNullableType,
    // getNonNullableType,
    // getNonOptionalType: removeOptionalTypeMarker,
    // getTypeArguments,
    // typeToTypeNode: nodeBuilder.typeToTypeNode,
    // indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,
    // signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,
    // symbolToEntityName: nodeBuilder.symbolToEntityName,
    // symbolToExpression: nodeBuilder.symbolToExpression,
    // symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,
    // symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,
    // typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,
    // getSymbolsInScope: (locationIn, meaning) => {
    //     let location = getParseTreeNode(locationIn);
    //     return location ? getSymbolsInScope(location, meaning) : [];
    // },
    pub fn pubGetSymbolAtLocation_todo(&mut self, nodeIn: BoundNode) -> Option<SymbolId> {
        // let node = getParseTreeNode(nodeIn);
        // // set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors
        // return node ? getSymbolAtLocation(node, /*ignoreErrors*/ true) : undefined;
        self.getSymbolAtLocation(nodeIn, /*ignoreErrors*/ true)
    }
    // getIndexInfosAtLocation: nodeIn => {
    //     let node = getParseTreeNode(nodeIn);
    //     return node ? getIndexInfosAtLocation(node) : undefined;
    // },
    // getShorthandAssignmentValueSymbol: nodeIn => {
    //     let node = getParseTreeNode(nodeIn);
    //     return node ? getShorthandAssignmentValueSymbol(node) : undefined;
    // },
    // getExportSpecifierLocalTargetSymbol: nodeIn => {
    //     let node = getParseTreeNode(nodeIn, isExportSpecifier);
    //     return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;
    // },
    // getExportSymbolOfSymbol(symbol) {
    //     return getMergedSymbol(symbol.exportSymbol || symbol);
    // },
    pub fn getTypeAtLocation(&mut self, nodeIn: BoundNode) -> TypeId {
        // let node = getParseTreeNode(nodeIn);
        // return node ? getTypeOfNode(node) : errorType;
        self.getTypeOfNode(nodeIn)
    }
    // getTypeOfAssignmentPattern: nodeIn => {
    //     let node = getParseTreeNode(nodeIn, isAssignmentPattern);
    //     return node && getTypeOfAssignmentPattern(node) || errorType;
    // },
    // getPropertySymbolOfDestructuringAssignment: locationIn => {
    //     let location = getParseTreeNode(locationIn, isIdentifier);
    //     return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;
    // },
    // signatureToString: (signature, enclosingDeclaration, flags, kind) => {
    //     return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind);
    // },
    // typeToString: (type, enclosingDeclaration, flags) => {
    //     return typeToString(type, getParseTreeNode(enclosingDeclaration), flags);
    // },
    pub fn pubSymbolToString_todo(
        &mut self,
        symbol: SymbolId,
        enclosingDeclaration: Option<BoundNode>,
        meaning: Option<SymbolFlags>,
        flags: Option<SymbolFormatFlags>,
    ) -> String {
        self.symbolToString(symbol, enclosingDeclaration, meaning, flags)
    }
    // typePredicateToString: (predicate, enclosingDeclaration, flags) => {
    //     return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags);
    // },
    // writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => {
    //     return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer);
    // },
    // writeType: (type, enclosingDeclaration, flags, writer) => {
    //     return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer);
    // },
    // writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {
    //     return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer);
    // },
    // writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {
    //     return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer);
    // },
    // getAugmentedPropertiesOfType,
    // getRootSymbols,
    // getSymbolOfExpando,
    // getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => {
    //     let node = getParseTreeNode(nodeIn, isExpression);
    //     if (!node) {
    //         return undefined;
    //     }
    //     let containingCall = findAncestor(node, isCallLikeExpression);
    //     let containingCallResolvedSignature = containingCall && getNodeLinks(containingCall).resolvedSignature;
    //     if (contextFlags! & ContextFlags.Completions && containingCall) {
    //         let toMarkSkip = node as Node;
    //         do {
    //             getNodeLinks(toMarkSkip).skipDirectInference = true;
    //             toMarkSkip = toMarkSkip.parent;
    //         } while (toMarkSkip && toMarkSkip !== containingCall);
    //         getNodeLinks(containingCall).resolvedSignature = undefined;
    //     }
    //     let result = getContextualType(node, contextFlags);
    //     if (contextFlags! & ContextFlags.Completions && containingCall) {
    //         let toMarkSkip = node as Node;
    //         do {
    //             getNodeLinks(toMarkSkip).skipDirectInference = undefined;
    //             toMarkSkip = toMarkSkip.parent;
    //         } while (toMarkSkip && toMarkSkip !== containingCall);
    //         getNodeLinks(containingCall).resolvedSignature = containingCallResolvedSignature;
    //     }
    //     return result;
    // },
    // getContextualTypeForObjectLiteralElement: nodeIn => {
    //     let node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);
    //     return node ? getContextualTypeForObjectLiteralElement(node) : undefined;
    // },
    // getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {
    //     let node = getParseTreeNode(nodeIn, isCallLikeExpression);
    //     return node && getContextualTypeForArgumentAtIndex(node, argIndex);
    // },
    // getContextualTypeForJsxAttribute: (nodeIn) => {
    //     let node = getParseTreeNode(nodeIn, isJsxAttributeLike);
    //     return node && getContextualTypeForJsxAttribute(node);
    // },
    // isContextSensitive,
    // getTypeOfPropertyOfContextualType,
    // getFullyQualifiedName,
    // getResolvedSignature: (node, candidatesOutArray, argumentCount) =>
    //     getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal),
    // getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) =>
    //     getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp),
    // getExpandedParameters,
    // hasEffectiveRestParameter,
    // containsArgumentsReference,
    // getConstantValue: nodeIn => {
    //     let node = getParseTreeNode(nodeIn, canHaveConstantValue);
    //     return node ? getConstantValue(node) : undefined;
    // },
    // isValidPropertyAccess: (nodeIn, propertyName) => {
    //     let node = getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode);
    //     return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName));
    // },
    // isValidPropertyAccessForCompletions: (nodeIn, type, property) => {
    //     let node = getParseTreeNode(nodeIn, isPropertyAccessExpression);
    //     return !!node && isValidPropertyAccessForCompletions(node, type, property);
    // },
    // getSignatureFromDeclaration: declarationIn => {
    //     let declaration = getParseTreeNode(declarationIn, isFunctionLike);
    //     return declaration ? getSignatureFromDeclaration(declaration) : undefined;
    // },
    // isImplementationOfOverload: nodeIn => {
    //     let node = getParseTreeNode(nodeIn, isFunctionLike);
    //     return node ? isImplementationOfOverload(node) : undefined;
    // },
    // getImmediateAliasedSymbol,
    // getAliasedSymbol: resolveAlias,
    // getEmitResolver,
    // getExportsOfModule: getExportsOfModuleAsArray,
    // getExportsAndPropertiesOfModule,
    // forEachExportAndPropertyOfModule,
    // getSymbolWalker: createGetSymbolWalker(
    //     getRestTypeOfSignature,
    //     getTypePredicateOfSignature,
    //     getReturnTypeOfSignature,
    //     getBaseTypes,
    //     resolveStructuredTypeMembers,
    //     getTypeOfSymbol,
    //     getResolvedSymbol,
    //     getConstraintOfTypeParameter,
    //     getFirstIdentifier,
    //     getTypeArguments,
    // ),
    // getAmbientModules,
    // getJsxIntrinsicTagNamesAt,
    // isOptionalParameter: nodeIn => {
    //     let node = getParseTreeNode(nodeIn, isParameter);
    //     return node ? isOptionalParameter(node) : false;
    // },
    // tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol),
    // tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol),
    // tryFindAmbientModule: moduleName => tryFindAmbientModule(moduleName, /*withAugmentations*/ true),
    // tryFindAmbientModuleWithoutAugmentations: moduleName => {
    //     // we deliberately exclude augmentations
    //     // since we are only interested in declarations of the module itself
    //     return tryFindAmbientModule(moduleName, /*withAugmentations*/ false);
    // },
    // getApparentType,
    // getUnionType,
    // isTypeAssignableTo,
    // createAnonymousType,
    // createSignature,
    // createSymbol,
    // createIndexInfo,
    // getAnyType: () => anyType,
    // getStringType: () => stringType,
    // getNumberType: () => numberType,
    // createPromiseType,
    // createArrayType,
    // getElementTypeOfArrayType,
    // getBooleanType: () => booleanType,
    // getFalseType: (fresh?) => fresh ? falseType : regularFalseType,
    // getTrueType: (fresh?) => fresh ? trueType : regularTrueType,
    // getVoidType: () => voidType,
    // getUndefinedType: () => undefinedType,
    // getNullType: () => nullType,
    // getESSymbolType: () => esSymbolType,
    // getNeverType: () => neverType,
    // getOptionalType: () => optionalType,
    // getPromiseType: () => getGlobalPromiseType(/*reportErrors*/ false),
    // getPromiseLikeType: () => getGlobalPromiseLikeType(/*reportErrors*/ false),
    // isSymbolAccessible,
    // isArrayType,
    // isTupleType,
    // isArrayLikeType,
    // isTypeInvalidDueToUnionDiscriminant,
    // getExactOptionalProperties,
    // getAllPossiblePropertiesOfTypes,
    // getSuggestedSymbolForNonexistentProperty,
    // getSuggestionForNonexistentProperty,
    // getSuggestedSymbolForNonexistentJSXAttribute,
    // getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),
    // getSuggestionForNonexistentSymbol: (location, name, meaning) => getSuggestionForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),
    // getSuggestedSymbolForNonexistentModule,
    // getSuggestionForNonexistentExport,
    // getSuggestedSymbolForNonexistentClassMember,
    // getBaseConstraintOfType,
    // getDefaultFromTypeParameter: type => type && type.flags & TypeFlags::TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined,
    // resolveName(name, location, meaning, excludeGlobals) {
    //     return resolveName(location, escapeLeadingUnderscores(name), meaning, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false, excludeGlobals);
    // },
    // getJsxNamespace: n => unescapeLeadingUnderscores(getJsxNamespace(n)),
    // getJsxFragmentFactory: n => {
    //     let jsxFragmentFactory = getJsxFragmentFactoryEntity(n);
    //     return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText);
    // },
    // getAccessibleSymbolChain,
    // getTypePredicateOfSignature,
    // resolveExternalModuleName: moduleSpecifierIn => {
    //     let moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);
    //     return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, /*ignoreErrors*/ true);
    // },
    // resolveExternalModuleSymbol,
    // tryGetThisTypeAt: (nodeIn, includeGlobalThis) => {
    //     let node = getParseTreeNode(nodeIn);
    //     return node && tryGetThisTypeAt(node, includeGlobalThis);
    // },
    // getTypeArgumentConstraint: nodeIn => {
    //     let node = getParseTreeNode(nodeIn, isTypeNode);
    //     return node && getTypeArgumentConstraint(node);
    // },
    // getSuggestionDiagnostics: (fileIn, ct) => {
    //     let file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.");
    //     if (skipTypeChecking(file, compilerOptions, host)) {
    //         return emptyArray;
    //     }

    //     let diagnostics: DiagnosticWithLocation[] | undefined;
    //     try {
    //         // Record the cancellation token so it can be checked later on during checkSourceElement.
    //         // Do this in a finally block so we can ensure that it gets reset back to nothing after
    //         // this call is done.
    //         cancellationToken = ct;

    //         // Ensure file is type checked
    //         checkSourceFile(file);
    //         Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked));

    //         diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));
    //         checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => {
    //             if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {
    //                 (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion });
    //             }
    //         });

    //         return diagnostics || emptyArray;
    //     }
    //     finally {
    //         cancellationToken = undefined;
    //     }
    // },

    // runWithCancellationToken: (token, callback) => {
    //     try {
    //         cancellationToken = token;
    //         return callback(checker);
    //     }
    //     finally {
    //         cancellationToken = undefined;
    //     }
    // },

    // getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
    // isDeclarationVisible,
    // isPropertyAccessible,
    // getTypeOnlyAliasDeclaration,
}

impl Checker {
    fn globals(&self) -> &SymbolTable {
        &self.symbol_tables[self.globals]
    }

    fn globals_mut(&mut self) -> &mut SymbolTable {
        &mut self.symbol_tables[self.globals]
    }

    fn get_transient_sym(&self, id: SymbolId) -> &TransientSymbol {
        self.symbols[id].as_transient_symbol()
    }

    fn get_transient_sym_mut(&mut self, id: SymbolId) -> &mut TransientSymbol {
        self.symbols[id].as_transient_symbol_mut()
    }

    fn node_data(&mut self, node: BoundNode) -> &NodeData {
        self.node_data.entry(node).or_default()
    }

    fn node_data_mut(&mut self, node: BoundNode) -> &mut NodeData {
        self.node_data.entry(node).or_default()
    }

    fn globalObjectType(&self) -> TypeId {
        self.globalObjectType.unwrap()
    }
    fn globalFunctionType(&self) -> TypeId {
        self.globalFunctionType.unwrap()
    }
    fn globalCallableFunctionType(&self) -> TypeId {
        self.globalCallableFunctionType.unwrap()
    }
    fn globalNewableFunctionType(&self) -> TypeId {
        self.globalNewableFunctionType.unwrap()
    }
    fn globalArrayType(&self) -> TypeId {
        self.globalArrayType.unwrap()
    }
    fn globalReadonlyArrayType(&self) -> TypeId {
        self.globalReadonlyArrayType.unwrap()
    }
    fn globalStringType(&self) -> TypeId {
        self.globalStringType.unwrap()
    }
    fn globalNumberType(&self) -> TypeId {
        self.globalNumberType.unwrap()
    }
    fn globalBooleanType(&self) -> TypeId {
        self.globalBooleanType.unwrap()
    }
    fn globalRegExpType(&self) -> TypeId {
        self.globalRegExpType.unwrap()
    }
    fn globalThisType(&self) -> TypeId {
        self.globalThisType.unwrap()
    }

    fn anyArrayType(&self) -> TypeId {
        self.anyArrayType.unwrap()
    }
    fn autoArrayType(&self) -> TypeId {
        self.autoArrayType.unwrap()
    }
    fn anyReadonlyArrayType(&self) -> TypeId {
        self.anyReadonlyArrayType.unwrap()
    }

    fn booleanType(&self) -> TypeId {
        self.booleanType.unwrap()
    }

    fn stringNumberSymbolType(&self) -> TypeId {
        self.stringNumberSymbolType.unwrap()
    }
    fn keyofConstraintType(&self) -> TypeId {
        self.keyofConstraintType.unwrap()
    }

    // TODO:
    // getResolvedSignatureWorker
    // TODO:
    // getJsxNamespace
    // TODO:
    // getLocalJsxNamespace
    // TODO:
    // markAsSynthetic
    // TODO:
    // getEmitResolver
    // TODO:
    // lookupOrIssueError
    // TODO:
    // errorSkippedOn
    // TODO:
    // createError
    // TODO:
    // error
    // TODO:
    // addErrorOrSuggestion
    // TODO:
    // errorOrSuggestion
    // TODO:
    // errorAndMaybeSuggestAwait
    // TODO:
    // addDeprecatedSuggestionWorker
    // TODO:
    // addDeprecatedSuggestion
    // TODO:
    // addDeprecatedSuggestionWithSignature

    fn createSymbol(
        &mut self,
        flags: SymbolFlags,
        name: JsWord,
        check_flags: Option<CheckFlags>,
    ) -> SymbolId {
        let symbol = Symbol::new_transient_symbol(
            flags | SymbolFlags::Transient,
            name,
            check_flags.unwrap_or_default(),
        );
        self.symbols.push(symbol)
    }

    // TODO:
    // getExcludedSymbolFlags
    // TODO:
    // recordMergedSymbol
    // TODO:
    // cloneSymbol
    // TODO:
    // mergeSymbol

    fn recordMergedSymbol(&mut self, target: SymbolId, source: SymbolId) {
        todo!();
        // if (!source.mergeId) {
        //     source.mergeId = nextMergeId;
        //     nextMergeId++;
        // }
        // mergedSymbols[source.mergeId] = target;
    }

    fn cloneSymbol(&mut self, symbol: SymbolId) -> SymbolId {
        todo!();
        // const result = createSymbol(symbol.flags, symbol.escapedName);
        // result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
        // result.parent = symbol.parent;
        // if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
        // if (symbol.constEnumOnlyModule) result.constEnumOnlyModule = true;
        // if (symbol.members) result.members = new Map(symbol.members);
        // if (symbol.exports) result.exports = new Map(symbol.exports);
        // recordMergedSymbol(result, symbol);
        // return result;
    }

    /**
     * Note: if target is transient, then it is mutable, and mergeSymbol with both mutate and return it.
     * If target is not transient, mergeSymbol will produce a transient clone, mutate that and return it.
     */
    fn mergeSymbol(
        &mut self,
        mut target: SymbolId,
        source: SymbolId,
        unidirectional: bool,
    ) -> SymbolId {
        if !(self.symbols[target]
            .flags()
            .intersects(getExcludedSymbolFlags(self.symbols[source].flags())))
            || (self.symbols[source].flags() | self.symbols[target].flags())
                .intersects(SymbolFlags::Assignment)
        {
            if source == target {
                // This can happen when an export assigned namespace exports something also erroneously exported at the top level
                // See `declarationFileNoCrashOnExtraExportModifier` for an example
                return target;
            }
            if !(self.symbols[target]
                .flags()
                .intersects(SymbolFlags::Transient))
            {
                let resolvedTarget = self.resolveSymbol(target, false);
                if resolvedTarget == self.unknownSymbol {
                    return source;
                }
                target = self.cloneSymbol(resolvedTarget);
            }
            // Javascript static-property-assignment declarations always merge, even though they are also values
            if self.symbols[source]
                .flags()
                .intersects(SymbolFlags::ValueModule)
                && self.symbols[target]
                    .flags()
                    .intersects(SymbolFlags::ValueModule)
                && self.symbols[target].constEnumOnlyModule()
                && !self.symbols[source].constEnumOnlyModule()
            {
                // reset flag when merging instantiated module into value module that has only const enums
                *self.symbols[target].constEnumOnlyModule_mut() = false;
            }
            {
                let (source_sym, target_sym) = self.symbols.pick2_mut(source, target);

                let existing = source_sym.flags();
                *target_sym.flags_mut() |= existing;

                if let Some(valueDeclaration) = source_sym.valueDeclaration().clone() {
                    setValueDeclaration(target_sym, valueDeclaration);
                }

                target_sym
                    .declarations_mut()
                    .extend(source_sym.declarations().iter().cloned());
            }
            if let Some(source_members) = self.symbols[source].members().clone() {
                let target_members = match self.symbols[target].members() {
                    Some(members) => *members,
                    None => {
                        let members = self.symbol_tables.push(SymbolTable::default());
                        *self.symbols[target].members_mut() = Some(members);
                        members
                    }
                };
                self.mergeSymbolTable(target_members, source_members, unidirectional);
                *self.symbols[target].members_mut() = Some(target_members);
                *self.symbols[source].members_mut() = Some(source_members);
            }
            if let Some(source_exports) = self.symbols[source].exports().clone() {
                let target_exports = match self.symbols[target].exports() {
                    Some(exports) => *exports,
                    None => {
                        let exports = self.symbol_tables.push(SymbolTable::default());
                        *self.symbols[target].exports_mut() = Some(exports);
                        exports
                    }
                };
                self.mergeSymbolTable(target_exports, source_exports, unidirectional);
                *self.symbols[target].exports_mut() = Some(target_exports);
                *self.symbols[source].exports_mut() = Some(source_exports);
            }
            if !unidirectional {
                self.recordMergedSymbol(target, source);
            }
        } else if self.symbols[target]
            .flags()
            .intersects(SymbolFlags::NamespaceModule)
        {
            // Do not report an error when merging `var globalThis` with the built-in `globalThis`,
            // as we will already report a "Declaration name conflicts..." error, and this error
            // won't make much sense.
            if target != self.globalThisSymbol {
                todo!();
                // error(
                //             self.symbols[source].declarations && getNameOfDeclaration(self.symbols[source].declarations[0]),
                //             Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity,
                //             symbolToString(target));
            }
        } else {
            todo!();
            // error
            // let isEitherEnum = !!(target.flags & SymbolFlags::Enum || source.flags & SymbolFlags::Enum);
            // let isEitherBlockScoped = !!(target.flags & SymbolFlags::BlockScopedVariable || source.flags & SymbolFlags::BlockScopedVariable);
            // let message = isEitherEnum
            //     ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
            //     : isEitherBlockScoped
            //         ? Diagnostics.Cannot_redeclare_block_scoped_variable_0
            //         : Diagnostics.Duplicate_identifier_0;
            // let sourceSymbolFile = source.declarations && getSourceFileOfNode(source.declarations[0]);
            // let targetSymbolFile = target.declarations && getSourceFileOfNode(target.declarations[0]);
            // let symbolName = symbolToString(source);

            // // Collect top-level duplicate identifier errors into one mapping, so we can then merge their diagnostics if there are a bunch
            // if (sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile !== targetSymbolFile) {
            //     const firstFile = comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile;
            //     const secondFile = firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile;
            //     const filesDuplicates = getOrUpdate(amalgamatedDuplicates, `${firstFile.path}|${secondFile.path}`, () =>
            //         ({ firstFile, secondFile, conflictingSymbols: new Map() } as DuplicateInfoForFiles));
            //     const conflictingSymbolInfo = getOrUpdate(filesDuplicates.conflictingSymbols, symbolName, () =>
            //         ({ isBlockScoped: isEitherBlockScoped, firstFileLocations: [], secondFileLocations: [] } as DuplicateInfoForSymbol));
            //     addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source);
            //     addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target);
            // }
            // else {
            //     addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target);
            //     addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source);
            // }
        }
        target

        // fn addDuplicateLocations(locs: Declaration[], symbol: Symbol): void {
        //     if (symbol.declarations) {
        //         for (const decl of symbol.declarations) {
        //             pushIfUnique(locs, decl);
        //         }
        //     }
        // }
    }

    // TODO:
    // addDuplicateDeclarationErrorsForSymbols
    // TODO:
    // addDuplicateDeclarationError

    fn combineSymbolTables(
        &mut self,
        first: Option<SymbolTableId>,
        second: Option<SymbolTableId>,
    ) -> Option<SymbolTableId> {
        if let Some(first) = first {
            if self.symbol_tables[first].is_empty() {
                return second;
            }
            if let Some(second) = second {
                if self.symbol_tables[second].is_empty() {
                    return Some(first);
                }
                let combined = self.symbol_tables.push(SymbolTable::default());
                self.mergeSymbolTable(combined, first, false);
                self.mergeSymbolTable(combined, second, false);
                Some(combined)
            } else {
                Some(first)
            }
        } else {
            second
        }
    }

    fn mergeSymbolTable(
        &mut self,
        target: SymbolTableId,
        source: SymbolTableId,
        unidirectional: bool,
    ) {
        // TODO: use of with_table could possible lead to hard to debug bug since it mem::takes the symbol table.
        // Maybe clone the parts we need and leave the original as is. Then, only if this is becomes a performance
        // issue, find a more clever solution.
        with_table!(source_table = &mut self.symbol_tables[source], {
            for (id, &sourceSymbol) in &source_table {
                let new = match self.symbol_tables[target].get(id) {
                    Some(existing) => self.mergeSymbol(*existing, sourceSymbol, unidirectional),
                    None => sourceSymbol,
                };
                self.symbol_tables[target].insert(id.clone(), new);
            }
        });
        // for (id, &sourceSymbol) in &self.symbol_tables[source] {
        //     let new = match self.symbol_tables[target].get(id) {
        //         Some(existing) => self.mergeSymbol(*existing, sourceSymbol, unidirectional),
        //         None => sourceSymbol,
        //     };
        //     self.symbol_tables[target].insert(id.clone(), new);
        // }
    }

    // TODO:
    // mergeModuleAugmentation

    fn getSymbolLinks(&mut self, symbol: SymbolId) -> &SymbolLinks {
        if let Symbol::TransientSymbol(s) = &self.symbols[symbol] {
            return &s.symbol_links;
        }
        self.symbolLinks.entry(symbol).or_default()
    }

    fn getSymbolLinksMut(&mut self, symbol: SymbolId) -> &mut SymbolLinks {
        if let Symbol::TransientSymbol(s) = &mut self.symbols[symbol] {
            return &mut s.symbol_links;
        }
        self.symbolLinks.entry(symbol).or_default()
    }

    fn getNodeLinks(&mut self, node: BoundNode) -> &NodeLinks {
        self.nodeLinks.entry(node).or_default()
    }

    fn getNodeLinks_mut(&mut self, node: BoundNode) -> &mut NodeLinks {
        self.nodeLinks.entry(node).or_default()
    }

    // TODO:
    // isGlobalSourceFile

    fn getSymbol(
        &mut self,
        symbols: SymbolTableId,
        name: JsWord,
        meaning: SymbolFlags,
    ) -> Option<SymbolId> {
        if !meaning.is_empty() {
            let symbol_id = self.symbol_tables[symbols]
                .get(&name)
                .map(|id| self.getMergedSymbol(*id));
            if let Some(symbol_id) = symbol_id {
                let symbol = &self.symbols[symbol_id];
                // TODO:
                // debug_assert!(
                //     !getCheckFlags(symbol).intersects(CheckFlags::Instantiated),
                //     "Should never get an instantiated symbol here."
                // );
                if symbol.flags().intersects(meaning) {
                    return Some(symbol_id);
                }
                if symbol.flags().intersects(SymbolFlags::Alias) {
                    let target = self.resolveAlias(symbol_id);
                    // Unknown symbol means an error occurred in alias resolution, treat it as positive answer to avoid cascading errors
                    if target == self.unknownSymbol
                        || self.symbols[target].flags().intersects(meaning)
                    {
                        return Some(symbol_id);
                    }
                }
            }
        }
        // return None if we can't find a symbol.
        None
    }

    // TODO:
    // getSymbolsOfParameterPropertyDeclaration
    // TODO:
    // isBlockScopedNameDeclaredBeforeUse

    fn useOuterVariableScopeInParameter(
        &mut self,
        result: SymbolId,
        location: BoundNode,
        lastLocation: BoundNode,
    ) -> bool {
        debug_assert!(isFunctionLike(Some(&location)));
        let target = getEmitScriptTarget(&self.compilerOptions);
        // let functionLocation = match location {
        //     BoundNode::FnDecl(n) => n.function.body.as_ref().map(|b|(b, n.function.params)),
        //     BoundNode::PrivateMethod(n) => n.function.body.as_ref().map(|b|(b, n.function.params)),
        //     BoundNode::ClassMethod(n) => n.function.body.as_ref().map(|b|(b, n.function.params)),
        //     BoundNode::MethodProp(n) => n.function.body.as_ref().map(|b|(b, n.function.params)),
        //     BoundNode::GetterProp(n) => n.body.as_ref().map(|b|(b,None)),
        //     BoundNode::SetterProp(n) => n.body.as_ref().map(|b|(b,n.param)),
        //     BoundNode::Constructor(n) => n.body.as_ref().map(|b|(b,n.params)),
        //     BoundNode::FnExpr(n) => n.function.body.as_ref().map(|b|(b, n.function.params)),
        //     BoundNode::ArrowExpr(n) => Some(n.body, n.params),
        //     _ => None
        // };
        let fn_body_span = match location {
            BoundNode::FnDecl(n) => n.function.body.as_ref().map(|b| b.span),
            BoundNode::PrivateMethod(n) => n.function.body.as_ref().map(|b| b.span),
            BoundNode::ClassMethod(n) => n.function.body.as_ref().map(|b| b.span),
            BoundNode::MethodProp(n) => n.function.body.as_ref().map(|b| b.span),
            BoundNode::GetterProp(n) => n.body.as_ref().map(|b| b.span),
            BoundNode::SetterProp(n) => n.body.as_ref().map(|b| b.span),
            BoundNode::Constructor(n) => n.body.as_ref().map(|b| b.span),
            BoundNode::FnExpr(n) => n.function.body.as_ref().map(|b| b.span),
            BoundNode::ArrowExpr(n) => todo!(),
            _ => None,
        };
        if let (Some(fn_body_span), Some(valueDeclaration)) =
            (fn_body_span, self.symbols[result].valueDeclaration())
        {
            if matches!(
                lastLocation,
                BoundNode::Param(_)
                    | BoundNode::ParamWithoutDecorators(_)
                    | BoundNode::TsAmbientParam(_)
                    | BoundNode::TsParamProp(_)
            ) && fn_body_span.contains(valueDeclaration.span())
            {
                // check for several cases where we introduce temporaries that require moving the name/initializer of the parameter to the body
                // - static field in a class expression
                // - optional chaining pre-es2020
                // - nullish coalesce pre-es2020
                // - spread assignment in binding pattern pre-es2017
                if target >= ScriptTarget::ES2015 {
                    todo!();
                    // let links = self.getNodeLinks_mut(location);
                    // if links.declarationRequiresScopeChange.is_none() {
                    //     links.declarationRequiresScopeChange =
                    //         forEach(functionLocation.parameters, requiresScopeChange) || false;
                    // }
                    // return !links.declarationRequiresScopeChange;
                }
            }
        }
        return false;

        // fn requiresScopeChange(node: BoundNode, param: Rc<Param>) -> bool {
        //     requiresScopeChangeWorker(param.name)
        //         || !!param.initializer && requiresScopeChangeWorker(param.initializer)
        // }

        // fn requiresScopeChangeWorker(node: BoundNode) -> bool {
        //     match node {
        //         BoundNode::ArrowExpr(_)
        //         | BoundNode::FnExpr(_)
        //         | BoundNode::FnDecl(_)
        //         | BoundNode::Constructor(_) => {
        //             // do not descend into these
        //             false
        //         }
        //         BoundNode::PrivateMethod(n) => requiresScopeChangeWorker(n.key.bind(node)),
        //         BoundNode::ClassMethod(n) => requiresScopeChangeWorker(n.key.bind(node)),
        //         BoundNode::MethodProp(n) => requiresScopeChangeWorker(n.key.bind(node)),
        //         BoundNode::GetterProp(n) => requiresScopeChangeWorker(n.key.bind(node)),
        //         BoundNode::SetterProp(n) => requiresScopeChangeWorker(n.key.bind(node)),
        //         BoundNode::KeyValueProp(p) => requiresScopeChangeWorker(p.key.bind(node)),
        //         BoundNode::ClassProp(p) => {
        //             // static properties in classes introduce temporary variables
        //             if p.is_static {
        //                 todo!();
        //                 // return target < ScriptTarget.ESNext || !useDefineForClassFields;
        //             }
        //             requiresScopeChangeWorker(p.key.bind(node))
        //         }
        //         BoundNode::PrivateProp(p) => {
        //             // static properties in classes introduce temporary variables
        //             if p.is_static {
        //                 todo!();
        //                 // return target < ScriptTarget.ESNext || !useDefineForClassFields;
        //             }
        //             requiresScopeChangeWorker(p.key.bind(node))
        //         }
        //         _ => {
        //             todo!()
        //             // // null coalesce and optional chain pre-es2020 produce temporary variables
        //             // if isNullishCoalesce(node) || isOptionalChain(node) {
        //             //     return target < ScriptTarget.ES2020;
        //             // }
        //             // if isBindingElement(node)
        //             //     && node.dotDotDotToken
        //             //     && isObjectBindingPattern(node.parent)
        //             // {
        //             //     return target < ScriptTarget.ES2017;
        //             // }
        //             // if isTypeNode(node) {
        //             //     return false;
        //             // }
        //             // forEachChild(node, requiresScopeChangeWorker) || false
        //         }
        //     }
        // }
    }

    /**
     * Resolve a given name for a given meaning at a given location. An error is reported if the name was not found and
     * the nameNotFoundMessage argument is not undefined. Returns the resolved symbol, or undefined if no symbol with
     * the given name can be found.
     *
     * @param isUse If true, this will count towards --noUnusedLocals / --noUnusedParameters.
     */
    fn resolveName(
        &mut self,
        location: Option<BoundNode>,
        name: JsWord,
        meaning: SymbolFlags,
        // nameNotFoundMessage: DiagnosticMessage | undefined,
        nameArg: Option<JsWord>,
        isUse: bool,
        excludeGlobals: bool,
    ) -> Option<SymbolId> {
        self.resolveNameHelper(
            location,
            name,
            meaning,
            // nameNotFoundMessage,
            // nameArg,
            isUse,
            excludeGlobals,
        )
    }

    fn resolveNameHelper(
        &mut self,
        mut location: Option<BoundNode>,
        name: JsWord,
        meaning: SymbolFlags,
        // nameNotFoundMessage: DiagnosticMessage | undefined,
        // nameArg: __String | Identifier | undefined,
        isUse: bool,
        excludeGlobals: bool,
    ) -> Option<SymbolId> {
        // let originalLocation = location.clone(); // needed for did-you-mean error reporting, which gathers candidates starting from the original location
        let mut result = None;
        let mut lastLocation = None;
        let mut lastSelfReferenceLocation = None;
        let mut propertyWithInvalidInitializer = None;
        // let mut associatedDeclarationForContainingInitializerOrBindingName: ParameterDeclaration | BindingElement | undefined;
        // let mut associatedDeclarationForContainingInitializerOrBindingName = None;
        let mut withinDeferredContext = false;
        // let errorLocation = location;
        let mut isInExternalModule = false;

        while let Some(loc) = location.clone() {
            // Locals of a source file are not in scope (because they get merged into the global symbol table)
            if !isGlobalSourceFile(&loc) {
                if let Some(locals) = self.node_data(loc.clone()).locals {
                    result = self.getSymbol(locals, name.clone(), meaning);
                    if let Some(res) = result {
                        let mut useResult = true;

                        if isFunctionLike(Some(&loc)) {
                            let (body, ty) = match &loc {
                                // | BoundNode::JSDocSignature(_)
                                // | BoundNode::JSDocFunctionType(_)
                                BoundNode::TsMethodSignature(f) => {
                                    (None, f.type_ann.as_ref().map(|t| t.bind(loc.clone())))
                                }
                                BoundNode::TsCallSignatureDecl(f) => {
                                    (None, f.type_ann.as_ref().map(|t| t.bind(loc.clone())))
                                }
                                BoundNode::TsConstructSignatureDecl(f) => {
                                    (None, f.type_ann.as_ref().map(|t| t.bind(loc.clone())))
                                }
                                BoundNode::TsIndexSignature(f) => {
                                    (None, f.type_ann.as_ref().map(|t| t.bind(loc.clone())))
                                }
                                BoundNode::TsFnType(f) => {
                                    (None, Some(f.type_ann.bind(loc.clone())))
                                }
                                BoundNode::TsConstructorType(f) => {
                                    (None, Some(f.type_ann.bind(loc.clone())))
                                }
                                BoundNode::FnDecl(f) => (
                                    f.function
                                        .body
                                        .as_ref()
                                        .map(|b| b.bind(f.function.bind(loc.clone()))),
                                    f.function
                                        .return_type
                                        .as_ref()
                                        .map(|t| t.bind(f.function.bind(loc.clone()))),
                                ),
                                BoundNode::Constructor(f) => {
                                    (f.body.as_ref().map(|b| b.bind(loc.clone())), None)
                                }
                                BoundNode::ClassMethod(f) => (
                                    f.function
                                        .body
                                        .as_ref()
                                        .map(|b| b.bind(f.function.bind(loc.clone()))),
                                    f.function
                                        .return_type
                                        .as_ref()
                                        .map(|t| t.bind(f.function.bind(loc.clone()))),
                                ),
                                BoundNode::PrivateMethod(f) => (
                                    f.function
                                        .body
                                        .as_ref()
                                        .map(|b| b.bind(f.function.bind(loc.clone()))),
                                    f.function
                                        .return_type
                                        .as_ref()
                                        .map(|t| t.bind(f.function.bind(loc.clone()))),
                                ),
                                BoundNode::FnExpr(f) => (
                                    f.function
                                        .body
                                        .as_ref()
                                        .map(|b| b.bind(f.function.bind(loc.clone()))),
                                    f.function
                                        .return_type
                                        .as_ref()
                                        .map(|t| t.bind(f.function.bind(loc.clone()))),
                                ),
                                BoundNode::ArrowExpr(f) => (
                                    Some(f.body.bind(loc.clone())),
                                    f.return_type.as_ref().map(|t| t.bind(loc.clone())),
                                ),
                                _ => unreachable!(),
                            };
                            if let Some(lastLocation) = &lastLocation {
                                if Some(lastLocation) != body.as_ref() {
                                    // symbol lookup restrictions for function-like declarations
                                    // - Type parameters of a function are in scope in the entire function declaration, including the parameter
                                    //   list and return type. However, local types are only in scope in the function body.
                                    // - parameters are only in the scope of function body
                                    // This restriction does not apply to JSDoc comment types because they are parented
                                    // at a higher level than type parameters would normally be
                                    if meaning
                                        .intersects(self.symbols[res].flags() & SymbolFlags::Type)
                                    // TODO: jsdoc
                                    // && lastLocation.kind != SyntaxKind.JSDocComment
                                    {
                                        useResult = if self.symbols[res]
                                            .flags()
                                            .intersects(SymbolFlags::TypeParameter)
                                        {
                                            // type parameters are visible in parameter list, return type and type parameter list
                                            Some(lastLocation) == ty.as_ref()
                                                || matches!(
                                                    lastLocation,
                                                    BoundNode::Param(_)
                                                        | BoundNode::ParamWithoutDecorators(_)
                                                        | BoundNode::TsAmbientParam(_)
                                                        | BoundNode::TsParamProp(_)
                                                        | BoundNode::TsTypeParamDecl(_)
                                                )
                                        } else {
                                            // local types not visible outside the function body
                                            false
                                        };
                                    }
                                    if meaning.intersects(
                                        self.symbols[res].flags() & SymbolFlags::Variable,
                                    ) {
                                        // expression inside parameter will lookup as normal variable scope when targeting es2015+
                                        if self.useOuterVariableScopeInParameter(
                                            res,
                                            loc.clone(),
                                            lastLocation.clone(),
                                        ) {
                                            useResult = false;
                                        } else if self.symbols[res]
                                            .flags()
                                            .intersects(SymbolFlags::FunctionScopedVariable)
                                        {
                                            // parameters are visible only inside function body, parameter list and return type
                                            // technically for parameter list case here we might mix parameters and variables declared in function,
                                            // however it is detected separately when checking initializers of parameters
                                            // to make sure that they reference no variables declared after them.
                                            useResult = matches!(
                                                lastLocation,
                                                BoundNode::Param(_)
                                                    | BoundNode::ParamWithoutDecorators(_)
                                                    | BoundNode::TsAmbientParam(_)
                                                    | BoundNode::TsParamProp(_)
                                            ) || (Some(lastLocation) == ty.as_ref()
                                                && findAncestor(
                                                    self.symbols[res].valueDeclaration().clone(),
                                                    |n| {
                                                        Some(matches!(
                                                            n,
                                                            BoundNode::Param(_)
                                                                | BoundNode::ParamWithoutDecorators(
                                                                    _
                                                                )
                                                                | BoundNode::TsAmbientParam(_)
                                                                | BoundNode::TsParamProp(_)
                                                        ))
                                                    },
                                                )
                                                .is_some());
                                        }
                                    }
                                }
                            }
                        } else if let BoundNode::TsConditionalType(t) = &loc {
                            // A type parameter declared using 'infer T' in a conditional type is visible only in
                            // the true branch of the conditional type.
                            useResult = lastLocation == Some(t.true_type.bind(loc.clone()));
                        }

                        if useResult {
                            break;
                        } else {
                            result = None;
                        }
                    }
                }
            }
            withinDeferredContext =
                withinDeferredContext || getIsDeferredContext(&loc, &lastLocation);
            match &loc {
                BoundNode::Script(_) | BoundNode::Module(_) | BoundNode::TsModuleDecl(_) => {
                    if matches!(&loc, BoundNode::TsModuleDecl(_))
                        || isExternalOrCommonJsModule(&loc)
                    {
                        let mod_decl = match &loc {
                            BoundNode::Script(_) | BoundNode::Module(_) => {
                                isInExternalModule = true;
                                None
                            }
                            BoundNode::TsModuleDecl(mod_decl) => Some(mod_decl),
                            _ => unreachable!(),
                        };

                        let mod_symbol_id = self.getSymbolOfNode(loc.clone()).unwrap();
                        let moduleExports = self.symbols[mod_symbol_id]
                            .exports()
                            .unwrap_or(self.emptySymbols);
                        if matches!(loc, BoundNode::Script(_) | BoundNode::Module(_))
                            || (self
                                .node_data(loc.clone())
                                .flags
                                .intersects(NodeFlags::Ambient)
                                && !isGlobalScopeAugmentation(mod_decl.unwrap()))
                        {
                            let moduleExports = &self.symbol_tables[moduleExports];

                            // It's an external module. First see if the module has an export default and if the local
                            // name of that export default matches.
                            result = moduleExports
                                .get(&InternalSymbolName::Default.into())
                                .copied();
                            if let Some(res) = result {
                                todo!();
                                // let localSymbol = self.getLocalSymbolForExportDefault(res);
                                // if localSymbol
                                //     && self.symbols[res].flags().intersects(meaning)
                                //     && localSymbol.escapedName == name
                                // {
                                //     break;
                                // }
                                // result = None;
                            }

                            // Because of module/namespace merging, a module's exports are in scope,
                            // yet we never want to treat an export specifier as putting a member in scope.
                            // Therefore, if the name we find is purely an export specifier, it is not actually considered in scope.
                            // Two things to note about this:
                            //     1. We have to check this without calling getSymbol. The problem with calling getSymbol
                            //        on an export specifier is that it might find the export specifier itself, and try to
                            //        resolve it as an alias. This will cause the checker to consider the export specifier
                            //        a circular alias reference when it might not be.
                            //     2. We check === SymbolFlags::Alias in order to check that the symbol is *purely*
                            //        an alias. If we used &, we'd be throwing out symbols that have non alias aspects,
                            //        which is not the desired behavior.
                            let moduleExport = moduleExports.get(&name);
                            if let Some(moduleExport) = moduleExport {
                                todo!();
                                // if moduleExport.flags == SymbolFlags::Alias
                                //     && (getDeclarationOfKind(moduleExport, SyntaxKind.ExportSpecifier)
                                //         || getDeclarationOfKind(
                                //             moduleExport,
                                //             SyntaxKind.NamespaceExport,
                                //         ))
                                // {
                                //     break;
                                // }
                            }
                        }

                        // ES6 exports are also visible locally (except for 'default'), but commonjs exports are not (except typedefs)
                        result = self.getSymbol(
                            moduleExports,
                            name.clone(),
                            meaning & SymbolFlags::ModuleMember,
                        );
                        if name != JsWord::from(InternalSymbolName::Default) && result.is_some() {
                            if matches!(loc, BoundNode::Script(_) | BoundNode::Module(_)) {
                                todo!("see below");
                            } else {
                                break;
                            }
                            // TODO: modules:
                            // if isSourceFile(loc)
                            //     && loc.commonJsModuleIndicator
                            //     && !result.declarations?.some(isJSDocTypeAlias)
                            // {
                            //     result = None;
                            // } else {
                            //     break;
                            // }
                        }
                    }
                }
                BoundNode::TsEnumDecl(_) => {
                    let decl_sym = self.getSymbolOfNode(loc.clone()).unwrap();
                    let exports = self.symbols[decl_sym]
                        .exports()
                        .unwrap_or(self.emptySymbols);
                    result =
                        self.getSymbol(exports, name.clone(), meaning & SymbolFlags::EnumMember);
                    if result.is_some() {
                        break;
                    }
                }
                BoundNode::ClassProp(_) | BoundNode::PrivateProp(_) => {
                    // TypeScript 1.0 spec (April 2014): 8.4.1
                    // Initializer expressions for instance member variables are evaluated in the scope
                    // of the class constructor body but are not permitted to reference parameters or
                    // local variables of the constructor. This effectively means that entities from outer scopes
                    // by the same name as a constructor parameter or local variable are inaccessible
                    // in initializer expressions for instance member variables.
                    if !isStatic(&loc) {
                        let ctor = loc
                            .parent()
                            .as_ref()
                            .and_then(|p| findConstructorDeclaration(p));
                        if let Some(ctor) = ctor {
                            if let Some(locals) = self.node_data(ctor.clone()).locals {
                                let symbol = self.getSymbol(
                                    locals,
                                    name.clone(),
                                    meaning & SymbolFlags::Value,
                                );
                                if symbol.is_some() {
                                    // Remember the property node, it will be used later to report appropriate error
                                    propertyWithInvalidInitializer = Some(loc.clone());
                                }
                            }
                        }
                    }
                }
                BoundNode::ClassDecl(_)
                | BoundNode::ClassExpr(_)
                | BoundNode::TsInterfaceDecl(_) => {
                    // The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals
                    // These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would
                    // trigger resolving late-bound names, which we may already be in the process of doing while we're here!
                    let decl_sym = self.getSymbolOfNode(loc.clone()).unwrap();
                    let members = self.symbols[decl_sym]
                        .members()
                        .unwrap_or(self.emptySymbols);

                    result = self.getSymbol(members, name.clone(), meaning & SymbolFlags::Type);
                    if let Some(res) = result {
                        let container = match &loc {
                            BoundNode::ClassDecl(n) => n.class.bind(loc.clone()),
                            BoundNode::ClassExpr(n) => n.class.bind(loc.clone()),
                            BoundNode::TsInterfaceDecl(n) => loc.clone(),
                            _ => unreachable!(),
                        };
                        if self.isTypeParameterSymbolDeclaredInContainer(res, &container) {
                            if let Some(lastLocation) = &lastLocation {
                                if isStatic(lastLocation) {
                                    // TypeScript 1.0 spec (April 2014): 3.4.1
                                    // The scope of a type parameter extends over the entire declaration with which the type
                                    // parameter list is associated, with the exception of static member declarations in classes.
                                    todo!("error");
                                    // error(
                                    //     errorLocation,
                                    //     Diagnostics.Static_members_cannot_reference_class_type_parameters,
                                    // );
                                    // return None;
                                }
                            }
                            break;
                        }
                        // ignore type parameters not declared in this container
                        result = None;
                    } else if let BoundNode::ClassExpr(class_expr) = &loc {
                        if meaning.intersects(SymbolFlags::Class) {
                            if let Some(class_name) = &class_expr.ident {
                                if name == class_name.sym {
                                    result = self.node_data(loc.clone()).symbol;
                                    break;
                                }
                            }
                        }
                    }
                }
                BoundNode::ExtendsClause(extends) => {
                    // The type parameters of a class are not in scope in the base class expression.
                    if lastLocation == Some(extends.super_class.bind(loc.clone())) {
                        let class = extends.parent.as_ref().unwrap().parent().clone().unwrap();
                        debug_assert!(matches!(
                            class,
                            BoundNode::ClassDecl(_) | BoundNode::ClassExpr(_)
                        ));
                        let class_symbol = self.getSymbolOfNode(class).unwrap();
                        let members = self.symbols[class_symbol].members().clone().unwrap();
                        result = self.getSymbol(members, name.clone(), meaning & SymbolFlags::Type);
                        if result.is_some() {
                            todo!();
                            // if (nameNotFoundMessage) {
                            //     error(errorLocation, Diagnostics.Base_class_expressions_cannot_reference_class_type_parameters);
                            // }
                            // return None;
                        }
                    }
                }
                // It is not legal to reference a class's own type parameters from a computed property name that
                // belongs to the class. For example:
                //
                //   function foo<T>() { return '' }
                //   class C<T> { // <-- Class's own type parameter T
                //       [foo<T>()]() { } // <-- Reference to T from class's own computed property
                //   }
                //
                // TODO:
                // BoundNode::ComputedPropertyName(_) => {
                //     let grandparent = loc.parent.parent;
                //     if isClassLike(grandparent)
                //         || grandparent.kind == SyntaxKind.InterfaceDeclaration
                //     {
                //         // A reference to this grandparent's type parameters would be an error
                //         result = self.getSymbol(
                //             getSymbolOfNode(
                //                 grandparent as ClassLikeDeclaration | InterfaceDeclaration,
                //             )
                //             .members
                //             .unwrap(),
                //             name,
                //             meaning & SymbolFlags::Type,
                //         );
                //         if result.is_some() {
                //             error(errorLocation, Diagnostics.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type);
                //             return None;
                //         }
                //     }
                // }
                BoundNode::ArrowExpr(_) => {
                    // when targeting ES6 or higher there is no 'arguments' in an arrow function
                    // for lower compile targets the resolved symbol is used to emit an error
                    if !(self.compilerOptions.getEmitScriptTarget() >= ScriptTarget::ES2015) {
                        if meaning.intersects(SymbolFlags::Variable)
                            && name == js_word!("arguments")
                        {
                            result = Some(self.argumentsSymbol);
                            break;
                        }
                    }
                }
                BoundNode::PrivateMethod(_)
                | BoundNode::ClassMethod(_)
                | BoundNode::MethodProp(_)
                | BoundNode::Constructor(_)
                | BoundNode::GetterProp(_)
                | BoundNode::SetterProp(_)
                | BoundNode::FnDecl(_) => {
                    if meaning.intersects(SymbolFlags::Variable) && name == js_word!("arguments") {
                        result = Some(self.argumentsSymbol);
                        break;
                    }
                }
                BoundNode::FnExpr(fn_expr) => {
                    if meaning.intersects(SymbolFlags::Variable) && name == js_word!("arguments") {
                        result = Some(self.argumentsSymbol);
                        break;
                    }

                    if meaning.intersects(SymbolFlags::Function) {
                        if let Some(fn_name) = &fn_expr.ident {
                            if name == fn_name.sym {
                                result = self.node_data(loc.clone()).symbol;
                                break;
                            }
                        }
                    }
                }
                BoundNode::Decorator(_) => {
                    // Decorators are resolved at the class declaration. Resolving at the parameter
                    // or member would result in looking up locals in the method.
                    //
                    //   function y() {}
                    //   class C {
                    //       method(@y x, y) {} // <-- decorator y should be resolved at the class declaration, not the parameter.
                    //   }
                    //
                    if let Some(
                        BoundNode::Param(_)
                        | BoundNode::ParamWithoutDecorators(_)
                        | BoundNode::TsAmbientParam(_)
                        | BoundNode::TsParamProp(_),
                    ) = loc.parent()
                    {
                        location = loc.parent();
                    }
                    //
                    //   function y() {}
                    //   class C {
                    //       @y method(x, y) {} // <-- decorator y should be resolved at the class declaration, not the method.
                    //   }
                    //

                    // class Decorators are resolved outside of the class to avoid referencing type parameters of that class.
                    //
                    //   type T = number;
                    //   declare function y(x: T): any;
                    //   @param(1 as T) // <-- T should resolve to the type alias outside of class C
                    //   class C<T> {}
                    if let Some(parent) = loc.parent() {
                        if isClassElement(&parent) || matches!(parent, BoundNode::ClassDecl(_)) {
                            location = loc.parent();
                        }
                    }
                }
                // BoundNode::JSDocTypedefTag:
                // BoundNode::JSDocCallbackTag:
                // BoundNode::JSDocEnumTag:
                //     // js type aliases do not resolve names from their host, so skip past it
                //     const root = getJSDocRoot(loc);
                //     if (root) {
                //         location = root.parent;
                //     }
                //     break;
                BoundNode::Param(_)
                | BoundNode::ParamWithoutDecorators(_)
                | BoundNode::TsAmbientParam(_)
                | BoundNode::TsParamProp(_) => {
                    // TODO:
                    // let pat_node = param.pat.bind(loc.clone());
                    // let initializer = match &param.pat {
                    //     ast::Pat::Assign(pat) => Some(pat.right.bind(pat_node)),
                    //     _ => None,
                    // };

                    // if let Some(last_location) = &lastLocation {
                    //     if lastLocation == initializer
                    //         || last_location == &param.pat.bind(loc.clone())
                    //             && isBindingPattern(last_location)
                    //     {
                    //         if associatedDeclarationForContainingInitializerOrBindingName.is_none()
                    //         {
                    //             associatedDeclarationForContainingInitializerOrBindingName =
                    //                 location.clone();
                    //         }
                    //     }
                    // }
                }
                BoundNode::BindingIdent(_)
                | BoundNode::ArrayPat(_)
                | BoundNode::RestPat(_)
                | BoundNode::ObjectPat(_)
                | BoundNode::AssignPat(_)
                | BoundNode::KeyValuePatProp(_)
                | BoundNode::AssignPatProp(_) => {
                    // todo!("BindingElement");
                    // if let Some(last_location) = lastLocation {
                    //     if lastLocation == (loc as BindingElement).initializer
                    //         || lastLocation == (loc as BindingElement).name
                    //             && isBindingPattern(lastLocation)
                    //     {
                    //         if isParameterDeclaration(loc as BindingElement)
                    //             && associatedDeclarationForContainingInitializerOrBindingName
                    //                 .is_none()
                    //         {
                    //             associatedDeclarationForContainingInitializerOrBindingName =
                    //                 Some(loc);
                    //         }
                    //     }
                    // }
                }
                BoundNode::TsInferType(infer_type) => {
                    if meaning.intersects(SymbolFlags::TypeParameter) {
                        let type_param = &infer_type.type_param;
                        if name == type_param.name.sym {
                            result = self.node_data(type_param.bind(loc.clone())).symbol;
                            break;
                        }
                    }
                }
                BoundNode::Class(_) | BoundNode::Function(_) => {
                    location = loc.parent();
                    continue;
                }
                _ => {}
            }
            if isSelfReferenceLocation(loc.clone()) {
                lastSelfReferenceLocation = location.clone();
            }
            lastLocation = location.clone();
            // location = if isJSDocTemplateTag(location) {
            //     getEffectiveContainerForJSDocTemplateTag(location) || location.parent
            // } else {
            //     location.parent
            // };
            location = loc.parent()
        }

        // We just climbed up parents looking for the name, meaning that we started in a descendant node of `lastLocation`.
        // If `result === lastSelfReferenceLocation.symbol`, that means that we are somewhere inside `lastSelfReferenceLocation` looking up a name, and resolving to `lastLocation` itself.
        // That means that this is a self-reference of `lastLocation`, and shouldn't count this when considering whether `lastLocation` is used.
        if isUse {
            if let Some(result_id) = result {
                if lastSelfReferenceLocation
                    .map(|l| result != self.node_data(l).symbol)
                    .unwrap_or_default()
                {
                    let result_sym = &mut self.symbols[result_id];
                    let meaning = result_sym.isReferenced() | meaning;
                    // TODO: .map(||) may be nicer here
                    *result_sym.isReferenced_mut() = meaning;
                }
            }
        }

        if result.is_none() {
            // TODO: commonjs
            // if let Some(_) = lastLocation {
            //     todo!();
            //     // Debug.assert(lastLocation.kind == SyntaxKind.SourceFile);
            //     // if ((lastLocation as SourceFile).commonJsModuleIndicator
            //     //     && name == "exports"
            //     //     && meaning & lastLocation.symbol.flags)
            //     // {
            //     //     return lastLocation.symbol;
            //     // }
            // }

            if !excludeGlobals {
                // TODO: remove clone():
                result = self.getSymbol(self.globals, name.clone(), meaning);
            }
        }
        // if (!result) {
        //     if (originalLocation && isBoundNodeInJSFile(originalLocation) && originalLocation.parent) {
        //         if (isRequireCall(originalLocation.parent, /*checkArgumentIsStringLiteralLike*/ false)) {
        //             return requireSymbol;
        //         }
        //     }
        // }
        // if (!result) {
        //     if (nameNotFoundMessage) {
        //         if (!errorLocation ||
        //             !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg!) && // TODO: GH#18217
        //             !checkAndReportErrorForExtendingInterface(errorLocation) &&
        //             !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) &&
        //             !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) &&
        //             !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) &&
        //             !checkAndReportErrorForUsingNamespaceModuleAsValue(errorLocation, name, meaning) &&
        //             !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning)) {
        //             let suggestion: Symbol | undefined;
        //             if (suggestionCount < maximumSuggestionCount) {
        //                 suggestion = getSuggestedSymbolForNonexistentSymbol(originalLocation, name, meaning);
        //                 const isGlobalScopeAugmentationDeclaration = suggestion?.valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration);
        //                 if (isGlobalScopeAugmentationDeclaration) {
        //                     suggestion = undefined;
        //                 }
        //                 if (suggestion) {
        //                     const suggestionName = symbolToString(suggestion);
        //                     const isUncheckedJS = isUncheckedJSSuggestion(originalLocation, suggestion, /*excludeClasses*/ false);
        //                     const message = meaning === SymbolFlags::Namespace || nameArg && typeof nameArg !== "string" && nodeIsSynthesized(nameArg) ? Diagnostics.Cannot_find_namespace_0_Did_you_mean_1
        //                         : isUncheckedJS ? Diagnostics.Could_not_find_name_0_Did_you_mean_1
        //                         : Diagnostics.Cannot_find_name_0_Did_you_mean_1;
        //                     const diagnostic = createError(errorLocation, message, diagnosticName(nameArg!), suggestionName);
        //                     addErrorOrSuggestion(!isUncheckedJS, diagnostic);
        //                     if (suggestion.valueDeclaration) {
        //                         addRelatedInfo(
        //                             diagnostic,
        //                             createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName)
        //                         );
        //                     }
        //                 }
        //             }
        //             if (!suggestion) {
        //                 if (nameArg) {
        //                     const lib = getSuggestedLibForNonExistentName(nameArg);
        //                     if (lib) {
        //                         error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), lib);
        //                     }
        //                     else {
        //                         error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg));
        //                     }
        //                 }
        //             }
        //             suggestionCount++;
        //         }
        //     }
        //     return undefined;
        // }

        // // Perform extra checks only if error reporting was requested
        // if (nameNotFoundMessage) {
        //     if (propertyWithInvalidInitializer && !(getEmitScriptTarget(compilerOptions) === ScriptTarget.ESNext && useDefineForClassFields)) {
        //         // We have a match, but the reference occurred within a property initializer and the identifier also binds
        //         // to a local variable in the constructor where the code will be emitted. Note that this is actually allowed
        //         // with ESNext+useDefineForClassFields because the scope semantics are different.
        //         const propertyName = (propertyWithInvalidInitializer as PropertyDeclaration).name;
        //         error(errorLocation, Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor,
        //             declarationNameToString(propertyName), diagnosticName(nameArg!));
        //         return undefined;
        //     }

        //     // Only check for block-scoped variable if we have an error location and are looking for the
        //     // name with variable meaning
        //     //      For example,
        //     //          declare module foo {
        //     //              interface bar {}
        //     //          }
        //     //      const foo/*1*/: foo/*2*/.bar;
        //     // The foo at /*1*/ and /*2*/ will share same symbol with two meanings:
        //     // block-scoped variable and namespace module. However, only when we
        //     // try to resolve name in /*1*/ which is used in variable position,
        //     // we want to check for block-scoped
        //     if (errorLocation &&
        //         (meaning & SymbolFlags::BlockScopedVariable ||
        //          ((meaning & SymbolFlags::Class || meaning & SymbolFlags::Enum) && (meaning & SymbolFlags::Value) === SymbolFlags::Value))) {
        //         const exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);
        //         if (exportOrLocalSymbol.flags & SymbolFlags::BlockScopedVariable || exportOrLocalSymbol.flags & SymbolFlags::Class || exportOrLocalSymbol.flags & SymbolFlags::Enum) {
        //             checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
        //         }
        //     }

        //     // If we're in an external module, we can't reference value symbols created from UMD export declarations
        //     if (result && isInExternalModule && (meaning & SymbolFlags::Value) === SymbolFlags::Value && !(originalLocation!.flags & NodeFlags.JSDoc)) {
        //         const merged = getMergedSymbol(result);
        //         if (length(merged.declarations) && every(merged.declarations, d => isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports)) {
        //             errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation!, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name));
        //         }
        //     }

        //     // If we're in a parameter initializer or binding name, we can't reference the values of the parameter whose initializer we're within or parameters to the right
        //     if (result && associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & SymbolFlags::Value) === SymbolFlags::Value) {
        //         const candidate = getMergedSymbol(getLateBoundSymbol(result));
        //         const root = (getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName) as ParameterDeclaration);
        //         // A parameter initializer or binding pattern initializer within a parameter cannot refer to itself
        //         if (candidate === getSymbolOfNode(associatedDeclarationForContainingInitializerOrBindingName)) {
        //             error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name));
        //         }
        //         // And it cannot refer to any declarations which come after it
        //         else if (candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && self.getSymbol(root.parent.locals, candidate.escapedName, meaning) === candidate) {
        //             error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation as Identifier));
        //         }
        //     }
        //     if (result && errorLocation && meaning & SymbolFlags::Value && result.flags & SymbolFlags::Alias) {
        //         checkSymbolUsageInExpressionContext(result, name, errorLocation);
        //     }
        // }

        result
    }

    // TODO:
    // checkSymbolUsageInExpressionContext
    // TODO:
    // addTypeOnlyDeclarationRelatedInfo
    // TODO:
    // getIsDeferredContext
    // TODO:
    // isSelfReferenceLocation
    // TODO:
    // diagnosticName

    fn isTypeParameterSymbolDeclaredInContainer(
        &self,
        symbol: SymbolId,
        container: &BoundNode,
    ) -> bool {
        for decl in self.symbols[symbol].declarations() {
            if let BoundNode::TsTypeParamDecl(param) = decl {
                // TODO: JSdoc
                // let parent = isJSDocTemplateTag(decl.parent) ? getJSDocHost(decl.parent) : decl.parent;
                let parent = param.parent.as_ref().unwrap();
                if parent == container {
                    // return !(isJSDocTemplateTag(decl.parent) && find((decl.parent.parent as JSDoc).tags!, isJSDocTypeAlias));
                    return true;
                }
            }
        }

        false
    }

    // TODO:
    // checkAndReportErrorForMissingPrefix
    // TODO:
    // checkAndReportErrorForExtendingInterface
    // TODO:
    // getEntityNameForExtendingInterface
    // TODO:
    // checkAndReportErrorForUsingTypeAsNamespace
    // TODO:
    // checkAndReportErrorForUsingValueAsType
    // TODO:
    // isPrimitiveTypeName
    // TODO:
    // checkAndReportErrorForExportingPrimitiveType
    // TODO:
    // checkAndReportErrorForUsingTypeAsValue
    // TODO:
    // maybeMappedType
    // TODO:
    // isES2015OrLaterConstructorName
    // TODO:
    // checkAndReportErrorForUsingNamespaceModuleAsValue
    // TODO:
    // checkResolvedBlockScopedVariable
    // TODO:
    // isSameScopeDescendentOf
    // TODO:
    // getAnyImportSyntax

    fn getDeclarationOfAliasSymbol(&mut self, symbol: SymbolId) -> Option<BoundNode> {
        // TODO: nasty intermidiary clone:
        self.symbols[symbol]
            .declarations()
            .clone()
            .into_iter()
            .rfind(|d| self.isAliasSymbolDeclaration(d.clone()))
    }

    /**
     * An alias symbol is created by one of the following declarations:
     * import <symbol> = ...
     * import <symbol> from ...
     * import * as <symbol> from ...
     * import { x as <symbol> } from ...
     * export { x as <symbol> } from ...
     * export * as ns <symbol> from ...
     * export = <EntityNameExpression>
     * export default <EntityNameExpression>
     * module.exports = <EntityNameExpression>
     * {<Identifier>}
     * {name: <EntityNameExpression>}
     * const { x } = require ...
     */
    fn isAliasSymbolDeclaration(&mut self, node: BoundNode) -> bool {
        // TODO: my convertion from TS SyntaxKinds to our AST nodes is probably incorrect:
        match node {
            BoundNode::TsImportEqualsDecl(_) => true,
            BoundNode::ImportDefaultSpecifier(_) => true,
            BoundNode::ImportStarAsSpecifier(_) => true,
            BoundNode::ExportNamespaceSpecifier(_) => true,
            BoundNode::ImportNamedSpecifier(_) => true,
            BoundNode::ExportNamedSpecifier(_) => true,
            BoundNode::TsExportAssignment(n) => exportAssignmentIsAlias(&n.into()),
            BoundNode::AssignExpr(e) => {
                getAssignmentDeclarationKind(&ast::Expr::Assign(e.node.clone()))
                    == AssignmentDeclarationKind::ModuleExports
                    && exportAssignmentIsAlias(&e.into())
            }
            BoundNode::MemberExpr(ref e) => {
                if let Some(parent @ BoundNode::AssignExpr(a)) = &e.parent {
                    a.left.bind(parent.clone()) == node
                        && a.op == ast::AssignOp::Assign
                        && self.isAliasableOrJsExpression(a.right.bind(parent.clone()))
                } else {
                    false
                }
            }
            // ShorthandPropertyAssignment
            BoundNode::Ident(_) => matches!(node.parent(), Some(BoundNode::ObjectLit(_))),
            BoundNode::KeyValueProp(ref n) => {
                self.isAliasableOrJsExpression(n.value.bind(node.clone()))
            }
            _ => isRequireVariableDeclaration(node),
        }
    }

    fn isAliasableOrJsExpression(&mut self, n: BoundNode) -> bool {
        isAliasableExpression(&n.clone().into())
            || matches!(n, BoundNode::FnExpr(_)) && self.isJSConstructor(Some(n))
    }

    // TODO:
    // getTargetOfImportEqualsDeclaration
    // TODO:
    // checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol
    // TODO:
    // resolveExportByName
    // TODO:
    // isSyntacticDefault
    // TODO:
    // getUsageModeForExpression
    // TODO:
    // isESMFormatImportImportingCommonjsFormatFile
    // TODO:
    // canHaveSyntheticDefault
    // TODO:
    // getTargetOfImportClause
    // TODO:
    // reportNonDefaultExport
    // TODO:
    // getTargetOfNamespaceImport
    // TODO:
    // getTargetOfNamespaceExport
    // TODO:
    // combineValueAndTypeSymbols
    // TODO:
    // getExportOfModule
    // TODO:
    // getPropertyOfVariable
    // TODO:
    // getExternalModuleMember
    // TODO:
    // reportNonExportedMember
    // TODO:
    // reportInvalidImportEqualsExportMember
    // TODO:
    // getTargetOfImportSpecifier
    // TODO:
    // getCommonJSPropertyAccess
    // TODO:
    // getTargetOfNamespaceExportDeclaration
    // TODO:
    // getTargetOfExportSpecifier
    // TODO:
    // getTargetOfExportAssignment
    // TODO:
    // getTargetOfAliasLikeExpression
    // TODO:
    // getTargetOfPropertyAssignment
    // TODO:
    // getTargetOfAccessExpression

    fn getTargetOfAliasDeclaration(
        &mut self,
        node: BoundNode,
        dontRecursivelyResolve: bool,
    ) -> Option<SymbolId> {
        todo!();
        // switch (node.kind) {
        //     case SyntaxKind.ImportEqualsDeclaration:
        //     case SyntaxKind.VariableDeclaration:
        //         return getTargetOfImportEqualsDeclaration(node as ImportEqualsDeclaration | VariableDeclaration, dontRecursivelyResolve);
        //     case SyntaxKind.ImportClause:
        //         return getTargetOfImportClause(node as ImportClause, dontRecursivelyResolve);
        //     case SyntaxKind.NamespaceImport:
        //         return getTargetOfNamespaceImport(node as NamespaceImport, dontRecursivelyResolve);
        //     case SyntaxKind.NamespaceExport:
        //         return getTargetOfNamespaceExport(node as NamespaceExport, dontRecursivelyResolve);
        //     case SyntaxKind.ImportSpecifier:
        //     case SyntaxKind.BindingElement:
        //         return getTargetOfImportSpecifier(node as ImportSpecifier | BindingElement, dontRecursivelyResolve);
        //     case SyntaxKind.ExportSpecifier:
        //         return getTargetOfExportSpecifier(node as ExportSpecifier, SymbolFlags::Value | SymbolFlags::Type | SymbolFlags::Namespace, dontRecursivelyResolve);
        //     case SyntaxKind.ExportAssignment:
        //     case SyntaxKind.BinaryExpression:
        //         return getTargetOfExportAssignment((node as ExportAssignment | BinaryExpression), dontRecursivelyResolve);
        //     case SyntaxKind.NamespaceExportDeclaration:
        //         return getTargetOfNamespaceExportDeclaration(node as NamespaceExportDeclaration, dontRecursivelyResolve);
        //     case SyntaxKind.ShorthandPropertyAssignment:
        //         return resolveEntityName((node as ShorthandPropertyAssignment).name, SymbolFlags::Value | SymbolFlags::Type | SymbolFlags::Namespace, /*ignoreErrors*/ true, dontRecursivelyResolve);
        //     case SyntaxKind.PropertyAssignment:
        //         return getTargetOfPropertyAssignment(node as PropertyAssignment, dontRecursivelyResolve);
        //     case SyntaxKind.ElementAccessExpression:
        //     case SyntaxKind.PropertyAccessExpression:
        //         return getTargetOfAccessExpression(node as AccessExpression, dontRecursivelyResolve);
        //     default:
        //         return Debug.fail();
        // }
    }

    /**
     * Indicates that a symbol is an alias that does not merge with a local declaration.
     * OR Is a JSContainer which may merge an alias with a local declaration
     */
    fn isNonLocalAlias(&self, symbol: Option<SymbolId>, excludes: Option<SymbolFlags>) -> bool {
        let excludes =
            excludes.unwrap_or(SymbolFlags::Value | SymbolFlags::Type | SymbolFlags::Namespace);
        if let Some(symbol) = symbol {
            let sym_flags = self.symbols[symbol].flags();
            return (sym_flags & (SymbolFlags::Alias | excludes)) == SymbolFlags::Alias
                || (sym_flags.intersects(SymbolFlags::Alias)
                    && sym_flags.intersects(SymbolFlags::Assignment));
        }
        false
    }

    fn resolveSymbol(&mut self, symbol: SymbolId, dontResolveAlias: bool) -> SymbolId {
        todo!();
        // if !dontResolveAlias && isNonLocalAlias(symbol) {
        //     resolveAlias(symbol)
        // } else {
        //     symbol
        // }
    }

    fn maybeResolveSymbol(
        &mut self,
        symbol: Option<SymbolId>,
        dontResolveAlias: bool,
    ) -> Option<SymbolId> {
        if !dontResolveAlias && self.isNonLocalAlias(symbol, None) {
            symbol.map(|s| self.resolveAlias(s))
        } else {
            symbol
        }
    }

    fn resolveAlias(&mut self, symbol: SymbolId) -> SymbolId {
        debug_assert!(
            self.symbols[symbol].flags().intersects(SymbolFlags::Alias),
            "Should only get Alias here."
        );
        match self.getSymbolLinks(symbol).target.clone() {
            Some(target) if target == self.resolvingSymbol => {
                self.getSymbolLinksMut(symbol).target = Some(self.unknownSymbol);
                self.unknownSymbol
            }
            Some(target) => target,
            None => {
                self.getSymbolLinksMut(symbol).target = Some(self.resolvingSymbol);
                let node = self.getDeclarationOfAliasSymbol(symbol).unwrap();
                let target = self.getTargetOfAliasDeclaration(node, false);
                let resolvingSymbol = self.resolvingSymbol;
                let unknownSymbol = self.unknownSymbol;
                let sym_links_target = &mut self.getSymbolLinksMut(symbol).target;
                if sym_links_target == &Some(resolvingSymbol) {
                    *sym_links_target = target.or(Some(unknownSymbol));
                } else {
                    todo!("error");
                    // error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
                }
                sym_links_target.unwrap()
            }
        }
    }

    // TODO:
    // tryResolveAlias
    // TODO:
    // markSymbolOfAliasDeclarationIfTypeOnly
    // TODO:
    // markSymbolOfAliasDeclarationIfTypeOnlyWorker

    /** Indicates that a symbol directly or indirectly resolves to a type-only import or export. */
    fn getTypeOnlyAliasDeclaration(&mut self, symbol: SymbolId) -> Option<BoundNode> {
        if !self.symbols[symbol].flags().intersects(SymbolFlags::Alias) {
            return None;
        }
        match &self.getSymbolLinks(symbol).typeOnlyDeclaration {
            Some(BoundNodeOrFalse::BoundNode(b)) => Some(b.clone()),
            _ => None,
        }
    }

    // TODO:
    // markExportAsReferenced
    // TODO:
    // markAliasSymbolAsReferenced
    // TODO:
    // markConstEnumAliasAsReferenced
    // TODO:
    // getSymbolOfPartOfRightHandSideOfImportEquals
    // TODO:
    // getFullyQualifiedName
    // TODO:
    // getContainingQualifiedNameNode
    // TODO:
    // tryGetQualifiedNameAsValue

    /// Resolves a qualified name and any involved aliases.
    fn resolveEntityName(
        &mut self,
        name: BoundNode,
        meaning: SymbolFlags,
        ignoreErrors: bool,
        dontResolveAlias: bool,
        location: Option<BoundNode>,
    ) -> Option<SymbolId> {
        // TODO:
        // if nodeIsMissing(name) {
        //     return None;
        // }

        let namespaceMeaning = SymbolFlags::Namespace
            | (if isBoundNodeInJSFile(&name) {
                meaning & SymbolFlags::Value
            } else {
                SymbolFlags::None
            });
        let symbol = match &name {
            BoundNode::Ident(i) => {
                // let message = if meaning == namespaceMeaning || nodeIsSynthesized(name) {
                //     Diagnostics.Cannot_find_namespace_0
                // } else {
                //     getCannotFindNameDiagnosticForName(getFirstIdentifier(name))
                // };
                let symbolFromJSPrototype =
                    if isBoundNodeInJSFile(&name) && !nodeIsSynthesized(&name) {
                        self.resolveEntityNameFromAssignmentDeclaration(&i, meaning)
                    } else {
                        None
                    };
                let s = self.resolveName(
                    location.or(Some(name.clone())),
                    i.sym.clone(),
                    meaning,
                    // if ignoreErrors || symbolFromJSPrototype {
                    //     None
                    // } else {
                    //     message
                    // },
                    Some(i.sym.clone()),
                    true,
                    false,
                );
                let s = self.getMergedSymbolOptional(s);
                match s {
                    Some(s) => s,
                    None => {
                        return self.getMergedSymbolOptional(symbolFromJSPrototype);
                    }
                }
            }
            BoundNode::TsQualifiedName(_) | BoundNode::MemberExpr(_) => {
                let (left, right) = match &name {
                    BoundNode::TsQualifiedName(n) => (n.left.bind(name.clone()), n.right.clone()),
                    BoundNode::MemberExpr(n) if !n.computed => (
                        n.obj.bind(name.clone()),
                        unwrap_as!(n.prop.clone(), ast::Expr::Ident(i), i),
                    ),
                    _ => unreachable!(),
                };
                let namespace =
                    self.resolveEntityName(left, namespaceMeaning, ignoreErrors, false, location);
                if let Some(namespace) = namespace {
                    if namespace == self.unknownSymbol {
                        return None;
                    }
                    if let Some(valueDeclaration) = self.symbols[namespace].valueDeclaration() {
                        if isBoundNodeInJSFile(valueDeclaration) {
                            if let BoundNode::VarDeclarator(d) = valueDeclaration {
                                if let Some(init) = &d.init {
                                    if self.isCommonJsRequire(init.bind(valueDeclaration.clone())) {
                                        todo!();
                                        // let moduleName = (namespace.initializer as CallExpression)
                                        //     .arguments[0] as StringLiteral;
                                        // let moduleSym = resolveExternalModuleName(moduleName, moduleName);
                                        // if (moduleSym) {
                                        //     let resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                                        //     if (resolvedModuleSymbol) {
                                        //         namespace = resolvedModuleSymbol;
                                        //     }
                                        // }
                                    }
                                }
                            }
                        }
                    }
                    let exports = self.getExportsOfSymbol(namespace);
                    let symbol = self.getSymbol(exports, right.sym.clone(), meaning);
                    let symbol = self.getMergedSymbolOptional(symbol);
                    if let Some(sym) = symbol {
                        sym
                    } else if !ignoreErrors {
                        todo!();
                        // let namespaceName = getFullyQualifiedName(namespace);
                        // let declarationName = declarationNameToString(right);
                        // let suggestionForNonexistentModule =
                        //     getSuggestedSymbolForNonexistentModule(right, namespace);
                        // let exportedTypeSymbol = getMergedSymbol(getSymbol(
                        //     getExportsOfSymbol(namespace),
                        //     right.escapedText,
                        //     SymbolFlags::Type,
                        // ));
                        // let containingQualifiedName =
                        //     isQualifiedName(name) && getContainingQualifiedNameNode(name);
                        // let canSuggestTypeof = containingQualifiedName
                        //     && !isTypeOfExpression(containingQualifiedName.parent)
                        //     && tryGetQualifiedNameAsValue(containingQualifiedName);
                        // if (suggestionForNonexistentModule) {
                        //     error(
                        //         right,
                        //         Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2,
                        //         namespaceName,
                        //         declarationName,
                        //         symbolToString(suggestionForNonexistentModule),
                        //     );
                        // } else if (canSuggestTypeof) {
                        //     error(containingQualifiedName, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, entityNameToString(containingQualifiedName));
                        // } else if (meaning & SymbolFlags::Namespace
                        //     && exportedTypeSymbol
                        //     && isQualifiedName(name.parent))
                        // {
                        //     error(name.parent.right, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, symbolToString(exportedTypeSymbol), unescapeLeadingUnderscores(name.parent.right.escapedText));
                        // } else {
                        //     error(
                        //         right,
                        //         Diagnostics.Namespace_0_has_no_exported_member_1,
                        //         namespaceName,
                        //         declarationName,
                        //     );
                        // }
                    } else {
                        return None;
                    }
                } else {
                    return None;
                }
            }
            _ => {
                todo!();
                // unreachable!();
            }
        };
        // TODO:
        // debug_assert!(
        //     (getCheckFlags(symbol) & CheckFlags::Instantiated) == 0,
        //     "Should never get an instantiated symbol here."
        // );
        // if !nodeIsSynthesized(&name)
        //     && isEntityName(&name)
        //     && (symbol.flags.intersects(SymbolFlags::Alias)
        //         || name.parent.kind == SyntaxKind.ExportAssignment)
        // {
        //     self.markSymbolOfAliasDeclarationIfTypeOnly(
        //         self.getAliasDeclarationFromName(name),
        //         symbol,
        //         /*finalTarget*/ None,
        //         /*overwriteEmpty*/ true,
        //     );
        // }
        if self.symbols[symbol].flags().intersects(meaning) || dontResolveAlias {
            Some(symbol)
        } else {
            Some(self.resolveAlias(symbol))
        }
    }

    /**
     * 1. For prototype-property methods like `A.prototype.m = function () ...`, try to resolve names in the scope of `A` too.
     * Note that prototype-property assignment to locations outside the current file (eg globals) doesn't work, so
     * name resolution won't work either.
     * 2. For property assignments like `{ x: function f () { } }`, try to resolve names in the scope of `f` too.
     */
    fn resolveEntityNameFromAssignmentDeclaration(
        &mut self,
        name: &Ident,
        meaning: SymbolFlags,
    ) -> Option<SymbolId> {
        // TODO:
        // if isJSDocTypeReference(name.parent) {
        //     let secondaryLocation = self.getAssignmentDeclarationLocation(name.parent);
        //     if (secondaryLocation) {
        //         return self.resolveName(
        //             secondaryLocation,
        //             name.escapedText,
        //             meaning,
        //             name,
        //             true,
        //         );
        //     }
        // }
        None
    }

    // TODO:
    // getAssignmentDeclarationLocation
    // TODO:
    // getDeclarationOfJSPrototypeContainer

    /**
     * Get the real symbol of a declaration with an expando initializer.
     *
     * Normally, declarations have an associated symbol, but when a declaration has an expando
     * initializer, the expando's symbol is the one that has all the members merged into it.
     */
    fn getExpandoSymbol(&mut self, symbol: SymbolId) -> Option<SymbolId> {
        let decl = self.symbols[symbol].valueDeclaration();
        if let Some(decl) = decl {
            if !isBoundNodeInJSFile(decl)
                || self.symbols[symbol]
                    .flags()
                    .intersects(SymbolFlags::TypeAlias)
                || getExpandoInitializer(decl.clone().into(), false).is_some()
            {
                return None;
            }
            let init = if matches!(decl, BoundNode::VarDeclarator(_)) {
                getDeclaredExpandoInitializer(decl)
            } else {
                getAssignedExpandoInitializer(Some(decl.clone()))
            };
            if let Some(init) = init {
                let initSymbol = self.getSymbolOfNode(init);
                if let Some(initSymbol) = initSymbol {
                    return self.mergeJSSymbols(initSymbol, Some(symbol));
                }
            }
        }

        None
    }

    // TODO:
    // resolveExternalModuleName
    // TODO:
    // resolveExternalModuleNameWorker
    // TODO:
    // resolveExternalModule
    // TODO:
    // errorOnImplicitAnyModule
    // TODO:
    // typesPackageExists
    // TODO:
    // packageBundlesTypes

    fn resolveExternalModuleSymbol(
        &mut self,
        moduleSymbol: Option<SymbolId>,
        dontResolveAlias: bool,
    ) -> Option<SymbolId> {
        if let Some(moduleSymbol) = moduleSymbol {
            if let Some(exports) = self.symbols[moduleSymbol].exports() {
                let export_equals_sym = self.symbol_tables[*exports]
                    .get(&JsWord::from(InternalSymbolName::ExportEquals))
                    .copied();
                let export_equals_sym =
                    self.maybeResolveSymbol(export_equals_sym, dontResolveAlias);
                let export_equals_sym = self.getMergedSymbolOptional(export_equals_sym);
                let merged_moduleSymbol = self.getMergedSymbol(moduleSymbol);
                let exported = self.getCommonJsExportEquals(export_equals_sym, merged_moduleSymbol);
                return self
                    .getMergedSymbolOptional(exported)
                    .or(Some(moduleSymbol));
            }
        }
        None
    }

    fn getCommonJsExportEquals(
        &mut self,
        exported: Option<SymbolId>,
        moduleSymbol: SymbolId,
    ) -> Option<SymbolId> {
        if let Some(exported) = exported {
            if exported == self.unknownSymbol
                || exported == moduleSymbol
                || self.symbol_tables[self.symbols[moduleSymbol].exports().unwrap()].len() == 1
                || self.symbols[exported]
                    .flags()
                    .intersects(SymbolFlags::Alias)
            {
                return Some(exported);
            }
            todo!();
            // let links = self.getSymbolLinks(exported);
            // if links.cjsExportMerged {
            //     return links.cjsExportMerged;
            // }
            // let merged = exported.flags & SymbolFlags::Transient ? exported : cloneSymbol(exported);
            // merged.flags = merged.flags | SymbolFlags::ValueModule;
            // if (merged.exports === undefined) {
            //     merged.exports = createSymbolTable();
            // }
            // moduleSymbol.exports!.forEach((s, name) => {
            //     if (name === InternalSymbolName.ExportEquals) return;
            //     merged.exports!.set(name, merged.exports!.has(name) ? mergeSymbol(merged.exports!.get(name)!, s) : s);
            // });
            // getSymbolLinks(merged).cjsExportMerged = merged;
            // return links.cjsExportMerged = merged;
        } else {
            return exported;
        }
    }

    // TODO:
    // resolveESModuleSymbol
    // TODO:
    // hasExportAssignmentSymbol
    // TODO:
    // getExportsOfModuleAsArray
    // TODO:
    // getExportsAndPropertiesOfModule
    // TODO:
    // forEachExportAndPropertyOfModule
    // TODO:
    // tryGetMemberInModuleExports
    // TODO:
    // tryGetMemberInModuleExportsAndProperties
    // TODO:
    // shouldTreatPropertiesOfExternalModuleAsExports

    fn getExportsOfSymbol(&mut self, symbol: SymbolId) -> SymbolTableId {
        let flags = self.symbols[symbol].flags();
        if flags.intersects(SymbolFlags::LateBindingContainer) {
            self.getResolvedMembersOrExportsOfSymbol(
                symbol,
                MembersOrExportsResolutionKind::ResolvedExports,
            )
        } else if flags.intersects(SymbolFlags::Module) {
            self.getExportsOfModule(symbol)
        } else {
            self.symbols[symbol]
                .exports_mut()
                .unwrap_or(self.emptySymbols)
        }
    }

    fn getExportsOfModule(&mut self, moduleSymbol: SymbolId) -> SymbolTableId {
        match self.getSymbolLinks(moduleSymbol).resolvedExports {
            Some(resolvedExports) => resolvedExports,
            None => {
                let resolvedExports = self.getExportsOfModuleWorker(moduleSymbol);
                self.getSymbolLinksMut(moduleSymbol).resolvedExports = Some(resolvedExports);
                resolvedExports
            }
        }
    }

    // TODO:
    // extendExportSymbols

    fn getExportsOfModuleWorker(&mut self, mut moduleSymbol: SymbolId) -> SymbolTableId {
        let mut visitedSymbols = Vec::new();

        // A module defined by an 'export=' consists of one export that needs to be resolved
        moduleSymbol = self
            .resolveExternalModuleSymbol(Some(moduleSymbol), false)
            .unwrap();

        return visit(self, &mut visitedSymbols, Some(moduleSymbol)).unwrap_or(self.emptySymbols);

        // The ES6 spec permits export * declarations in a module to circularly reference the module itself. For example,
        // module 'a' can 'export * from "b"' and 'b' can 'export * from "a"' without error.
        fn visit(
            checker: &mut Checker,
            visitedSymbols: &mut Vec<SymbolId>,
            symbol: Option<SymbolId>,
        ) -> Option<SymbolTableId> {
            if let Some(symbol) = symbol {
                if let Some(exports) = checker.symbols[symbol].exports().clone() {
                    if !visitedSymbols.push_if_unique(symbol) {
                        return None;
                    }
                    // TODO:
                    // let symbols = new Map(symbol.exports);
                    let symbols = &checker.symbol_tables[exports];
                    // All export * declarations are collected in an __export symbol by the binder
                    let exportStars = symbols.get(&JsWord::from(InternalSymbolName::ExportStar));
                    if let Some(exportStars) = exportStars {
                        todo!();
                        // let nestedSymbols = createSymbolTable();
                        // let lookupTable: ExportCollisionTrackerTable = new Map();
                        // if (exportStars.declarations) {
                        //     for (const node of exportStars.declarations) {
                        //         const resolvedModule = resolveExternalModuleName(node, (node as ExportDeclaration).moduleSpecifier!);
                        //         const exportedSymbols = visit(resolvedModule);
                        //         extendExportSymbols(
                        //             nestedSymbols,
                        //             exportedSymbols,
                        //             lookupTable,
                        //             node as ExportDeclaration
                        //         );
                        //     }
                        // }
                        // lookupTable.forEach(({ exportsWithDuplicate }, id) => {
                        //     // It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself
                        //     if (id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) {
                        //         return;
                        //     }
                        //     for (const node of exportsWithDuplicate) {
                        //         diagnostics.add(createDiagnosticForNode(
                        //             node,
                        //             Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity,
                        //             lookupTable.get(id)!.specifierText,
                        //             unescapeLeadingUnderscores(id)
                        //         ));
                        //     }
                        // });
                        // checker.extendExportSymbols(symbols, nestedSymbols);
                    }
                    return Some(exports);
                }
            }
            None
        }
    }

    fn getMergedSymbol(&self, symbol: SymbolId) -> SymbolId {
        if let Some(mergeId) = self.symbols[symbol].mergeId() {
            self.mergedSymbols[*mergeId]
        } else {
            symbol
        }
    }

    fn getMergedSymbolOptional(&self, symbol: Option<SymbolId>) -> Option<SymbolId> {
        if let Some(symbol) = symbol {
            if let Some(mergeId) = self.symbols[symbol].mergeId() {
                return Some(self.mergedSymbols[*mergeId]);
            }
        }
        symbol
    }

    fn getSymbolOfNode(&mut self, node: BoundNode) -> Option<SymbolId> {
        let sym = self
            .node_data(node.clone())
            .symbol
            .map(|s| self.getLateBoundSymbol(s));

        self.getMergedSymbolOptional(sym)
    }

    fn getParentOfSymbol(&mut self, symbol: SymbolId) -> Option<SymbolId> {
        let sym = self.symbols[symbol]
            .parent()
            .map(|p| self.getLateBoundSymbol(p));
        self.getMergedSymbolOptional(sym)
    }

    fn getAlternativeContainingModules(
        &mut self,
        symbol: SymbolId,
        enclosingDeclaration: BoundNode,
    ) -> Vec<SymbolId> {
        // TODO: modules
        Vec::new()
        // todo!();
        // const containingFile = getSourceFileOfNode(enclosingDeclaration);
        // const id = getNodeId(containingFile);
        // const links = getSymbolLinks(symbol);
        // let results: Symbol[] | undefined;
        // if (links.extendedContainersByFile && (results = links.extendedContainersByFile.get(id))) {
        //     return results;
        // }
        // if (containingFile && containingFile.imports) {
        //     // Try to make an import using an import already in the enclosing file, if possible
        //     for (const importRef of containingFile.imports) {
        //         if (nodeIsSynthesized(importRef)) continue; // Synthetic names can't be resolved by `resolveExternalModuleName` - they'll cause a debug assert if they error
        //         const resolvedModule = resolveExternalModuleName(enclosingDeclaration, importRef, /*ignoreErrors*/ true);
        //         if (!resolvedModule) continue;
        //         const ref = getAliasForSymbolInContainer(resolvedModule, symbol);
        //         if (!ref) continue;
        //         results = append(results, resolvedModule);
        //     }
        //     if (length(results)) {
        //         (links.extendedContainersByFile || (links.extendedContainersByFile = new Map())).set(id, results!);
        //         return results!;
        //     }
        // }
        // if (links.extendedContainers) {
        //     return links.extendedContainers;
        // }
        // // No results from files already being imported by this file - expand search (expensive, but not location-specific, so cached)
        // const otherFiles = host.getSourceFiles();
        // for (const file of otherFiles) {
        //     if (!isExternalModule(file)) continue;
        //     const sym = getSymbolOfNode(file);
        //     const ref = getAliasForSymbolInContainer(sym, symbol);
        //     if (!ref) continue;
        //     results = append(results, sym);
        // }
        // return links.extendedContainers = results || emptyArray;
    }

    /**
     * Attempts to find the symbol corresponding to the container a symbol is in - usually this
     * is just its' `.parent`, but for locals, this value is `None`
     */
    fn getContainersOfSymbol(
        &mut self,
        symbol: SymbolId,
        enclosingDeclaration: Option<BoundNode>,
        meaning: SymbolFlags,
    ) -> Option<Vec<SymbolId>> {
        let container = self.getParentOfSymbol(symbol);
        // Type parameters end up in the `members` lists but are not externally visible
        if let Some(container) = container {
            if !self.symbols[symbol]
                .flags()
                .intersects(SymbolFlags::TypeParameter)
            {
                macro_rules! get_additional_containers {
                    () => {
                        self.symbols[container]
                            .declarations()
                            .iter()
                            .cloned()
                            .filter_map(fileSymbolIfFileSymbolExportEqualsContainer)
                    };
                }
                let container_flags = self.symbols[container].flags();
                // let additionalContainers = self.symbols[container]
                //     .declarations()
                //     .iter()
                //     .cloned()
                //     .filter_map(fileSymbolIfFileSymbolExportEqualsContainer);
                let reexportContainers = enclosingDeclaration
                    .clone()
                    .map(|d| self.getAlternativeContainingModules(symbol, d));
                let objectLiteralContainer =
                    self.getVariableDeclarationOfObjectLiteral(container, meaning);
                if enclosingDeclaration.is_some()
                    && container_flags.intersects(getQualifiedLeftMeaning(meaning))
                    && self
                        .getAccessibleSymbolChain(
                            Some(container),
                            enclosingDeclaration.clone(),
                            SymbolFlags::Namespace,
                            false,
                            &mut Default::default(),
                        )
                        .is_some()
                {
                    todo!();
                    // return append(
                    //     concatenate(
                    //         concatenate([container], additionalContainers),
                    //         reexportContainers,
                    //     ),
                    //     objectLiteralContainer,
                    // ); // This order expresses a preference for the real container if it is in scope
                }
                let ty = self.getDeclaredTypeOfSymbol(container);
                // we potentially have a symbol which is a member of the instance side of something - look for a variable in scope with the container's type
                // which may be acting like a namespace (eg, `Symbol` acts like a namespace when looking up `Symbol.toStringTag`)
                let firstVariableMatch = if !container_flags
                    .intersects(getQualifiedLeftMeaning(meaning))
                    && container_flags.intersects(SymbolFlags::Type)
                    && self.types[ty].get_flags().intersects(TypeFlags::Object)
                    && meaning == SymbolFlags::Value
                {
                    self.forEachSymbolTableInScope(enclosingDeclaration, |checker, t, _, _, _| {
                        // TODO: nasty intermedite collect:
                        checker.symbol_tables[t]
                            .values()
                            .cloned()
                            .collect::<Vec<_>>()
                            .into_iter()
                            .find(|&s| {
                                checker.symbols[s]
                                    .flags()
                                    .intersects(getQualifiedLeftMeaning(meaning))
                                    && checker.getTypeOfSymbol(s)
                                        == checker.getDeclaredTypeOfSymbol(container)
                            })
                    })
                } else {
                    None
                };
                use std::iter::once;
                return Some(
                    firstVariableMatch
                        .into_iter()
                        .chain(get_additional_containers!())
                        .chain(once(container))
                        .chain(objectLiteralContainer)
                        .chain(reexportContainers.into_iter().flatten())
                        .collect(),
                );
            }
        }
        // TODO: remove clone of vec:
        let mut candidates = self.symbols[symbol]
            .declarations()
            .clone()
            .iter()
            .filter_map(|d| {
                if !isAmbientModule(&d) {
                    if let Some(parent) = d.parent() {
                        if hasNonGlobalAugmentationExternalModuleSymbol(&parent) {
                            return self.getSymbolOfNode(parent);
                        }
                    }
                }
                if matches!(d, BoundNode::ClassExpr(_)) {
                    todo!();
                    // if let Some(parent) = d.parent() {
                    //     if isBinaryExpression(parent) && parent.operatorToken.kind == SyntaxKind.EqualsToken && isAccessExpression(parent.left) && isEntityNameExpression(parent.left.expression) {
                    //         if isModuleExportsAccessExpression(parent.left) || isExportsIdentifier(parent.left.expression) {
                    //             return self.getSymbolOfNode(getSourceFileOfNode(d));
                    //         }
                    //         self.checkExpressionCached(parent.left.expression);
                    //         return self.getNodeLinks(parent.left.expression).resolvedSymbol;
                    //     }
                    // }
                }
                None
            })
            .collect::<Vec<_>>();
        if candidates.is_empty() {
            return None;
        }
        candidates.retain(|candidate| {
            self.getAliasForSymbolInContainer(*candidate, symbol)
                .is_some()
        });
        return Some(candidates);

        fn fileSymbolIfFileSymbolExportEqualsContainer(d: BoundNode) -> Option<SymbolId> {
            // todo!();
            // TODO:
            None
            // return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container);
        }
    }

    fn getVariableDeclarationOfObjectLiteral(
        &mut self,
        symbol: SymbolId,
        meaning: SymbolFlags,
    ) -> Option<SymbolId> {
        // If we're trying to reference some object literal in, eg `var a = { x: 1 }`, the symbol for the literal, `__object`, is distinct
        // from the symbol of the declaration it is being assigned to. Since we can use the declaration to refer to the literal, however,
        // we'd like to make that connection here - potentially causing us to paint the declaration's visibility, and therefore the literal.
        if let Some(firstDecl) = self.symbols[symbol].declarations().first() {
            if let Some(parent_node) = firstDecl.parent() {
                if let BoundNode::VarDeclarator(parent) = &parent_node {
                    if meaning.intersects(SymbolFlags::Value) {
                        match firstDecl {
                            BoundNode::ObjectLit(n)
                                if Some(ast::Expr::Object(n.node.clone())) == parent.init =>
                            {
                                return self.getSymbolOfNode(parent_node)
                            }
                            BoundNode::TsTypeLit(n) => {
                                let type_ann = match &parent.name {
                                    ast::Pat::Ident(n) => &n.type_ann,
                                    ast::Pat::Array(n) => &n.type_ann,
                                    ast::Pat::Rest(n) => &n.type_ann,
                                    ast::Pat::Object(n) => &n.type_ann,
                                    ast::Pat::Assign(n) => &n.type_ann,
                                    ast::Pat::Expr(_) => todo!("unreachable?"),
                                    _ => unreachable!(),
                                };
                                if type_ann.as_ref().map(|t| &t.type_ann)
                                    == Some(&ast::TsType::TsTypeLit(n.node.clone()))
                                {
                                    return self.getSymbolOfNode(parent_node);
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
        }
        None
    }

    // TODO:
    // getFileSymbolIfFileSymbolExportEqualsContainer

    fn getAliasForSymbolInContainer(
        &mut self,
        container: SymbolId,
        symbol: SymbolId,
    ) -> Option<SymbolId> {
        if Some(container) == self.getParentOfSymbol(symbol) {
            // fast path, `symbol` is either already the alias or isn't aliased
            return Some(symbol);
        }
        // Check if container is a thing with an `export=` which points directly at `symbol`, and if so, return
        // the container itself as the alias for the symbol
        if let Some(exportEquals) = self.symbols[container].exports().and_then(|e| {
            self.symbol_tables[e].get(&JsWord::from(InternalSymbolName::ExportEquals))
        }) {
            if self
                .getSymbolIfSameReference(*exportEquals, symbol)
                .is_some()
            {
                return Some(container);
            }
        }
        let exports = self.getExportsOfSymbol(container);
        if let Some(&quick) = self.symbol_tables[exports].get(self.symbols[symbol].escapedName()) {
            if self.getSymbolIfSameReference(quick, symbol).is_some() {
                return Some(quick);
            }
        }
        // TODO: nasty intermedite collect:
        self.symbol_tables[exports]
            .values()
            .cloned()
            .collect::<Vec<_>>()
            .into_iter()
            .find(|exported| self.getSymbolIfSameReference(*exported, symbol).is_some())
    }

    /**
     * Checks if two symbols, through aliasing and/or merging, refer to the same thing
     */
    fn getSymbolIfSameReference(&mut self, s1: SymbolId, s2: SymbolId) -> Option<SymbolId> {
        let left = self.getMergedSymbol(s1);
        let left = self.resolveSymbol(left, false);
        let left = self.getMergedSymbol(left);

        let right = self.getMergedSymbol(s2);
        let right = self.resolveSymbol(right, false);
        let right = self.getMergedSymbol(right);

        if left == right {
            Some(s1)
        } else {
            None
        }
    }

    fn getExportSymbolOfValueSymbolIfExported(&mut self, symbol: SymbolId) -> SymbolId {
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::ExportValue)
        {
            self.getMergedSymbol(self.symbols[symbol].exportSymbol().unwrap())
        } else {
            self.getMergedSymbol(symbol)
        }
    }

    fn getExportSymbolOfValueSymbolIfExportedOptional(
        &mut self,
        symbol: Option<SymbolId>,
    ) -> Option<SymbolId> {
        if let Some(sym) = symbol {
            if self.symbols[sym]
                .flags()
                .intersects(SymbolFlags::ExportValue)
            {
                self.getMergedSymbolOptional(self.symbols[sym].exportSymbol())
            } else {
                self.getMergedSymbolOptional(symbol)
            }
        } else {
            None
        }
    }

    fn symbolIsValue(&mut self, symbol: SymbolId) -> bool {
        let flags = self.symbols[symbol].flags();
        if flags.intersects(SymbolFlags::Value) {
            true
        } else if flags.intersects(SymbolFlags::Alias) {
            let resolved = self.resolveAlias(symbol);
            self.symbols[resolved]
                .flags()
                .intersects(SymbolFlags::Value)
                && self.getTypeOnlyAliasDeclaration(symbol).is_none()
        } else {
            false
        }
    }

    // TODO:
    // fn createIntrinsicType(
    //     &mut self,
    //     kind: TypeFlags,
    //     intrinsic_name: &'static str,
    //     object_flags: ObjectFlags,
    // ) -> TypeId {
    //     let ty = Type::new_intrinsic(kind, intrinsic_name, object_flags);
    //     self.types.push(ty)
    // }

    fn createObjectType(&mut self, objectFlags: ObjectFlags, symbol: Option<SymbolId>) -> TypeId {
        let ty = Type::ObjectType(ObjectType::new(objectFlags, symbol));
        self.types.push(ty)
    }

    // TODO:
    // createTypeofType

    fn createTypeParameter(&mut self, symbol: Option<SymbolId>) -> TypeId {
        let ty = Type::TypeParameter(TypeParameter {
            instantiable_type: InstantiableType::default(),
            type_base: TypeBase::new(TypeFlags::TypeParameter, symbol),
            constraint: None,
            default: None,
            target: None,
            mapper: None,
            isThisType: false,
            resolvedDefaultType: None,
        });
        self.types.push(ty)
    }

    // A reserved member name starts with two underscores, but the third character cannot be an underscore,
    // @, or #. A third underscore indicates an escaped form of an identifier that started
    // with at least two underscores. The @ character indicates that the name is denoted by a well known ES
    // Symbol instance and the # character indicates that the name is a PrivateIdentifier.
    fn isReservedMemberName(&self, name: &JsWord) -> bool {
        // TODO:
        false
        // return (name as string).charCodeAt(0) === CharacterCodes._ &&
        //     (name as string).charCodeAt(1) === CharacterCodes._ &&
        //     (name as string).charCodeAt(2) !== CharacterCodes._ &&
        //     (name as string).charCodeAt(2) !== CharacterCodes.at &&
        //     (name as string).charCodeAt(2) !== CharacterCodes.hash;
    }

    fn getNamedMembers(&mut self, members: SymbolTableId) -> Vec<SymbolId> {
        // TODO: bad collect
        let mut all_members = self.symbol_tables[members]
            .values()
            .copied()
            .collect::<Vec<_>>();
        all_members.retain(|&symbol| {
            let id = self.symbols[symbol].escapedName();
            !self.isReservedMemberName(id) && self.symbolIsValue(symbol)
        });
        all_members
    }

    fn getNamedMembersOfSymbolTableId(&mut self, members: SymbolTableId) -> Vec<SymbolId> {
        // TODO: bad double collect:
        self.symbol_tables[members]
            .iter()
            .map(|(js_word, sym)| (js_word.clone(), *sym))
            .collect::<Vec<_>>()
            .into_iter()
            .filter_map(|(id, symbol)| {
                if !self.isReservedMemberName(&id) && self.symbolIsValue(symbol) {
                    Some(symbol)
                } else {
                    None
                }
            })
            .collect()
    }

    // TODO: it may be possible to optimise this (look at the callers and check that they really
    // have to allocate an intermidiary SymbolTable).
    fn getNamedMembersOfSymbolTable(&mut self, members: SymbolTable) -> Vec<SymbolId> {
        members
            .into_iter()
            .filter_map(|(id, symbol)| {
                if !self.isReservedMemberName(&id) && self.symbolIsValue(symbol) {
                    Some(symbol)
                } else {
                    None
                }
            })
            .collect()
    }

    // TODO: maybe make call pass in the symbol table the members will be added to,
    // so we can avoid the intermidaiary vec. Would also need to change `getNamedMembers`
    fn getNamedOrIndexSignatureMembers(&mut self, members: SymbolTableId) -> Vec<SymbolId> {
        let mut result = self.getNamedMembers(members);
        let index = self.getIndexSymbolFromSymbolTable(members);
        if let Some(index) = index {
            result.push(index);
        }
        result
    }

    fn setStructuredTypeMembers(
        &mut self,
        ty: TypeId,
        members: SymbolTableId,
        callSignatures: Rc<Vec<SignatureId>>,
        constructSignatures: Rc<Vec<SignatureId>>,
        indexInfos: Rc<Vec<IndexInfoId>>,
    ) -> TypeId {
        ResolvedType::convert(&mut self.types[ty]);
        let resolved = unwrap_as!(&mut self.types[ty], Type::ResolvedType(t), t);
        resolved.object_type_base.members = Some(members);
        // resolved.object_type_base.properties = Vec::new();
        resolved.object_type_base.callSignatures = callSignatures;
        resolved.object_type_base.constructSignatures = constructSignatures;
        resolved.object_type_base.indexInfos = indexInfos;
        // This can loop back to getPropertyOfType() which would crash if `callSignatures` & `constructSignatures` are not initialized.
        if members != self.emptySymbols {
            let props = self.getNamedMembersOfSymbolTableId(members);
            unwrap_as!(&mut self.types[ty], Type::ResolvedType(t), t)
                .object_type_base
                .properties = Rc::new(props);
        }
        ty
    }

    fn createAnonymousType(
        &mut self,
        symbol: Option<SymbolId>,
        members: SymbolTableId,
        callSignatures: Rc<Vec<SignatureId>>,
        constructSignatures: Rc<Vec<SignatureId>>,
        indexInfos: Rc<Vec<IndexInfoId>>,
    ) -> TypeId {
        // TODO: is this correct?
        let ty = Type::AnonymousType(AnonymousType {
            anonymous_type: Default::default(),
            object_type_base: ObjectTypeBase::new(ObjectFlags::Anonymous),
            type_base: TypeBase::new(TypeFlags::Object, symbol),
        });
        let ty = self.types.push(ty);
        self.setStructuredTypeMembers(ty, members, callSignatures, constructSignatures, indexInfos);
        ty
    }

    // TODO:
    // getResolvedTypeWithoutAbstractConstructSignatures

    fn forEachSymbolTableInScope<T, C>(
        &mut self,
        enclosingDeclaration: Option<BoundNode>,
        mut callback: C,
    ) -> Option<T>
    where
        T: std::fmt::Debug,
        C: FnMut(&mut Checker, SymbolTableId, bool, bool, Option<BoundNode>) -> Option<T>,
    {
        let mut location = enclosingDeclaration;
        while let Some(loc) = location {
            // Locals of a source file are not in scope (because they get merged into the global symbol table)
            if let Some(locals) = self.node_data(loc.clone()).locals {
                if !isGlobalSourceFile(&loc) {
                    let result = callback(
                        self,
                        locals,
                        /*ignoreQualification*/ false,
                        /*isLocalNameLookup*/ true,
                        /*scopeNode*/ Some(loc.clone()),
                    );
                    if result.is_some() {
                        return result;
                    }
                }
            }
            match &loc {
                BoundNode::Script(_) | BoundNode::Module(_) | BoundNode::TsModuleDecl(_) => {
                    if !matches!(loc, BoundNode::Script(_) | BoundNode::Module(_))
                        || isExternalOrCommonJsModule(&loc)
                    {
                        let sym = self.getSymbolOfNode(loc.clone()).unwrap();
                        // `sym` may not have exports if this module declaration is backed by the symbol for a `const` that's being rewritten
                        // into a namespace - in such cases, it's best to just let the namespace appear empty (the const members couldn't have referred
                        // to one another anyway)
                        let exports = self.symbols[sym].exports().unwrap_or(self.emptySymbols);
                        let result = callback(
                            self,
                            exports,
                            /*ignoreQualification*/ false,
                            /*isLocalNameLookup*/ true,
                            /*scopeNode*/ Some(loc.clone()),
                        );
                        if result.is_some() {
                            return result;
                        }
                    }
                }
                BoundNode::ClassDecl(_)
                | BoundNode::ClassExpr(_)
                | BoundNode::TsInterfaceDecl(_) => {
                    // Type parameters are bound into `members` lists so they can merge across declarations
                    // This is troublesome, since in all other respects, they behave like locals :cries:
                    // TODO: the below is shared with similar code in `resolveName` - in fact, rephrasing all this symbol
                    // lookup logic in terms of `resolveName` would be nice
                    // The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals
                    // These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would
                    // trigger resolving late-bound names, which we may already be in the process of doing while we're here!
                    let mut table: Option<SymbolTable> = None;
                    // TODO: Should this filtered table be cached in some way?

                    let sym = self.getSymbolOfNode(loc.clone()).unwrap();
                    let members = self.symbols[sym].members().unwrap_or(self.emptySymbols);
                    for (key, &memberSymbol) in &self.symbol_tables[members] {
                        if self.symbols[memberSymbol]
                            .flags()
                            .intersects(SymbolFlags::Type & !SymbolFlags::Assignment)
                        {
                            table
                                .get_or_insert_with(|| new_ahash_map![(key.clone(), memberSymbol)]);
                        }
                    }
                    if let Some(table) = table {
                        // TODO: this is probably bad. Each time this branch is reached, we permenantly store the symbol
                        // table, but it is only temporary/used once, thereby "leaking memory" until the Checker is dropped.
                        let table = self.symbol_tables.push(table);
                        let result = callback(
                            self,
                            table,
                            /*ignoreQualification*/ false,
                            /*isLocalNameLookup*/ false,
                            /*scopeNode*/ Some(loc.clone()),
                        );
                        if result.is_some() {
                            return result;
                        }
                    }
                }
                _ => {}
            }
            location = loc.parent();
        }

        callback(
            self,
            self.globals,
            /*ignoreQualification*/ false,
            /*isLocalNameLookup*/ true,
            /*scopeNode*/ None,
        )
    }

    // TODO: optimise this method to remove clones
    fn getAccessibleSymbolChain(
        &mut self,
        symbol: Option<SymbolId>,
        enclosingDeclaration: Option<BoundNode>,
        meaning: SymbolFlags,
        useOnlyExternalAliasing: bool,
        visitedSymbolTablesMap: &mut AHashMap<SymbolId, Vec<SymbolTableId>>,
    ) -> Option<Vec<SymbolId>> {
        let symbol = symbol?;
        if self.isPropertyOrMethodDeclarationSymbol(symbol) {
            return None;
        }
        // Go from enclosingDeclaration to the first scope we check, so the cache is keyed off the scope and thus shared more
        let firstRelevantLocation =
            self.forEachSymbolTableInScope(enclosingDeclaration.clone(), |_, _, _, _, node| node);
        let key = SymbolLinksAccessibleChainCacheKey::new(
            useOnlyExternalAliasing,
            firstRelevantLocation,
            meaning,
        );
        if let Some(v) = self.getSymbolLinks(symbol).accessibleChainCache.get(&key) {
            return v.clone();
        }

        let result = self.forEachSymbolTableInScope(
            enclosingDeclaration.clone(),
            |checker, symbols, ignoreQualification, isLocalNameLookup, _| {
                getAccessibleSymbolChainFromSymbolTable(
                    checker,
                    symbol,
                    visitedSymbolTablesMap,
                    enclosingDeclaration.clone(),
                    meaning,
                    useOnlyExternalAliasing,
                    symbols,
                    ignoreQualification,
                    isLocalNameLookup,
                )
            },
        );
        self.getSymbolLinksMut(symbol)
            .accessibleChainCache
            .insert(key, result.clone());
        return result;

        /**
         * @param {ignoreQualification} boolean Set when a symbol is being looked for through the exports of another symbol (meaning we have a route to qualify it already)
         */
        fn getAccessibleSymbolChainFromSymbolTable(
            checker: &mut Checker,
            symbol: SymbolId,
            visitedSymbolTablesMap: &mut AHashMap<SymbolId, Vec<SymbolTableId>>,
            enclosingDeclaration: Option<BoundNode>,
            meaning: SymbolFlags,
            useOnlyExternalAliasing: bool,
            symbols: SymbolTableId,
            ignoreQualification: bool,
            isLocalNameLookup: bool,
        ) -> Option<Vec<SymbolId>> {
            if !visitedSymbolTablesMap
                .entry(symbol)
                .or_default()
                .push_if_unique(symbols)
            {
                return None;
            }

            let result = trySymbolTable(
                checker,
                symbol,
                visitedSymbolTablesMap,
                enclosingDeclaration,
                meaning,
                useOnlyExternalAliasing,
                symbols,
                ignoreQualification,
                isLocalNameLookup,
            );
            visitedSymbolTablesMap.entry(symbol).or_default().pop();
            result
        }

        fn canQualifySymbol(
            checker: &mut Checker,
            enclosingDeclaration: Option<BoundNode>,
            useOnlyExternalAliasing: bool,
            visitedSymbolTablesMap: &mut AHashMap<SymbolId, Vec<SymbolTableId>>,
            symbolFromSymbolTable: SymbolId,
            meaning: SymbolFlags,
        ) -> bool {
            // If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
            !checker.needsQualification(symbolFromSymbolTable, enclosingDeclaration.clone(), meaning) ||
                // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too
                checker.getAccessibleSymbolChain(checker.symbols[symbolFromSymbolTable].parent(), enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing,visitedSymbolTablesMap).is_some()
        }

        fn isAccessible(
            checker: &mut Checker,
            symbol: SymbolId,
            visitedSymbolTablesMap: &mut AHashMap<SymbolId, Vec<SymbolTableId>>,
            enclosingDeclaration: Option<BoundNode>,
            meaning: SymbolFlags,
            useOnlyExternalAliasing: bool,
            symbolFromSymbolTable: Option<SymbolId>,
            resolvedAliasSymbol: Option<SymbolId>,
            ignoreQualification: bool,
        ) -> bool {
            (Some(symbol) == resolvedAliasSymbol.or(symbolFromSymbolTable) || Some(checker.getMergedSymbol(symbol)) == checker.getMergedSymbolOptional(resolvedAliasSymbol.or(symbolFromSymbolTable))) &&
                // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)
                // and if symbolFromSymbolTable or alias resolution matches the symbol,
                // check the symbol can be qualified, it is only then this symbol is accessible
                !checker.symbols[symbolFromSymbolTable.unwrap()].declarations().iter().any(hasNonGlobalAugmentationExternalModuleSymbol) &&
                (ignoreQualification || canQualifySymbol(checker, enclosingDeclaration.clone(),useOnlyExternalAliasing,visitedSymbolTablesMap, checker.getMergedSymbol(symbolFromSymbolTable.unwrap()), meaning))
        }

        fn trySymbolTable(
            checker: &mut Checker,
            symbol: SymbolId,
            visitedSymbolTablesMap: &mut AHashMap<SymbolId, Vec<SymbolTableId>>,
            enclosingDeclaration: Option<BoundNode>,
            meaning: SymbolFlags,
            useOnlyExternalAliasing: bool,
            symbols: SymbolTableId,
            ignoreQualification: bool,
            isLocalNameLookup: bool,
        ) -> Option<Vec<SymbolId>> {
            macro_rules! s {
                ($sym:expr) => {
                    checker.symbols[$sym]
                };
            }
            // If symbol is directly available by its name in the symbol table
            if isAccessible(
                checker,
                symbol,
                visitedSymbolTablesMap,
                enclosingDeclaration.clone(),
                meaning,
                useOnlyExternalAliasing,
                checker.symbol_tables[symbols]
                    .get(s!(symbol).escapedName())
                    .copied(),
                None,
                ignoreQualification,
            ) {
                return Some(vec![symbol]);
            }

            // Check if symbol is any of the aliases in scope
            // TODO: nasty intermedite collect:
            let result = checker.symbol_tables[symbols].values().cloned().collect::<Vec<_>>().into_iter().find_map(|symbolFromSymbolTable|  {
                if s!(symbolFromSymbolTable).flags().intersects(SymbolFlags::Alias)
                    && s!(symbolFromSymbolTable).escapedName() != InternalSymbolName::ExportEquals
                    && s!(symbolFromSymbolTable).escapedName() != InternalSymbolName::Default
                    && !(isUMDExportSymbol(Some(&s!(symbolFromSymbolTable))) && enclosingDeclaration.is_some() && todo!()/*isExternalModule(getSourceFileOfNode(enclosingDeclaration.unwrap()))*/)
                    // If `!useOnlyExternalAliasing`, we can use any type of alias to get the name
                    && (!useOnlyExternalAliasing || todo!()/*s!(symbolFromSymbolTable).declarations().iter().any(isExternalModuleImportEqualsDeclaration)*/)
                    // If we're looking up a local name to reference directly, omit namespace reexports, otherwise when we're trawling through an export list to make a dotted name, we can keep it
                    && (if isLocalNameLookup {todo!()/* !s!(symbolFromSymbolTable).declarations().iter().any(isNamespaceReexportDeclaration)*/} else {true})
                    // While exports are generally considered to be in scope, export-specifier declared symbols are _not_
                    // See similar comment in `resolveName` for details
                    && (ignoreQualification || checker.getDeclarationOfKind(symbolFromSymbolTable, |_|{todo!()/*SyntaxKind.ExportSpecifier*/}).is_none())
                 {

                    let resolvedImportedSymbol = checker.resolveAlias(symbolFromSymbolTable);
                    let candidate = getCandidateListForSymbol(checker,symbol,visitedSymbolTablesMap, enclosingDeclaration.clone(),meaning,useOnlyExternalAliasing, symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification);
                    if candidate.is_some() {
                        return candidate;
                    }
                }
                if s!(symbolFromSymbolTable).escapedName() == s!(symbol).escapedName() && s!(symbolFromSymbolTable).exportSymbol().is_some() {
                    if isAccessible(checker,symbol,visitedSymbolTablesMap, enclosingDeclaration.clone(),meaning, useOnlyExternalAliasing,Some(checker.getMergedSymbol(s!(symbolFromSymbolTable).exportSymbol().unwrap())),  None, ignoreQualification) {
                        return Some(vec![symbol]);
                    }
                }
                None
            });

            // If there's no result and we're looking at the global symbol table, treat `globalThis` like an alias and try to lookup thru that
            result.or(if symbols == checker.globals {
                getCandidateListForSymbol(
                    checker,
                    symbol,
                    visitedSymbolTablesMap,
                    enclosingDeclaration,
                    meaning,
                    useOnlyExternalAliasing,
                    checker.globalThisSymbol,
                    checker.globalThisSymbol,
                    ignoreQualification,
                )
            } else {
                None
            })
        }

        fn getCandidateListForSymbol(
            checker: &mut Checker,
            symbol: SymbolId,
            visitedSymbolTablesMap: &mut AHashMap<SymbolId, Vec<SymbolTableId>>,
            enclosingDeclaration: Option<BoundNode>,
            meaning: SymbolFlags,
            useOnlyExternalAliasing: bool,
            symbolFromSymbolTable: SymbolId,
            resolvedImportedSymbol: SymbolId,
            ignoreQualification: bool,
        ) -> Option<Vec<SymbolId>> {
            if isAccessible(
                checker,
                symbol,
                visitedSymbolTablesMap,
                enclosingDeclaration.clone(),
                meaning,
                useOnlyExternalAliasing,
                Some(symbolFromSymbolTable),
                Some(resolvedImportedSymbol),
                ignoreQualification,
            ) {
                return Some(vec![symbolFromSymbolTable]);
            }

            // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
            // but only if the symbolFromSymbolTable can be qualified
            let candidateTable = checker.getExportsOfSymbol(resolvedImportedSymbol);
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// BIGBAD
            let accessibleSymbolsFromExports = getAccessibleSymbolChainFromSymbolTable(
                checker,
                symbol,
                visitedSymbolTablesMap,
                enclosingDeclaration.clone(),
                meaning,
                useOnlyExternalAliasing,
                candidateTable,
                true,
                false,
            );
            if let Some(mut accessibleSymbolsFromExports) = accessibleSymbolsFromExports {
                if canQualifySymbol(
                    checker,
                    enclosingDeclaration,
                    useOnlyExternalAliasing,
                    visitedSymbolTablesMap,
                    symbolFromSymbolTable,
                    getQualifiedLeftMeaning(meaning),
                ) {
                    accessibleSymbolsFromExports.insert(0, symbolFromSymbolTable);
                    return Some(accessibleSymbolsFromExports);
                    // return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
                }
            }
            None
        }
    }

    fn needsQualification(
        &mut self,
        symbol: SymbolId,
        enclosingDeclaration: Option<BoundNode>,
        meaning: SymbolFlags,
    ) -> bool {
        let mut qualify = false;
        self.forEachSymbolTableInScope(enclosingDeclaration, |checker, symbolTable, _, _, _| {
            macro_rules! s {
                ($sym:expr) => {
                    checker.symbols[$sym]
                };
            }
            // If symbol of this name is not available in the symbol table we are ok
            let symbolFromSymbolTable = checker.getMergedSymbolOptional(
                checker.symbol_tables[symbolTable]
                    .get(s!(symbol).escapedName())
                    .copied(),
            );
            if let Some(mut symbolFromSymbolTable) = symbolFromSymbolTable {
                // If the symbol with this name is present it should refer to the symbol
                if symbolFromSymbolTable == symbol {
                    // No need to qualify
                    return Some(true);
                }

                // Qualify if the symbol from symbol table has same meaning as expected
                // TODO:
                // symbolFromSymbolTable = if s!(symbolFromSymbolTable)
                //     .flags()
                //     .intersects(SymbolFlags::Alias)
                //     && checker
                //         .getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier)
                //         .is_none()
                // {
                //     checker.resolveAlias(symbolFromSymbolTable)
                // } else {
                //     symbolFromSymbolTable
                // };
                symbolFromSymbolTable = if s!(symbolFromSymbolTable)
                    .flags()
                    .intersects(SymbolFlags::Alias)
                {
                    todo!("see above");
                } else {
                    symbolFromSymbolTable
                };
                if s!(symbolFromSymbolTable).flags().intersects(meaning) {
                    qualify = true;
                    return Some(true);
                }
            }

            // Continue to the next symbol table
            None
        });
        qualify
    }

    fn isPropertyOrMethodDeclarationSymbol(&self, symbol: SymbolId) -> bool {
        let decls = self.symbols[symbol].declarations();
        !decls.is_empty()
            && decls.iter().all(|d| {
                matches!(
                    d,
                    BoundNode::ClassProp(_)
                        | BoundNode::PrivateProp(_)
                        | BoundNode::PrivateMethod(_)
                        | BoundNode::ClassMethod(_)
                        | BoundNode::MethodProp(_)
                        | BoundNode::GetterProp(_)
                        | BoundNode::SetterProp(_)
                )
            })
    }

    // TODO:
    // isTypeSymbolAccessible
    // TODO:
    // isValueSymbolAccessible
    // TODO:
    // isSymbolAccessibleByFlags
    // TODO:
    // isAnySymbolAccessible
    // TODO:
    // isSymbolAccessible
    // TODO:
    // isSymbolAccessibleWorker
    // TODO:
    // getExternalModuleContainer
    // TODO:
    // hasExternalModuleSymbol
    // TODO:
    // hasNonGlobalAugmentationExternalModuleSymbol
    // TODO:
    // hasVisibleDeclarations
    // TODO:
    // isEntityNameVisible

    fn symbolToString(
        &mut self,
        symbol: SymbolId,
        enclosingDeclaration: Option<BoundNode>,
        meaning: Option<SymbolFlags>,
        flags: Option<SymbolFormatFlags>,
    ) -> String {
        let flags = flags.unwrap_or(SymbolFormatFlags::AllowAnyNodeKind);
        // TODO: optimisations all the ways down
        let mut nodeFlags = NodeBuilderFlags::IgnoreErrors;
        if flags.intersects(SymbolFormatFlags::UseOnlyExternalAliasing) {
            nodeFlags |= NodeBuilderFlags::UseOnlyExternalAliasing;
        }
        if flags.intersects(SymbolFormatFlags::WriteTypeParametersOrArguments) {
            nodeFlags |= NodeBuilderFlags::WriteTypeParametersInQualifiedName;
        }
        if flags.intersects(SymbolFormatFlags::UseAliasDefinedOutsideCurrentScope) {
            nodeFlags |= NodeBuilderFlags::UseAliasDefinedOutsideCurrentScope;
        }
        if flags.intersects(SymbolFormatFlags::DoNotIncludeSymbolChain) {
            nodeFlags |= NodeBuilderFlags::DoNotIncludeSymbolChain;
        }
        let mut context = NodeBuilderContext {
            enclosingDeclaration,
            flags: nodeFlags,
        };
        let chain = self.lookupSymbolChain(symbol, &context, meaning.unwrap_or_default(), false);
        let mut res = String::new();
        for (i, sym) in chain.iter().enumerate() {
            // let typeParameterNodes = lookupTypeParameterNodes(chain, i, context);

            if i == 0 {
                context.flags |= NodeBuilderFlags::InInitialEntityName;
            }
            let symbolName = self.getNameOfSymbolAsWritten(*sym, Some(&mut context));
            if i == 0 {
                context.flags ^= NodeBuilderFlags::InInitialEntityName;
            }

            if i > 0 {
                res.push('.');
            }
            res.push_str(&symbolName);
        }
        res

        // let nodeFlags = NodeBuilderFlags::IgnoreErrors;
        // if flags.intersects(SymbolFormatFlags::UseOnlyExternalAliasing) {
        //     nodeFlags |= NodeBuilderFlags::UseOnlyExternalAliasing;
        // }
        // if flags.intersects(SymbolFormatFlags::WriteTypeParametersOrArguments) {
        //     nodeFlags |= NodeBuilderFlags::WriteTypeParametersInQualifiedName;
        // }
        // if flags.intersects(SymbolFormatFlags::UseAliasDefinedOutsideCurrentScope) {
        //     nodeFlags |= NodeBuilderFlags::UseAliasDefinedOutsideCurrentScope;
        // }
        // if flags.intersects(SymbolFormatFlags::DoNotIncludeSymbolChain) {
        //     nodeFlags |= NodeBuilderFlags::DoNotIncludeSymbolChain;
        // }
        // let builder = if flags.intersects(SymbolFormatFlags::AllowAnyNodeKind) {
        //     nodeBuilder.symbolToExpression
        // } else {
        //     nodeBuilder.symbolToEntityName
        // };
        // return if writer {
        //     symbolToStringWorker(writer).getText()
        // } else {
        //     usingSingleLineStringWriter(symbolToStringWorker)
        // };

        // fn symbolToStringWorker(writer: EmitTextWriter) -> EmitTextWriter {
        //     // TODO: GH#18217
        //     let entity =
        //         builder(symbol, meaning.unwrap(), enclosingDeclaration, nodeFlags).unwrap();
        //     // add neverAsciiEscape for GH#39027
        //     // let printer = if enclosingDeclaration?.kind == SyntaxKind.SourceFile {createPrinter({ removeComments: true, neverAsciiEscape: true }) }else{createPrinter({ removeComments: true })};
        //     let sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
        //     printer.writeNode(
        //         EmitHint.Unspecified,
        //         entity,
        //         /*sourceFile*/ sourceFile,
        //         writer,
        //     );
        //     return writer;
        // }
    }

    // TODO:
    // signatureToString
    // TODO:
    // typeToString
    // TODO:
    // getTypeNamesForErrorDisplay
    // TODO:
    // getTypeNameForErrorDisplay
    // TODO:
    // symbolValueDeclarationIsContextSensitive
    // TODO:
    // toNodeBuilderFlags
    // TODO:
    // isClassInstanceSide
    // TODO:
    // createNodeBuilder
    // TODO:
    // typePredicateToString
    // TODO:
    // formatUnionTypes
    // TODO:
    // visibilityToString
    // TODO:
    // getTypeAliasForTypeLiteral
    // TODO:
    // isTopLevelInExternalModuleAugmentation

    fn getNameOfSymbolFromNameType(
        &mut self,
        symbol: SymbolId,
        context: Option<&mut NodeBuilderContext>,
    ) -> Option<String> {
        let nameType = self.getSymbolLinks(symbol).nameType;
        if let Some(nameType) = nameType {
            if self.types[nameType]
                .get_flags()
                .intersects(TypeFlags::StringOrNumberLiteral)
            {
                todo!();
                // let name = match &self.types[nameType] {
                //     Type::StringLiteralType(t) => t.value,
                //     Type::NumberLiteralType(t) => t.value,
                //     _ => unreachable!()
                // };
                // let name = "" + (nameType as StringLiteralType | NumberLiteralType).value;
                // if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name) {
                //     todo!()
                //     // return `"${escapeString(name, CharacterCodes.doubleQuote)}"`;
                // }
                // if isNumericLiteralName(name) && startsWith(name, "-") {
                //     todo!()
                //     // return `[${name}]`;
                // }
                // return name;
            }
            if self.types[nameType]
                .get_flags()
                .intersects(TypeFlags::UniqueESSymbol)
            {
                let sym = self.types[nameType].get_symbol().unwrap();
                let name_of_sym = self.getNameOfSymbolAsWritten(sym, context);
                return Some(format!("[{}]", name_of_sym));
            }
        }
        None
    }

    /// Gets a human-readable name for a symbol.
    /// Should *not* be used for the right-hand side of a `.` -- use `symbolName(symbol)` for that instead.
    ///
    /// Unlike `symbolName(symbol)`, this will include quotes if the name is from a string literal.
    /// It will also use a representation of a number as written instead of a decimal form, e.g. `0o11` instead of `9`.
    fn getNameOfSymbolAsWritten(
        &mut self,
        symbol: SymbolId,
        context: Option<&mut NodeBuilderContext>,
    ) -> String {
        if let Some(context) = &context {
            if self.symbols[symbol].escapedName() == InternalSymbolName::Default && !context.flags.intersects(NodeBuilderFlags::UseAliasDefinedOutsideCurrentScope) &&
            // If it's not the first part of an entity name, it must print as `default`
            (!context.flags.intersects(NodeBuilderFlags::InInitialEntityName) ||
            // if the symbol is synthesized, it will only be referenced externally it must print as `default`
            self.symbols[symbol].declarations().is_empty() ||
            // if not in the same binding context (source file, module declaration), it must print as `default`
            (context.enclosingDeclaration.is_some() && findAncestor(self.symbols[symbol].declarations().first().cloned(), |d|Some(isDefaultBindingContext(d))) != findAncestor(context.enclosingDeclaration.clone(), |d|Some(isDefaultBindingContext(d)))))
            {
                return "default".to_string();
            }
        }
        if !self.symbols[symbol].declarations().is_empty() {
            // Try using a declaration with a name, first
            let mut declaration = self.symbols[symbol]
                .declarations()
                .iter()
                .find(|&d| getNameOfDeclaration(d).is_some())
                .cloned();
            let name = declaration.as_ref().and_then(|d| getNameOfDeclaration(d));
            if let (Some(declaration), Some(name)) = (&declaration, name) {
                if let BoundNode::CallExpr(c) = declaration {
                    if isBindableObjectDefinePropertyCall(c) {
                        return symbolName(&self.symbols[symbol]).to_string();
                    }
                }
                if matches!(name, DeclName::ComputedProperty(_))
                    && !getCheckFlags(&self.symbols[symbol]).intersects(CheckFlags::Late)
                {
                    let nameTypeFlags = self
                        .getSymbolLinks(symbol)
                        .nameType
                        .map(|t| self.types[t].get_flags());
                    if let Some(nameTypeFlags) = nameTypeFlags {
                        if nameTypeFlags.intersects(TypeFlags::StringOrNumberLiteral) {
                            // Computed property name isn't late bound, but has a well-known name type - use name type to generate a symbol name
                            let result = self.getNameOfSymbolFromNameType(symbol, context);
                            if let Some(result) = result {
                                return result;
                            }
                        }
                    }
                }
                // TODO:
                // return declarationNameToString(name);
                return match name {
                    DeclName::Ident(n) => n.sym.to_string(),
                    DeclName::PrivateName(n) => n.id.sym.to_string(),
                    DeclName::String(n) => n.value.to_string(),
                    _ => todo!(),
                };
            }
            if declaration.is_none() {
                // Declaration may be nameless, but we'll try anyway
                declaration = Some(self.symbols[symbol].declarations()[0].clone());
            }
            let declaration = declaration.unwrap();
            if let Some(BoundNode::VarDeclarator(v)) = declaration.parent() {
                todo!();
                // return declarationNameToString(v.name);
            }
            match declaration {
                // TODO:
                // BoundNode::ClassExpr(_) | BoundNode::FnExpr(_) | BoundNode::ArrowExpr(_) => {
                //
                //     // if context
                //     //     && !context.encounteredError
                //     //     && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)
                //     // {
                //     //     context.encounteredError = true;
                //     // }
                //     return if declaration.kind == SyntaxKind.ClassExpression {
                //         "(Anonymous class)"
                //     } else {
                //         "(Anonymous function)"
                //     };
                // }
                BoundNode::ClassExpr(_) => {
                    return "(Anonymous class)".to_string();
                }
                BoundNode::FnExpr(_) | BoundNode::ArrowExpr(_) => {
                    return "(Anonymous function)".to_string();
                }
                _ => {}
            }
        }
        let name = self.getNameOfSymbolFromNameType(symbol, context);
        if let Some(name) = name {
            name
        } else {
            todo!();
            // symbolName(symbol)
        }
    }

    // TODO:
    // isDeclarationVisible
    // TODO:
    // collectLinkedAliases

    /**
     * Push an entry on the type resolution stack. If an entry with the given target and the given property name
     * is already on the stack, and no entries in between already have a type, then a circularity has occurred.
     * In this case, the result values of the existing entry and all entries pushed after it are changed to false,
     * and the value false is returned. Otherwise, the new entry is just pushed onto the stack, and true is returned.
     * In order to see if the same query has already been done before, the target object and the propertyName both
     * must match the one passed in.
     *
     * @param target The symbol, type, or signature whose type is being queried
     * @param propertyName The property name that should be used to query the target for its type
     */
    fn pushTypeResolution(
        &mut self,
        target: TypeSystemEntity,
        propertyName: TypeSystemPropertyName,
    ) -> bool {
        let resolutionCycleStartIndex =
            self.findResolutionCycleStartIndex(target.clone(), propertyName);
        if let Some(resolutionCycleStartIndex) = resolutionCycleStartIndex {
            todo!();
            // A cycle was found
            // for (let i = resolutionCycleStartIndex; i < self.resolutionTargets.len(); i++) {
            //    self. resolutionResults[i] = false;
            // }
            // return false;
        }
        self.resolutionTargets.push(target);
        self.resolutionResults.push(/*items*/ true);
        self.resolutionPropertyNames.push(propertyName);
        true
    }

    fn findResolutionCycleStartIndex(
        &mut self,
        target: TypeSystemEntity,
        propertyName: TypeSystemPropertyName,
    ) -> Option<usize> {
        for i in 0..self.resolutionTargets.len() {
            if self.hasType(
                self.resolutionTargets[i].clone(),
                self.resolutionPropertyNames[i],
            ) {
                return None;
            }
            if self.resolutionTargets[i] == target
                && self.resolutionPropertyNames[i] == propertyName
            {
                return Some(i);
            }
        }
        None
    }

    fn hasType(&mut self, target: TypeSystemEntity, propertyName: TypeSystemPropertyName) -> bool {
        match propertyName {
            TypeSystemPropertyName::Type => self
                .getSymbolLinks(unwrap_as!(target, TypeSystemEntity::Symbol(s), s))
                .ty
                .is_some(),
            TypeSystemPropertyName::EnumTagType => {
                todo!();
                // !!(getNodeLinks(target as JSDocEnumTag).resolvedEnumType)
            }
            TypeSystemPropertyName::DeclaredType => self
                .getSymbolLinks(unwrap_as!(target, TypeSystemEntity::Symbol(s), s))
                .declaredType
                .is_some(),
            TypeSystemPropertyName::ResolvedBaseConstructorType => {
                todo!();
                // unwrap_as!(target as InterfaceType).resolvedBaseConstructorType.is_some()
            }
            TypeSystemPropertyName::ResolvedReturnType => {
                unwrap_as!(target, TypeSystemEntity::Signature(s), &self.signatures[s])
                    .resolvedReturnType
                    .is_some()
            }
            TypeSystemPropertyName::ImmediateBaseConstraint => {
                unwrap_as!(target, TypeSystemEntity::Type(t), &self.types[t])
                    .get_immediateBaseConstraint()
                    .is_some()
            }
            TypeSystemPropertyName::ResolvedTypeArguments => {
                todo!();
                // unwrap_as!(target as TypeReference).resolvedTypeArguments.is_some()
            }
            TypeSystemPropertyName::ResolvedBaseTypes => {
                unwrap_as!(target, TypeSystemEntity::Type(t), &self.types[t])
                    .unwrap_as_interface_type()
                    .baseTypesResolved
            }
        }
    }

    /**
     * Pop an entry from the type resolution stack and return its associated result value. The result value will
     * be true if no circularities were detected, or false if a circularity was found.
     */
    fn popTypeResolution(&mut self) -> bool {
        self.resolutionTargets.pop();
        self.resolutionPropertyNames.pop();
        self.resolutionResults.pop().unwrap()
    }

    // TODO:
    // getDeclarationContainer

    fn getTypeOfPrototypeProperty(&mut self, prototype: SymbolId) -> TypeId {
        // TypeScript 1.0 spec (April 2014): 8.4
        // Every class automatically contains a static property member named 'prototype',
        // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
        // It is an error to explicitly declare a static property member with the name 'prototype'.
        let parent_sym = self.getParentOfSymbol(prototype).unwrap();
        let classType = self.getDeclaredTypeOfSymbol(parent_sym);
        if let Some(typeParameters) = &self.types[classType]
            .unwrap_as_interface_type()
            .typeParameters
        {
            let typeArguments = Rc::new(vec![self.anyType; typeParameters.len()]);
            self.createTypeReference(classType, Some(typeArguments))
        } else {
            classType
        }
    }

    // TODO:
    // getTypeOfPropertyOfType
    // TODO:
    // getTypeOfPropertyOrIndexSignature

    fn isTypeAny(&self, ty: Option<TypeId>) -> bool {
        if let Some(ty) = ty {
            self.types[ty].get_flags().intersects(TypeFlags::Any)
        } else {
            false
        }
    }

    fn isErrorType(&self, ty: TypeId) -> bool {
        // The only 'any' types that have alias symbols are those manufactured by getTypeFromTypeAliasReference for
        // a reference to an unresolved symbol. We want those to behave like the errorType.
        ty == self.errorType
            || self.types[ty].get_flags().intersects(TypeFlags::Any)
                && self.types[ty].get_aliasSymbol().is_some()
    }

    // TODO:
    // getTypeForBindingElementParent
    // TODO:
    // getRestType
    // TODO:
    // isGenericTypeWithUndefinedConstraint
    // TODO:
    // getNonUndefinedType
    // TODO:
    // getFlowTypeOfDestructuring
    // TODO:
    // getSyntheticElementAccess
    // TODO:
    // getParentElementAccess
    // TODO:
    // getDestructuringPropertyName
    // TODO:
    // getLiteralPropertyNameText
    // TODO:
    // getTypeForBindingElement
    // TODO:
    // getTypeForDeclarationFromJSDocComment
    // TODO:
    // isNullOrUndefined
    // TODO:
    // isEmptyArrayLiteral

    // TODO: once all calls to this fn are ported, change `isOptional` from Option<bool> to bool.
    fn addOptionality(&mut self, ty: TypeId, isProperty: bool, isOptional: Option<bool>) -> TypeId {
        let isOptional = isOptional.unwrap_or_default();
        if self.strictNullChecks && isOptional {
            todo!();
            // self.getOptionalType(ty, isProperty)
        } else {
            ty
        }
    }

    // Return the inferred type for a variable, parameter, or property declaration
    fn getTypeForVariableLikeDeclaration(
        &mut self,
        declaration: BoundNode,
        includeOptionality: bool,
    ) -> Option<TypeId> {
        if matches!(declaration, BoundNode::VarDeclarator(_)) {
            if matches!(declaration.parent(), Some(parent) if matches!(parent.parent(), Some(BoundNode::ForInStmt(_)| BoundNode::ForOfStmt(_))))
            {
                todo!();
            }
        }
        // A variable declared in a for..in statement is of type string, or of type keyof T when the
        // right hand expression is of a type parameter type.
        // if (isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKind.ForInStatement) {
        //     todo!();
        //     // let indexType = getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression)));
        //     // return indexType.flags & (TypeFlags::TypeParameter | TypeFlags::Index) ? getExtractStringType(indexType) : stringType;
        // }

        // if (isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKind.ForOfStatement) {
        //     todo!();
        //     // checkRightHandSideOfForOf will return undefined if the for-of expression type was
        //     // missing properties/signatures required to get its iteratedType (like
        //     // [Symbol.iterator] or next). This may be because we accessed properties from anyType,
        //     // or it may have led to an error inside getElementTypeOfIterable.
        //     // let forOfStatement = declaration.parent.parent;
        //     // return checkRightHandSideOfForOf(forOfStatement) || anyType;
        // }

        if isBindingPattern(&declaration.parent().unwrap()) {
            todo!();
            // return getTypeForBindingElement(declaration as BindingElement);
        }

        macro_rules! is_property {
            ($node:expr) => {
                matches!(
                    $node,
                    BoundNode::ClassProp(_)
                        | BoundNode::PrivateProp(_)
                        | BoundNode::TsPropertySignature(_)
                )
            };
        }

        // TODO: jsdoc:
        macro_rules! is_optional {
            ($node:expr) => {
                includeOptionality
                    && match $node {
                        BoundNode::ClassProp(n) => n.is_optional,
                        BoundNode::PrivateProp(n) => n.is_optional,
                        BoundNode::TsPropertySignature(n) => n.optional,
                        BoundNode::Param(p) => match &p.pat {
                            ast::Pat::Ident(n) => n.id.optional,
                            ast::Pat::Array(n) => n.optional,
                            ast::Pat::Object(n) => n.optional,
                            _ => false,
                        },
                        BoundNode::ParamWithoutDecorators(p) => match &p.pat {
                            ast::Pat::Ident(n) => n.id.optional,
                            ast::Pat::Array(n) => n.optional,
                            ast::Pat::Object(n) => n.optional,
                            _ => false,
                        },
                        BoundNode::TsAmbientParam(p) => match &p.pat {
                            ast::TsAmbientParamPat::Ident(n) => n.id.optional,
                            ast::TsAmbientParamPat::Array(n) => n.optional,
                            ast::TsAmbientParamPat::Object(n) => n.optional,
                            _ => false,
                        },
                        BoundNode::TsParamProp(p) => match &p.param {
                            ast::TsParamPropParam::Ident(n) => n.id.optional,
                            _ => false,
                        },
                        /*|| isJSDocOptionalParameter(declaration) */
                        // _ => isOptionalJSDocPropertyLikeTag(declaration),
                        _ => false,
                    }
            };
        }

        // let isProperty = isPropertyDeclaration(declaration) || isPropertySignature(declaration);
        // let isOptional = includeOptionality && (
        //     isProperty && !!(declaration as PropertyDeclaration | PropertySignature).questionToken ||
        //     isParameter(declaration) && (!!declaration.questionToken || isJSDocOptionalParameter(declaration)) ||
        //     isOptionalJSDocPropertyLikeTag(declaration));

        // Use type from type annotation if one is present
        if let Some(declaredType) = self.tryGetTypeFromEffectiveTypeNode(declaration.clone()) {
            return Some(self.addOptionality(
                declaredType,
                is_property!(declaration),
                Some(is_optional!(&declaration)),
            ));
        }

        if self.noImplicitAny || isBoundNodeInJSFile(&declaration) {
            todo!("see below");
        }
        // if (self.noImplicitAny || isBoundNodeInJSFile(&declaration)) &&
        //     isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) &&
        //     !(getCombinedModifierFlags(declaration) & ModifierFlags::Export) && !(declaration.flags & NodeFlags.Ambient) {
        //         todo!();
        //     // If --noImplicitAny is on or the declaration is in a Javascript file,
        //     // use control flow tracked 'any' type for non-ambient, non-exported var or let variables with no
        //     // initializer or a 'null' or 'undefined' initializer.
        //     // if (!(getCombinedNodeFlags(declaration) & NodeFlags.Const) && (!declaration.initializer || isNullOrUndefined(declaration.initializer))) {
        //     //     return autoType;
        //     // }
        //     // // Use control flow tracked 'any[]' type for non-ambient, non-exported variables with an empty array
        //     // // literal initializer.
        //     // if (declaration.initializer && isEmptyArrayLiteral(declaration.initializer)) {
        //     //     return autoArrayType;
        //     // }
        // }

        if matches!(
            declaration,
            BoundNode::Param(_)
                | BoundNode::ParamWithoutDecorators(_)
                | BoundNode::TsAmbientParam(_)
                | BoundNode::TsParamProp(_)
        ) {
            let mut func = declaration.parent().unwrap();
            if matches!(func, BoundNode::Function(_)) {
                func = func.parent().unwrap();
            }
            // For a parameter of a set accessor, use the type of the get accessor if one is present
            if matches!(&func, BoundNode::ClassMethod(m) if m.kind ==ast::MethodKind::Setter )
                || matches!(&func, BoundNode::PrivateMethod(m) if m.kind== ast::MethodKind::Setter)
                || matches!(
                    func,
                    BoundNode::SetterProp(_) | BoundNode::TsSetterSignature(_)
                ) && self.hasBindableName(&func)
            {
                todo!();
                // let getter = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfNode(declaration.parent), SyntaxKind.GetAccessor);
                // if (getter) {
                //     let getterSignature = getSignatureFromDeclaration(getter);
                //     let thisParameter = getAccessorThisParameter(func as AccessorDeclaration);
                //     if (thisParameter && declaration == thisParameter) {
                //         // Use the type from the *getter*
                //         Debug.assert(!thisParameter.type);
                //         return getTypeOfSymbol(getterSignature.thisParameter!);
                //     }
                //     return getReturnTypeOfSignature(getterSignature);
                // }
            }
            if isBoundNodeInJSFile(&declaration) {
                todo!();
                // let typeTag = getJSDocType(func);
                // if (typeTag && isFunctionTypeNode(typeTag)) {
                //     let signature = getSignatureFromDeclaration(typeTag);
                //     let pos = func.parameters.indexOf(declaration);
                //     return if declaration.dotDotDotToken {getRestTypeAtPosition(signature, pos) }else{getTypeAtPosition(signature, pos)};
                // }
            }
            // Use contextual parameter type if one is available
            let sym = self.node_data(declaration.clone()).symbol.unwrap();
            let ty = if self.symbols[sym].escapedName() == &JsWord::from(InternalSymbolName::This) {
                self.getContextualThisParameterType(func)
            } else {
                let param = match &declaration {
                    BoundNode::Param(n) => Parameter::Param(n.clone()),
                    BoundNode::ParamWithoutDecorators(n) => {
                        Parameter::ParamWithoutDecorators(n.clone())
                    }
                    BoundNode::TsAmbientParam(n) => Parameter::TsAmbientParam(n.clone()),
                    BoundNode::TsParamProp(n) => Parameter::TsParamProp(n.clone()),
                    _ => unreachable!(),
                };
                self.getContextuallyTypedParameterType(param)
            };
            if let Some(ty) = ty {
                return Some(self.addOptionality(ty, false, Some(is_optional!(&declaration))));
            }
        }

        // Use the type of the initializer expression if one is present and the declaration is
        // not a parameter of a contextually typed function
        if let Some(init) = getOnlyExpressionInitializer(&declaration) {
            // TODO: js files:
            // if isBoundNodeInJSFile(&declaration) && !isParameter(declaration) {
            //     const containerObjectType = getJSContainerObjectType(declaration, getSymbolOfNode(declaration), getDeclaredExpandoInitializer(declaration));
            //     if (containerObjectType) {
            //         return containerObjectType;
            //     }
            // }
            let ty = self.checkDeclarationInitializer(&declaration, None);
            let ty = self.widenTypeInferredFromInitializer(&declaration, ty);
            return Some(self.addOptionality(
                ty,
                is_property!(&declaration),
                Some(is_optional!(&declaration)),
            ));
        }

        if matches!(
            declaration,
            BoundNode::ClassProp(_) | BoundNode::PrivateProp(_)
        ) && (self.noImplicitAny || isBoundNodeInJSFile(&declaration))
        {
            todo!();
            // We have a property declaration with no type annotation or initializer, in noImplicitAny mode or a .js file.
            // Use control flow analysis of this.xxx assignments in the constructor or static block to determine the type of the property.
            // if (!hasStaticModifier(declaration)) {
            //     const constructor = findConstructorDeclaration(declaration.parent);
            //     const type = constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :
            //         getEffectiveModifierFlags(declaration) & ModifierFlags::Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :
            //         undefined;
            //     return type && addOptionality(type, /*isProperty*/ true, isOptional);
            // }
            // else {
            //     const staticBlocks = filter(declaration.parent.members, isClassStaticBlockDeclaration);
            //     const type = staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :
            //         getEffectiveModifierFlags(declaration) & ModifierFlags::Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :
            //         undefined;
            //     return type && addOptionality(type, /*isProperty*/ true, isOptional);
            // }
        }

        // if (isJsxAttribute(declaration)) {
        //     todo!();
        //     // if JSX attribute doesn't have initializer, by default the attribute will have boolean value of true.
        //     // I.e <Elem attr /> is sugar for <Elem attr={true} />
        //     // return trueType;
        // }

        // If the declaration specifies a binding pattern and is not a parameter of a contextually
        // typed function, use the type implied by the binding pattern
        // if (isBindingPattern(declaration.name)) {
        //     todo!();
        //     // return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ false, /*reportErrors*/ true);
        // }

        // dbg!(declaration);
        // todo!();

        // No type specified and nothing can be inferred
        None
    }

    fn isConstructorDeclaredProperty(&mut self, symbol: SymbolId) -> bool {
        // A property is considered a constructor declared property when all declaration sites are this.xxx assignments,
        // when no declaration sites have JSDoc type annotations, and when at least one declaration site is in the body of
        // a class constructor.
        // TODO: TSC uses isBinaryExpression rather than AssignExpr:
        if matches!(
            self.symbols[symbol].valueDeclaration(),
            Some(BoundNode::AssignExpr(_))
        ) {
            let links = self.getSymbolLinksMut(symbol);
            if links.isConstructorDeclaredProperty.is_none() {
                todo!();
                // links.isConstructorDeclaredProperty = false;
                // links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && every(symbol.declarations, declaration =>
                //     isBinaryExpression(declaration) &&
                //     isPossiblyAliasedThisProperty(declaration) &&
                //     (declaration.left.kind != SyntaxKind.ElementAccessExpression || isStringOrNumericLiteralLike((declaration.left as ElementAccessExpression).argumentExpression)) &&
                //     !getAnnotatedTypeForAssignmentDeclaration(/*declaredType*/ undefined, declaration, symbol, declaration));
            }
            return links.isConstructorDeclaredProperty.unwrap();
        }
        false
    }

    fn isAutoTypedProperty(&self, symbol: SymbolId) -> bool {
        // A property is auto-typed when its declaration has no type annotation or initializer and we're in
        // noImplicitAny mode or a .js file.
        if let Some(declaration) = self.symbols[symbol].valueDeclaration() {
            if let BoundNode::ClassProp(n) = declaration {
                return getEffectiveTypeAnnotationNode(&declaration.clone().into()).is_none()
                    && n.value.is_none()
                    && (self.noImplicitAny || isBoundNodeInJSFile(declaration));
            } else if let BoundNode::PrivateProp(n) = declaration {
                return getEffectiveTypeAnnotationNode(&declaration.clone().into()).is_none()
                    && n.value.is_none()
                    && (self.noImplicitAny || isBoundNodeInJSFile(declaration));
            }
        }
        false
    }

    fn getDeclaringConstructor(&mut self, symbol: SymbolId) -> Option<BoundNode> {
        // TODO: bad clone:
        for declaration in self.symbols[symbol].declarations().clone() {
            let container = getThisContainer(declaration, false);
            if matches!(container, BoundNode::Constructor(_))
                || self.isJSConstructor(Some(container.clone()))
            {
                return Some(container);
            }
        }
        None
    }

    // TODO:
    // getFlowTypeFromCommonJSExport
    // TODO:
    // getFlowTypeInStaticBlocks
    // TODO:
    // getFlowTypeInConstructor
    // TODO:
    // getFlowTypeOfProperty
    // TODO:
    // getWidenedTypeForAssignmentDeclaration
    // TODO:
    // getJSContainerObjectType
    // TODO:
    // getAnnotatedTypeForAssignmentDeclaration
    // TODO:
    // getInitializerTypeFromAssignmentDeclaration
    // TODO:
    // containsSameNamedThisProperty
    // TODO:
    // isDeclarationInConstructor
    // TODO:
    // getConstructorDefinedThisAssignmentTypes
    // TODO:
    // getTypeFromBindingElement
    // TODO:
    // getTypeFromObjectBindingPattern
    // TODO:
    // getTypeFromArrayBindingPattern
    // TODO:
    // getTypeFromBindingPattern

    // Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
    // specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
    // is a bit more involved. For example:
    //
    //   var [x, s = ""] = [1, "one"];
    //
    // Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
    // binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
    // tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
    fn getWidenedTypeForVariableLikeDeclaration(
        &mut self,
        declaration: BoundNode,
        reportErrors: bool,
    ) -> TypeId {
        let ty = self.getTypeForVariableLikeDeclaration(declaration.clone(), true);
        self.widenTypeForVariableLikeDeclaration(ty, declaration, reportErrors)
    }

    // TODO:
    // isGlobalSymbolConstructor

    fn widenTypeForVariableLikeDeclaration(
        &mut self,
        mut ty: Option<TypeId>,
        declaration: BoundNode,
        reportErrors: bool,
    ) -> TypeId {
        if let Some(ty) = ty {
            // TODO: If back compat with pre-3.0/4.0 libs isn't required, remove the following SymbolConstructor special case transforming `symbol` into `unique symbol`
            if self.types[ty].get_flags().intersects(TypeFlags::ESSymbol)
            // && isGlobalSymbolConstructor(declaration.parent)
            {
                todo!();
                // ty = self.getESSymbolLikeTypeForNode(declaration);
            }
            if reportErrors {
                self.reportErrorsFromWidening(declaration, ty, None);
            }

            // always widen a 'unique symbol' type if the type was created for a different declaration.
            // if self.types[ty]
            //     .get_flags()
            //     .intersects(TypeFlags::UniqueESSymbol)
            //     && (isBindingElement(declaration) || !declaration.ty)
            //     && self.types[ty].get_symbol() != &self.getSymbolOfNode(declaration)
            // {
            //     ty = self.esSymbolType;
            // }
            if self.types[ty]
                .get_flags()
                .intersects(TypeFlags::UniqueESSymbol)
            {
                todo!();
            }

            return self.getWidenedType(ty);
        }
        // Rest parameters default to type any[], other parameters default to type any
        let ty = if declaration.is_rest_param() {
            self.anyArrayType()
        } else {
            self.anyType
        };

        // Report implicit any errors unless this is a private property within an ambient declaration
        if reportErrors {
            // TODO: error
            // if (!declarationBelongsToPrivateAmbientMember(declaration)) {
            //     reportImplicitAny(declaration, ty);
            // }
        }
        ty
    }

    // TODO:
    // declarationBelongsToPrivateAmbientMember

    fn tryGetTypeFromEffectiveTypeNode(&mut self, declaration: BoundNode) -> Option<TypeId> {
        getBoundEffectiveTypeAnnotationNode(&declaration)
            .map(|typeNode| self.getTypeFromTypeNode(typeNode))
    }

    fn getTypeOfVariableOrParameterOrProperty(&mut self, symbol: SymbolId) -> TypeId {
        match self.getSymbolLinks(symbol).ty {
            Some(ty) => ty,
            None => {
                let ty = self.getTypeOfVariableOrParameterOrPropertyWorker(symbol);
                // For a contextually typed parameter it is possible that a type has already
                // been assigned (in assignTypeToParameterAndFixTypeParameters), and we want
                // to preserve this type.
                match self.getSymbolLinks(symbol).ty {
                    Some(ty) => ty,
                    None => {
                        self.getSymbolLinksMut(symbol).ty = Some(ty);
                        ty
                    }
                }
            }
        }
    }

    fn getTypeOfVariableOrParameterOrPropertyWorker(&mut self, symbol: SymbolId) -> TypeId {
        // Handle prototype property
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::Prototype)
        {
            return self.getTypeOfPrototypeProperty(symbol);
        }
        // CommonsJS require and module both have type any.
        if symbol == self.requireSymbol {
            return self.anyType;
        }
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::ModuleExports)
            && self.symbols[symbol].valueDeclaration().is_some()
        {
            todo!();
            // const fileSymbol = getSymbolOfNode(getSourceFileOfNode(symbol.valueDeclaration));
            // const result = createSymbol(fileSymbol.flags, "exports" as __String);
            // result.declarations = fileSymbol.declarations ? fileSymbol.declarations.slice() : [];
            // result.parent = symbol;
            // result.target = fileSymbol;
            // if (fileSymbol.valueDeclaration) result.valueDeclaration = fileSymbol.valueDeclaration;
            // if (fileSymbol.members) result.members = new Map(fileSymbol.members);
            // if (fileSymbol.exports) result.exports = new Map(fileSymbol.exports);
            // const members = createSymbolTable();
            // members.set("exports" as __String, result);
            // return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray);
        }
        let declaration = match self.symbols[symbol].valueDeclaration() {
            Some(d) => d.clone(),
            None => unreachable!(),
        };
        // Handle catch clause variables
        if isCatchClauseVariableDeclarationOrBindingElement(declaration.clone()) {
            todo!();
            // const typeNode = getEffectiveTypeAnnotationNode(declaration);
            // if (typeNode === undefined) {
            //     return useUnknownInCatchVariables ? unknownType : anyType;
            // }
            // const type = getTypeOfNode(typeNode);
            // // an errorType will make `checkTryStatement` issue an error
            // return isTypeAny(type) || type === unknownType ? type : errorType;
        }
        // Handle export default expressions
        // TODO:
        // if (isSourceFile(declaration) && isJsonSourceFile(declaration)) {
        //     todo!();
        //     // if (!declaration.statements.length) {
        //     //     return emptyObjectType;
        //     // }
        //     // return getWidenedType(getWidenedLiteralType(checkExpression(declaration.statements[0].expression)));
        // }

        // Handle variable, parameter or property
        if !self.pushTypeResolution(
            TypeSystemEntity::Symbol(symbol),
            TypeSystemPropertyName::Type,
        ) {
            // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
            todo!();
            // if (symbol.flags & SymbolFlags::ValueModule && !(symbol.flags & SymbolFlags::Assignment)) {
            //     return getTypeOfFuncClassEnumModule(symbol);
            // }
            // return reportCircularityError(symbol);
        }
        let ty = if matches!(declaration, BoundNode::TsExportAssignment(_)) {
            todo!();
            // ty = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached((declaration as ExportAssignment).expression), declaration);
        }
        /*TODO: else if (isBinaryExpression(declaration)
            || (isBoundNodeInJSFile(declaration)
                && (isCallExpression(declaration)
                    || (isPropertyAccessExpression(declaration)
                        || isBindableStaticElementAccessExpression(declaration))
                        && isBinaryExpression(declaration.parent))))
        {
            todo!();
            // ty = getWidenedTypeForAssignmentDeclaration(symbol);
        }*/
        else if matches!(declaration, BoundNode::Ident(_))
            && matches!(declaration.parent(), Some(BoundNode::ObjectLit(_)))
        {
            // ShorthandPropertyAssignment
            todo!();
            // tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckMode.Normal)
        } else if matches!(
            declaration,
            BoundNode::MemberExpr(_)
                | BoundNode::Ident(_)
                | BoundNode::Number(_)
                | BoundNode::ClassDecl(_)
                | BoundNode::FnDecl(_)
        ) /* TODO: || isStringLiteralLike(declaration)*/
            || matches!(
                declaration,
                BoundNode::PrivateMethod(_)
                    | BoundNode::ClassMethod(_)
                    | BoundNode::TsMethodSignature(_)
                    | BoundNode::Script(_)
                    | BoundNode::Module(_)
            )
        {
            todo!();
            // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
            // if (symbol.flags & (SymbolFlags::Function | SymbolFlags::Method | SymbolFlags::Class | SymbolFlags::Enum | SymbolFlags::ValueModule)) {
            //     return getTypeOfFuncClassEnumModule(symbol);
            // }
            // ty = isBinaryExpression(declaration.parent) ?
            //     getWidenedTypeForAssignmentDeclaration(symbol) :
            //     tryGetTypeFromEffectiveTypeNode(declaration) || anyType;
        } else if let BoundNode::KeyValueProp(p) = &declaration {
            self.tryGetTypeFromEffectiveTypeNode(declaration.clone())
                .unwrap_or_else(|| self.checkPropertyAssignment(&p, None))
        }
        /* TODO:  else if (isJsxAttribute(declaration)) {
            todo!();
            //  tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration)
        } */
        else if matches!(declaration, BoundNode::MethodProp(_)) {
            todo!();
            // tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckMode.Normal)
        } else if matches!(
            declaration,
            BoundNode::Param(_)
                | BoundNode::ParamWithoutDecorators(_)
                | BoundNode::TsAmbientParam(_)
                | BoundNode::TsParamProp(_)
                | BoundNode::ClassProp(_)
                | BoundNode::PrivateProp(_)
                | BoundNode::TsPropertySignature(_)
                | BoundNode::VarDeclarator(_)
        )
        // TODO:  || isBindingElement(declaration)
        || matches!(declaration, BoundNode::RestPat(_))
        // TODO:  || isJSDocPropertyLikeTag(declaration)
        {
            self.getWidenedTypeForVariableLikeDeclaration(
                declaration,
                /*includeOptionality*/ true,
            )
        }
        // getTypeOfSymbol dispatches some JS merges incorrectly because their symbol flags are not mutually exclusive.
        // Re-dispatch based on valueDeclaration.kind instead.
        else if matches!(declaration, BoundNode::TsEnumDecl(_)) {
            todo!();
            // getTypeOfFuncClassEnumModule(symbol)
        } else if matches!(declaration, BoundNode::TsEnumMember(_)) {
            todo!();
            // getTypeOfEnumMember(symbol)
        }
        /*TODO: else if isAccessor(declaration) {
            todo!();
            // resolveTypeOfAccessors(symbol) || Debug.fail("Non-write accessor resolution must always produce a type")
        } */
        else {
            dbg!(&declaration);
            todo!();
            // return Debug.fail("Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol));
        };

        if !self.popTypeResolution() {
            // Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
            todo!();
            // if (symbol.flags & SymbolFlags::ValueModule && !(symbol.flags & SymbolFlags::Assignment)) {
            //     return getTypeOfFuncClassEnumModule(symbol);
            // }
            // return reportCircularityError(symbol);
        }
        ty
    }

    // TODO:
    // getAnnotatedAccessorTypeNode
    // TODO:
    // getAnnotatedAccessorType
    // TODO:
    // getAnnotatedAccessorThisParameter

    fn getThisTypeOfDeclaration(&mut self, declaration: BoundNode) -> Option<TypeId> {
        let sig = self.getSignatureFromDeclaration(declaration);
        self.getThisTypeOfSignature(sig)
    }

    // TODO:
    // getTypeOfAccessors
    // TODO:
    // getTypeOfSetAccessor
    // TODO:
    // getTypeOfAccessorsWorker
    // TODO:
    // resolveTypeOfAccessors

    fn getBaseTypeVariableOfClass(&mut self, symbol: SymbolId) -> Option<TypeId> {
        let class_type = self.getDeclaredTypeOfClassOrInterface(symbol);
        let baseConstructorType = self.getBaseConstructorTypeOfClass(class_type);
        if self.types[baseConstructorType]
            .get_flags()
            .intersects(TypeFlags::TypeVariable)
        {
            Some(baseConstructorType)
        } else if self.types[baseConstructorType]
            .get_flags()
            .intersects(TypeFlags::Intersection)
        {
            self.types[baseConstructorType]
                .unwrap_as_union_or_intersection()
                .types
                .iter()
                .find(|&&t| {
                    self.types[t]
                        .get_flags()
                        .intersects(TypeFlags::TypeVariable)
                })
                .copied()
        } else {
            None
        }
    }

    fn getTypeOfFuncClassEnumModule(&mut self, mut symbol: SymbolId) -> TypeId {
        #[derive(Clone, Copy)]
        enum TransientSymbolOrSymbolLinksKey {
            SymbolLinksKey(SymbolId),
            TransientSymbol(SymbolId),
        }
        impl TransientSymbolOrSymbolLinksKey {
            fn ty<'a>(&self, checker: &'a mut Checker) -> &'a mut Option<TypeId> {
                match self {
                    TransientSymbolOrSymbolLinksKey::SymbolLinksKey(s) => {
                        &mut checker.getSymbolLinksMut(*s).ty
                    }
                    TransientSymbolOrSymbolLinksKey::TransientSymbol(s) => {
                        &mut checker.getSymbolLinksMut(*s).ty
                    }
                }
            }
        }

        match self.getSymbolLinks(symbol).ty {
            Some(ty) => ty,
            None => {
                let mut links = match self.symbols[symbol] {
                    Symbol::Base(_) => TransientSymbolOrSymbolLinksKey::SymbolLinksKey(symbol),
                    Symbol::TransientSymbol(_) => {
                        TransientSymbolOrSymbolLinksKey::TransientSymbol(symbol)
                    }
                };
                let originalLinks = links;

                let expando = self.symbols[symbol]
                    .valueDeclaration()
                    .clone()
                    .map(|d| self.getSymbolOfExpando(d, false));
                if let Some(expando) = expando {
                    let merged = self.mergeJSSymbols(symbol, expando);
                    if let Some(merged) = merged {
                        // note:we overwrite links because we just cloned the symbol
                        symbol = merged;
                        links = match self.symbols[merged] {
                            Symbol::Base(_) => unreachable!("TODO: is this really unreachable?"),
                            Symbol::TransientSymbol(_) => {
                                TransientSymbolOrSymbolLinksKey::TransientSymbol(merged)
                            }
                        };
                    }
                }
                let ty = self.getTypeOfFuncClassEnumModuleWorker(symbol);
                *originalLinks.ty(self) = Some(ty);
                *links.ty(self) = Some(ty);
                ty
            }
        }
    }

    fn getTypeOfFuncClassEnumModuleWorker(&mut self, symbol: SymbolId) -> TypeId {
        let declaration = self.symbols[symbol].valueDeclaration();
        if self.symbols[symbol].flags().intersects(SymbolFlags::Module) {
            if isShorthandAmbientModuleSymbol(&self.symbols[symbol]) {
                return self.anyType;
            }
        }
        if matches!(declaration, Some(BoundNode::BinExpr(_)))
            || matches!(declaration, Some(p@BoundNode::MemberExpr(_)) if matches!(p.parent(), Some(BoundNode::BinExpr(_))))
        {
            todo!();
            // return self.getWidenedTypeForAssignmentDeclaration(symbol);
        }
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::ValueModule)
        {
            if matches!(
                declaration,
                Some(BoundNode::Script(_) | BoundNode::Module(_))
            ) {
                todo!();
            }
            // if declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator {
            // let  resolvedModule = resolveExternalModuleSymbol(symbol);
            // if (resolvedModule != symbol) {
            //     if !pushTypeResolution(symbol, TypeSystemPropertyName::Type) {
            //         return errorType;
            //     }
            //     let exportEquals = getMergedSymbol(symbol.exports.unwrap().get(InternalSymbolName.ExportEquals).unwrap());
            //     let ty = getWidenedTypeForAssignmentDeclaration(exportEquals, if exportEquals == resolvedModule {undefined}else{resolvedModule});
            //     if (!popTypeResolution()) {
            //         return reportCircularityError(symbol);
            //     }
            //     return ty;
            // }
            // }
        }
        // TODO:
        // let ty = self.types.push(Type::ObjectType(ObjectType::new(
        //     ObjectFlags::Anonymous,
        //     Some(symbol),
        // )));
        let ty = self.types.push(Type::AnonymousType(AnonymousType {
            anonymous_type: Default::default(),
            object_type_base: ObjectTypeBase::new(ObjectFlags::Anonymous),
            type_base: TypeBase::new(TypeFlags::Object, Some(symbol)),
        }));
        if self.symbols[symbol].flags().intersects(SymbolFlags::Class) {
            let baseTypeVariable = self.getBaseTypeVariableOfClass(symbol);
            return if let Some(baseTypeVariable) = baseTypeVariable {
                self.getIntersectionType(&[ty, baseTypeVariable], None, None)
            } else {
                ty
            };
        } else {
            return if self.strictNullChecks
                && self.symbols[symbol]
                    .flags()
                    .intersects(SymbolFlags::Optional)
            {
                todo!();
                // self.getOptionalType(ty)
            } else {
                ty
            };
        }
    }

    // TODO:
    // getTypeOfEnumMember
    // TODO:
    // getTypeOfAlias

    fn getTypeOfInstantiatedSymbol(&mut self, symbol: SymbolId) -> TypeId {
        match self.getSymbolLinks(symbol).ty {
            Some(ty) => ty,
            None => {
                if !self.pushTypeResolution(
                    TypeSystemEntity::Symbol(symbol),
                    TypeSystemPropertyName::Type,
                ) {
                    self.getSymbolLinksMut(symbol).ty = Some(self.errorType);
                    return self.errorType;
                }
                let target = self.getSymbolLinks(symbol).target.unwrap();
                let ty = self.getTypeOfSymbol(target);
                let mapper = self.getSymbolLinks(symbol).mapper.clone();
                let ty = self.instantiateType(ty, mapper);
                if !self.popTypeResolution() {
                    todo!();
                    // ty = reportCircularityError(symbol);
                }
                self.getSymbolLinksMut(symbol).ty = Some(ty);
                ty
            }
        }
    }

    // TODO:
    // reportCircularityError
    // TODO:
    // getTypeOfSymbolWithDeferredType

    fn getSetAccessorTypeOfSymbol(&mut self, symbol: SymbolId) -> TypeId {
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::Accessor)
        {
            todo!();
            // const ty = self.getTypeOfSetAccessor(symbol);
            // if (ty) {
            //     return ty;
            // }
        }
        self.getTypeOfSymbol(symbol)
    }

    pub fn getTypeOfSymbol(&mut self, symbol: SymbolId) -> TypeId {
        let checkFlags = getCheckFlags(&self.symbols[symbol]);
        if checkFlags.intersects(CheckFlags::DeferredType) {
            todo!();
            // return self.getTypeOfSymbolWithDeferredType(symbol);
        }
        if checkFlags.intersects(CheckFlags::Instantiated) {
            return self.getTypeOfInstantiatedSymbol(symbol);
        }
        if checkFlags.intersects(CheckFlags::Mapped) {
            todo!();
            // return self.getTypeOfMappedSymbol(symbol as MappedSymbol);
        }
        if checkFlags.intersects(CheckFlags::ReverseMapped) {
            todo!();
            // return self.getTypeOfReverseMappedSymbol(symbol as ReverseMappedSymbol);
        }
        let symbol_flags = self.symbols[symbol].flags();
        if symbol_flags.intersects(SymbolFlags::Variable | SymbolFlags::Property) {
            return self.getTypeOfVariableOrParameterOrProperty(symbol);
        }
        if symbol_flags.intersects(
            SymbolFlags::Function
                | SymbolFlags::Method
                | SymbolFlags::Class
                | SymbolFlags::Enum
                | SymbolFlags::ValueModule,
        ) {
            return self.getTypeOfFuncClassEnumModule(symbol);
        }
        if symbol_flags.intersects(SymbolFlags::EnumMember) {
            todo!();
            // return self.getTypeOfEnumMember(symbol);
        }
        if symbol_flags.intersects(SymbolFlags::Accessor) {
            todo!();
            // return self.getTypeOfAccessors(symbol);
        }
        if symbol_flags.intersects(SymbolFlags::Alias) {
            todo!();
            // return self.getTypeOfAlias(symbol);
        }
        self.errorType
    }

    // TODO:
    // getNonMissingTypeOfSymbol
    // TODO:
    // isReferenceToType

    pub fn getTargetType(&self, ty: TypeId) -> TypeId {
        if self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::Reference)
        {
            self.types[ty].unwrap_as_type_reference().target.unwrap()
        } else {
            ty
        }
    }

    // TODO: GH#18217 If `checkBase` is undefined, we should not call this because this will always return false.
    fn hasBaseType(&mut self, ty: TypeId, checkBase: Option<TypeId>) -> bool {
        return check(self, ty, checkBase);
        fn check(checker: &mut Checker, ty: TypeId, checkBase: Option<TypeId>) -> bool {
            if checker.types[ty]
                .get_object_flags()
                .intersects(ObjectFlags::ClassOrInterface | ObjectFlags::Reference)
            {
                let target = checker.getTargetType(ty);
                return Some(target) == checkBase
                    || checker
                        .getBaseTypes(target)
                        .iter()
                        .any(|t| check(checker, *t, checkBase));
            } else if checker.types[ty]
                .get_flags()
                .intersects(TypeFlags::Intersection)
            {
                // TODO: nasty intermidiary clone:
                return checker.types[ty]
                    .unwrap_as_union_or_intersection()
                    .types
                    .clone()
                    .iter()
                    .any(|t| check(checker, *t, checkBase));
            }
            false
        }
    }

    // Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
    // The function allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set
    // in-place and returns the same array.
    fn appendTypeParameters(
        &mut self,
        mut typeParameters: Option<Vec<TypeId>>,
        declarations: Vec<BoundNode>,
    ) -> Option<Vec<TypeId>> {
        for declaration in declarations {
            let sym = self.getSymbolOfNode(declaration);
            typeParameters = Some(appendIfUnique(
                typeParameters,
                self.getDeclaredTypeOfTypeParameter(sym.unwrap()),
            ));
        }
        typeParameters
    }

    // Return the outer type parameters of a node or undefined if the node has no outer type parameters.
    fn getOuterTypeParameters(
        &mut self,
        mut node: BoundNode,
        includeThisTypes: bool,
    ) -> Option<Vec<TypeId>> {
        loop {
            node = node.parent()?; // TODO: GH#18217 Use SourceFile kind check instead
            if let BoundNode::AssignExpr(e) = &node {
                // prototype assignments get the outer type parameters of their constructor function
                let assignmentKind =
                    getAssignmentDeclarationKind(&ast::Expr::Assign(e.node.clone()));
                if assignmentKind == AssignmentDeclarationKind::Prototype
                    || assignmentKind == AssignmentDeclarationKind::PrototypeProperty
                {
                    todo!();
                    // let symbol = getSymbolOfNode(node.left);
                    // if symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, d => node === d) {
                    //     node = symbol.parent.valueDeclaration?;
                    // }
                }
            }
            match node {
                // TODO: jsdoc
                // | BoundNode::JSDocTemplateTag(_)
                // | BoundNode::JSDocTypedefTag(_)
                // | BoundNode::JSDocEnumTag(_)
                // | BoundNode::JSDocCallbackTag(_)
                // | BoundNode::JSDocFunctionType(_)
                BoundNode::ClassDecl(_)
                | BoundNode::ClassExpr(_)
                | BoundNode::TsInterfaceDecl(_)
                | BoundNode::TsCallSignatureDecl(_)
                | BoundNode::TsConstructSignatureDecl(_)
                | BoundNode::TsMethodSignature(_)
                | BoundNode::TsFnType(_)
                | BoundNode::TsConstructorType(_)
                | BoundNode::FnDecl(_)
                | BoundNode::PrivateMethod(_)
                | BoundNode::ClassMethod(_)
                | BoundNode::MethodProp(_)
                | BoundNode::FnExpr(_)
                | BoundNode::ArrowExpr(_)
                | BoundNode::TsTypeAliasDecl(_)
                | BoundNode::TsMappedType(_)
                | BoundNode::TsConditionalType(_) => {
                    let mut outerTypeParameters =
                        self.getOuterTypeParameters(node.clone(), includeThisTypes);
                    if let BoundNode::TsMappedType(n) = &node {
                        todo!();
                        // let type_param_symbol = self.getSymbolOfNode(n.type_param.bind(node));
                        // let type_param = self.getDeclaredTypeOfTypeParameter(type_param_symbol);
                        // outerTypeParameters
                        //     .get_or_insert(Vec::default())
                        //     .push(type_param);
                        // return outerTypeParameters;
                    } else if let BoundNode::TsConditionalType(n) = &node {
                        let type_params = self.getInferTypeParameters(n.clone());
                        if let Some(mut type_params) = type_params {
                            outerTypeParameters
                                .get_or_insert(Vec::default())
                                .append(&mut type_params);
                        }
                        return outerTypeParameters;
                    }
                    let mut outerAndOwnTypeParameters = self.appendTypeParameters(
                        outerTypeParameters,
                        getBoundEffectiveTypeParameterDeclarations(node.clone()),
                    );
                    let thisType = if includeThisTypes {
                        if matches!(
                            node,
                            BoundNode::ClassDecl(_)
                                | BoundNode::ClassExpr(_)
                                | BoundNode::TsInterfaceDecl(_)
                        ) || self.isJSConstructor(Some(node.clone()))
                        {
                            let sym = self.getSymbolOfNode(node).unwrap();
                            let ty = self.getDeclaredTypeOfClassOrInterface(sym);
                            self.types[ty].unwrap_as_interface_type().thisType
                        } else {
                            None
                        }
                    } else {
                        None
                    };
                    if let Some(thisType) = thisType {
                        outerAndOwnTypeParameters
                            .get_or_insert(Vec::default())
                            .push(thisType);
                    }
                    return outerAndOwnTypeParameters;
                } // TODO: jsdoc
                // BoundNode::JSDocParameterTag(_)=> {
                //     const paramSymbol = getParameterSymbolFromJSDoc(node as JSDocParameterTag);
                //     if (paramSymbol) {
                //         node = paramSymbol.valueDeclaration!;
                //     }
                // }
                // TODO: jsdoc
                // BoundNode::JSDocComment(_)=> {
                //     const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                //     return (node as JSDoc).tags
                //         ? appendTypeParameters(outerTypeParameters, flatMap((node as JSDoc).tags, t => isJSDocTemplateTag(t) ? t.typeParameters : undefined))
                //         : outerTypeParameters;
                // }
                _ => {}
            }
        }
    }

    // The outer type parameters are those defined by enclosing generic classes, methods, or functions.
    fn getOuterTypeParametersOfClassOrInterface(
        &mut self,
        symbol: SymbolId,
    ) -> Option<Vec<TypeId>> {
        let declaration = if self.symbols[symbol].flags().intersects(SymbolFlags::Class) {
            self.symbols[symbol].valueDeclaration().clone()
        } else {
            self.getDeclarationOfKind(symbol, |decl| matches!(decl, BoundNode::TsInterfaceDecl(_)))
        };
        debug_assert!(
            declaration.is_some(),
            "Class was missing valueDeclaration -OR- non-class had no interface declarations"
        );
        self.getOuterTypeParameters(declaration.unwrap(), false)
    }

    fn getDeclarationOfKind<P>(&mut self, symbol: SymbolId, mut predicate: P) -> Option<BoundNode>
    where
        P: FnMut(&BoundNode) -> bool,
    {
        self.symbols[symbol]
            .declarations()
            .iter()
            .find(|&decl| predicate(decl))
            .cloned()
    }

    // The local type parameters are the combined set of type parameters from all declarations of the class,
    // interface, or type alias.
    fn getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(
        &mut self,
        symbol: SymbolId,
    ) -> Option<Rc<Vec<TypeId>>> {
        let mut result = None;
        // TODO: try to remove vec clone:
        for node in self.symbols[symbol].declarations().clone() {
            if matches!(
                node,
                BoundNode::TsInterfaceDecl(_) | BoundNode::ClassDecl(_) | BoundNode::ClassExpr(_)
            ) || self.isJSConstructor(Some(node.clone()))
                || isTypeAlias(&node)
            {
                result = self
                    .appendTypeParameters(result, getBoundEffectiveTypeParameterDeclarations(node));
            }
        }
        result.map(Rc::new)
    }

    // TODO:
    // getTypeParametersOfClassOrInterface

    // A type is a mixin constructor if it has a single construct signature taking no type parameters and a single
    // rest parameter of type any[].
    fn isMixinConstructorType(&mut self, ty: TypeId) -> bool {
        let signatures = self.getSignaturesOfType(ty, SignatureKind::Construct);
        if signatures.len() == 1 {
            let s = signatures[0];
            let sig = &self.signatures[s];
            if sig.typeParameters.is_none()
                && sig.parameters.len() == 1
                && signatureHasRestParameter(sig)
            {
                let paramType = self.getTypeOfParameter(sig.parameters[0]);
                return self.isTypeAny(Some(paramType))
                    || self.getElementTypeOfArrayType(paramType) == Some(self.anyType);
            }
        }
        false
    }

    fn isConstructorType(&mut self, ty: TypeId) -> bool {
        if !self
            .getSignaturesOfType(ty, SignatureKind::Construct)
            .is_empty()
        {
            return true;
        }
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::TypeVariable)
        {
            let constraint = self.getBaseConstraintOfType(ty);
            return constraint
                .map(|c| self.isMixinConstructorType(c))
                .unwrap_or_default();
        }
        false
    }

    fn getBaseTypeNodeOfClass(&self, ty: TypeId) -> Option<BoundExprWithTypeArgs> {
        let sym = self.types[ty].get_symbol().unwrap();
        getEffectiveBaseTypeNode(self.symbols[sym].valueDeclaration().clone().unwrap())
    }

    // TODO: maybe clean this up
    fn getConstructorsForTypeArguments(
        &mut self,
        ty: TypeId,
        typeArgumentNodes: &Option<Rc<TsTypeParamInstantiation>>,
        location: &BoundNode,
    ) -> Rc<Vec<SignatureId>> {
        let typeArgCount = typeArgumentNodes
            .as_ref()
            .map(|i| i.params.len())
            .unwrap_or_default();
        let isJavascript = isBoundNodeInJSFile(location);
        let mut construct_sigs = self.getSignaturesOfType(ty, SignatureKind::Construct);
        Rc::make_mut(&mut construct_sigs).retain(|&sig| {
            (isJavascript
                || typeArgCount
                    >= self.getMinTypeArgumentCount(self.signatures[sig].typeParameters.clone()))
                && typeArgCount <= self.signatures[sig].typeParameters.length()
        });
        construct_sigs
    }

    fn getInstantiatedConstructorsForTypeArguments(
        &mut self,
        ty: TypeId,
        typeArgumentNodes: Option<Rc<TsTypeParamInstantiation>>,
        location: BoundNode,
    ) -> Rc<Vec<SignatureId>> {
        let signatures = self.getConstructorsForTypeArguments(ty, &typeArgumentNodes, &location);
        let typeArguments = typeArgumentNodes.map(|i| {
            let bound_instantiation = BoundNode::TsTypeParamInstantiation(i.clone());
            Rc::new(
                i.params
                    .iter()
                    .map(|a| self.getTypeFromTypeNode(a.bind(bound_instantiation.clone())))
                    .collect(),
            )
        });
        // TODO: sameMap from tsc
        Rc::new(
            signatures
                .iter()
                .map(|&sig| {
                    if self.signatures[sig].typeParameters.is_some() {
                        self.getSignatureInstantiation(
                            sig,
                            typeArguments.clone(),
                            isBoundNodeInJSFile(&location),
                            None,
                        )
                    } else {
                        sig
                    }
                })
                .collect(),
        )
    }

    /**
     * The base constructor of a class can resolve to
     * * undefinedType if the class has no extends clause,
     * * unknownType if an error occurred during resolution of the extends expression,
     * * nullType if the extends expression is the null value,
     * * anyType if the extends expression has type any, or
     * * an object type with at least one construct signature.
     */
    fn getBaseConstructorTypeOfClass(&mut self, ty: TypeId) -> TypeId {
        match self.types[ty]
            .unwrap_as_interface_type()
            .resolvedBaseConstructorType
        {
            Some(resolvedBaseConstructorType) => resolvedBaseConstructorType,
            None => {
                let sym = self.types[ty].get_symbol().unwrap();
                let decl = self.symbols[sym].valueDeclaration().clone().unwrap();
                if let Some(baseTypeNode) = self.getBaseTypeNodeOfClass(ty) {
                    if !self.pushTypeResolution(
                        TypeSystemEntity::Type(ty),
                        TypeSystemPropertyName::ResolvedBaseConstructorType,
                    ) {
                        return self.errorType;
                    }
                    let baseConstructorType =
                        self.checkExpression(baseTypeNode.expr.clone(), None, false);
                    if let Some(extended) = getEffectiveBaseTypeNode(decl) {
                        if baseTypeNode != extended {
                            debug_assert!(extended.type_args.is_none()); // Because this is in a JS file, and baseTypeNode is in an @extends tag
                            self.checkExpression(extended.expr, None, false);
                        }
                    }
                    if self.types[baseConstructorType]
                        .get_flags()
                        .intersects(TypeFlags::Object | TypeFlags::Intersection)
                    {
                        // Resolving the members of a class requires us to resolve the base class of that class.
                        // We force resolution here such that we catch circularities now.
                        self.resolveStructuredTypeMembers(baseConstructorType);
                    }
                    if !self.popTypeResolution() {
                        todo!();
                        // error(ty.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(ty.symbol));
                        // return ty.resolvedBaseConstructorType = errorType;
                    }
                    if !self.types[baseConstructorType]
                        .get_flags()
                        .intersects(TypeFlags::Any)
                        && baseConstructorType != self.nullWideningType
                        && !self.isConstructorType(baseConstructorType)
                    {
                        todo!();
                        // const err = error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));
                        // if (baseConstructorType.flags & TypeFlags::TypeParameter) {
                        //     const constraint = getConstraintFromTypeParameter(baseConstructorType);
                        //     let ctorReturn: Type = unknownType;
                        //     if (constraint) {
                        //         const ctorSig = getSignaturesOfType(constraint, SignatureKind::Construct);
                        //         if (ctorSig[0]) {
                        //             ctorReturn = getReturnTypeOfSignature(ctorSig[0]);
                        //         }
                        //     }
                        //     if (baseConstructorType.symbol.declarations) {
                        //         addRelatedInfo(err, createDiagnosticForNode(baseConstructorType.symbol.declarations[0], Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)));
                        //     }
                        // }
                        // return ty.resolvedBaseConstructorType = errorType;
                    }
                    self.types[ty]
                        .unwrap_as_interface_type_mut()
                        .resolvedBaseConstructorType = Some(baseConstructorType);
                    baseConstructorType
                } else {
                    self.types[ty]
                        .unwrap_as_interface_type_mut()
                        .resolvedBaseConstructorType = Some(self.undefinedType);
                    self.undefinedType
                }
            }
        }
    }

    // TODO:
    // getImplementsTypes
    // TODO:
    // reportCircularBaseType

    fn getBaseTypes(&mut self, ty: TypeId) -> Rc<Vec<TypeId>> {
        if !self.types[ty].unwrap_as_interface_type().baseTypesResolved {
            if self.pushTypeResolution(
                TypeSystemEntity::Type(ty),
                TypeSystemPropertyName::ResolvedBaseTypes,
            ) {
                let symbol_flags = self.symbols[self.types[ty].get_symbol().unwrap()].flags();
                if self.types[ty]
                    .get_object_flags()
                    .intersects(ObjectFlags::Tuple)
                {
                    todo!();
                    // self.types[ty].unwrap_as_interface_type().resolvedBaseTypes = vec![getTupleBaseType(ty as TupleType)];
                } else if symbol_flags.intersects(SymbolFlags::Class | SymbolFlags::Interface) {
                    if symbol_flags.intersects(SymbolFlags::Class) {
                        self.resolveBaseTypesOfClass(ty);
                    }
                    if symbol_flags.intersects(SymbolFlags::Interface) {
                        self.resolveBaseTypesOfInterface(ty);
                    }
                } else {
                    unreachable!("ty must be class or interface");
                }
                if !self.popTypeResolution() {
                    todo!();
                    // for (const declaration of ty.symbol.declarations) {
                    //     if (declaration.kind === SyntaxKind.ClassDeclaration || declaration.kind === SyntaxKind.InterfaceDeclaration) {
                    //         reportCircularBaseType(declaration, ty);
                    //     }
                    // }
                }
            }
            self.types[ty]
                .unwrap_as_interface_type_mut()
                .baseTypesResolved = true;
        }
        self.types[ty]
            .unwrap_as_interface_type()
            .resolvedBaseTypes
            .as_ref()
            .unwrap()
            .clone()
    }

    // TODO:
    // getTupleBaseType

    fn resolveBaseTypesOfClass(&mut self, ty: TypeId) -> Rc<Vec<TypeId>> {
        // TODO:
        // self.types[ty]
        //     .unwrap_as_interface_type_mut()
        //     .resolvedBaseTypes = self.resolvingEmptyArray;
        let baseConstructorType = self.getBaseConstructorTypeOfClass(ty);
        let baseConstructorType = self.getApparentType(baseConstructorType);
        if !self.types[baseConstructorType]
            .get_flags()
            .intersects(TypeFlags::Object | TypeFlags::Intersection | TypeFlags::Any)
        {
            let resolvedBaseTypes: Rc<Vec<TypeId>> = Default::default();
            self.types[ty]
                .unwrap_as_interface_type_mut()
                .resolvedBaseTypes = Some(resolvedBaseTypes.clone());
            return resolvedBaseTypes;
        }
        let baseTypeNode = self.getBaseTypeNodeOfClass(ty).unwrap();
        let originalBaseType = self.types[baseConstructorType]
            .get_symbol()
            .map(|s| self.getDeclaredTypeOfSymbol(s));
        let baseType = if self.types[baseConstructorType].get_symbol().is_some()
            && self.symbols[self.types[baseConstructorType].get_symbol().unwrap()]
                .flags()
                .intersects(SymbolFlags::Class)
            && self.areAllOuterTypeParametersApplied(originalBaseType.unwrap())
        {
            // When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
            // class and all return the instance type of the class. There is no need for further checks and we can apply the
            // type arguments in the same manner as a type reference to get the same error reporting experience.
            self.getTypeFromClassOrInterfaceReference(
                baseTypeNode.expr,
                self.types[baseConstructorType].get_symbol().unwrap(),
            )
        } else if self.types[baseConstructorType]
            .get_flags()
            .intersects(TypeFlags::Any)
        {
            baseConstructorType
        } else {
            todo!();
            // // The class derives from a "class-like" constructor function, check that we have at least one construct signature
            // // with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
            // // we check that all instantiated signatures return the same type.
            // let constructors = self.getInstantiatedConstructorsForTypeArguments(
            //     baseConstructorType,
            //     baseTypeNode.typeArguments,
            //     baseTypeNode,
            // );
            // if (!constructors.length) {
            //     todo!();
            //     // error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments);
            //     // return ty.resolvedBaseTypes = emptyArray;
            // }
            // self.getReturnTypeOfSignature(constructors[0])
        };

        if self.isErrorType(baseType) {
            todo!();
            // // TODO: we set and return two different arrays
            // self.types[ty]
            //     .unwrap_as_interface_type_mut()
            //     .resolvedBaseTypes = Vec::new();
            // return Vec::new();
        }
        let reducedBaseType = self.getReducedType(baseType);
        if !self.isValidBaseType(reducedBaseType) {
            todo!();
            // const elaboration = elaborateNeverIntersection(/*errorInfo*/ undefined, baseType);
            // const diagnostic = chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType));
            // diagnostics.add(createDiagnosticForNodeFromMessageChain(baseTypeNode.expression, diagnostic));
            // return ty.resolvedBaseTypes = emptyArray;
        }
        if ty == reducedBaseType || self.hasBaseType(reducedBaseType, Some(ty)) {
            todo!();
            // error(ty.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type,
            //     typeToString(ty, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType));
            // return ty.resolvedBaseTypes = emptyArray;
        }
        // TODO:
        // if self.types[ty].unwrap_as_interface_type().resolvedBaseTypes == self.resolvingEmptyArray {
        //     todo!();
        //     // Circular reference, likely through instantiation of default parameters
        //     // (otherwise there'd be an error from hasBaseType) - this is fine, but `.members` should be reset
        //     // as `getIndexedAccessType` via `instantiateType` via `getTypeFromClassOrInterfaceReference` forces a
        //     // partial instantiation of the members without the base types fully resolved
        //     // ty.members = undefined;
        // }
        let resolvedBaseTypes: Rc<Vec<TypeId>> = vec![reducedBaseType].into();
        self.types[ty]
            .unwrap_as_interface_type_mut()
            .resolvedBaseTypes = Some(resolvedBaseTypes.clone());
        resolvedBaseTypes
    }

    // TODO: GH#18217 Shouldn't this take an InterfaceType?
    fn areAllOuterTypeParametersApplied(&mut self, ty: TypeId) -> bool {
        // An unapplied type parameter has its symbol still the same as the matching argument symbol.
        // Since parameters are applied outer-to-inner, only the last outer parameter needs to be checked.
        let outerTypeParameters = self.types[ty]
            .unwrap_as_interface_type()
            .outerTypeParameters
            .as_ref();
        if let Some(outerTypeParameters) = outerTypeParameters {
            todo!();
            // let last = outerTypeParameters.length - 1;
            // let typeArguments = getTypeArguments(ty as TypeReference);
            // return outerTypeParameters[last].symbol != typeArguments[last].symbol;
        }
        true
    }

    // A valid base type is `any`, an object type or intersection of object types.
    fn isValidBaseType(&mut self, ty: TypeId) -> bool {
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::TypeParameter)
        {
            todo!();
            // let constraint = getBaseConstraintOfType(ty);
            // if (constraint) {
            //     return isValidBaseType(constraint);
            // }
        }
        let ty_flags = self.types[ty].get_flags();
        // TODO: Given that we allow type parmeters here now, is this `!isGenericMappedType(type)` check really needed?
        // There's no reason a `T` should be allowed while a `Readonly<T>` should not.
        // TODO: nasty intermidiary clone:
        ty_flags.intersects(TypeFlags::Object | TypeFlags::NonPrimitive | TypeFlags::Any)
            && !self.isGenericMappedType(ty)
            || ty_flags.intersects(TypeFlags::Intersection)
                && self.types[ty]
                    .unwrap_as_union_or_intersection()
                    .types
                    .clone()
                    .iter()
                    .all(|t| self.isValidBaseType(*t))
    }

    fn resolveBaseTypesOfInterface(&mut self, ty: TypeId) {
        debug_assert!(self.types[ty]
            .unwrap_as_interface_type()
            .resolvedBaseTypes
            .is_none());
        let mut resolvedBaseTypes = Vec::new();
        let sym = self.types[ty].get_symbol().unwrap();
        // TODO: I have assumed that nothing in this loop accesses ty.resolvedBaseTypes. This assumption is
        // quite possible incorrect, in which case resolvedBaseTypes will be in an invalid state when accessed.
        // TODO: bad clone:
        for declaration in self.symbols[sym].declarations().clone() {
            if let BoundNode::TsInterfaceDecl(decl) = &declaration {
                for node in &decl.extends {
                    let baseType = self.getTypeFromTypeNode(node.bind(declaration.clone()));
                    let baseType = self.getReducedType(baseType);
                    if !self.isErrorType(baseType) {
                        if self.isValidBaseType(baseType) {
                            if (ty != baseType && !self.hasBaseType(baseType, Some(ty))) {
                                resolvedBaseTypes.push(baseType);
                            } else {
                                todo!();
                                // reportCircularBaseType(declaration, ty);
                            }
                        } else {
                            todo!();
                            // error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members);
                        }
                    }
                }
            }
        }
        self.types[ty]
            .unwrap_as_interface_type_mut()
            .resolvedBaseTypes = Some(resolvedBaseTypes.into());
        // let sym = self.types[ty].get_symbol();
        // for declaration in self.symbols[sym].unwrap().declarations() {
        //     if let BoundNode::TsInterfaceDecl(decl) = declaration {
        //         if let Some(base_types) = self.getInterfaceBaseTypeNodes(decl) {
        //             for node in base_types {
        //                 let baseType = self.getReducedType(self.getTypeFromTypeNode(node));
        //                 if !self.isErrorType(baseType) {
        //                     if self.isValidBaseType(baseType) {
        //                         if (ty != baseType && !self.hasBaseType(baseType, Some(ty))) {
        //                             if ty.resolvedBaseTypes == self.emptyArray {
        //                                 ty.resolvedBaseTypes = vec![baseType];
        //                             } else {
        //                                 ty.resolvedBaseTypes.push(baseType);
        //                             }
        //                         } else {
        //                             todo!();
        //                             // reportCircularBaseType(declaration, ty);
        //                         }
        //                     } else {
        //                         todo!();
        //                         // error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members);
        //                     }
        //                 }
        //             }
        //         }
        //     }
        // }
    }

    /// Returns true if the interface given by the symbol is free of "this" references.
    ///
    /// Specifically, the result is true if the interface itself contains no references
    /// to "this" in its body, if all base types are interfaces,
    /// and if none of the base interfaces have a "this" type.
    fn isThislessInterface(&mut self, symbol: SymbolId) -> bool {
        // TODO: bad clone:
        for declaration in self.symbols[symbol].declarations().clone() {
            if let BoundNode::TsInterfaceDecl(d) = &declaration {
                if self
                    .node_data(declaration.clone())
                    .flags
                    .intersects(NodeFlags::ContainsThis)
                {
                    return false;
                }
                for node in &d.extends {
                    if isEntityNameExpression(&node.expr.clone().into()) {
                        let baseSymbol = self.resolveEntityName(
                            node.expr.bind(declaration.clone()),
                            SymbolFlags::Type,
                            true,
                            false,
                            None,
                        );
                        if let Some(baseSymbol) = baseSymbol {
                            if !self.symbols[baseSymbol]
                                .flags()
                                .intersects(SymbolFlags::Interface)
                                || {
                                    let ty = self.getDeclaredTypeOfClassOrInterface(baseSymbol);
                                    self.types[ty].unwrap_as_interface_type().thisType.is_some()
                                }
                            {
                                return false;
                            }
                        } else {
                            return false;
                        }
                    }
                }
            }
        }
        true
    }

    fn getDeclaredTypeOfClassOrInterface(&mut self, mut symbol: SymbolId) -> TypeId {
        #[derive(Clone, Copy)]
        enum TransientSymbolOrSymbolLinksKey {
            SymbolLinksKey(SymbolId),
            TransientSymbol(SymbolId),
        }
        impl TransientSymbolOrSymbolLinksKey {
            fn declaredType<'a>(&self, checker: &'a mut Checker) -> &'a mut Option<TypeId> {
                match self {
                    TransientSymbolOrSymbolLinksKey::SymbolLinksKey(s) => {
                        &mut checker.getSymbolLinksMut(*s).declaredType
                    }
                    TransientSymbolOrSymbolLinksKey::TransientSymbol(s) => {
                        &mut checker.getSymbolLinksMut(*s).declaredType
                    }
                }
            }
        }
        if let Some(declared_type) = self.getSymbolLinksMut(symbol).declaredType {
            declared_type
        } else {
            let mut links = match self.symbols[symbol] {
                Symbol::Base(_) => TransientSymbolOrSymbolLinksKey::SymbolLinksKey(symbol),
                Symbol::TransientSymbol(_) => {
                    TransientSymbolOrSymbolLinksKey::TransientSymbol(symbol)
                }
            };
            let originalLinks = links;
            let kind = if self.symbols[symbol].flags().intersects(SymbolFlags::Class) {
                ObjectFlags::Class
            } else {
                ObjectFlags::Interface
            };
            let merged = {
                let source = self.symbols[symbol]
                    .valueDeclaration()
                    .clone()
                    .and_then(|decl| self.getAssignedClassSymbol(decl));
                self.mergeJSSymbols(symbol, source)
            };
            if let Some(merged) = merged {
                // note: we overwrite links because we just cloned the symbol
                symbol = merged;
                links = match self.symbols[merged] {
                    Symbol::Base(_) => unreachable!("TODO: is this really unreachable?"),
                    Symbol::TransientSymbol(_) => {
                        TransientSymbolOrSymbolLinksKey::TransientSymbol(merged)
                    }
                };
            }

            let mut ty = Type::InterfaceType(InterfaceType {
                interface_type: InterfaceTypeBase::default(),
                object_type_base: ObjectTypeBase::new(kind),
                type_base: TypeBase::new(TypeFlags::Object, Some(symbol)),
            });

            let outerTypeParameters = self
                .getOuterTypeParametersOfClassOrInterface(symbol)
                .map(|v| Rc::new(v));
            let localTypeParameters =
                self.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);

            let ty_id = self.types.next_index();

            // A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
            // because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
            // property types inferred from initializers and method return types inferred from return statements are very hard
            // to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
            // "this" references.
            if outerTypeParameters.is_some()
                || localTypeParameters.is_some()
                || kind == ObjectFlags::Class
                || !self.isThislessInterface(symbol)
            {
                let interface = unwrap_as!(ty, Type::InterfaceType(t), t);
                let mut generic = GenericType {
                    type_reference: TypeReferenceBase {
                        target: Some(ty_id),
                        resolvedTypeArguments: interface.interface_type.typeParameters.clone(),
                        ..Default::default()
                    },
                    generic_type_base: GenericTypeBase {
                        instantiations: new_ahash_map![(
                            self.getTypeListId(
                                interface
                                    .interface_type
                                    .typeParameters
                                    .as_ref()
                                    .map(|t| t.as_ref())
                            ),
                            ty_id,
                        )],
                        variances: Default::default(),
                    },
                    interface_type: interface.interface_type,
                    object_type_base: interface.object_type_base,
                    type_base: interface.type_base,
                };
                generic.object_type_base.objectFlags |= ObjectFlags::Reference;
                generic.interface_type.typeParameters =
                    match (&outerTypeParameters, &localTypeParameters) {
                        (Some(outer), Some(local)) => {
                            let mut v = Vec::new();
                            v.extend(outer.iter().chain(local.iter()));
                            Some(v.into())
                        }
                        (Some(outer), None) => Some(outer.clone()),
                        (None, Some(local)) => Some(local.clone()),
                        _ => None,
                    };
                generic.interface_type.outerTypeParameters = outerTypeParameters;
                generic.interface_type.localTypeParameters = localTypeParameters;
                let this_type_id = ty_id + 1;
                generic.interface_type.thisType = Some(this_type_id);

                ty = Type::GenericType(generic);
                self.types.push(ty);

                let this_type = Type::TypeParameter(TypeParameter {
                    instantiable_type: InstantiableType::default(),
                    type_base: TypeBase::new(TypeFlags::TypeParameter, Some(symbol)),
                    constraint: Some(ty_id),
                    default: None,
                    target: None,
                    mapper: None,
                    isThisType: true,
                    resolvedDefaultType: None,
                });
                self.types.push(this_type);
            } else {
                self.types.push(ty);
            }
            *originalLinks.declaredType(self) = Some(ty_id);
            *links.declaredType(self) = Some(ty_id);

            ty_id
        }
    }

    fn getDeclaredTypeOfTypeAlias(&mut self, symbol: SymbolId) -> TypeId {
        match self.getSymbolLinks(symbol).declaredType {
            Some(t) => t,
            None => {
                // Note that we use the links object as the target here because the symbol object is used as the unique
                // identity for resolution of the 'type' property in SymbolLinks.
                if !self.pushTypeResolution(
                    TypeSystemEntity::Symbol(symbol),
                    TypeSystemPropertyName::DeclaredType,
                ) {
                    return self.errorType;
                }

                let declaration = match self.symbols[symbol]
                    .declarations()
                    .iter()
                    .find(|&d| isTypeAlias(d))
                {
                    Some(d) => d,
                    None => unreachable!("Type alias symbol with no valid declaration found"),
                };
                let typeNode = match declaration {
                    BoundNode::TsTypeAliasDecl(a) => a.type_ann.bind(a.clone().into()),
                    // TODO: jsodc:
                    // isJSDocTypeAlias(a) => a.typeExpression,
                    _ => unreachable!("checked by isTypeAlias"),
                };
                // If typeNode is missing, we will error in checkJSDocTypedefTag.
                // let ty = if let Some(typeNode) = typeNode {
                //     self.getTypeFromTypeNode(typeNode)
                // } else {
                //     self.errorType
                // };
                let ty = self.getTypeFromTypeNode(typeNode);

                if self.popTypeResolution() {
                    let typeParameters =
                        self.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                    if typeParameters.is_some() {
                        // Initialize the instantiation cache for generic type aliases. The declared type corresponds to
                        // an instantiation of the type alias with the type parameters supplied as type arguments.
                        let typeParameterListId =
                            self.getTypeListId(typeParameters.as_ref().map(|v| v.as_ref()));
                        let links = self.getSymbolLinksMut(symbol);
                        links.typeParameters = typeParameters;
                        links.instantiations.insert(typeParameterListId.0, ty);
                    }
                } else {
                    todo!();
                    // ty = errorType;
                    // if (declaration.kind === SyntaxKind.JSDocEnumTag) {
                    //     error(declaration.typeExpression.ty, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                    // }
                    // else {
                    //     error(isNamedDeclaration(declaration) ? declaration.name : declaration || declaration, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                    // }
                }
                self.getSymbolLinksMut(symbol).declaredType = Some(ty);
                ty
            }
        }
    }

    // TODO:
    // isStringConcatExpression
    // TODO:
    // isLiteralEnumMember
    // TODO:
    // getEnumKind
    // TODO:
    // getBaseTypeOfEnumLiteralType
    // TODO:
    // getDeclaredTypeOfEnum
    // TODO:
    // getDeclaredTypeOfEnumMember

    fn getDeclaredTypeOfTypeParameter(&mut self, symbol: SymbolId) -> TypeId {
        match self.getSymbolLinks(symbol).declaredType {
            Some(declaredType) => declaredType,
            None => {
                let declaredType = self.createTypeParameter(Some(symbol));
                self.getSymbolLinksMut(symbol).declaredType = Some(declaredType);
                declaredType
            }
        }
    }

    // TODO:
    // getDeclaredTypeOfAlias

    fn getDeclaredTypeOfSymbol(&mut self, symbol: SymbolId) -> TypeId {
        self.tryGetDeclaredTypeOfSymbol(symbol)
            .unwrap_or(self.errorType)
    }

    fn tryGetDeclaredTypeOfSymbol(&mut self, symbol: SymbolId) -> Option<TypeId> {
        let flags = self.symbols[symbol].flags();
        if flags.intersects(SymbolFlags::Class | SymbolFlags::Interface) {
            Some(self.getDeclaredTypeOfClassOrInterface(symbol))
        } else if flags.intersects(SymbolFlags::TypeAlias) {
            Some(self.getDeclaredTypeOfTypeAlias(symbol))
        } else if flags.intersects(SymbolFlags::TypeParameter) {
            Some(self.getDeclaredTypeOfTypeParameter(symbol))
        } else if flags.intersects(SymbolFlags::Enum) {
            todo!();
            // self.getDeclaredTypeOfEnum(symbol)
        } else if flags.intersects(SymbolFlags::EnumMember) {
            todo!();
            // self.getDeclaredTypeOfEnumMember(symbol)
        } else if flags.intersects(SymbolFlags::Alias) {
            todo!();
            // self.getDeclaredTypeOfAlias(symbol)
        } else {
            None
        }
    }

    /**
     * Returns true if the class or interface member given by the symbol is free of "this" references. The
     * function may return false for symbols that are actually free of "this" references because it is not
     * feasible to perform a complete analysis in all cases. In particular, property members with types
     * inferred from their initializers and function members with inferred return types are conservatively
     * assumed not to be free of "this" references.
     */
    fn isThisless(&self, symbol: SymbolId) -> bool {
        let decls = self.symbols[symbol].declarations();
        if decls.len() == 1 {
            let decl = &decls[0];

            match decl {
                BoundNode::ClassProp(_)
                | BoundNode::PrivateProp(_)
                | BoundNode::TsPropertySignature(_) => {
                    return isThislessVariableLikeDeclaration(&decl.clone().into());
                }
                BoundNode::PrivateMethod(_)
                | BoundNode::ClassMethod(_)
                | BoundNode::MethodProp(_)
                | BoundNode::TsMethodSignature(_)
                | BoundNode::Constructor(_)
                | BoundNode::GetterProp(_)
                | BoundNode::TsGetterSignature(_)
                | BoundNode::SetterProp(_)
                | BoundNode::TsSetterSignature(_) => {
                    return isThislessFunctionLikeDeclaration(&decl.clone().into());
                }
                _ => {}
            }
        }
        false
    }

    // The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
    // we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
    fn createInstantiatedSymbolTable(
        &mut self,
        symbols: Rc<Vec<SymbolId>>,
        mapper: Rc<TypeMapper>,
        mappingThisOnly: bool,
    ) -> SymbolTableId {
        let result = SymbolTable::from_iter(symbols.iter().map(|&s| {
            (
                self.symbols[s].escapedName().clone(),
                if mappingThisOnly && self.isThisless(s) {
                    s
                } else {
                    self.instantiateSymbol(s, mapper.clone())
                },
            )
        }));
        self.symbol_tables.push(result)
    }

    fn addInheritedMembers(&mut self, symbols: SymbolTableId, baseSymbols: Rc<Vec<SymbolId>>) {
        for &s in baseSymbols.iter() {
            let escpaed_name = self.symbols[s].escapedName();
            if !self.symbol_tables[symbols].contains_key(escpaed_name)
                && !self.isStaticPrivateIdentifierProperty(s)
            {
                self.symbol_tables[symbols].insert(escpaed_name.clone(), s);
            }
        }
    }

    fn isStaticPrivateIdentifierProperty(&self, s: SymbolId) -> bool {
        self.symbols[s]
            .valueDeclaration()
            .as_ref()
            .map(|vd| isPrivateIdentifierClassElementDeclaration(vd) && isStatic(vd))
            .unwrap_or_default()
    }

    fn resolveDeclaredMembers(&mut self, ty: TypeId) -> TypeId {
        if self.types[ty]
            .unwrap_as_interface_type()
            .declared_members
            .is_none()
        {
            let symbol = self.types[ty].get_symbol().unwrap();
            let members = self.getMembersOfSymbol(symbol);
            let declared_members = DeclaredMembers {
                declaredProperties: self.getNamedMembersOfSymbolTableId(members).into(),
                // Start with signatures at empty array in case of recursive types
                declaredCallSignatures: Default::default(),
                declaredConstructSignatures: Default::default(),
                declaredIndexInfos: Default::default(),
            };
            self.types[ty]
                .unwrap_as_interface_type_mut()
                .declared_members = Some(declared_members);

            // TODO:

            let call_sym = self.symbol_tables[members]
                .get(&JsWord::from(InternalSymbolName::Call))
                .copied();
            self.types[ty]
                .unwrap_as_interface_type_mut()
                .declared_members
                .as_mut()
                .unwrap()
                .declaredCallSignatures = self.getSignaturesOfSymbol(call_sym).into();

            let new_sym = self.symbol_tables[members]
                .get(&JsWord::from(InternalSymbolName::New))
                .copied();
            self.types[ty]
                .unwrap_as_interface_type_mut()
                .declared_members
                .as_mut()
                .unwrap()
                .declaredConstructSignatures = self.getSignaturesOfSymbol(new_sym).into();

            self.types[ty]
                .unwrap_as_interface_type_mut()
                .declared_members
                .as_mut()
                .unwrap()
                .declaredIndexInfos = self.getIndexInfosOfSymbol(symbol).into();
        }
        ty
    }

    /**
     * Indicates whether a type can be used as a property name.
     */
    fn isTypeUsableAsPropertyName(&self, ty: TypeId) -> bool {
        self.types[ty]
            .get_flags()
            .intersects(TypeFlags::StringOrNumberLiteralOrUnique)
    }

    /**
     * Indicates whether a declaration name is definitely late-bindable.
     * A declaration name is only late-bindable if:
     * - It is a `ComputedPropertyName`.
     * - Its expression is an `Identifier` or either a `PropertyAccessExpression` an
     * `ElementAccessExpression` consisting only of these same three types of nodes.
     * - The type of its expression is a string or numeric literal type, or is a `unique symbol` type.
     */
    fn isLateBindableName(&mut self, node: DeclName) -> bool {
        match node {
            DeclName::ComputedProperty(_) => {
                todo!();
                // isEntityNameExpression(&Node::from(expr))
                //     && self.isTypeUsableAsPropertyName(self.checkComputedPropertyName(node))
            }
            DeclName::ElementAccessExpression(_) => {
                todo!();
                // isEntityNameExpression(&Node::from(expr))
                //     && self.isTypeUsableAsPropertyName(self.checkExpressionCached(expr))
            }
            _ => false,
        }
    }

    // TODO:
    // isLateBoundName

    /**
     * Indicates whether a declaration has a late-bindable dynamic name.
     */
    fn hasLateBindableName(&mut self, node: &BoundNode) -> bool {
        let name = getNameOfDeclaration(node);
        name.map(|n| self.isLateBindableName(n)).unwrap_or_default()
    }

    /**
     * Indicates whether a declaration has an early-bound name or a dynamic name that can be late-bound.
     */
    fn hasBindableName(&mut self, node: &BoundNode) -> bool {
        return !hasDynamicName(node) || self.hasLateBindableName(node);
    }

    // TODO:
    // isNonBindableDynamicName

    /**
     * Gets the symbolic name for a member from its type.
     */
    fn getPropertyNameFromType(&self, ty: TypeId) -> JsWord {
        match &self.types[ty] {
            Type::UniqueESSymbolType(t) => t.escapedName.clone(),
            Type::StringLiteralType(t) => escapeLeadingUnderscores(&t.value).clone(),
            Type::NumberLiteralType(t) => {
                escapeLeadingUnderscores(&JsWord::from(ecma_number_to_string(t.value))).clone()
            }
            _ => unreachable!(),
        }
    }

    // TODO:
    // addDeclarationToLateBoundSymbol
    // TODO:
    // lateBindMember

    fn getResolvedMembersOrExportsOfSymbol(
        &mut self,
        symbol: SymbolId,
        resolutionKind: MembersOrExportsResolutionKind,
    ) -> SymbolTableId {
        macro_rules! get_links_prop {
            ($resolution_kind:expr) => {{
                match $resolution_kind {
                    MembersOrExportsResolutionKind::ResolvedExports => {
                        &mut self.getSymbolLinksMut(symbol).resolvedExports
                    }
                    MembersOrExportsResolutionKind::ResolvedMembers => {
                        &mut self.getSymbolLinksMut(symbol).resolvedMembers
                    }
                }
            }};
        }
        if get_links_prop!(resolutionKind).is_none() {
            let isStatic = resolutionKind == MembersOrExportsResolutionKind::ResolvedExports;
            let earlySymbols = if !isStatic {
                self.symbols[symbol].members().clone()
            } else if self.symbols[symbol].flags().intersects(SymbolFlags::Module) {
                Some(self.getExportsOfModuleWorker(symbol))
            } else {
                self.symbols[symbol].exports().clone()
            };

            // In the event we recursively resolve the members/exports of the symbol, we
            // set the initial value of resolvedMembers/resolvedExports to the early-bound
            // members/exports of the symbol.
            // TODO: in TSC earlySymbols is just a reference, so changing 'resolutionKind' or 'earlySymbols' will update the other.
            *get_links_prop!(resolutionKind) = earlySymbols.or(Some(self.emptySymbols));

            // fill in any as-yet-unresolved late-bound members.
            let lateSymbols = self.symbol_tables.push(SymbolTable::default());
            // TODO: nasty intermidiary clone:
            for decl in self.symbols[symbol].declarations().clone() {
                macro_rules! process_members {
                    ($members:expr) => {{
                        for (member_is_static, member) in $members {
                            if isStatic == member_is_static && self.hasLateBindableName(&member) {
                                todo!();
                                // self.lateBindMember(symbol, earlySymbols, lateSymbols, member);
                            }
                        }
                    }};
                }
                match &decl {
                    BoundNode::TsInterfaceDecl(n) => {
                        process_members!(n.body.body.iter().map(|m| (
                            match m {
                                ast::TsTypeElement::TsIndexSignature(i) => i.is_static,
                                _ => false,
                            },
                            m.bind(n.body.bind(decl.clone()))
                        )))
                    }
                    BoundNode::ClassDecl(n) => process_members!(n.class.body.iter().map(|m| (
                        match m {
                            ast::ClassMember::ClassProp(p) => p.is_static,
                            ast::ClassMember::PrivateProp(p) => p.is_static,
                            ast::ClassMember::Method(m) => m.is_static,
                            ast::ClassMember::PrivateMethod(m) => m.is_static,
                            _ => false,
                        },
                        m.bind(n.class.bind(decl.clone()))
                    ))),
                    BoundNode::ClassExpr(n) => process_members!(n.class.body.iter().map(|m| (
                        match m {
                            ast::ClassMember::ClassProp(p) => p.is_static,
                            ast::ClassMember::PrivateProp(p) => p.is_static,
                            ast::ClassMember::Method(m) => m.is_static,
                            ast::ClassMember::PrivateMethod(m) => m.is_static,
                            _ => false,
                        },
                        m.bind(n.class.bind(decl.clone()))
                    ))),
                    BoundNode::TsTypeLit(n) => process_members!(n.members.iter().map(|m| (
                        match m {
                            ast::TsTypeElement::TsIndexSignature(i) => i.is_static,
                            _ => false,
                        },
                        m.bind(decl.clone())
                    ))),
                    BoundNode::ObjectLit(n) => {
                        process_members!(n.props.iter().map(|m| (false, m.bind(decl.clone()))))
                    }
                    _ => {}
                }
            }
            if let Some(assignments) = self.symbols[symbol].assignmentDeclarationMembers() {
                todo!();
                // const decls = arrayFrom(assignments.values());
                // for (const member of decls) {
                //     const assignmentKind = getAssignmentDeclarationKind(member as BinaryExpression | CallExpression);
                //     const isInstanceMember = assignmentKind === AssignmentDeclarationKind.PrototypeProperty
                //         || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind)
                //         || assignmentKind === AssignmentDeclarationKind.ObjectDefinePrototypeProperty
                //         || assignmentKind === AssignmentDeclarationKind.Prototype; // A straight `Prototype` assignment probably can never have a computed name
                //     if (isStatic === !isInstanceMember && hasLateBindableName(member)) {
                //         lateBindMember(symbol, earlySymbols, lateSymbols, member);
                //     }
                // }
            }

            *get_links_prop!(resolutionKind) = self
                .combineSymbolTables(earlySymbols, Some(lateSymbols))
                .or(Some(self.emptySymbols));
        }

        get_links_prop!(resolutionKind).unwrap()
    }

    /**
     * Gets a SymbolTable containing both the early- and late-bound members of a symbol.
     *
     * For a description of late-binding, see `lateBindMember`.
     */
    pub fn getMembersOfSymbol(&mut self, sym: SymbolId) -> SymbolTableId {
        if self.symbols[sym]
            .flags()
            .intersects(SymbolFlags::LateBindingContainer)
        {
            self.getResolvedMembersOrExportsOfSymbol(
                sym,
                MembersOrExportsResolutionKind::ResolvedMembers,
            )
        } else {
            self.symbols[sym].members().unwrap_or(self.emptySymbols)
        }
    }

    /**
     * If a symbol is the dynamic name of the member of an object type, get the late-bound
     * symbol of the member.
     *
     * For a description of late-binding, see `lateBindMember`.
     */
    fn getLateBoundSymbol(&mut self, symbol: SymbolId) -> SymbolId {
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::ClassMember)
            && self.symbols[symbol].escapedName() == &JsWord::from(InternalSymbolName::Computed)
        {
            todo!();
            // if self.getSymbolLinks(symbol).lateSymbol.is_none()
            //     && self.symbols[symbol]
            //         .declarations()
            //         .iter()
            //         .any(self.hasLateBindableName)
            // {
            //     // force late binding of members/exports. This will set the late-bound symbol
            //     let parent = self
            //         .getMergedSymbolOptional(self.symbols[symbol].parent())
            //         .unwrap();
            //     if self.symbols[symbol]
            //         .declarations()
            //         .iter()
            //         .any(hasStaticModifier)
            //     {
            //         self.getExportsOfSymbol(parent);
            //     } else {
            //         self.getMembersOfSymbol(parent);
            //     }
            // }
            // return *self
            //     .getSymbolLinksMut(symbol)
            //     .lateSymbol
            //     .get_or_insert(symbol);
        }
        symbol
    }

    fn getTypeWithThisArgument(
        &mut self,
        ty: TypeId,
        thisArgument: Option<TypeId>,
        needApparentType: bool,
    ) -> TypeId {
        if self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::Reference)
        {
            let target = self.types[ty].unwrap_as_type_reference().target.unwrap();
            let typeArguments = self.getTypeArguments(ty);
            let target = self.types[target].unwrap_as_interface_type();
            if target.typeParameters.as_ref().map(|p| p.len()) == Some(typeArguments.len()) {
                todo!();
                // let r = createTypeReference(
                //     target,
                //     concatenate(
                //         typeArguments,
                //         [thisArgument.unwrap_or(target.thisType.unwrap())],
                //     ),
                // );
                // return if needApparentType {
                //     self.getApparentType(r)
                // } else {
                //     r
                // };
            }
        } else if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Intersection)
        {
            todo!();
            // let types = sameMap((ty as IntersectionType).types, t => getTypeWithThisArgument(t, thisArgument, needApparentType));
            // return if types != (ty as IntersectionType).types {getIntersectionType(types) }else{ty};
        }
        if needApparentType {
            self.getApparentType(ty)
        } else {
            ty
        }
    }

    fn resolveObjectTypeMembers(
        &mut self,
        ty: TypeId,
        source: TypeId,
        typeParameters: Rc<Vec<TypeId>>,
        typeArguments: Rc<Vec<TypeId>>,
    ) {
        let mut mapper = None;
        let mut members;
        let mut callSignatures;
        let mut constructSignatures;
        let mut indexInfos;
        if rangeEquals(&typeParameters, &typeArguments, 0, typeParameters.len()) {
            members = if let Some(symbol) = self.types[source].get_symbol() {
                self.getMembersOfSymbol(*symbol)
            } else {
                let mut result = SymbolTable::default();
                result.extend(
                    self.types[source]
                        .unwrap_as_interface_type()
                        .declared_members
                        .as_ref()
                        .unwrap()
                        .declaredProperties
                        .iter()
                        .map(|&s| (self.symbols[s].escapedName().clone(), s)),
                );

                self.symbol_tables.push(result)
            };
            let source = self.types[source]
                .unwrap_as_interface_type()
                .declared_members
                .as_ref()
                .unwrap();
            callSignatures = source.declaredCallSignatures.clone();
            constructSignatures = source.declaredConstructSignatures.clone();
            indexInfos = source.declaredIndexInfos.clone();
        } else {
            let mappingThisOnly = typeParameters.len() == 1;
            let m = self.createTypeMapper(typeParameters, Some(typeArguments.clone()));
            members = self.createInstantiatedSymbolTable(
                self.types[source]
                    .unwrap_as_interface_type()
                    .declared_members
                    .as_ref()
                    .unwrap()
                    .declaredProperties
                    .clone(),
                m.clone(),
                mappingThisOnly,
            );
            let source = self.types[source]
                .unwrap_as_interface_type()
                .declared_members
                .as_ref()
                .unwrap();
            let declaredCallSignatures = source.declaredCallSignatures.clone();
            let declaredConstructSignatures = source.declaredConstructSignatures.clone();
            let declaredIndexInfos = source.declaredIndexInfos.clone();
            callSignatures = self.instantiateSignatures(declaredCallSignatures, m.clone());
            constructSignatures =
                self.instantiateSignatures(declaredConstructSignatures, m.clone());
            indexInfos = self.instantiateIndexInfos(declaredIndexInfos, m.clone());
            mapper = Some(m);
        }
        let baseTypes = self.getBaseTypes(source);
        if !baseTypes.is_empty() {
            if let Some(source_sym) = self.types[source].get_symbol() {
                if members == self.getMembersOfSymbol(*source_sym) {
                    let mut result = SymbolTable::default();
                    result.extend(
                        self.types[source]
                            .unwrap_as_interface_type()
                            .declared_members
                            .as_ref()
                            .unwrap()
                            .declaredProperties
                            .iter()
                            .map(|&s| (self.symbols[s].escapedName().clone(), s)),
                    );

                    members = self.symbol_tables.push(result);
                }
            }

            self.setStructuredTypeMembers(
                ty,
                members,
                callSignatures.clone(),
                constructSignatures.clone(),
                indexInfos.clone(),
            );
            let thisArgument = typeArguments.last();
            for &baseType in baseTypes.iter() {
                let instantiatedBaseType = if let Some(thisArgument) = thisArgument {
                    let ty = self.instantiateType(baseType, mapper.clone());
                    self.getTypeWithThisArgument(ty, Some(*thisArgument), false)
                } else {
                    baseType
                };
                let base_props = self.getPropertiesOfType(instantiatedBaseType).clone();
                self.addInheritedMembers(members, base_props);
                Rc::make_mut(&mut callSignatures).extend(
                    self.getSignaturesOfType(instantiatedBaseType, SignatureKind::Call)
                        .iter(),
                );
                Rc::make_mut(&mut constructSignatures).extend(
                    self.getSignaturesOfType(instantiatedBaseType, SignatureKind::Construct)
                        .iter(),
                );
                if instantiatedBaseType != self.anyType {
                    let inheritedIndexInfos = self.getIndexInfosOfType(instantiatedBaseType);
                    for &inheritedIndexInfo in inheritedIndexInfos.iter() {
                        if self
                            .findIndexInfo(
                                &indexInfos,
                                self.index_infos[inheritedIndexInfo].keyType,
                            )
                            .is_none()
                        {
                            Rc::make_mut(&mut indexInfos).push(inheritedIndexInfo);
                        }
                    }
                } else {
                    let inheritedIndexInfo =
                        self.createIndexInfo(self.stringType, self.anyType, false, None);
                    if self
                        .findIndexInfo(&indexInfos, self.index_infos[inheritedIndexInfo].keyType)
                        .is_none()
                    {
                        Rc::make_mut(&mut indexInfos).push(inheritedIndexInfo);
                    }
                };
            }
        }
        self.setStructuredTypeMembers(ty, members, callSignatures, constructSignatures, indexInfos);
    }

    fn resolveClassOrInterfaceMembers(&mut self, ty: TypeId) {
        let source = self.resolveDeclaredMembers(ty);
        self.resolveObjectTypeMembers(ty, source, Default::default(), Default::default());
    }

    fn resolveTypeReferenceMembers(&mut self, ty: TypeId) {
        let target = self.types[ty].unwrap_as_type_reference().target.unwrap();
        let source = self.resolveDeclaredMembers(target);
        let typeParameters = {
            let source = self.types[source].unwrap_as_interface_type();
            source
                .typeParameters
                .as_ref()
                .into_iter()
                .map(|v| v.iter())
                .flatten()
                .copied()
                .chain(source.thisType.clone())
                .collect::<Vec<_>>()
        };
        // TODO: if getTypeArguments is changed to no longer retrun an owned vec, we can no longer push to it:
        let mut paddedTypeArguments = self.getTypeArguments(ty);
        if paddedTypeArguments.len() != typeParameters.len() {
            Rc::make_mut(&mut paddedTypeArguments).push(ty);
        }
        self.resolveObjectTypeMembers(ty, source, typeParameters.into(), paddedTypeArguments);
    }

    fn createSignature(
        &mut self,
        declaration: Option<BoundNode>,
        typeParameters: Option<Rc<Vec<TypeId>>>,
        thisParameter: Option<SymbolId>,
        parameters: Rc<Vec<SymbolId>>,
        resolvedReturnType: Option<TypeId>,
        // resolvedTypePredicate: Option<TypePredicate>,
        minArgumentCount: usize,
        flags: SignatureFlags,
    ) -> SignatureId {
        let sig = Signature {
            flags,
            declaration,
            typeParameters,
            parameters,
            thisParameter,
            resolvedReturnType,
            // resolvedTypePredicate,
            minArgumentCount,
            ..Default::default()
        };

        self.signatures.push(sig)
    }

    fn cloneSignature(&mut self, sig: SignatureId) -> SignatureId {
        let other = &self.signatures[sig];
        let result = Signature {
            flags: other.flags & SignatureFlags::PropagatingFlags,
            declaration: other.declaration.clone(),
            typeParameters: other.typeParameters.clone(),
            parameters: other.parameters.clone(),
            thisParameter: other.thisParameter,
            minArgumentCount: other.minArgumentCount,
            target: other.target,
            mapper: other.mapper.clone(),
            compositeSignatures: other.compositeSignatures.clone(),
            compositeKind: other.compositeKind,
            ..Default::default()
        };
        self.signatures.push(result)
    }

    fn createUnionSignature(
        &mut self,
        signature: SignatureId,
        unionSignatures: Rc<Vec<SignatureId>>,
    ) -> SignatureId {
        let mut result_id = self.cloneSignature(signature);
        let mut result = &mut self.signatures[result_id];
        result.compositeSignatures = unionSignatures;
        result.compositeKind = Some(TypeFlags::Union);
        result.target = None;
        result.mapper = None;
        result_id
    }

    fn getOptionalCallSignature(
        &mut self,
        signature: SignatureId,
        callChainFlags: SignatureFlags,
    ) -> SignatureId {
        if self.signatures[signature].flags & SignatureFlags::CallChainFlags == callChainFlags {
            return signature;
        }
        let cached = if callChainFlags == SignatureFlags::IsInnerCallChain {
            self.signatures[signature].optionalCallSignatureCache.inner
        } else {
            self.signatures[signature].optionalCallSignatureCache.outer
        };
        match cached {
            Some(s) => s,
            None => {
                let sig = self.createOptionalCallSignature(signature, callChainFlags);
                if callChainFlags == SignatureFlags::IsInnerCallChain {
                    self.signatures[signature].optionalCallSignatureCache.inner = Some(sig);
                } else {
                    self.signatures[signature].optionalCallSignatureCache.outer = Some(sig);
                }
                sig
            }
        }
    }

    fn createOptionalCallSignature(
        &mut self,
        signature: SignatureId,
        callChainFlags: SignatureFlags,
    ) -> SignatureId {
        debug_assert!(callChainFlags == SignatureFlags::IsInnerCallChain || callChainFlags == SignatureFlags::IsOuterCallChain,
            "An optional call signature can either be for an inner call chain or an outer call chain, but not both.");
        let result = self.cloneSignature(signature);
        self.signatures[result].flags |= callChainFlags;
        result
    }

    // TODO:
    // getExpandedParameters

    fn getDefaultConstructSignatures(&mut self, classType: TypeId) -> Vec<SignatureId> {
        let baseConstructorType = self.getBaseConstructorTypeOfClass(classType);
        let baseSignatures =
            self.getSignaturesOfType(baseConstructorType, SignatureKind::Construct);
        let class_sym = self.types[classType].get_symbol().unwrap();
        let declaration = getClassLikeDeclarationOfSymbol(&self.symbols[class_sym]);
        let isAbstract = declaration
            .map(|d| hasSyntacticModifier(&d, ModifierFlags::Abstract))
            .unwrap_or_default();
        if baseSignatures.is_empty() {
            return vec![self.createSignature(
                None,
                self.types[classType]
                    .unwrap_as_interface_type()
                    .localTypeParameters
                    .clone(),
                None,
                Default::default(),
                Some(classType),
                /*resolvedTypePredicate undefined ,*/ 0,
                if isAbstract {
                    SignatureFlags::Abstract
                } else {
                    SignatureFlags::None
                },
            )];
        }
        let baseTypeNode = &self.getBaseTypeNodeOfClass(classType).unwrap().expr;
        let isJavaScript = isBoundNodeInJSFile(baseTypeNode);
        let typeArguments = self.typeArgumentsFromTypeReferenceNode(baseTypeNode);
        let typeArgCount = typeArguments.length();
        let mut result = Vec::new();
        for &baseSig in baseSignatures.iter() {
            let minTypeArgumentCount =
                self.getMinTypeArgumentCount(self.signatures[baseSig].typeParameters.clone());
            let typeParamCount = self.signatures[baseSig].typeParameters.length();
            if isJavaScript
                || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount
            {
                let sig = if typeParamCount != 0 {
                    let typeArguments = self.fillMissingTypeArguments(
                        typeArguments.clone(),
                        self.signatures[baseSig].typeParameters.clone(),
                        minTypeArgumentCount,
                        isJavaScript,
                    );
                    self.createSignatureInstantiation(baseSig, typeArguments)
                } else {
                    self.cloneSignature(baseSig)
                };
                self.signatures[sig].typeParameters = self.types[classType]
                    .unwrap_as_interface_type()
                    .localTypeParameters
                    .clone();
                self.signatures[sig].resolvedReturnType = Some(classType);
                self.signatures[sig].flags = if isAbstract {
                    self.signatures[sig].flags | SignatureFlags::Abstract
                } else {
                    self.signatures[sig].flags & !SignatureFlags::Abstract
                };
                result.push(sig);
            }
        }
        result
    }

    fn findMatchingSignature(
        &mut self,
        signatureList: &[SignatureId],
        signature: SignatureId,
        partialMatch: bool,
        ignoreThisTypes: bool,
        ignoreReturnTypes: bool,
    ) -> Option<SignatureId> {
        // TODO: iter.find?
        for &s in signatureList.iter() {
            if self.compareSignaturesIdentical(
                s,
                signature,
                partialMatch,
                ignoreThisTypes,
                ignoreReturnTypes,
                |checker, s, t| {
                    if partialMatch {
                        todo!();
                        // checker.compareTypesSubtypeOf(s, t)
                    } else {
                        todo!();
                        // checker.compareTypesIdentical(s, t)
                    }
                },
            ) != Ternary::False
            {
                return Some(s);
            }
        }
        None
    }

    fn findMatchingSignatures(
        &mut self,
        signatureLists: &[Rc<Vec<SignatureId>>],
        signature: SignatureId,
        listIndex: usize,
    ) -> Vec<SignatureId> {
        if self.signatures[signature].typeParameters.is_some() {
            todo!();
            // We require an exact match for generic signatures, so we only return signatures from the first
            // signature list and only if they have exact matches in the other signature lists.
            // if (listIndex > 0) {
            //     return undefined;
            // }
            // for (let i = 1; i < signatureLists.length; i++) {
            //     if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false)) {
            //         return undefined;
            //     }
            // }
            // return [signature];
        }
        let mut result = Vec::new();
        for (i, signatureList) in signatureLists.iter().enumerate() {
            // Allow matching non-generic signatures to have excess parameters and different return types.
            // Prefer matching this types if possible.
            let found = if i == listIndex {
                Some(signature)
            } else {
                self.findMatchingSignature(&signatureList, signature, true, false, true)
            };
            if let Some(found) = found {
                result.push_if_unique(found);
            } else {
                return Vec::new();
            }
        }
        result
    }

    // The signatures of a union type are those signatures that are present in each of the constituent types.
    // Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
    // parameters and may differ in return types. When signatures differ in return types, the resulting return
    // type is the union of the constituent return types.
    fn getUnionSignatures(&mut self, signatureLists: &[Rc<Vec<SignatureId>>]) -> Vec<SignatureId> {
        #[derive(PartialEq)]
        enum OverloadSet {
            None,
            Single(usize),
            Multiple,
        }
        let mut result = Vec::new();
        let mut indexWithLengthOverOne = OverloadSet::None;
        for (i, signatureList) in signatureLists.iter().enumerate() {
            if signatureList.is_empty() {
                return Vec::new();
            };
            if signatureList.len() > 1 {
                indexWithLengthOverOne = if indexWithLengthOverOne == OverloadSet::None {
                    OverloadSet::Single(i)
                } else {
                    OverloadSet::Multiple
                };
            }
            for &signature in signatureList.iter() {
                // Only process signatures with parameter lists that aren't already in the result list
                if result.is_empty()
                    || self
                        .findMatchingSignature(&result, signature, false, false, true)
                        .is_none()
                {
                    let unionSignatures = self.findMatchingSignatures(signatureLists, signature, i);
                    if !unionSignatures.is_empty() {
                        let mut s = signature;
                        // Union the result types when more than one signature matches
                        if unionSignatures.len() > 1 {
                            let thisParameter = self.signatures[signature].thisParameter;
                            let firstThisParameterOfUnionSignatures = unionSignatures
                                .iter()
                                .find_map(|&sig| self.signatures[sig].thisParameter);
                            if let Some(firstThisParameterOfUnionSignatures) =
                                firstThisParameterOfUnionSignatures
                            {
                                todo!();
                                // let thisType = getIntersectionType(mapDefined(unionSignatures, sig => sig.thisParameter && getTypeOfSymbol(sig.thisParameter)));
                                // thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);
                            }
                            s = self.createUnionSignature(signature, Rc::new(unionSignatures));
                            self.signatures[s].thisParameter = thisParameter;
                        }
                        result.push(s);
                    }
                }
            }
        }
        if result.is_empty() && indexWithLengthOverOne != OverloadSet::Multiple {
            todo!();
            // // No sufficiently similar signature existed to subsume all the other signatures in the union - time to see if we can make a single
            // // signature that handles all over them. We only do this when there are overloads in only one constituent.
            // // (Overloads are conditional in nature and having overloads in multiple constituents would necessitate making a power set of
            // // signatures from the type, whose ordering would be non-obvious)
            // const masterList = signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0];
            // let results: Signature[] | undefined = masterList.slice();
            // for (const signatures of signatureLists) {
            //     if (signatures !== masterList) {
            //         const signature = signatures[0];
            //         Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass");
            //         results = !!signature.typeParameters && some(results, s => !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)) ? undefined : map(results, sig => combineSignaturesOfUnionMembers(sig, signature));
            //         if (!results) {
            //             break;
            //         }
            //     }
            // }
            // result = results;
        }
        result
    }

    fn compareTypeParametersIdentical(
        &mut self,
        sourceParams: Option<Rc<Vec<TypeId>>>,
        targetParams: Option<Rc<Vec<TypeId>>>,
    ) -> bool {
        if sourceParams.length() != targetParams.length() {
            return false;
        }

        let (sourceParams, targetParams) = match (sourceParams, targetParams) {
            (Some(sourceParams), Some(targetParams)) => (sourceParams, targetParams),
            _ => return true,
        };

        let mapper = self.createTypeMapper(targetParams.clone(), Some(sourceParams.clone()));
        for (&source, &target) in sourceParams.iter().zip(targetParams.iter()) {
            if source == target {
                continue;
            }
            let source = self
                .getConstraintFromTypeParameter(source)
                .unwrap_or(self.unknownType);
            let target_ty = self
                .getConstraintFromTypeParameter(target)
                .unwrap_or(self.unknownType);
            // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`
            let target = self.instantiateType(target_ty, Some(mapper.clone()));
            if !self.isTypeIdenticalTo(source, target) {
                return false;
            }
            // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.
            // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing
            // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)
            // and, since it's just an inference _default_, just picking one arbitrarily works OK.
        }

        true
    }

    // TODO:
    // combineUnionThisParam
    // TODO:
    // combineUnionParameters
    // TODO:
    // combineSignaturesOfUnionMembers

    fn getUnionIndexInfos(&mut self, types: Rc<Vec<TypeId>>) -> Vec<IndexInfoId> {
        let sourceInfos = self.getIndexInfosOfType(types[0]);
        let mut result = Vec::new();
        for &info in sourceInfos.iter() {
            let indexType = self.index_infos[info].keyType;
            if types
                .iter()
                .all(|&t| self.getIndexInfoOfType(t, indexType).is_some())
            {
                let mapped_types = types
                    .iter()
                    .map(|&t| self.getIndexTypeOfType(t, indexType).unwrap())
                    // TODO: bad collect
                    .collect::<Vec<_>>();
                let ty = self.getUnionType(&mapped_types, None, None, None, None);
                let isReadonly = types.iter().any(|&t| {
                    let info = self.getIndexInfoOfType(t, indexType).unwrap();
                    self.index_infos[info].isReadonly
                });
                result.push(self.createIndexInfo(indexType, ty, isReadonly, None));
            }
        }
        return result;

        Vec::new()
    }

    fn resolveUnionTypeMembers(&mut self, ty: TypeId) {
        let types = self.types[ty]
            .unwrap_as_union_or_intersection()
            .types
            .clone();
        // The members and properties collections are empty for union types. To get all properties of a union
        // type use getPropertiesOfType (only the language service uses this).
        // TODO: bad collect:
        let callSignatures = types
            .iter()
            .map(|&t| {
                if t == self.globalFunctionType() {
                    // TODO: unnedded alloc?
                    Rc::new(vec![self.unknownSignature])
                } else {
                    self.getSignaturesOfType(t, SignatureKind::Call)
                }
            })
            .collect::<Vec<_>>();
        let callSignatures = self.getUnionSignatures(&callSignatures);
        // TODO: bad collect:
        let constructSignatures = types
            .iter()
            .map(|&t| self.getSignaturesOfType(t, SignatureKind::Construct))
            .collect::<Vec<_>>();
        let constructSignatures = self.getUnionSignatures(&constructSignatures);
        let indexInfos = self.getUnionIndexInfos(types);
        self.setStructuredTypeMembers(
            ty,
            self.emptySymbols,
            Rc::new(callSignatures),
            Rc::new(constructSignatures),
            Rc::new(indexInfos),
        );
    }

    // TODO:
    // intersectTypes
    // TODO:
    // intersectTypes
    // TODO:
    // intersectTypes
    // TODO:
    // findMixins
    // TODO:
    // includeMixinType
    // TODO:
    // resolveIntersectionTypeMembers
    // TODO:
    // appendSignatures
    // TODO:
    // appendIndexInfo

    /**
     * TODO: this comment is not strictly true (ty may not be AnonymousType)
     * Converts an AnonymousType to a ResolvedType.
     */
    fn resolveAnonymousTypeMembers(&mut self, ty: TypeId) {
        // TODO: could ty be a MappedType?

        let symbol = self.getMergedSymbol(self.types[ty].get_symbol().unwrap());
        if matches!(&self.types[ty], Type::AnonymousType(t))
            && unwrap_as!(&self.types[ty], Type::AnonymousType(t), t)
                .anonymous_type
                .target
                .is_some()
        {
            let target = unwrap_as!(&self.types[ty], Type::AnonymousType(t), t)
                .anonymous_type
                .target
                .unwrap();
            let mapper = unwrap_as!(&self.types[ty], Type::AnonymousType(t), t)
                .anonymous_type
                .mapper
                .clone()
                .unwrap();

            self.setStructuredTypeMembers(
                ty,
                self.emptySymbols,
                Default::default(),
                Default::default(),
                Default::default(),
            );

            let members = self.getPropertiesOfObjectType(target);
            let members = self.createInstantiatedSymbolTable(members, mapper.clone(), false);

            let callSignatures = self.getSignaturesOfType(target, SignatureKind::Call);
            let callSignatures = self.instantiateSignatures(callSignatures, mapper.clone());

            let constructSignatures = self.getSignaturesOfType(target, SignatureKind::Construct);
            let constructSignatures =
                self.instantiateSignatures(constructSignatures, mapper.clone());

            let indexInfos = self.getIndexInfosOfType(target);
            let indexInfos = self.instantiateIndexInfos(indexInfos, mapper);

            self.setStructuredTypeMembers(
                ty,
                members,
                callSignatures,
                constructSignatures,
                indexInfos,
            );
        } else if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::TypeLiteral)
        {
            self.setStructuredTypeMembers(
                ty,
                self.emptySymbols,
                Default::default(),
                Default::default(),
                Default::default(),
            );
            let members = self.getMembersOfSymbol(symbol);
            let callSignatures = self.getSignaturesOfSymbol(
                self.symbol_tables[members]
                    .get(&JsWord::from(InternalSymbolName::Call))
                    .copied(),
            );
            let constructSignatures = self.getSignaturesOfSymbol(
                self.symbol_tables[members]
                    .get(&JsWord::from(InternalSymbolName::New))
                    .copied(),
            );
            let indexInfos = self.getIndexInfosOfSymbol(symbol);
            self.setStructuredTypeMembers(
                ty,
                members,
                callSignatures.into(),
                constructSignatures.into(),
                indexInfos.into(),
            );
        } else {
            // Combinations of function, class, enum and module
            let mut members = self.emptySymbols;
            if self.symbols[symbol].exports().is_some() {
                members = self.getExportsOfSymbol(symbol);
                if symbol == self.globalThisSymbol {
                    let mut varsOnly = SymbolTable::default();
                    for &p in self.symbol_tables[members].values() {
                        if !self.symbols[p].flags().intersects(SymbolFlags::BlockScoped) {
                            varsOnly.insert(self.symbols[p].escapedName().clone(), p);
                        }
                    }
                    members = self.symbol_tables.push(varsOnly);
                }
            }
            self.setStructuredTypeMembers(
                ty,
                members,
                Default::default(),
                Default::default(),
                Default::default(),
            );
            let mut baseConstructorIndexInfo = None;
            if self.symbols[symbol].flags().intersects(SymbolFlags::Class) {
                let classType = self.getDeclaredTypeOfClassOrInterface(symbol);
                let baseConstructorType = self.getBaseConstructorTypeOfClass(classType);
                if self.types[baseConstructorType].get_flags().intersects(
                    TypeFlags::Object | TypeFlags::Intersection | TypeFlags::TypeVariable,
                ) {
                    let new_members = SymbolTable::from_iter(
                        self.getNamedOrIndexSignatureMembers(members)
                            .iter()
                            .map(|&s| (self.symbols[s].escapedName().clone(), s)),
                    );
                    members = self.symbol_tables.push(new_members);
                    let base_props = self.getPropertiesOfType(baseConstructorType);
                    self.addInheritedMembers(members, base_props);
                } else if baseConstructorType == self.anyType {
                    baseConstructorIndexInfo =
                        Some(self.createIndexInfo(self.stringType, self.anyType, false, None));
                }
            }

            let indexInfos = if let Some(indexSymbol) = self.getIndexSymbolFromSymbolTable(members)
            {
                Some(Rc::new(self.getIndexInfosOfIndexSymbol(indexSymbol)))
            } else {
                let mut indexInfos = None;
                if let Some(baseConstructorIndexInfo) = baseConstructorIndexInfo {
                    indexInfos = Some(vec![baseConstructorIndexInfo]);
                }
                if self.symbols[symbol].flags().intersects(SymbolFlags::Enum) {
                    let sym_ty = self.getDeclaredTypeOfSymbol(symbol);
                    if self.types[sym_ty].get_flags().intersects(TypeFlags::Enum)
                        || unwrap_as!(&self.types[ty], Type::ResolvedType(t), t)
                            .object_type_base
                            .properties
                            .clone()
                            .iter()
                            .any(|&prop| {
                                let ty = self.getTypeOfSymbol(prop);
                                self.types[ty].get_flags().intersects(TypeFlags::NumberLike)
                            })
                    {
                        if let Some(indexInfos) = &mut indexInfos {
                            indexInfos.push(self.enumNumberIndexInfo);
                        } else {
                            indexInfos = Some(vec![self.enumNumberIndexInfo]);
                        }
                    }
                }
                indexInfos.map(|v| Rc::new(v))
            };
            self.setStructuredTypeMembers(
                ty,
                members,
                Default::default(),
                Default::default(),
                indexInfos.unwrap_or_default(),
            );
            // We resolve the members before computing the signatures because a signature may use
            // typeof with a qualified name expression that circularly references the type we are
            // in the process of resolving (see issue #6072). The temporarily empty signature list
            // will never be observed because a qualified name can't reference signatures.
            if self.symbols[symbol]
                .flags()
                .intersects(SymbolFlags::Function | SymbolFlags::Method)
            {
                unwrap_as!(&mut self.types[ty], Type::ResolvedType(t), t)
                    .object_type_base
                    .callSignatures = self.getSignaturesOfSymbol(Some(symbol)).into();
            }
            // And likewise for construct signatures for classes
            if self.symbols[symbol].flags().intersects(SymbolFlags::Class) {
                let classType = self.getDeclaredTypeOfClassOrInterface(symbol);
                let mut constructSignatures = if let Some(members) = self.symbols[symbol].members()
                {
                    let constructor_sym = self.symbol_tables[*members]
                        .get(&JsWord::from(InternalSymbolName::Constructor))
                        .copied();
                    self.getSignaturesOfSymbol(constructor_sym)
                } else {
                    Vec::new()
                };
                if self.symbols[symbol]
                    .flags()
                    .intersects(SymbolFlags::Function)
                {
                    todo!();
                    // constructSignatures = addRange(constructSignatures.slice(), mapDefined(
                    //     ty.callSignatures,
                    //     sig => isJSConstructor(sig.declaration) ?
                    //         createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, /*resolvedTypePredicate*/ undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags) :
                    //         undefined));
                }
                if constructSignatures.is_empty() {
                    constructSignatures = self.getDefaultConstructSignatures(classType);
                }
                self.types[ty]
                    .unwrap_object_type_base_mut()
                    .constructSignatures = Rc::new(constructSignatures);
            }
        }
    }

    // TODO:
    // replaceIndexedAccess
    // TODO:
    // resolveReverseMappedTypeMembers
    // TODO:
    // getLowerBoundOfKeyType
    // TODO:
    // getIsLateCheckFlag
    // TODO:
    // forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType
    // TODO:
    // resolveMappedTypeMembers
    // TODO:
    // getTypeOfMappedSymbol

    fn getTypeParameterFromMappedType(&mut self, ty: TypeId) -> TypeId {
        match unwrap_as!(&self.types[ty], Type::MappedType(t), t).typeParameter {
            Some(t) => t,
            None => {
                let decl = &unwrap_as!(&self.types[ty], Type::MappedType(t), t).declaration;
                let sym = self
                    .getSymbolOfNode(decl.type_param.bind(decl.clone().into()))
                    .unwrap();
                let tp = self.getDeclaredTypeOfTypeParameter(sym);
                unwrap_as!(&mut self.types[ty], Type::MappedType(t), t).typeParameter = Some(tp);
                tp
            }
        }
    }

    fn getConstraintTypeFromMappedType(&mut self, ty: TypeId) -> TypeId {
        match unwrap_as!(&self.types[ty], Type::MappedType(t), t).constraintType {
            Some(constraintType) => constraintType,
            None => {
                let type_param = self.getTypeParameterFromMappedType(ty);
                let constraintType = self
                    .getConstraintOfTypeParameter(type_param)
                    .unwrap_or(self.errorType);
                unwrap_as!(&mut self.types[ty], Type::MappedType(t), t).constraintType =
                    Some(constraintType);
                constraintType
            }
        }
    }

    fn getNameTypeFromMappedType(&mut self, ty: TypeId) -> Option<TypeId> {
        let t = unwrap_as!(&self.types[ty], Type::MappedType(t), t);
        if let Some(name_type_node) = &t.declaration.name_type {
            if t.nameType.is_none() {
                let mapper = t.anonymous_type.mapper.clone();
                let nameType =
                    self.getTypeFromTypeNode(name_type_node.bind(t.declaration.clone().into()));
                let nameType = self.instantiateType(nameType, mapper);
                unwrap_as!(&mut self.types[ty], Type::MappedType(t), t).nameType = Some(nameType);
            }
            unwrap_as!(&self.types[ty], Type::MappedType(t), t).nameType
        } else {
            None
        }
    }
    // TODO:
    // getTemplateTypeFromMappedType
    // TODO:
    // getConstraintDeclarationForMappedType
    // TODO:
    // isMappedTypeWithKeyofConstraintDeclaration
    // TODO:
    // getModifiersTypeFromMappedType
    // TODO:
    // getMappedTypeModifiers
    // TODO:
    // getMappedTypeOptionality
    // TODO:
    // getCombinedMappedTypeOptionality
    // TODO:
    // isPartialMappedType

    fn isGenericMappedType(&mut self, ty: TypeId) -> bool {
        // TODO:
        // return !!(getObjectFlags(ty) & ObjectFlags.Mapped) && isGenericIndexType(getConstraintTypeFromMappedType(ty as MappedType));
        if self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::Mapped)
        {
            todo!();
            // isGenericIndexType(getConstraintTypeFromMappedType(ty as MappedType))
        } else {
            false
        }
    }

    fn resolveStructuredTypeMembers(&mut self, ty: TypeId) -> TypeId {
        let type_flags = self.types[ty].get_flags();
        if !matches!(self.types[ty], Type::ResolvedType(_))
            || self.types[ty].unwrap_object_type_base().members.is_none()
        {
            if type_flags.intersects(TypeFlags::Object) {
                let object_flags = self.types[ty].get_object_flags();
                if object_flags.intersects(ObjectFlags::Reference) {
                    self.resolveTypeReferenceMembers(ty);
                } else if object_flags.intersects(ObjectFlags::ClassOrInterface) {
                    self.resolveClassOrInterfaceMembers(ty);
                } else if object_flags.intersects(ObjectFlags::ReverseMapped) {
                    todo!();
                    // resolveReverseMappedTypeMembers(ty as ReverseMappedType);
                } else if object_flags.intersects(ObjectFlags::Anonymous) {
                    self.resolveAnonymousTypeMembers(ty);
                } else if object_flags.intersects(ObjectFlags::Mapped) {
                    todo!();
                    // resolveMappedTypeMembers(ty as MappedType);
                }
            } else if type_flags.intersects(TypeFlags::Union) {
                self.resolveUnionTypeMembers(ty);
            } else if type_flags.intersects(TypeFlags::Intersection) {
                todo!();
                // resolveIntersectionTypeMembers(ty as IntersectionType);
            }
        }
        ty
    }

    /** Return properties of an object type or an empty array for other types */
    fn getPropertiesOfObjectType(&mut self, ty: TypeId) -> Rc<Vec<SymbolId>> {
        if self.types[ty].get_flags().intersects(TypeFlags::Object) {
            let resolved = self.resolveStructuredTypeMembers(ty);
            return unwrap_as!(&self.types[resolved], Type::ResolvedType(t), t)
                .object_type_base
                .properties
                .clone();
        }
        Default::default()
    }

    /// If the given type is an object type and that type has a property by the given name,
    /// return the symbol for that property. Otherwise return `None`.
    fn getPropertyOfObjectType(&mut self, ty: TypeId, name: &JsWord) -> Option<SymbolId> {
        if self.types[ty].get_flags().intersects(TypeFlags::Object) {
            let resolved = self.resolveStructuredTypeMembers(ty);
            let resolved = unwrap_as!(&self.types[resolved], Type::ResolvedType(t), t);
            let members = resolved.object_type_base.members.unwrap();
            if let Some(sym) = self.symbol_tables[members].get(name).copied() {
                if self.symbolIsValue(sym) {
                    return Some(sym);
                }
            }
        }
        None
    }

    fn getPropertiesOfUnionOrIntersectionType(&mut self, ty: TypeId) -> Rc<Vec<SymbolId>> {
        match &self.types[ty]
            .unwrap_as_union_or_intersection()
            .resolvedProperties
        {
            Some(props) => props.clone(),
            None => {
                let members = SymbolTable::default();
                for &current in self.types[ty]
                    .unwrap_as_union_or_intersection()
                    .types
                    .clone()
                    .iter()
                {
                    for prop in self.getPropertiesOfType(current).clone().iter() {
                        let escapedName = self.symbols[*prop].escapedName();
                        if !members.contains_key(escapedName) {
                            todo!();
                            // let combinedProp = self.getPropertyOfUnionOrIntersectionType(ty, escapedName);
                            // if let Some(combinedProp) = combinedProp {
                            //     members.insert(escapedName, combinedProp);
                            // }
                        }
                    }
                    // The properties of a union type are those that are present in all constituent types, so
                    // we only need to check the properties of the first type without index signature
                    if self.types[ty].get_flags().intersects(TypeFlags::Union)
                        && self.getIndexInfosOfType(current).is_empty()
                    {
                        break;
                    }
                }
                let resolvedProperties = Rc::new(self.getNamedMembersOfSymbolTable(members));
                self.types[ty]
                    .unwrap_as_union_or_intersection_mut()
                    .resolvedProperties = Some(resolvedProperties.clone());
                resolvedProperties
            }
        }
    }

    pub fn getPropertiesOfType(&mut self, mut ty: TypeId) -> Rc<Vec<SymbolId>> {
        ty = self.getReducedApparentType(ty);
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::UnionOrIntersection)
        {
            self.getPropertiesOfUnionOrIntersectionType(ty)
        } else {
            self.getPropertiesOfObjectType(ty)
        }
    }

    // TODO:
    // isTypeInvalidDueToUnionDiscriminant
    // TODO:
    // getAllPossiblePropertiesOfTypes

    pub fn getConstraintOfType(&mut self, ty: TypeId) -> Option<TypeId> {
        // TODO: debug_assert!(type is InstantiableType | UnionOrIntersectionType);
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::TypeParameter)
        {
            self.getConstraintOfTypeParameter(ty)
        } else if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::IndexedAccess)
        {
            todo!();
            // self.getConstraintOfIndexedAccess(ty)
        } else if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Conditional)
        {
            todo!();
            // self.getConstraintOfConditionalType(ty)
        } else {
            self.getBaseConstraintOfType(ty)
        }
    }

    fn getConstraintOfTypeParameter(&mut self, typeParameter: TypeId) -> Option<TypeId> {
        if self.hasNonCircularBaseConstraint(typeParameter) {
            self.getConstraintFromTypeParameter(typeParameter)
        } else {
            None
        }
    }

    // TODO:
    // getConstraintOfIndexedAccess
    // TODO:
    // getSimplifiedTypeOrConstraint
    // TODO:
    // getConstraintFromIndexedAccess
    // TODO:
    // getDefaultConstraintOfConditionalType
    // TODO:
    // getConstraintOfDistributiveConditionalType
    // TODO:
    // getConstraintFromConditionalType
    // TODO:
    // getConstraintOfConditionalType
    // TODO:
    // getEffectiveConstraintOfIntersection

    fn getBaseConstraintOfType(&mut self, ty: TypeId) -> Option<TypeId> {
        let type_flags = self.types[ty].get_flags();
        if type_flags.intersects(
            TypeFlags::InstantiableNonPrimitive
                | TypeFlags::UnionOrIntersection
                | TypeFlags::TemplateLiteral
                | TypeFlags::StringMapping,
        ) {
            let constraint = self.getResolvedBaseConstraint(ty);
            return if constraint != self.noConstraintType
                && constraint != self.circularConstraintType
            {
                Some(constraint)
            } else {
                None
            };
        }
        if type_flags.intersects(TypeFlags::Index) {
            self.keyofConstraintType
        } else {
            None
        }
    }

    /**
     * This is similar to `getBaseConstraintOfType` except it returns the input type if there's no base constraint, instead of `None`
     * It also doesn't map indexes to `string`, as where this is used this would be unneeded (and likely undesirable)
     */
    fn getBaseConstraintOrType(&mut self, ty: TypeId) -> TypeId {
        self.getBaseConstraintOfType(ty).unwrap_or(ty)
    }

    fn hasNonCircularBaseConstraint(&mut self, ty: TypeId) -> bool {
        self.getResolvedBaseConstraint(ty) != self.circularConstraintType
    }

    /**
     * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
     * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
     * circularly references the type variable.
     */
    fn getResolvedBaseConstraint(&mut self, ty: TypeId) -> TypeId {
        if let Some(resolvedBaseConstraint) = self.types[ty].resolvedBaseConstraint() {
            return resolvedBaseConstraint;
        }
        let mut stack = Vec::new();
        let immediate_base_constraint = getImmediateBaseConstraint(self, &mut stack, ty);
        let resolved_base_constraint =
            self.getTypeWithThisArgument(immediate_base_constraint, Some(ty), false);
        *self.types[ty].resolvedBaseConstraintMut() = Some(resolved_base_constraint);
        return resolved_base_constraint;

        fn getImmediateBaseConstraint(
            checker: &mut Checker,
            stack: &mut Vec<TypeId>,
            t: TypeId,
        ) -> TypeId {
            match checker.types[t].get_immediateBaseConstraint() {
                Some(t) => *t,
                None => {
                    if !checker.pushTypeResolution(
                        TypeSystemEntity::Type(t),
                        TypeSystemPropertyName::ImmediateBaseConstraint,
                    ) {
                        return checker.circularConstraintType;
                    }
                    let mut result = None;
                    // We always explore at least 10 levels of nested constraints. Thereafter, we continue to explore
                    // up to 50 levels of nested constraints provided there are no "deeply nested" types on the stack
                    // (i.e. no types for which five instantiations have been recorded on the stack). If we reach 50
                    // levels of nesting, we are presumably exploring a repeating pattern with a long cycle that hasn't
                    // yet triggered the deeply nested limiter. We have no test cases that actually get to 50 levels of
                    // nesting, so it is effectively just a safety stop.
                    if stack.len() < 10
                        || stack.len() < 50 && !checker.isDeeplyNestedType(t, stack, stack.len())
                    {
                        stack.push(t);
                        let t = checker.getSimplifiedType(t, false);
                        result = computeBaseConstraint(checker, stack, t);
                        stack.pop();
                    }
                    if !checker.popTypeResolution() {
                        todo!();
                        // if (t.flags & TypeFlags::TypeParameter) {
                        //     const errorNode = getConstraintDeclaration(t as TypeParameter);
                        //     if (errorNode) {
                        //         const diagnostic = error(errorNode, Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t));
                        //         if (currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode)) {
                        //             addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, Diagnostics.Circularity_originates_in_type_at_this_location));
                        //         }
                        //     }
                        // }
                        // result = circularConstraintType;
                    }
                    let result = result.unwrap_or(checker.noConstraintType);
                    *checker.types[t].get_immediateBaseConstraint_mut() = Some(result);
                    result
                }
            }
        }

        fn getBaseConstraint(
            checker: &mut Checker,
            stack: &mut Vec<TypeId>,
            t: TypeId,
        ) -> Option<TypeId> {
            let c = getImmediateBaseConstraint(checker, stack, t);
            if c != checker.noConstraintType && c != checker.circularConstraintType {
                Some(c)
            } else {
                None
            }
        }

        fn computeBaseConstraint(
            checker: &mut Checker,
            stack: &mut Vec<TypeId>,
            t: TypeId,
        ) -> Option<TypeId> {
            let type_flags = checker.types[t].get_flags();
            if type_flags.intersects(TypeFlags::TypeParameter) {
                let constraint = checker.getConstraintFromTypeParameter(t);
                if unwrap_as!(&checker.types[t], Type::TypeParameter(t), t).isThisType {
                    constraint
                } else if let Some(constraint) = constraint {
                    getBaseConstraint(checker, stack, constraint)
                } else {
                    constraint
                }
            } else if type_flags.intersects(TypeFlags::UnionOrIntersection) {
                let types = checker.types[t]
                    .unwrap_as_union_or_intersection()
                    .types
                    .clone();
                let mut baseTypes = Vec::new();
                let mut different = false;
                for &ty in types.iter() {
                    if let Some(baseType) = getBaseConstraint(checker, stack, ty) {
                        if baseType != ty {
                            different = true;
                        }
                        baseTypes.push(baseType);
                    } else {
                        different = true;
                    }
                }
                if !different {
                    return Some(t);
                }
                if checker.types[t].get_flags().intersects(TypeFlags::Union)
                    && baseTypes.len() == types.len()
                {
                    Some(checker.getUnionType(&baseTypes, None, None, None, None))
                } else if checker.types[t]
                    .get_flags()
                    .intersects(TypeFlags::Intersection)
                    && !baseTypes.is_empty()
                {
                    Some(checker.getIntersectionType(&baseTypes, None, None))
                } else {
                    None
                }
            } else if type_flags.intersects(TypeFlags::Index) {
                checker.keyofConstraintType
            } else if type_flags.intersects(TypeFlags::TemplateLiteral) {
                todo!();
                // const types = (t as TemplateLiteralType).types;
                // const constraints = mapDefined(types, getBaseConstraint);
                // if constraints.length === types.length {getTemplateLiteralType((t as TemplateLiteralType).texts, constraints) }else{stringType};
            } else if type_flags.intersects(TypeFlags::StringMapping) {
                todo!();
                // const constraint = getBaseConstraint((t as StringMappingType).ty);
                // if constraint {getStringMappingType((t as StringMappingType).symbol, constraint)}else{stringType}
            } else if type_flags.intersects(TypeFlags::IndexedAccess) {
                todo!();
                // const baseObjectType = getBaseConstraint((t as IndexedAccessType).objectType);
                // const baseIndexType = getBaseConstraint((t as IndexedAccessType).indexType);
                // const baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, (t as IndexedAccessType).accessFlags);
                // baseIndexedAccess && getBaseConstraint(baseIndexedAccess)
            } else if type_flags.intersects(TypeFlags::Conditional) {
                todo!();
                // const constraint = getConstraintFromConditionalType(t as ConditionalType);
                // constraint && getBaseConstraint(constraint)
            } else if type_flags.intersects(TypeFlags::Substitution) {
                todo!();
                // getBaseConstraint((t as SubstitutionType).substitute)
            } else {
                Some(t)
            }
        }
    }

    // TODO:
    // getApparentTypeOfIntersectionType

    fn getResolvedTypeParameterDefault(&mut self, typeParameter: TypeId) -> Option<TypeId> {
        macro_rules! tp {
            () => {
                unwrap_as!(&self.types[typeParameter], Type::TypeParameter(t), t)
            };
            (mut) => {
                unwrap_as!(&mut self.types[typeParameter], Type::TypeParameter(t), t)
            };
        }
        match tp!().default {
            Some(default) => {
                if default == self.resolvingDefaultType {
                    // If we are called recursively for this type parameter, mark the default as circular.
                    tp!(mut).default = Some(self.circularConstraintType);
                    Some(self.circularConstraintType)
                } else {
                    Some(default)
                }
            }
            None => {
                if let Some(target) = tp!().target {
                    let targetDefault = self.getResolvedTypeParameterDefault(target);
                    tp!(mut).default = Some(if let Some(targetDefault) = targetDefault {
                        self.instantiateType(targetDefault, tp!().mapper.clone())
                    } else {
                        self.noConstraintType
                    });
                } else {
                    // To block recursion, set the initial value to the resolvingDefaultType.
                    tp!(mut).default = Some(self.resolvingDefaultType);
                    let type_param_symbol = self.types[typeParameter].get_symbol().clone();
                    let defaultDeclaration = type_param_symbol.and_then(|s| {
                        self.symbols[s].declarations().iter().find(
                            |decl| matches!(decl, BoundNode::TsTypeParamDecl(p) if p.default.is_some()),
                        )
                    });
                    let defaultType = if let Some(defaultDeclaration) = defaultDeclaration {
                        self.getTypeFromTypeNode(defaultDeclaration.clone())
                    } else {
                        self.noConstraintType
                    };
                    if tp!().default == Some(self.resolvingDefaultType) {
                        // If we have not been called recursively, set the correct default type.
                        tp!(mut).default = Some(defaultType);
                    }
                }
                tp!().default
            }
        }
    }

    /**
     * Gets the default type for a type parameter.
     *
     * If the type parameter is the result of an instantiation, this gets the instantiated
     * default type of its target. If the type parameter has no default type or the default is
     * circular, `undefined` is returned.
     */
    fn getDefaultFromTypeParameter(&mut self, typeParameter: TypeId) -> Option<TypeId> {
        let defaultType = self.getResolvedTypeParameterDefault(typeParameter);
        if defaultType != Some(self.noConstraintType)
            && defaultType != Some(self.circularConstraintType)
        {
            defaultType
        } else {
            None
        }
    }

    // TODO:
    // hasNonCircularTypeParameterDefault

    /**
     * Indicates whether the declaration of a typeParameter has a default type.
     */
    fn hasTypeParameterDefault(&self, typeParameter: TypeId) -> bool {
        if let Some(sym) = self.types[typeParameter].get_symbol() {
            self.symbols[*sym]
                .declarations()
                .iter()
                .any(|d| matches!(&d, BoundNode::TsTypeParamDecl(p) if p.default.is_some()))
        } else {
            false
        }
    }

    // TODO:
    // getApparentTypeOfMappedType
    // TODO:
    // getResolvedApparentTypeOfMappedType

    /**
     * For a type parameter, return the base constraint of the type parameter. For the string, number,
     * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
     * type itself.
     */
    pub fn getApparentType(&mut self, ty: TypeId) -> TypeId {
        let t = if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Instantiable)
        {
            self.getBaseConstraintOfType(ty).unwrap_or(self.unknownType)
        } else {
            ty
        };
        let ty_flags = self.types[t].get_flags();
        if self.types[t]
            .get_object_flags()
            .intersects(ObjectFlags::Mapped)
        {
            todo!();
            // self.getApparentTypeOfMappedType(t as MappedType)
        } else if ty_flags.intersects(TypeFlags::Intersection) {
            todo!();
            // self.getApparentTypeOfIntersectionType(t as IntersectionType)
        } else if ty_flags.intersects(TypeFlags::StringLike) {
            self.globalStringType()
        } else if ty_flags.intersects(TypeFlags::NumberLike) {
            self.globalNumberType()
        } else if ty_flags.intersects(TypeFlags::BigIntLike) {
            todo!();
            // self.getGlobalBigIntType(/*reportErrors*/ languageVersion >= ScriptTarget.ES2020)
        } else if ty_flags.intersects(TypeFlags::BooleanLike) {
            self.globalBooleanType()
        } else if ty_flags.intersects(TypeFlags::ESSymbolLike) {
            todo!();
            // self.getGlobalESSymbolType(/*reportErrors*/ languageVersion >= ScriptTarget.ES2015)
        } else if ty_flags.intersects(TypeFlags::NonPrimitive) {
            self.emptyObjectType
        } else if ty_flags.intersects(TypeFlags::Index) {
            self.keyofConstraintType()
        } else if ty_flags.intersects(TypeFlags::Unknown) && !self.strictNullChecks {
            self.emptyObjectType
        } else {
            t
        }
    }

    fn getReducedApparentType(&mut self, ty: TypeId) -> TypeId {
        // Since getApparentType may return a non-reduced union or intersection type, we need to perform
        // type reduction both before and after obtaining the apparent type. For example, given a type parameter
        // 'T extends A | B', the type 'T & X' becomes 'A & X | B & X' after obtaining the apparent type, and
        // that type may need further reduction to remove empty intersections.
        let reduced = self.getReducedType(ty);
        let apparent = self.getApparentType(reduced);
        self.getReducedType(apparent)
    }

    fn createUnionOrIntersectionProperty(
        &mut self,
        containingType: TypeId,
        name: &JsWord,
        skipObjectFunctionPropertyAugment: bool,
    ) -> Option<SymbolId> {
        let mut singleProp = None;
        let mut propSet = None;
        // TODO: remove type ann
        let mut indexTypes: Vec<TypeId> = Vec::new();
        let isUnion = self.types[containingType]
            .get_flags()
            .intersects(TypeFlags::Union);
        // Flags we want to propagate to the result if they exist in all source symbols
        let mut optionalFlag = if isUnion {
            SymbolFlags::None
        } else {
            SymbolFlags::Optional
        };
        let mut syntheticFlag = CheckFlags::SyntheticMethod;
        let mut checkFlags = if isUnion {
            CheckFlags::empty()
        } else {
            CheckFlags::Readonly
        };
        let mut mergedInstantiations = false;
        for &current in self.types[containingType]
            .unwrap_as_union_or_intersection()
            .types
            .clone()
            .iter()
        {
            let ty = self.getApparentType(current);
            if !(self.isErrorType(ty) || self.types[ty].get_flags().intersects(TypeFlags::Never)) {
                let prop = self.getPropertyOfType(ty, &name, skipObjectFunctionPropertyAugment);
                let modifiers = if let Some(prop) = prop {
                    self.getDeclarationModifierFlagsFromSymbol(prop, false)
                } else {
                    ModifierFlags::empty()
                };
                if let Some(prop) = prop {
                    if isUnion {
                        optionalFlag |= self.symbols[prop].flags() & SymbolFlags::Optional;
                    } else {
                        optionalFlag &= self.symbols[prop].flags();
                    }
                    if singleProp.is_none() {
                        singleProp = Some(prop);
                    } else if prop != singleProp.unwrap() {
                        let singleProp = singleProp.unwrap();
                        let isInstantiation = self.getTargetSymbol(prop).unwrap_or(prop)
                            == self.getTargetSymbol(singleProp).unwrap_or(singleProp);
                        // If the symbols are instances of one another with identical types - consider the symbols
                        // equivalent and just use the first one, which thus allows us to avoid eliding private
                        // members when intersecting a (this-)instantiations of a class with it's raw base or another instance
                        if isInstantiation
                            && self.compareProperties(singleProp, prop, |a, b| {
                                if a == b {
                                    Ternary::True
                                } else {
                                    Ternary::False
                                }
                            }) == Ternary::True
                        {
                            todo!();
                            // If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used
                            // to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed
                            // back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`
                            // mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));
                        } else {
                            if propSet.is_none() {
                                let mut set = AHashSet::with_capacity(2);
                                set.insert(singleProp);
                                propSet = Some(set);
                            }
                            if !propSet.as_ref().unwrap().contains(&prop) {
                                propSet.as_mut().unwrap().insert(prop);
                            }
                        }
                    }
                    if isUnion && self.isReadonlySymbol(prop) {
                        checkFlags |= CheckFlags::Readonly;
                    } else if !isUnion && !self.isReadonlySymbol(prop) {
                        checkFlags &= !CheckFlags::Readonly;
                    }
                    let mut new_check_flags = CheckFlags::empty();
                    new_check_flags.set(
                        CheckFlags::ContainsProtected,
                        modifiers.intersects(ModifierFlags::Protected),
                    );
                    new_check_flags.set(
                        CheckFlags::ContainsPrivate,
                        modifiers.intersects(ModifierFlags::Private),
                    );
                    new_check_flags.set(
                        CheckFlags::ContainsStatic,
                        modifiers.intersects(ModifierFlags::Static),
                    );
                    new_check_flags.set(
                        CheckFlags::ContainsPublic,
                        !modifiers.intersects(ModifierFlags::NonPublicAccessibilityModifier),
                    );
                    checkFlags |= new_check_flags;
                    if !self.isPrototypeProperty(prop) {
                        syntheticFlag = CheckFlags::SyntheticProperty;
                    }
                } else if isUnion {
                    todo!();
                    // const indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(ty, name);
                    // if (indexInfo) {
                    //     checkFlags |= CheckFlags.WritePartial | (indexInfo.isReadonly ? CheckFlags.Readonly : 0);
                    //     indexTypes = append(indexTypes, isTupleType(ty) ? getRestTypeOfTupleType(ty) || undefinedType : indexInfo.ty);
                    // }
                    // else if (isObjectLiteralType(ty) && !(getObjectFlags(ty) & ObjectFlags.ContainsSpread)) {
                    //     checkFlags |= CheckFlags.WritePartial;
                    //     indexTypes = append(indexTypes, undefinedType);
                    // }
                    // else {
                    //     checkFlags |= CheckFlags.ReadPartial;
                    // }
                }
            }
        }
        if singleProp.is_none()
            || isUnion
                && (propSet.is_some() || checkFlags.intersects(CheckFlags::Partial))
                && checkFlags
                    .intersects(CheckFlags::ContainsPrivate | CheckFlags::ContainsProtected)
        {
            // No property was found, or, in a union, a property has a private or protected declaration in one
            // constituent, but is missing or has a different declaration in another constituent.
            return None;
        }
        if propSet.is_none()
            && !checkFlags.intersects(CheckFlags::ReadPartial)
            && indexTypes.is_empty()
        {
            todo!();
            // if (mergedInstantiations) {
            //     // No symbol from a union/intersection should have a `.parent` set (since unions/intersections don't act as symbol parents)
            //     // Unless that parent is "reconstituted" from the "first value declaration" on the symbol (which is likely different than its instantiated parent!)
            //     // They also have a `.containingType` set, which affects some services endpoints behavior, like `getRootSymbol`
            //     const clone = createSymbolWithType(singleProp, (singleProp as TransientSymbol).type);
            //     clone.parent = singleProp.valueDeclaration?.symbol?.parent;
            //     clone.containingType = containingType;
            //     clone.mapper = (singleProp as TransientSymbol).mapper;
            //     return clone;
            // }
            // else {
            //     return singleProp;
            // }
        }
        let prop_counts = if let Some(propSet) = &propSet {
            propSet.len()
        } else {
            // 1 for singleProp
            1
        };
        // let props = if let Some(propSet) = propSet {
        //     propSet.values().collect()
        // } else {
        //     vec![singleProp.unwrap()]
        // };
        let mut declarations = Vec::new();
        let mut firstType = None;
        let mut nameType = None;
        let mut propTypes = Vec::with_capacity(prop_counts);
        let mut firstValueDeclaration = None;
        let mut hasNonUniformValueDeclaration = false;
        let mut handle_prop = |prop| {
            if firstValueDeclaration.is_none() {
                firstValueDeclaration = self.symbols[prop].valueDeclaration().clone();
            } else if self.symbols[prop].valueDeclaration().is_some()
                && self.symbols[prop].valueDeclaration() != &firstValueDeclaration
            {
                hasNonUniformValueDeclaration = true;
            }
            declarations.extend(self.symbols[prop].declarations().iter().cloned());
            let ty = self.getTypeOfSymbol(prop);
            if firstType.is_none() {
                firstType = Some(ty);
                nameType = self.getSymbolLinks(prop).nameType;
            } else if ty != firstType.unwrap() {
                checkFlags |= CheckFlags::HasNonUniformType;
            }
            if self.isLiteralType(ty) || self.isPatternLiteralType(ty) {
                checkFlags |= CheckFlags::HasLiteralType;
            }
            if self.types[ty].get_flags().intersects(TypeFlags::Never) {
                checkFlags |= CheckFlags::HasNeverType;
            }
            propTypes.push(ty);
        };
        let prop_counts = if let Some(propSet) = propSet {
            for prop in propSet {
                handle_prop(prop);
            }
        } else {
            handle_prop(singleProp.unwrap());
        };

        // for prop in props {
        //     if firstValueDeclaration.is_none() {
        //         firstValueDeclaration = self.symbols[prop].valueDeclaration().clone();
        //     } else if self.symbols[prop].valueDeclaration().is_some()
        //         && self.symbols[prop].valueDeclaration() != &firstValueDeclaration
        //     {
        //         hasNonUniformValueDeclaration = true;
        //     }
        //     declarations.extend(self.symbols[prop].declarations().iter().cloned());
        //     let ty = self.getTypeOfSymbol(prop);
        //     if firstType.is_none() {
        //         firstType = Some(ty);
        //         nameType = self.getSymbolLinks(prop).nameType;
        //     } else if ty != firstType.unwrap() {
        //         checkFlags |= CheckFlags::HasNonUniformType;
        //     }
        //     if self.isLiteralType(ty) || self.isPatternLiteralType(ty) {
        //         checkFlags |= CheckFlags::HasLiteralType;
        //     }
        //     if self.types[ty].get_flags().intersects(TypeFlags::Never) {
        //         checkFlags |= CheckFlags::HasNeverType;
        //     }
        //     propTypes.push(ty);
        // }
        propTypes.extend(indexTypes.iter().copied());
        let result_id = self.createSymbol(
            SymbolFlags::Property | optionalFlag,
            name.clone(),
            Some(syntheticFlag | checkFlags),
        );
        let result = self.symbols[result_id].as_transient_symbol_mut();
        result.symbol_links.containingType = Some(containingType);
        if !hasNonUniformValueDeclaration && firstValueDeclaration.is_some() {
            result.valueDeclaration = firstValueDeclaration.clone();

            let firstValueDeclaration_sym = self
                .node_data(firstValueDeclaration.unwrap())
                .symbol
                .unwrap();
            // Inherit information about parent type.
            if self.symbols[firstValueDeclaration_sym].parent().is_some() {
                self.symbols[result_id].as_transient_symbol_mut().parent =
                    self.symbols[firstValueDeclaration_sym].parent();
            }
        }
        let result = self.symbols[result_id].as_transient_symbol_mut();
        result.declarations = declarations;
        result.symbol_links.nameType = nameType;
        if propTypes.len() > 2 {
            // When `propTypes` has the potential to explode in size when normalized, defer normalization until absolutely needed
            result.check_flags |= CheckFlags::DeferredType;
            result.symbol_links.deferralParent = Some(containingType);
            result.symbol_links.deferralConstituents = propTypes;
        } else {
            self.symbols[result_id]
                .as_transient_symbol_mut()
                .symbol_links
                .ty = Some(if isUnion {
                self.getUnionType(&propTypes, None, None, None, None)
            } else {
                self.getIntersectionType(&propTypes, None, None)
            });
        }
        Some(result_id)
    }

    // Return the symbol for a given property in a union or intersection type, or undefined if the property
    // does not exist in any constituent type. Note that the returned property may only be present in some
    // constituents, in which case the isPartial flag is set when the containing type is union type. We need
    // these partial properties when identifying discriminant properties, but otherwise they are filtered out
    // and do not appear to be present in the union type.
    fn getUnionOrIntersectionProperty(
        &mut self,
        ty: TypeId,
        name: &JsWord,
        skipObjectFunctionPropertyAugment: bool,
    ) -> Option<SymbolId> {
        let t = self.types[ty].unwrap_as_union_or_intersection();
        let mut property = if t
            .propertyCacheWithoutObjectFunctionPropertyAugment
            .map(|c| self.symbol_tables[c].contains_key(name))
            .unwrap_or_default()
            || !skipObjectFunctionPropertyAugment
        {
            t.propertyCache
                .and_then(|c| self.symbol_tables[c].get(name).copied())
        } else {
            None
        };
        if property.is_none() {
            property =
                self.createUnionOrIntersectionProperty(ty, name, skipObjectFunctionPropertyAugment);
            if let Some(property) = property {
                let properties = if skipObjectFunctionPropertyAugment {
                    match self.types[ty]
                        .unwrap_as_union_or_intersection()
                        .propertyCacheWithoutObjectFunctionPropertyAugment
                    {
                        Some(cache) => cache,
                        None => {
                            let cache = self.symbol_tables.push(SymbolTable::with_capacity(1));
                            self.types[ty]
                                .unwrap_as_union_or_intersection_mut()
                                .propertyCacheWithoutObjectFunctionPropertyAugment = Some(cache);
                            cache
                        }
                    }
                } else {
                    match self.types[ty]
                        .unwrap_as_union_or_intersection()
                        .propertyCache
                    {
                        Some(cache) => cache,
                        None => {
                            let cache = self.symbol_tables.push(SymbolTable::with_capacity(1));
                            self.types[ty]
                                .unwrap_as_union_or_intersection_mut()
                                .propertyCache = Some(cache);
                            cache
                        }
                    }
                };
                self.symbol_tables[properties].insert(name.clone(), property);
            }
        }
        property
    }

    fn getPropertyOfUnionOrIntersectionType(
        &mut self,
        ty: TypeId,
        name: &JsWord,
        skipObjectFunctionPropertyAugment: bool,
    ) -> Option<SymbolId> {
        let property =
            self.getUnionOrIntersectionProperty(ty, name, skipObjectFunctionPropertyAugment);
        // We need to filter out partial properties in union types
        if property.is_some()
            && !getCheckFlags(&self.symbols[property.unwrap()]).intersects(CheckFlags::ReadPartial)
        {
            property
        } else {
            None
        }
    }

    /**
     * Return the reduced form of the given type. For a union type, it is a union of the normalized constituent types.
     * For an intersection of types containing one or more mututally exclusive discriminant properties, it is 'never'.
     * For all other types, it is simply the type itself. Discriminant properties are considered mutually exclusive when
     * no constituent property has type 'never', but the intersection of the constituent property types is 'never'.
     */
    fn getReducedType(&mut self, ty: TypeId) -> TypeId {
        let type_flags = self.types[ty].get_flags();
        if type_flags.intersects(TypeFlags::Union)
            && self.types[ty]
                .get_object_flags()
                .intersects(ObjectFlags::ContainsIntersections)
        {
            todo!();
            // return (ty as UnionType).resolvedReducedType || ((ty as UnionType).resolvedReducedType = getReducedUnionType(ty as UnionType));
        } else if type_flags.intersects(TypeFlags::Intersection) {
            todo!();
            // if (!((ty as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersectionComputed)) {
            //     (ty as IntersectionType).objectFlags |= ObjectFlags.IsNeverIntersectionComputed |
            //         (some(getPropertiesOfUnionOrIntersectionType(ty as IntersectionType), isNeverReducedProperty) ? ObjectFlags.IsNeverIntersection : 0);
            // }
            // return (ty as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersection ? neverType : ty;
        }
        ty
    }

    // TODO:
    // getReducedUnionType
    // TODO:
    // isNeverReducedProperty
    // TODO:
    // isDiscriminantWithNeverType
    // TODO:
    // isConflictingPrivateProperty
    // TODO:
    // elaborateNeverIntersection

    /**
     * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
     * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
     * Object and Function as appropriate.
     *
     * @param type a type to look up property from
     * @param name a name of property to look up in a given type
     */
    fn getPropertyOfType(
        &mut self,
        ty: TypeId,
        name: &JsWord,
        skipObjectFunctionPropertyAugment: bool,
    ) -> Option<SymbolId> {
        let ty = self.getReducedApparentType(ty);
        let type_flags = self.types[ty].get_flags();
        if type_flags.intersects(TypeFlags::Object) {
            let resolved = self.resolveStructuredTypeMembers(ty);
            let members = self.types[resolved]
                .unwrap_object_type_base()
                .members
                .unwrap();
            if let Some(symbol) = self.symbol_tables[members].get(name).copied() {
                if self.symbolIsValue(symbol) {
                    return Some(symbol);
                }
            }
            if skipObjectFunctionPropertyAugment {
                return None;
            }
            let functionType = if resolved == self.anyFunctionType {
                Some(self.globalFunctionType())
            } else if !unwrap_as!(&self.types[resolved], Type::ResolvedType(t), t)
                .object_type_base
                .callSignatures
                .is_empty()
            {
                Some(self.globalCallableFunctionType())
            } else if !unwrap_as!(&self.types[resolved], Type::ResolvedType(t), t)
                .object_type_base
                .constructSignatures
                .is_empty()
            {
                Some(self.globalNewableFunctionType())
            } else {
                None
            };
            if let Some(functionType) = functionType {
                let symbol = self.getPropertyOfObjectType(functionType, name);
                if symbol.is_some() {
                    return symbol;
                }
            }
            return self.getPropertyOfObjectType(self.globalObjectType(), name);
        }
        if type_flags.intersects(TypeFlags::UnionOrIntersection) {
            return self.getPropertyOfUnionOrIntersectionType(
                ty,
                name,
                skipObjectFunctionPropertyAugment,
            );
        }
        None
    }

    fn getSignaturesOfStructuredType(
        &mut self,
        ty: TypeId,
        kind: SignatureKind,
    ) -> Rc<Vec<SignatureId>> {
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::StructuredType)
        {
            let resolved = self.resolveStructuredTypeMembers(ty);
            let resolved = unwrap_as!(&self.types[resolved], Type::ResolvedType(t), t);
            return if kind == SignatureKind::Call {
                // TODO: bad clones:
                resolved.object_type_base.callSignatures.clone()
            } else {
                // TODO: bad clones;
                resolved.object_type_base.constructSignatures.clone()
            };
        }
        Default::default()
    }

    /**
     * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
     * maps primitive types and type parameters are to their apparent types.
     */
    fn getSignaturesOfType(&mut self, ty: TypeId, kind: SignatureKind) -> Rc<Vec<SignatureId>> {
        let ty = self.getReducedApparentType(ty);
        self.getSignaturesOfStructuredType(ty, kind)
    }

    fn findIndexInfo(&self, indexInfos: &Vec<IndexInfoId>, keyType: TypeId) -> Option<IndexInfoId> {
        indexInfos
            .iter()
            .find(|info| self.index_infos[**info].keyType == keyType)
            .copied()
    }

    fn findApplicableIndexInfo(
        &mut self,
        indexInfos: Rc<Vec<IndexInfoId>>,
        keyType: TypeId,
    ) -> Option<IndexInfoId> {
        // Index signatures for type 'string' are considered only when no other index signatures apply.
        let mut stringIndexInfo = None;
        let mut applicableInfo = None;
        // TODO: this Vec allocation may be unneccessar. Use iters instead
        let mut applicableInfos: Option<Vec<IndexInfoId>> = None;
        for info in indexInfos.iter().copied() {
            if self.index_infos[info].keyType == self.stringType {
                stringIndexInfo = Some(info);
            } else if self.isApplicableIndexType(keyType, self.index_infos[info].keyType) {
                if let Some(applicableInfo) = applicableInfo {
                    match &mut applicableInfos {
                        Some(infos) => infos.push(info),
                        None => applicableInfos = Some(vec![applicableInfo, info]),
                    }
                } else {
                    applicableInfo = Some(info);
                }
            }
        }
        // When more than one index signature is applicable we create a synthetic IndexInfo. Instead of computing
        // the intersected key type, we just use unknownType for the key type as nothing actually depends on the
        // keyType property of the returned IndexInfo.
        if let Some(applicableInfos) = applicableInfos {
            todo!();
        // createIndexInfo(unknownType, getIntersectionType(map(applicableInfos, info => info.type)),
        //     reduceLeft(applicableInfos, (isReadonly, info) => isReadonly && info.isReadonly, /*initial*/ true))
        } else if applicableInfo.is_some() {
            applicableInfo
        } else if stringIndexInfo.is_some() && self.isApplicableIndexType(keyType, self.stringType)
        {
            stringIndexInfo
        } else {
            None
        }
    }

    fn isApplicableIndexType(&mut self, source: TypeId, target: TypeId) -> bool {
        // A 'string' index signature applies to types assignable to 'string' or 'number', and a 'number' index
        // signature applies to types assignable to 'number' and numeric string literal types.
        self.isTypeAssignableTo(source, target)
            || target == self.stringType && self.isTypeAssignableTo(source, self.numberType)
            || target == self.numberType
                && matches!(&self.types[source], Type::StringLiteralType(t) if is_numeric_literal_name(&t.value))
    }

    fn getIndexInfosOfStructuredType(&mut self, ty: TypeId) -> Rc<Vec<IndexInfoId>> {
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::StructuredType)
        {
            let resolved = self.resolveStructuredTypeMembers(ty);
            return unwrap_as!(&self.types[resolved], Type::ResolvedType(t), t)
                .object_type_base
                .indexInfos
                .clone();
        }
        Default::default()
    }

    fn getIndexInfosOfType(&mut self, ty: TypeId) -> Rc<Vec<IndexInfoId>> {
        let ty = self.getReducedApparentType(ty);
        self.getIndexInfosOfStructuredType(ty)
    }

    // Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
    // maps primitive types and type parameters are to their apparent types.
    fn getIndexInfoOfType(&mut self, ty: TypeId, keyType: TypeId) -> Option<IndexInfoId> {
        let indexInfos = self.getIndexInfosOfType(ty);
        self.findIndexInfo(indexInfos.as_ref(), keyType)
    }

    // Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
    // maps primitive types and type parameters are to their apparent types.
    fn getIndexTypeOfType(&mut self, ty: TypeId, keyType: TypeId) -> Option<TypeId> {
        self.getIndexInfoOfType(ty, keyType)
            .map(|id| self.index_infos[id].ty)
    }

    fn getApplicableIndexInfo(&mut self, ty: TypeId, keyType: TypeId) -> Option<IndexInfoId> {
        let index_infos = self.getIndexInfosOfType(ty);
        self.findApplicableIndexInfo(index_infos, keyType)
    }

    fn getApplicableIndexInfoForName(&mut self, ty: TypeId, name: &JsWord) -> Option<IndexInfoId> {
        let keyType = if isLateBoundName(name) {
            todo!();
            // self.esSymbolType
        } else {
            self.getStringLiteralType(unescapeLeadingUnderscores(name))
        };
        self.getApplicableIndexInfo(ty, keyType)
    }

    // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
    // type checking functions).
    fn getTypeParametersFromDeclaration(&mut self, declaration: BoundNode) -> Option<Vec<TypeId>> {
        let mut result = None;
        for node in getBoundEffectiveTypeParameterDeclarations(declaration) {
            let sym = self.node_data(node).symbol;
            result = Some(appendIfUnique(
                result,
                self.getDeclaredTypeOfTypeParameter(sym.unwrap()),
            ));
        }
        result
    }

    // TODO:
    // symbolsToArray
    // TODO:
    // isJSDocOptionalParameter
    // TODO:
    // tryFindAmbientModule
    // TODO:
    // isOptionalParameter
    // TODO:
    // isOptionalPropertyDeclaration
    // TODO:
    // isOptionalJSDocPropertyLikeTag
    // TODO:
    // createTypePredicate

    /**
     * Gets the minimum number of type arguments needed to satisfy all non-optional type
     * parameters.
     */
    fn getMinTypeArgumentCount(&self, typeParameters: Option<Rc<Vec<TypeId>>>) -> usize {
        let mut minTypeArgumentCount = 0;
        if let Some(typeParameters) = typeParameters {
            for (i, param) in typeParameters.iter().enumerate() {
                if !self.hasTypeParameterDefault(*param) {
                    minTypeArgumentCount = i + 1;
                }
            }
        }
        minTypeArgumentCount
    }

    /**
     * Fill in default types for unsupplied type arguments. If `typeArguments` is undefined
     * when a default type is supplied, a new array will be created and returned.
     *
     * @param typeArguments The supplied type arguments.
     * @param typeParameters The requested type parameters.
     * @param minTypeArgumentCount The minimum number of required type arguments.
     */
    fn fillMissingTypeArguments(
        &mut self,
        typeArguments: Option<Rc<Vec<TypeId>>>,
        typeParameters: Option<Rc<Vec<TypeId>>>,
        minTypeArgumentCount: usize,
        isJavaScriptImplicitAny: bool,
    ) -> Option<Rc<Vec<TypeId>>> {
        if let Some(typeParameters) = typeParameters {
            let numTypeParameters = typeParameters.len();
            let numTypeArguments = typeArguments.length();
            if isJavaScriptImplicitAny
                || (numTypeArguments >= minTypeArgumentCount
                    && numTypeArguments <= numTypeParameters)
            {
                let mut result = if let Some(typeArguments) = &typeArguments {
                    typeArguments.clone()
                } else {
                    Rc::new(Vec::new())
                };

                // Note: In the following, TSC iterates over the range numTypeArguments..numTypeParameters, and indexes into `result`.
                // However, this range can sometimes be out of bounds (e.g. if a class' only tpe param is a default and an instantiation supplies 0).
                // TSC doesn't appear to explicitly handle this, but because javascript allows out of bounds assignment, it implicitly works.
                // Our code below has to handle it explicitly using get_mut.

                // Map invalid forward references in default types to the error type
                for i in numTypeArguments..numTypeParameters {
                    let mut r = Rc::make_mut(&mut result);
                    match r.get_mut(i) {
                        Some(v) => *v = self.errorType,
                        None => {
                            r.push(self.errorType);
                        }
                    }
                }
                let baseDefaultType = self.getDefaultTypeArgumentType(isJavaScriptImplicitAny);
                for i in numTypeArguments..numTypeParameters {
                    let mut defaultType = self.getDefaultFromTypeParameter(typeParameters[i]);
                    if (isJavaScriptImplicitAny
                        && defaultType.is_some()
                        && (self.isTypeIdenticalTo(defaultType.unwrap(), self.unknownType)
                            || self.isTypeIdenticalTo(defaultType.unwrap(), self.emptyObjectType)))
                    {
                        defaultType = Some(self.anyType);
                    }

                    let defaultType = if let Some(defaultType) = defaultType {
                        self.instantiateType(
                            defaultType,
                            // TODO: this might be wrong; each default type gets its own copy of the result,
                            // which won't include the remapping in the following iterations.
                            Some(
                                self.createTypeMapper(typeParameters.clone(), Some(result.clone())),
                            ),
                        )
                    } else {
                        baseDefaultType
                    };
                    let mut r = Rc::make_mut(&mut result);
                    match r.get_mut(i) {
                        Some(v) => *v = defaultType,
                        None => {
                            r.push(defaultType);
                        }
                    }
                }
                Rc::make_mut(&mut result).truncate(typeParameters.len());
                return Some(result);
            }
            typeArguments
        } else {
            Some(Rc::new(Vec::new()))
        }
    }
    fn getSignatureFromDeclaration(&mut self, declaration: BoundNode) -> SignatureId {
        if self
            .getNodeLinks(declaration.clone())
            .resolvedSignature
            .is_none()
        {
            let mut parameters = Vec::new();
            let mut flags = SignatureFlags::None;
            let mut minArgumentCount = 0;
            let mut thisParameter = None;
            let mut hasThisParameter = false;
            let iife = getImmediatelyInvokedFunctionExpression(declaration.clone());
            // let isJSConstructSignature = isJSDocConstructSignature(declaration);
            // let isUntypedSignatureInJSFile = !iife
            //     && isBoundNodeInJSFile(&declaration)
            //     && isValueSignatureDeclaration(&declaration)
            //     && !hasJSDocParameterTags(declaration)
            //     && !getJSDocType(declaration);
            // TODO: jsdoc: use above instead of below
            let isJSConstructSignature = false;
            let isUntypedSignatureInJSFile = iife.is_none()
                && isBoundNodeInJSFile(&declaration)
                && isValueSignatureDeclaration(&declaration);
            if isUntypedSignatureInJSFile {
                flags.insert(SignatureFlags::IsUntypedSignatureInJSFile);
            }

            #[derive(Debug)]
            struct Param {
                node: BoundNode,
                is_optional: bool,
                is_binding_pattern: bool,
                ty: Option<Rc<ast::TsTypeAnn>>,
            }

            impl Param {
                fn new(
                    node: BoundNode,
                    is_optional: bool,
                    is_binding_pattern: bool,
                    ty: Option<Rc<ast::TsTypeAnn>>,
                ) -> Self {
                    Self {
                        node,
                        is_optional,
                        is_binding_pattern,
                        ty,
                    }
                }
            }

            macro_rules! handle_ts_fn_params {
                ($params:expr) => {{
                    $params
                        .iter()
                        .map(|p| match &p.pat {
                            ast::TsAmbientParamPat::Ident(n) => Param::new(
                                p.bind(declaration.clone()),
                                n.id.optional,
                                false,
                                n.type_ann.clone(),
                            ),
                            ast::TsAmbientParamPat::Array(n) => Param::new(
                                p.bind(declaration.clone()),
                                n.optional,
                                true,
                                n.type_ann.clone(),
                            ),
                            ast::TsAmbientParamPat::Rest(n) => Param::new(
                                p.bind(declaration.clone()),
                                true,
                                false,
                                n.type_ann.clone(),
                            ),
                            ast::TsAmbientParamPat::Object(n) => Param::new(
                                p.bind(declaration.clone()),
                                n.optional,
                                true,
                                n.type_ann.clone(),
                            ),
                        })
                        .collect()
                }};
            }

            macro_rules! handle_pat {
                ($param:expr, $pat:expr) => {{
                    match &$pat {
                        ast::Pat::Ident(_n) => {
                            Param::new($param, _n.id.optional, false, _n.type_ann.clone())
                        }
                        ast::Pat::Array(_n) => {
                            Param::new($param, _n.optional, true, _n.type_ann.clone())
                        }
                        ast::Pat::Rest(_n) => Param::new($param, true, false, _n.type_ann.clone()),
                        ast::Pat::Object(_n) => {
                            Param::new($param, _n.optional, true, _n.type_ann.clone())
                        }
                        ast::Pat::Assign(_n) => {
                            Param::new($param, true, false, _n.type_ann.clone())
                        }
                        ast::Pat::Invalid(_) => unreachable!(),
                        ast::Pat::Expr(_) => unreachable!(),
                    }
                }};
            }

            macro_rules! handle_param {
                ($param:expr, $param_parent:expr) => {{
                    handle_pat!($param.bind($param_parent), $param.pat)
                }};
            }

            macro_rules! handle_params {
                ($params:expr, $param_parent:expr) => {{
                    $params
                        .iter()
                        .map(|p| handle_param!(p, $param_parent))
                        .collect()
                }};
            }

            let decl_params: Vec<Param> = match &declaration {
                // todo: jsdoc
                // BoundNode::JSDocSignature
                // | BoundNode::JSDocFunctionType(_)
                BoundNode::TsCallSignatureDecl(n) => handle_ts_fn_params!(n.params),
                BoundNode::TsConstructSignatureDecl(n) => handle_ts_fn_params!(n.params),
                BoundNode::TsMethodSignature(n) => handle_ts_fn_params!(n.params),
                BoundNode::TsIndexSignature(n) => handle_ts_fn_params!(n.params),
                BoundNode::TsFnType(n) => handle_ts_fn_params!(n.params),
                BoundNode::TsConstructorType(n) => handle_ts_fn_params!(n.params),
                BoundNode::FnDecl(n) => {
                    handle_params!(n.function.params, n.function.bind(declaration.clone()))
                }
                BoundNode::PrivateMethod(n) => {
                    handle_params!(n.function.params, n.function.bind(declaration.clone()))
                }
                BoundNode::ClassMethod(n) => {
                    handle_params!(n.function.params, n.function.bind(declaration.clone()))
                }
                BoundNode::MethodProp(n) => {
                    handle_params!(n.function.params, n.function.bind(declaration.clone()))
                }
                BoundNode::Constructor(n) => n
                    .params
                    .iter()
                    .map(|p| match p {
                        ast::ParamOrTsParamProp::TsParamProp(n) => match &n.param {
                            ast::TsParamPropParam::Ident(p) => Param::new(
                                n.bind(declaration.clone()),
                                p.id.optional,
                                true,
                                p.type_ann.clone(),
                            ),
                            ast::TsParamPropParam::Assign(p) => Param::new(
                                n.bind(declaration.clone()),
                                true,
                                true,
                                p.type_ann.clone(),
                            ),
                        },
                        ast::ParamOrTsParamProp::Param(param) => {
                            handle_param!(param, declaration.clone())
                        }
                    })
                    .collect(),
                BoundNode::SetterProp(n) => vec![handle_param!(n.param, declaration.clone())],
                BoundNode::FnExpr(n) => {
                    handle_params!(n.function.params, n.function.bind(declaration.clone()))
                }
                BoundNode::ArrowExpr(n) => n
                    .params
                    .iter()
                    .map(|p| handle_param!(p, declaration.clone()))
                    .collect(),
                _ => unreachable!(),
            };

            // If this is a JSDoc construct signature, then skip the first parameter in the
            // parameter list.  The first parameter represents the return type of the construct
            // signature.
            {
                let mut i = if isJSConstructSignature { 1 } else { 0 };
                while i < decl_params.len() {
                    let param = &decl_params[i];

                    let mut paramSymbol = self.node_data(param.node.clone()).symbol.unwrap();
                    let ty = &param.ty;
                    // todo: jsdoc use below, not above
                    // let ty = if isJSDocParameterTag(param) {(param.typeExpression && param.typeExpression.type) }else{ param.type};
                    // Include parameter symbol instead of property symbol in the signature
                    if self.symbols[paramSymbol]
                        .flags()
                        .intersects(SymbolFlags::Property)
                        && !param.is_binding_pattern
                    {
                        let resolvedSymbol = self.resolveName(
                            Some(param.node.clone()),
                            self.symbols[paramSymbol].escapedName().clone(),
                            SymbolFlags::Value,
                            None,
                            false,
                            false,
                        );
                        paramSymbol = resolvedSymbol.unwrap();
                    }
                    if i == 0 && self.symbols[paramSymbol].escapedName() == InternalSymbolName::This
                    {
                        hasThisParameter = true;
                        thisParameter = self.node_data(param.node.clone()).symbol;
                    } else {
                        parameters.push(paramSymbol);
                    }

                    if let Some(ty) = ty {
                        if let ast::TsType::TsLitType(_) = ty.type_ann {
                            flags |= SignatureFlags::HasLiteralTypes;
                        }
                    }

                    // Record a new minimum argument count if this is not an optional parameter
                    // TODO: jsdoc:
                    // let isOptionalParameter = param.1
                    //     || isOptionalJSDocPropertyLikeTag(param)
                    //     || iife.is_some()
                    //         && parameters.len() > iife.unwrap().args.len()
                    //         && ty.is_none()
                    //     || isJSDocOptionalParameter(param);
                    let isOptionalParameter = param.is_optional
                        || iife.is_some()
                            && parameters.len() > iife.as_ref().unwrap().args.len()
                            && ty.is_none();
                    if !isOptionalParameter {
                        minArgumentCount = parameters.len();
                    }
                    i += 1;
                }
            }

            match declaration {
                BoundNode::GetterProp(_) | BoundNode::SetterProp(_) => todo!(),
                BoundNode::PrivateMethod(m)
                    if m.kind == ast::MethodKind::Getter || m.kind == ast::MethodKind::Setter =>
                {
                    todo!()
                }
                BoundNode::ClassMethod(m)
                    if m.kind == ast::MethodKind::Getter || m.kind == ast::MethodKind::Setter =>
                {
                    todo!()
                }
                _ => {}
            }
            // If only one accessor includes a this-type annotation, the other behaves as if it had the same type annotation
            if matches!(
                declaration,
                BoundNode::GetterProp(_) | BoundNode::SetterProp(_)
            ) {
                todo!();
            }
            if matches!(&declaration, BoundNode::ClassMethod(m) if m.kind == ast::MethodKind::Getter || m.kind == ast::MethodKind::Setter)
                || matches!(&declaration, BoundNode::PrivateMethod(m) if m.kind == ast::MethodKind::Getter || m.kind == ast::MethodKind::Setter)
            {
                todo!()
            }
            // if (declaration.kind == SyntaxKind.GetAccessor
            //     || declaration.kind == SyntaxKind.SetAccessor)
            //     && hasBindableName(declaration)
            //     && (!hasThisParameter || !thisParameter)
            // {
            //     let otherKind = if declaration.kind == SyntaxKind.GetAccessor {
            //         SyntaxKind.SetAccessor
            //     } else {
            //         SyntaxKind.GetAccessor
            //     };
            //     let other = getDeclarationOfKind::<AccessorDeclaration>(
            //         getSymbolOfNode(declaration),
            //         otherKind,
            //     );
            //     if other {
            //         thisParameter = self.getAnnotatedAccessorThisParameter(other);
            //     }
            // }

            let classType = if let BoundNode::Constructor(c) = &declaration {
                let parent_class = c.parent.as_ref().unwrap().parent().unwrap();
                debug_assert!(matches!(
                    parent_class,
                    BoundNode::ClassDecl(_) | BoundNode::ClassExpr(_)
                ));
                let sym = self.node_data(parent_class).symbol.unwrap();
                let sym = self.getMergedSymbol(sym);
                Some(self.getDeclaredTypeOfClassOrInterface(sym))
            } else {
                None
            };
            let typeParameters = if let Some(classType) = classType {
                self.types[classType]
                    .unwrap_as_interface_type()
                    .localTypeParameters
                    .clone()
            } else {
                self.getTypeParametersFromDeclaration(declaration.clone())
                    .map(|v| v.into())
            };
            if hasRestParameter(&declaration)
                || isBoundNodeInJSFile(&declaration)
                    && self.maybeAddJsSyntheticRestParameter(declaration.clone(), &parameters)
            {
                flags |= SignatureFlags::HasRestParameter;
            }
            if let BoundNode::TsConstructorType(constructor_type) = &declaration {
                if constructor_type.is_abstract {
                    flags |= SignatureFlags::Abstract;
                }
            } else if let BoundNode::Constructor(constructor_decl) = &declaration {
                let parent_class = match declaration.parent() {
                    Some(BoundNode::Class(c)) => c,
                    _ => unreachable!(),
                };
                if parent_class.is_abstract {
                    flags |= SignatureFlags::Abstract;
                }
            }
            let resolvedSignature = self.createSignature(
                Some(declaration.clone()),
                typeParameters,
                thisParameter,
                parameters.into(),
                /*resolvedReturnType*/ None,
                // /*resolvedTypePredicate*/ None,
                minArgumentCount,
                flags,
            );
            self.getNodeLinks_mut(declaration.clone()).resolvedSignature = Some(resolvedSignature);
        }
        self.getNodeLinks(declaration).resolvedSignature.unwrap()
    }

    /**
     * A JS function gets a synthetic rest parameter if it references `arguments` AND:
     * 1. It has no parameters but at least one `@param` with a type that starts with `...`
     * OR
     * 2. It has at least one parameter, and the last parameter has a matching `@param` with a type that starts with `...`
     */
    fn maybeAddJsSyntheticRestParameter(
        &mut self,
        declaration: BoundNode,
        parameters: &[SymbolId],
    ) -> bool {
        todo!();
        // if (isJSDocSignature(declaration) || !containsArgumentsReference(declaration)) {
        //     return false;
        // }
        // const lastParam = lastOrUndefined(declaration.parameters);
        // const lastParamTags = lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag);
        // const lastParamVariadicType = firstDefined(lastParamTags, p =>
        //     p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined);

        // const syntheticArgsSymbol = createSymbol(SymbolFlags::Variable, "args" as __String, CheckFlags.RestParameter);
        // syntheticArgsSymbol.type = lastParamVariadicType ? createArrayType(getTypeFromTypeNode(lastParamVariadicType.type)) : anyArrayType;
        // if (lastParamVariadicType) {
        //     // Replace the last parameter with a rest parameter.
        //     parameters.pop();
        // }
        // parameters.push(syntheticArgsSymbol);
        // return true;
    }

    fn getSignatureOfTypeTag(&mut self, node: &BoundNode) -> Option<SignatureId> {
        // should be attached to a function declaration or expression
        if !(isBoundNodeInJSFile(node) && isFunctionLikeDeclaration(node)) {
            return None;
        };
        todo!();
        // const typeTag = getJSDocTypeTag(node);
        // return typeTag?.typeExpression && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
    }

    fn getReturnTypeOfTypeTag(&mut self, node: &BoundNode) -> Option<TypeId> {
        self.getSignatureOfTypeTag(node)
            .map(|sig| self.getReturnTypeOfSignature(sig))
    }

    // TODO:
    // containsArgumentsReference

    fn getSignaturesOfSymbol(&mut self, symbol: Option<SymbolId>) -> Vec<SignatureId> {
        let mut result = Vec::new();
        if let Some(symbol) = symbol {
            // TODO: bad clone:
            let decls = self.symbols[symbol].declarations().clone();
            for (i, decl) in decls.iter().enumerate() {
                let has_body = match decl {
                    // TODO: jsdoc:
                    // | BoundNode::JSDocSignature(_)
                    // | BoundNode::JSDocFunctionType(_)
                    BoundNode::TsMethodSignature(_)
                    | BoundNode::TsCallSignatureDecl(_)
                    | BoundNode::TsConstructSignatureDecl(_)
                    | BoundNode::TsIndexSignature(_)
                    | BoundNode::TsFnType(_)
                    | BoundNode::TsConstructorType(_) => false,
                    BoundNode::FnDecl(n) => n.function.body.is_some(),
                    BoundNode::Constructor(n) => n.body.is_some(),
                    BoundNode::ClassMethod(n) => n.function.body.is_some(),
                    BoundNode::PrivateMethod(n) => n.function.body.is_some(),
                    BoundNode::FnExpr(n) => n.function.body.is_some(),
                    BoundNode::ArrowExpr(n) => true,
                    _ => continue,
                };
                // Don't include signature if node is the implementation of an overloaded function. A node is considered
                // an implementation node if it has a body and the previous node is of the same kind and immediately
                // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
                if i > 0 && has_body {
                    let previous = &decls[i - 1];
                    // TODO:
                    // if decl.parent() == previous.parent() && std::mem::discriminant(decl) == std::mem::discriminant(previous) && decl.pos == previous.end {
                    //     continue;
                    // }
                    if decl.parent() == previous.parent()
                        && std::mem::discriminant(decl) == std::mem::discriminant(previous)
                    {
                        todo!();
                    }
                }
                result.push(self.getSignatureFromDeclaration(decl.clone()));
            }
        }
        result
    }

    // TODO:
    // resolveExternalModuleTypeByLiteral

    fn getThisTypeOfSignature(&mut self, signature: SignatureId) -> Option<TypeId> {
        self.signatures[signature]
            .thisParameter
            .map(|this_param| self.getTypeOfSymbol(this_param))
    }

    fn getTypePredicateOfSignature(&mut self, signature: SignatureId) -> Option<TypePredicate> {
        let resolvedTypePredicate = match &self.signatures[signature].resolvedTypePredicate {
            Some(p) => p.clone(),
            None => {
                let resolvedTypePredicate = if let Some(target) = self.signatures[signature].target
                {
                    let targetTypePredicate = self.getTypePredicateOfSignature(target);
                    if let Some(targetTypePredicate) = targetTypePredicate {
                        self.instantiateTypePredicate(
                            targetTypePredicate,
                            self.signatures[signature].mapper.clone(),
                        )
                    } else {
                        self.noTypePredicate.clone()
                    }
                } else if !self.signatures[signature].compositeSignatures.is_empty() {
                    self.getUnionOrIntersectionTypePredicate(
                        &self.signatures[signature].compositeSignatures.clone(),
                        self.signatures[signature].compositeKind,
                    )
                    .unwrap_or(self.noTypePredicate.clone())
                } else {
                    let decl = &self.signatures[signature].declaration;
                    let ty = decl
                        .as_ref()
                        .and_then(|d| getBoundEffectiveReturnTypeNode(d));
                    let jsdocPredicate = None;
                    if ty.is_none() && isInJSFile(decl.as_ref()) {
                        todo!();
                        // let jsdocSignature = getSignatureOfTypeTag(signature.declaration!);
                        // if (jsdocSignature && signature != jsdocSignature) {
                        //     jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
                        // }
                    }
                    let typePredicate = if let Some(BoundNode::TsTypePredicate(t)) = ty {
                        self.createTypePredicateFromTypePredicateNode(t, signature)
                    } else {
                        jsdocPredicate.unwrap_or(self.noTypePredicate.clone())
                    };
                    self.signatures[signature].resolvedTypePredicate = Some(typePredicate.clone());
                    typePredicate
                };
                self.signatures[signature].resolvedTypePredicate =
                    Some(resolvedTypePredicate.clone());
                resolvedTypePredicate
            }
        };
        if resolvedTypePredicate == self.noTypePredicate {
            None
        } else {
            Some(resolvedTypePredicate)
        }
    }

    fn createTypePredicateFromTypePredicateNode(
        &mut self,
        node: Rc<TsTypePredicate>,
        signature: SignatureId,
    ) -> TypePredicate {
        let ty = node
            .type_ann
            .as_ref()
            .map(|t| self.getTypeFromTypeNode(t.bind(node.clone().into())));
        match &node.param_name {
            ast::TsThisTypeOrIdent::TsThisType(_) => {
                if node.asserts {
                    TypePredicate::AssertsThisTypePredicate { ty }
                } else {
                    // TODO: im not sure these unwraps are safe/correct
                    TypePredicate::ThisTypePredicate { ty: ty.unwrap() }
                }
            }
            ast::TsThisTypeOrIdent::Ident(param_name) => {
                let parameterIndex = self.signatures[signature]
                    .parameters
                    .iter()
                    .position(|p| self.symbols[*p].escapedName() == &param_name.sym)
                    .unwrap();
                if node.asserts {
                    TypePredicate::AssertsIdentifierTypePredicate {
                        parameterName: param_name.sym.clone(),
                        parameterIndex,
                        ty,
                    }
                } else {
                    TypePredicate::IdentifierTypePredicate {
                        parameterName: param_name.sym.clone(),
                        parameterIndex,
                        // TODO: im not sure these unwraps are safe/correct
                        ty: ty.unwrap(),
                    }
                }
            }
        }
    }

    fn getUnionOrIntersectionType(
        &mut self,
        types: &[TypeId],
        kind: Option<TypeFlags>,
        unionReduction: Option<UnionReduction>,
    ) -> TypeId {
        if kind != Some(TypeFlags::Intersection) {
            self.getUnionType(types, unionReduction, None, None, None)
        } else {
            self.getIntersectionType(types, None, None)
        }
    }

    fn getReturnTypeOfSignature(&mut self, signature: SignatureId) -> TypeId {
        match self.signatures[signature].resolvedReturnType {
            Some(t) => t,
            None => {
                if !self.pushTypeResolution(
                    TypeSystemEntity::Signature(signature),
                    TypeSystemPropertyName::ResolvedReturnType,
                ) {
                    return self.errorType;
                }
                let mut ty = if let Some(target) = self.signatures[signature].target {
                    let ty = self.getReturnTypeOfSignature(target);
                    self.instantiateType(ty, self.signatures[signature].mapper.clone())
                } else if !self.signatures[signature].compositeSignatures.is_empty() {
                    let types = self.signatures[signature]
                        .compositeSignatures
                        .clone()
                        .iter()
                        .map(|&s| self.getReturnTypeOfSignature(s))
                        .collect::<Vec<_>>();
                    let ty = self.getUnionOrIntersectionType(
                        &types,
                        self.signatures[signature].compositeKind,
                        Some(UnionReduction::Subtype),
                    );
                    self.instantiateType(ty, self.signatures[signature].mapper.clone())
                } else {
                    fn signature_declaration_has_body(decl: &Option<BoundNode>) -> bool {
                        if let Some(decl) = decl {
                            match decl {
                                // TODO: jsdoc:
                                // JSDocFunctionType
                                // JSDocSignature
                                BoundNode::FnDecl(n) => n.function.body.is_some(),
                                BoundNode::PrivateMethod(n) => n.function.body.is_some(),
                                BoundNode::ClassMethod(n) => n.function.body.is_some(),
                                BoundNode::MethodProp(n) => n.function.body.is_some(),
                                BoundNode::Constructor(n) => n.body.is_some(),
                                BoundNode::GetterProp(n) => n.body.is_some(),
                                BoundNode::SetterProp(n) => n.body.is_some(),
                                BoundNode::FnExpr(n) => n.function.body.is_some(),
                                BoundNode::ArrowExpr(n) => true,
                                _ => false,
                            }
                        } else {
                            false
                        }
                    }
                    self.getReturnTypeFromAnnotation(
                        &self.signatures[signature].declaration.clone().unwrap(),
                    )
                    .unwrap_or_else(|| {
                        if signature_declaration_has_body(&self.signatures[signature].declaration) {
                            self.getReturnTypeFromBody(
                                &self.signatures[signature].declaration.clone().unwrap(),
                                None,
                            )
                        } else {
                            self.anyType
                        }
                    })
                };
                if self.signatures[signature]
                    .flags
                    .intersects(SignatureFlags::IsInnerCallChain)
                {
                    todo!();
                    // ty = self.addOptionalTypeMarker(ty);
                } else if self.signatures[signature]
                    .flags
                    .intersects(SignatureFlags::IsOuterCallChain)
                {
                    todo!();
                    // ty = self.getOptionalType(ty);
                }
                if !self.popTypeResolution() {
                    todo!();
                    // if let Some(decl) = self.signatures[signature].declaration {
                    //     let typeNode = self.getEffectiveReturnTypeNode(decl);
                    //     if typeNode {
                    //         todo!();
                    //         // error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself);
                    //     } else if self.noImplicitAny {
                    //         todo!();
                    //         // const declaration = decl as Declaration;
                    //         // const name = getNameOfDeclaration(declaration);
                    //         // if (name) {
                    //         //     error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name));
                    //         // }
                    //         // else {
                    //         //     error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                    //         // }
                    //     }
                    // }
                    // ty = self.anyType;
                }
                self.signatures[signature].resolvedReturnType = Some(ty);
                ty
            }
        }
    }

    fn getReturnTypeFromAnnotation(&mut self, declaration: &BoundNode) -> Option<TypeId> {
        if matches!(declaration, BoundNode::Constructor(_)) {
            let parent_class = declaration.parent().unwrap().parent().unwrap();
            debug_assert!(matches!(
                parent_class,
                BoundNode::ClassDecl(_) | BoundNode::ClassExpr(_)
            ));
            let sym = self.node_data(parent_class).symbol.unwrap();
            let sym = self.getMergedSymbol(sym);
            return Some(self.getDeclaredTypeOfClassOrInterface(sym));
        }
        // TODO: jsdoc:
        // if isJSDocConstructSignature(declaration) {
        //     return self.getTypeFromTypeNode((declaration.parameters[0] as ParameterDeclaration).ty.unwrap()); // TODO: GH#18217
        // }
        if let Some(typeNode) = getBoundEffectiveReturnTypeNode(declaration) {
            return Some(self.getTypeFromTypeNode(typeNode));
        }
        if (matches!(declaration, BoundNode::ClassMethod(m) if m.kind == ast::MethodKind::Getter)
            || matches!(declaration, BoundNode::PrivateMethod(m) if m.kind ==ast::MethodKind::Getter)
            || matches!(
                declaration,
                BoundNode::GetterProp(_) | BoundNode::TsGetterSignature(_)
            ))
            && self.hasBindableName(declaration)
        {
            // let jsDocType = isInJSFile(declaration) && self.getTypeForDeclarationFromJSDocComment(declaration);
            // if (jsDocType) {
            //     return jsDocType;
            // }
            // let setter = getDeclarationOfKind<AccessorDeclaration>(self.getSymbolOfNode(declaration), SyntaxKind.SetAccessor);
            // let setterType = self.getAnnotatedAccessorType(setter);
            // if (setterType) {
            //     return setterType;
            // }
        }
        self.getReturnTypeOfTypeTag(declaration)
    }

    fn isResolvingReturnTypeOfSignature(&mut self, signature: SignatureId) -> bool {
        self.signatures[signature].resolvedReturnType.is_none()
            && self
                .findResolutionCycleStartIndex(
                    TypeSystemEntity::Signature(signature),
                    TypeSystemPropertyName::ResolvedReturnType,
                )
                .is_some()
    }

    // TODO:
    // getRestTypeOfSignature
    // TODO:
    // tryGetRestTypeOfSignature

    fn getSignatureInstantiation(
        &mut self,
        signature: SignatureId,
        typeArguments: Option<Rc<Vec<TypeId>>>,
        isJavascript: bool,
        inferredTypeParameters: Option<Rc<Vec<TypeId>>>,
    ) -> SignatureId {
        let typeArguments = self.fillMissingTypeArguments(
            typeArguments,
            self.signatures[signature].typeParameters.clone(),
            self.getMinTypeArgumentCount(self.signatures[signature].typeParameters.clone()),
            isJavascript,
        );
        let instantiatedSignature =
            self.getSignatureInstantiationWithoutFillingInTypeArguments(signature, typeArguments);
        if inferredTypeParameters.is_some() {
            let ty = self.getReturnTypeOfSignature(instantiatedSignature);
            let returnSignature = self.getSingleCallOrConstructSignature(ty);
            if let Some(returnSignature) = returnSignature {
                let newReturnSignature = self.cloneSignature(returnSignature);
                self.signatures[newReturnSignature].typeParameters = inferredTypeParameters;
                let newInstantiatedSignature = self.cloneSignature(instantiatedSignature);
                self.signatures[newInstantiatedSignature].resolvedReturnType =
                    Some(self.getOrCreateTypeFromSignature(newReturnSignature));
                return newInstantiatedSignature;
            }
        }
        instantiatedSignature
    }

    fn getSignatureInstantiationWithoutFillingInTypeArguments(
        &mut self,
        signature: SignatureId,
        typeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> SignatureId {
        let id = self.getTypeListId(typeArguments.as_ref().map(|rc| rc.as_ref()));
        match self.signatures[signature].instantiations.get(&id) {
            Some(instantiation) => *instantiation,
            None => {
                let instantiation = self.createSignatureInstantiation(signature, typeArguments);
                self.signatures[signature]
                    .instantiations
                    .insert(id, instantiation);
                instantiation
            }
        }
    }

    fn createSignatureInstantiation(
        &mut self,
        signature: SignatureId,
        typeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> SignatureId {
        let mapper = self.createSignatureTypeMapper(signature, typeArguments);
        self.instantiateSignature(signature, mapper, true)
    }

    fn createSignatureTypeMapper(
        &mut self,
        signature: SignatureId,
        typeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> Rc<TypeMapper> {
        let typeParameters = self.signatures[signature].typeParameters.clone().unwrap();
        self.createTypeMapper(typeParameters, typeArguments)
    }

    fn getErasedSignature(&mut self, signature: SignatureId) -> SignatureId {
        if self.signatures[signature].typeParameters.is_some() {
            match self.signatures[signature].erasedSignatureCache {
                Some(sig) => sig,
                None => {
                    let erased_sig = self.createErasedSignature(signature);
                    self.signatures[signature].erasedSignatureCache = Some(erased_sig);
                    erased_sig
                }
            }
        } else {
            signature
        }
    }

    fn createErasedSignature(&mut self, signature: SignatureId) -> SignatureId {
        // Create an instantiation of the signature where all type arguments are the any type.
        self.instantiateSignature(
            signature,
            self.createTypeEraser(self.signatures[signature].typeParameters.clone().unwrap()),
            true,
        )
    }

    // TODO:
    // getCanonicalSignature
    // TODO:
    // createCanonicalSignature

    fn getBaseSignature(&mut self, signature: SignatureId) -> SignatureId {
        if let Some(typeParameters) = self.signatures[signature].typeParameters.clone() {
            if let Some(baseSignatureCache) = self.signatures[signature].baseSignatureCache {
                return baseSignatureCache;
            }
            let typeEraser = self.createTypeEraser(typeParameters.clone());
            let targets = Some(Rc::new(
                typeParameters
                    .clone()
                    .iter()
                    .map(|tp| {
                        self.getConstraintOfTypeParameter(*tp)
                            .unwrap_or(self.unknownType)
                    })
                    .collect(),
            ));
            let baseConstraintMapper = self.createTypeMapper(typeParameters.clone(), targets);
            let mut baseConstraints = Rc::new(
                typeParameters
                    .clone()
                    .iter()
                    .map(|tp| self.instantiateType(*tp, Some(baseConstraintMapper.clone())))
                    .collect(),
            );
            // Run N type params thru the immediate constraint mapper up to N times
            // This way any noncircular interdependent type parameters are definitely resolved to their external dependencies
            for _ in 0..typeParameters.len() - 1 {
                baseConstraints =
                    self.instantiateTypes(baseConstraints, baseConstraintMapper.clone());
            }
            // and then apply a type eraser to remove any remaining circularly dependent type parameters
            baseConstraints = self.instantiateTypes(baseConstraints, typeEraser);
            let base_sig = self.instantiateSignature(
                signature,
                self.createTypeMapper(typeParameters, Some(baseConstraints)),
                true,
            );
            self.signatures[signature].baseSignatureCache = Some(base_sig);
            return base_sig;
        }
        signature
    }

    fn getOrCreateTypeFromSignature(&mut self, signature: SignatureId) -> TypeId {
        // There are two ways to declare a construct signature, one is by declaring a class constructor
        // using the constructor keyword, and the other is declaring a bare construct signature in an
        // object type literal or interface (using the new keyword). Each way of declaring a constructor
        // will result in a different declaration kind.
        match self.signatures[signature].isolatedSignatureType {
            Some(ty) => ty,
            None => {
                let mut ty = AnonymousType {
                    anonymous_type: Default::default(),
                    object_type_base: ObjectTypeBase::new(ObjectFlags::Anonymous),
                    type_base: TypeBase::new(TypeFlags::Object, None),
                };
                let isConstructor = matches!(
                    self.signatures[signature].declaration,
                    Some(
                        BoundNode::Constructor(_)
                            | BoundNode::TsConstructSignatureDecl(_)
                            | BoundNode::TsConstructorType(_)
                    )
                );
                if isConstructor {
                    ty.object_type_base.constructSignatures = Rc::new(vec![signature]);
                } else {
                    ty.object_type_base.callSignatures = Rc::new(vec![signature]);
                }
                let ty = self.types.push(Type::AnonymousType(ty));
                self.signatures[signature].isolatedSignatureType = Some(ty);
                ty
            }
        }
    }

    fn getIndexSymbol(&mut self, symbol: SymbolId) -> Option<SymbolId> {
        self.symbols[symbol]
            .members()
            .and_then(|members| self.getIndexSymbolFromSymbolTable(members))
    }

    fn getIndexSymbolFromSymbolTable(&self, symbolTable: SymbolTableId) -> Option<SymbolId> {
        self.symbol_tables[symbolTable]
            .get(&JsWord::from(InternalSymbolName::Index))
            .copied()
    }

    fn createIndexInfo(
        &mut self,
        keyType: TypeId,
        ty: TypeId,
        isReadonly: bool,
        declaration: Option<Rc<TsIndexSignature>>,
    ) -> IndexInfoId {
        self.index_infos.push(IndexInfo {
            keyType,
            ty,
            isReadonly,
            declaration,
        })
    }

    fn getIndexInfosOfSymbol(&mut self, symbol: SymbolId) -> Vec<IndexInfoId> {
        let indexSymbol = self.getIndexSymbol(symbol);
        indexSymbol
            .map(|s| self.getIndexInfosOfIndexSymbol(s))
            .unwrap_or_default()
    }

    fn getIndexInfosOfIndexSymbol(&mut self, indexSymbol: SymbolId) -> Vec<IndexInfoId> {
        let mut indexInfos = Vec::new();
        // TODO: bad clone:
        for declaration in self.symbols[indexSymbol].declarations().clone() {
            let decl = unwrap_as!(&declaration, BoundNode::TsIndexSignature(d), d);
            if decl.params.len() == 1 {
                let parameter = &decl.params[0];
                let param_ty_ann = match &parameter.pat {
                    ast::TsAmbientParamPat::Ident(n) => &n.type_ann,
                    ast::TsAmbientParamPat::Array(n) => &n.type_ann,
                    ast::TsAmbientParamPat::Rest(n) => &n.type_ann,
                    ast::TsAmbientParamPat::Object(n) => &n.type_ann,
                };
                if let Some(param_ty_ann) = param_ty_ann {
                    let ty = self.getTypeFromTypeNode(
                        param_ty_ann.bind(parameter.pat.bind(parameter.bind(declaration.clone()))),
                    );
                    self.forEachType(ty, |checker, keyType| {
                        if checker.isValidIndexKeyType(keyType)
                            && checker.findIndexInfo(&indexInfos, keyType).is_none()
                        {
                            let ty = if let Some(ty) = &decl.type_ann {
                                checker.getTypeFromTypeNode(ty.bind(declaration.clone()))
                            } else {
                                checker.anyType
                            };
                            indexInfos.push(checker.createIndexInfo(
                                keyType,
                                ty,
                                decl.readonly,
                                Some(decl.clone()),
                            ));
                        }
                    });
                }
            }
        }
        indexInfos
    }

    fn isValidIndexKeyType(&mut self, ty: TypeId) -> bool {
        self.types[ty]
            .get_flags()
            .intersects(TypeFlags::String | TypeFlags::Number | TypeFlags::ESSymbol)
            || self.isPatternLiteralType(ty)
            || self.types[ty]
                .get_flags()
                .intersects(TypeFlags::Intersection)
                && !self.isGenericType(ty)
                && self.types[ty]
                    .unwrap_as_union_or_intersection()
                    .types
                    .clone()
                    .iter()
                    .any(|t| self.isValidIndexKeyType(*t))
    }

    fn getConstraintDeclaration(&mut self, ty: TypeId) -> Option<BoundNode> {
        if let Some(sym) = self.types[ty].get_symbol() {
            self.symbols[*sym]
                .declarations()
                .iter()
                .find_map(|d| match d {
                    BoundNode::TsTypeParamDecl(p) => getBoundEffectiveConstraintOfTypeParameter(&p),
                    _ => None,
                })
        } else {
            None
        }
        // mapDefined(filter(ty.symbol && ty.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0]
    }

    fn getInferredTypeParameterConstraint(&mut self, typeParameter: TypeId) -> Option<TypeId> {
        // TODO: remove type ann
        let mut inferences: Vec<TypeId> = Vec::new();
        if let Some(sym) = self.types[typeParameter].get_symbol() {
            for declaration in self.symbols[*sym].declarations() {
                if let Some(parent @ BoundNode::TsInferType(p)) = &declaration.parent() {
                    // When an 'infer T' declaration is immediately contained in a type reference node
                    // (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the
                    // corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are
                    // present, we form an intersection of the inferred constraint types.
                    let (childTypeParameter, grandParent) =
                        walkUpParenthesizedTypesAndGetParentAndChild(
                            declaration.parent().and_then(|p| p.parent()),
                        );
                    let childTypeParameter = childTypeParameter
                        .map(BoundNode::TsParenthesizedType)
                        .unwrap_or_else(|| declaration.parent().unwrap());
                    if let BoundNode::TsTypeRef(typeReference) = grandParent {
                        todo!();
                        // let typeParameters = self.getTypeParametersForTypeReference(typeReference);
                        // if (typeParameters) {
                        //     let index = typeReference
                        //         .typeArguments
                        //         .unwrap()
                        //         .indexOf(childTypeParameter as TypeNode);
                        //     if (index < typeParameters.length) {
                        //         let declaredConstraint =
                        //             self.getConstraintOfTypeParameter(typeParameters[index]);
                        //         if (declaredConstraint) {
                        //             // Type parameter constraints can reference other type parameters so
                        //             // constraints need to be instantiated. If instantiation produces the
                        //             // type parameter itself, we discard that inference. For example, in
                        //             //   type Foo<T extends string, U extends T> = [T, U];
                        //             //   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;
                        //             // the instantiated constraint for U is X, so we discard that inference.
                        //             let mapper = self.createTypeMapper(
                        //                 typeParameters,
                        //                 self.getEffectiveTypeArguments(
                        //                     typeReference,
                        //                     typeParameters,
                        //                 ),
                        //             );
                        //             let constraint =
                        //                 self.instantiateType(declaredConstraint, mapper);
                        //             if (constraint != typeParameter) {
                        //                 inferences.push(constraint);
                        //             }
                        //         }
                        //     }
                        // }
                    }
                    // When an 'infer T' declaration is immediately contained in a rest parameter declaration, a rest type
                    // or a named rest tuple element, we infer an 'unknown[]' constraint.
                    else if {
                        // The following is a VERY conservative error.
                        let parent = declaration.parent().unwrap();
                        let grandParent = parent.parent();
                        matches!(
                            parent,
                            BoundNode::Param(_)
                                | BoundNode::ParamWithoutDecorators(_)
                                | BoundNode::TsAmbientParam(_)
                                | BoundNode::TsParamProp(_)
                                | BoundNode::TsRestType(_)
                                | BoundNode::TsTupleElement(_)
                                | BoundNode::TsTupleType(_)
                                | BoundNode::RestPat(_)
                                | BoundNode::SpreadAssignment(_)
                                | BoundNode::SpreadElement(_)
                        ) || matches!(
                            grandParent,
                            Some(
                                BoundNode::Param(_)
                                    | BoundNode::ParamWithoutDecorators(_)
                                    | BoundNode::TsAmbientParam(_)
                                    | BoundNode::TsParamProp(_)
                                    | BoundNode::TsRestType(_)
                                    | BoundNode::TsTupleElement(_)
                                    | BoundNode::TsTupleType(_)
                                    | BoundNode::RestPat(_)
                                    | BoundNode::SpreadAssignment(_)
                                    | BoundNode::SpreadElement(_)
                            )
                        )
                    } {
                        todo!("see below");
                    }
                    // else if grandParent.kind == SyntaxKind.Parameter
                    //     && (grandParent as ParameterDeclaration).dotDotDotToken
                    //     || grandParent.kind == SyntaxKind.RestType
                    //     || grandParent.kind == SyntaxKind.NamedTupleMember
                    //         && (grandParent as NamedTupleMember).dotDotDotToken
                    // {
                    //     todo!();
                    //     // inferences.push(createArrayType(self.unknownType));
                    // }
                    // When an 'infer T' declaration is immediately contained in a string template type, we infer a 'string'
                    // constraint.
                    else if matches!(declaration.parent(), Some(BoundNode::TsTplLitType(_)))
                        || matches!(
                            declaration.parent().and_then(|p| p.parent()),
                            Some(BoundNode::TsTplLitType(_))
                        )
                    {
                        todo!("see below");
                    }
                    // else if (grandParent.kind == SyntaxKind.TemplateLiteralTypeSpan) {
                    //     inferences.push(self.stringType);
                    // }
                    // When an 'infer T' declaration is in the constraint position of a mapped type, we infer a 'keyof any'
                    // constraint.
                    else if matches!(grandParent, BoundNode::TsTypeParamDecl(_) if matches!(grandParent.parent(), Some(BoundNode::TsMappedType(_))))
                    {
                        inferences.push(self.keyofConstraintType());
                    }
                    // When an 'infer T' declaration is the template of a mapped type, and that mapped type is the extends
                    // clause of a conditional whose check type is also a mapped type, give it a constraint equal to the template
                    // of the check type's mapped type
                    else if let BoundNode::TsMappedType(t) = grandParent {
                        todo!();
                        // if  (grandParent as MappedTypeNode).ty
                        // && skipParentheses((grandParent as MappedTypeNode).ty.unwrap())
                        //     == declaration.parent
                        // && grandParent.parent.kind == SyntaxKind.ConditionalType
                        // && (grandParent.parent as ConditionalTypeNode).extendsType == grandParent
                        // && (grandParent.parent as ConditionalTypeNode).checkType.kind
                        //     == SyntaxKind.MappedType
                        // && ((grandParent.parent as ConditionalTypeNode).checkType
                        //     as MappedTypeNode)
                        //     .ty {
                        //         todo!();
                        //         // const checkMappedType = (grandParent.parent as ConditionalTypeNode).checkType as MappedTypeNode;
                        //         // const nodeType = getTypeFromTypeNode(checkMappedType.type!);
                        //         // inferences = append(inferences, instantiateType(nodeType,
                        //         //     makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfNode(checkMappedType.typeParameter)), checkMappedType.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType.typeParameter.constraint) : keyofConstraintType)
                        //         // ));
                        //     }
                    }
                }
            }
        }
        if inferences.is_empty() {
            None
        } else {
            todo!();
            // Some(self.getIntersectionType(inferences))
        }
    }

    /** This is a worker function. Use getConstraintOfTypeParameter which guards against circular constraints. */
    fn getConstraintFromTypeParameter(&mut self, type_param: TypeId) -> Option<TypeId> {
        let constraint =
            match unwrap_as!(&self.types[type_param], Type::TypeParameter(p), p).constraint {
                Some(constraint) => constraint,
                None => {
                    if let Some(target) =
                        unwrap_as!(&self.types[type_param], Type::TypeParameter(p), p).target
                    {
                        let targetConstraint = self.getConstraintOfTypeParameter(target);
                        let constraint = if let Some(targetConstraint) = targetConstraint {
                            self.instantiateType(
                                targetConstraint,
                                unwrap_as!(&self.types[type_param], Type::TypeParameter(p), p)
                                    .mapper
                                    .clone(),
                            )
                        } else {
                            self.noConstraintType
                        };
                        unwrap_as!(&mut self.types[type_param], Type::TypeParameter(p), p)
                            .constraint = Some(constraint);
                        constraint
                    } else {
                        let constraintDeclaration = self.getConstraintDeclaration(type_param);
                        if let Some(constraintDeclaration) = constraintDeclaration {
                            let ty = self.getTypeFromTypeNode(constraintDeclaration);
                            if self.types[ty].get_flags().intersects(TypeFlags::Any)
                                && !self.isErrorType(ty)
                            {
                                todo!();
                                // // Allow errorType to propegate to keep downstream errors suppressed
                                // // use keyofConstraintType as the base constraint for mapped type key constraints (unknown isn;t assignable to that, but `any` was),
                                // // use unknown otherwise
                                // ty = if constraintDeclaration.parent.parent.kind
                                //     == SyntaxKind.MappedType
                                // {
                                //     todo!();
                                //     // keyofConstraintType
                                // } else {
                                //     self.unknownType
                                // };
                            }
                            unwrap_as!(&mut self.types[type_param], Type::TypeParameter(p), p)
                                .constraint = Some(ty);
                            ty
                        } else {
                            let constraint = self
                                .getInferredTypeParameterConstraint(type_param)
                                .unwrap_or(self.noConstraintType);
                            unwrap_as!(&mut self.types[type_param], Type::TypeParameter(p), p)
                                .constraint = Some(constraint);
                            constraint
                        }
                    }
                }
            };
        if constraint == self.noConstraintType {
            None
        } else {
            Some(constraint)
        }
    }

    // TODO:
    // getParentSymbolOfTypeParameter

    fn getTypeListId(&self, types: Option<&Vec<TypeId>>) -> TypeList {
        // TODO: TypeList::new just hashed the input types without hashing the delimiters. This could cause
        // issues if the same types are passed in but with different delimiters.
        TypeList::new(types)
        // let result = "";
        // if (types) {
        //     const length = types.length;
        //     let i = 0;
        //     while (i < length) {
        //         const startId = types[i].id;
        //         let count = 1;
        //         while (i + count < length && types[i + count].id === startId + count) {
        //             count++;
        //         }
        //         if (result.length) {
        //             result += ",";
        //         }
        //         result += startId;
        //         if (count > 1) {
        //             result += ":" + count;
        //         }
        //         i += count;
        //     }
        // }
        // return result;
    }

    // TODO:
    fn getAliasId(
        &self,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<&Vec<TypeId>>,
    ) -> u64 {
        hash![aliasSymbol, aliasTypeArguments]
        // return aliasSymbol ? `@${getSymbolId(aliasSymbol)}` + (aliasTypeArguments ? `:${getTypeListId(aliasTypeArguments)}` : "") : "";
    }

    // This function is used to propagate certain flags when creating new object type references and union types.
    // It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
    // of an object literal or the anyFunctionType. This is because there are operations in the type checker
    // that care about the presence of such types at arbitrary depth in a containing type.
    fn getPropagatingFlagsOfTypes(
        &self,
        types: &Rc<Vec<TypeId>>,
        excludeKinds: TypeFlags,
    ) -> ObjectFlags {
        let mut result = ObjectFlags::empty();
        for &ty in types.iter() {
            if !self.types[ty].get_flags().intersects(excludeKinds) {
                result |= self.types[ty].get_object_flags();
            }
        }
        result & ObjectFlags::PropagatingFlags
    }

    fn createTypeReference(
        &mut self,
        target: TypeId,
        typeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let id = self.getTypeListId(typeArguments.as_ref().map(|r| r.as_ref()));
        match self.types[target]
            .unwrap_as_generic_type_base()
            .instantiations
            .get(&id)
        {
            Some(ty) => *ty,
            None => {
                let mut objectFlags = ObjectFlags::Reference;
                if let Some(typeArguments) = &typeArguments {
                    objectFlags
                        .insert(self.getPropagatingFlagsOfTypes(typeArguments, TypeFlags::empty()))
                }
                let ty = TypeReference {
                    type_reference: TypeReferenceBase {
                        target: Some(target),
                        resolvedTypeArguments: typeArguments,
                        ..Default::default()
                    },
                    object_type_base: ObjectTypeBase {
                        objectFlags,
                        ..Default::default()
                    },
                    type_base: TypeBase::new(TypeFlags::Object, *self.types[target].get_symbol()),
                };
                let ty = self.types.push(Type::TypeReference(ty));
                self.types[target]
                    .unwrap_as_generic_type_base_mut()
                    .instantiations
                    .insert(id, ty);
                ty
            }
        }
    }

    // TODO:
    // cloneTypeReference

    fn createDeferredTypeReference(
        &mut self,
        target: TypeId,
        node: BoundNode,
        mapper: Option<Rc<TypeMapper>>,
        mut aliasSymbol: Option<SymbolId>,
        mut aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        if aliasSymbol.is_none() {
            aliasSymbol = self.getAliasSymbolForTypeNode(&node);
            let localAliasTypeArguments = self.getTypeArgumentsForAliasSymbol(aliasSymbol);
            aliasTypeArguments = if let Some(mapper) = &mapper {
                self.instantiateTypesOptional(localAliasTypeArguments, mapper.clone())
            } else {
                localAliasTypeArguments
            };
        }
        let ty = DeferredTypeReference {
            type_reference: TypeReferenceBase {
                target: Some(target),
                node: Some(node),
                mapper,
                ..Default::default()
            },
            object_type_base: ObjectTypeBase::new(ObjectFlags::Reference),
            type_base: TypeBase {
                flags: TypeFlags::Object,
                symbol: *self.types[target].get_symbol(),
                aliasSymbol,
                aliasTypeArguments,
                ..Default::default()
            },
            instantiations: Default::default(),
        };
        self.types.push(Type::DeferredTypeReference(ty))
    }

    fn getTypeArguments(&mut self, ty: TypeId) -> Rc<Vec<TypeId>> {
        macro_rules! ty_ref {
            () => {
                self.types[ty].unwrap_as_type_reference()
            };
        }
        match &ty_ref!().resolvedTypeArguments {
            Some(resolvedTypeArguments) => resolvedTypeArguments.clone(),
            None => {
                if !self.pushTypeResolution(
                    TypeSystemEntity::Type(ty),
                    TypeSystemPropertyName::ResolvedTypeArguments,
                ) {
                    todo!();
                    // return ty.target.localTypeParameters?.map(() => errorType) || emptyArray;
                }
                let typeArguments = if let Some(node) = ty_ref!().node.clone() {
                    if matches!(node, BoundNode::TsTypeRef(_)) {
                        todo!();
                        // let target = ty_ref!().target.unwrap();
                        // concatenate(
                        //     ty.target.outerTypeParameters,
                        //     self.getEffectiveTypeArguments(node, self.types[target].localTypeParameters.unwrap()),
                        // )
                    } else if let BoundNode::TsArrayType(n) = &node {
                        vec![self.getTypeFromTypeNode(n.elem_type.bind(node.clone()))]
                    } else if let BoundNode::TsTupleType(n) = &node {
                        n.elem_types
                            .iter()
                            .map(|e| self.getTypeFromTypeNode(e.bind(node.clone())))
                            .collect()
                    } else {
                        unreachable!();
                    }
                } else {
                    Vec::new()
                };
                let typeArguments = Rc::new(typeArguments);
                if self.popTypeResolution() {
                    let resolvedTypeArguments = if let Some(mapper) = &ty_ref!().mapper {
                        // TODO: replace clone with more robust/final impl:
                        self.instantiateTypes(typeArguments, mapper.clone())
                    } else {
                        typeArguments
                    };
                    self.types[ty]
                        .unwrap_as_type_reference_mut()
                        .resolvedTypeArguments = Some(resolvedTypeArguments.clone());
                    resolvedTypeArguments
                } else {
                    todo!();
                    // ty.resolvedTypeArguments = ty.target.localTypeParameters?.map(() => errorType) || emptyArray;
                    // error(
                    //     ty.node || currentNode,
                    //     ty.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves,
                    //     ty.target.symbol && symbolToString(ty.target.symbol)
                    // );
                }
            }
        }
    }

    // TODO:
    // getTypeReferenceArity

    /**
     * Get type from type-reference that reference to class or interface
     */
    // TODO: figure out all possible values of `node`:
    fn getTypeFromClassOrInterfaceReference(
        &mut self,
        node: BoundNode,
        symbol: SymbolId,
    ) -> TypeId {
        let ty = self.getDeclaredTypeOfSymbol(self.getMergedSymbol(symbol));
        let typeParameters = &self.types[ty]
            .unwrap_as_interface_type()
            .localTypeParameters;
        if let Some(typeParameters) = typeParameters {
            let numTypeArguments = match &node {
                BoundNode::TsTypeRef(t) => t.type_params.as_ref().map(|p| p.params.len()),
                _ => todo!(),
            };
            let numTypeArguments = numTypeArguments.unwrap_or_default();
            let minTypeArgumentCount = self.getMinTypeArgumentCount(Some(typeParameters.clone()));
            let isJs = isBoundNodeInJSFile(&node);
            let isJsImplicitAny = !self.noImplicitAny && isJs;
            if !isJsImplicitAny
                && (numTypeArguments < minTypeArgumentCount
                    || numTypeArguments > typeParameters.len())
            {
                todo!();
                // const missingAugmentsTag = isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent);
                // const diag = minTypeArgumentCount === typeParameters.length ?
                //     missingAugmentsTag ?
                //         Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :
                //         Diagnostics.Generic_type_0_requires_1_type_argument_s :
                //     missingAugmentsTag ?
                //         Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :
                //         Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments;

                // const typeStr = typeToString(ty, /*enclosingDeclaration*/ undefined, TypeFormatFlags.WriteArrayAsGenericType);
                // error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length);
                // if (!isJs) {
                //     // TODO: Adopt same permissive behavior in TS as in JS to reduce follow-on editing experience failures (requires editing fillMissingTypeArguments)
                //     return errorType;
                // }
            }
            let typeParameters = typeParameters.clone();
            if matches!(node, BoundNode::TsTypeRef(_)) {
                if self.isDeferredTypeReferenceNode(&node, numTypeArguments != typeParameters.len())
                {
                    return self.createDeferredTypeReference(ty, node.clone(), None, None, None);
                }
            }
            // In a type reference, the outer type parameters of the referenced class or interface are automatically
            // supplied as type arguments and the type reference only specifies arguments for the local type parameters
            // of the class or interface.
            let outerTypeParameters = self.types[ty]
                .unwrap_as_interface_type()
                .outerTypeParameters
                .clone();
            let typeArguments = self.typeArgumentsFromTypeReferenceNode(&node);
            let typeArguments = self.fillMissingTypeArguments(
                typeArguments,
                Some(typeParameters.clone()),
                minTypeArgumentCount,
                isJs,
            );
            let typeArguments = match (outerTypeParameters, typeArguments) {
                (Some(outerTypeParameters), Some(typeArguments)) => {
                    let mut new = Vec::new();
                    new.extend(outerTypeParameters.iter());
                    new.extend(typeArguments.iter());
                    Some(Rc::new(new))
                }
                (Some(outerTypeParameters), None) => Some(outerTypeParameters.clone()),
                (None, Some(typeArguments)) => Some(typeArguments.clone()),
                _ => Some(Rc::new(Vec::new())),
            };
            return self.createTypeReference(ty, typeArguments);
        }
        if self.checkNoTypeArguments(node, Some(symbol)) {
            ty
        } else {
            self.errorType
        }
    }

    fn getTypeAliasInstantiation(
        &mut self,
        symbol: SymbolId,
        typeArguments: Option<Rc<Vec<TypeId>>>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let ty = self.getDeclaredTypeOfSymbol(symbol);
        if ty == self.intrinsicMarkerType
            && get_intrinsic_type_kind(self.symbols[symbol].escapedName()).is_some()
            && typeArguments.is_some()
            && typeArguments.as_ref().unwrap().len() == 1
        {
            todo!();
            // return self.getStringMappingType(symbol, typeArguments.unwrap()[0]);
        }
        let typeParameters = self.getSymbolLinks(symbol).typeParameters.clone().unwrap();
        let make_instantiation_cache_key = || {
            let type_list_id = self.getTypeListId(typeArguments.as_ref().map(|v| v.as_ref()));
            let alias_id =
                self.getAliasId(aliasSymbol, aliasTypeArguments.as_ref().map(|v| v.as_ref()));
            hash![type_list_id, alias_id]
        };
        let id = make_instantiation_cache_key();
        match self.getSymbolLinks(symbol).instantiations.get(&id) {
            Some(instantiation) => *instantiation,
            None => {
                let targets = self.fillMissingTypeArguments(
                    typeArguments,
                    Some(typeParameters.clone()),
                    self.getMinTypeArgumentCount(Some(typeParameters.clone())),
                    isInJSFile(self.symbols[symbol].valueDeclaration().as_ref()),
                );
                let mapper = self.createTypeMapper(typeParameters, targets);
                let instantiation =
                    self.instantiateTypeWithAlias(ty, mapper, aliasSymbol, aliasTypeArguments);
                self.getSymbolLinksMut(symbol)
                    .instantiations
                    .insert(id, instantiation);
                instantiation
            }
        }
    }

    /**
     * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
     * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
     * declared type. Instantiations are cached using the type identities of the type arguments as the key.
     */
    fn getTypeFromTypeAliasReference(&mut self, node: &BoundNode, symbol: SymbolId) -> TypeId {
        if getCheckFlags(&self.symbols[symbol]).intersects(CheckFlags::Unresolved) {
            todo!();
            // let typeArguments = self.typeArgumentsFromTypeReferenceNode(node);
            // let id = self.getAliasId(Some(symbol), typeArguments);
            // let errorType = self.errorTypes.get(id);
            // if !errorType {
            //     todo!();
            //     // errorType = createIntrinsicType(TypeFlags::Any, "error");
            //     // errorType.aliasSymbol = symbol;
            //     // errorType.aliasTypeArguments = typeArguments;
            //     // errorTypes.set(id, errorType);
            // }
            // return errorType;
        }
        let ty = self.getDeclaredTypeOfSymbol(symbol);
        if let Some(typeParameters) = self.getSymbolLinks(symbol).typeParameters.clone() {
            // TODO: maybe create a util method for extracting the type args from a node.
            // Something like fn getTypeArguments(node: BoundNode) -> Option<&Vec<_>>
            // TODO: remove type ann
            let numTypeArguments = match node {
                BoundNode::TsTypeRef(n) => n
                    .type_params
                    .as_ref()
                    .map(|i| i.params.len())
                    .unwrap_or_default(),
                _ => {
                    dbg!(node);
                    todo!()
                }
            };
            // let numTypeArguments = node.typeArguments.len();
            let minTypeArgumentCount = self.getMinTypeArgumentCount(Some(typeParameters.clone()));
            if numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.len() {
                todo!();
                // error(node,
                //     minTypeArgumentCount === typeParameters.length ?
                //         Diagnostics.Generic_type_0_requires_1_type_argument_s :
                //         Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments,
                //     symbolToString(symbol),
                //     minTypeArgumentCount,
                //     typeParameters.length);
                // return errorType;
            }
            // We refrain from associating a local type alias with an instantiation of a top-level type alias
            // because the local alias may end up being referenced in an inferred return type where it is not
            // accessible--which in turn may lead to a large structural expansion of the type when generating
            // a .d.ts file. See #43622 for an example.
            let aliasSymbol = self.getAliasSymbolForTypeNode(node);
            let newAliasSymbol = if aliasSymbol.is_some()
                && (self.isLocalTypeAlias(symbol) || !self.isLocalTypeAlias(aliasSymbol.unwrap()))
            {
                aliasSymbol
            } else {
                None
            };
            let typeArguments = self.typeArgumentsFromTypeReferenceNode(node);
            let aliasTypeArguments = self.getTypeArgumentsForAliasSymbol(newAliasSymbol);
            return self.getTypeAliasInstantiation(
                symbol,
                typeArguments,
                newAliasSymbol,
                aliasTypeArguments,
            );
        }
        if self.checkNoTypeArguments(node.clone(), Some(symbol)) {
            ty
        } else {
            self.errorType
        }
    }

    fn isLocalTypeAlias(&self, symbol: SymbolId) -> bool {
        let declaration = self.symbols[symbol]
            .declarations()
            .iter()
            .find(|&d| isTypeAlias(d));
        declaration.and_then(|d| getContainingFunction(d)).is_some()
    }

    // TODO:
    // getTypeReferenceName
    // TODO:
    // getSymbolPath

    fn getUnresolvedSymbolForEntityName(&mut self, name: BoundNode) -> SymbolId {
        dbg!(name);
        todo!();
        // let ident = match name {
        //     BoundNode::Ident(n) =>n,
        //     BoundNode::TsQualifiedName(n) => n.right,
        //     BoundNode::MemberExpr(n) if !n.computed => unwrap_as!(n.prop, ast::Expr::Ident(i),i),
        //     _ => unreachable!()
        // };
        // // const identifier = name.kind === SyntaxKind.QualifiedName ? name.right :
        // //     name.kind === SyntaxKind.PropertyAccessExpression ? name.name :
        // //     name;
        // let text = identifier.sym;
        // if (text) {
        //     let parentSymbol = name.kind === SyntaxKind.QualifiedName ? getUnresolvedSymbolForEntityName(name.left) :
        //         name.kind === SyntaxKind.PropertyAccessExpression ? getUnresolvedSymbolForEntityName(name.expression) :
        //         undefined;
        //     let path = parentSymbol ? `${getSymbolPath(parentSymbol)}.${text}` : text as string;
        //     let result = unresolvedSymbols.get(path);
        //     if (!result) {
        //         unresolvedSymbols.set(path, result = createSymbol(SymbolFlags::TypeAlias, text, CheckFlags.Unresolved));
        //         result.parent = parentSymbol;
        //         result.declaredType = unresolvedType;
        //     }
        //     return result;
        // }
        // return unknownSymbol;
    }

    fn resolveTypeReferenceName(
        &mut self,
        typeReference: &BoundNode,
        meaning: SymbolFlags,
        ignoreErrors: bool,
    ) -> SymbolId {
        if let Some(name) = getTypeReferenceName(typeReference) {
            if let Some(sym) =
                self.resolveEntityName(name.clone(), meaning, ignoreErrors, false, None)
            {
                if sym != self.unknownSymbol {
                    return sym;
                }
            }
            if ignoreErrors {
                self.unknownSymbol
            } else {
                self.getUnresolvedSymbolForEntityName(name)
            }
        } else {
            self.unknownSymbol
        }
    }

    fn getTypeReferenceType(&mut self, node: BoundNode, mut symbol: SymbolId) -> TypeId {
        if symbol == self.unknownSymbol {
            return self.errorType;
        }
        symbol = self.getExpandoSymbol(symbol).unwrap_or(symbol);
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::Class | SymbolFlags::Interface)
        {
            return self.getTypeFromClassOrInterfaceReference(node, symbol);
        }
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::TypeAlias)
        {
            return self.getTypeFromTypeAliasReference(&node, symbol);
        }
        // Get type from reference to named type that cannot be generic (enum or type parameter)
        let res = self.tryGetDeclaredTypeOfSymbol(symbol);
        if let Some(res) = res {
            return if self.checkNoTypeArguments(node, Some(symbol)) {
                self.getRegularTypeOfLiteralType(res)
            } else {
                self.errorType
            };
        }
        // TODO: jsdoc:
        // if self.symbols[symbol].flags().intersects(SymbolFlags::Value) && isJSDocTypeReference(node) {
        //     let jsdocType = self.getTypeFromJSDocValueReference(node, symbol);
        //     if jsdocType {
        //         return jsdocType;
        //     }
        //     else {
        //         // Resolve the type reference as a Type for the purpose of reporting errors.
        //         self.resolveTypeReferenceName(node, SymbolFlags::Type);
        //         return self.getTypeOfSymbol(symbol);
        //     }
        // }
        self.errorType
    }

    // TODO:
    // getTypeFromJSDocValueReference

    fn getSubstitutionType(&mut self, baseType: TypeId, substitute: TypeId) -> TypeId {
        if self.types[substitute]
            .get_flags()
            .intersects(TypeFlags::AnyOrUnknown)
            || substitute == baseType
        {
            return baseType;
        }
        let id = SubstitutionTypeKey::new(baseType, substitute);
        match self.substitutionTypes.get(&id) {
            Some(cached) => *cached,
            None => {
                let result = SubstitutionType {
                    instantiable_type: InstantiableType::default(),
                    type_base: TypeBase::new(TypeFlags::Substitution, None),
                    objectFlags: ObjectFlags::default(),
                    baseType,
                    substitute,
                };
                let result = self.types.push(Type::SubstitutionType(result));
                self.substitutionTypes.insert(id, result);
                result
            }
        }
    }

    fn getImpliedConstraint(
        &mut self,
        ty: TypeId,
        checkNode: BoundNode,
        extendsNode: BoundNode,
    ) -> Option<TypeId> {
        fn isUnaryTupleTypeNode(node: &BoundNode) -> Option<&Rc<TsTupleType>> {
            if let BoundNode::TsTupleType(tuple) = node {
                if tuple.elem_types.len() == 1 {
                    return Some(&tuple);
                }
            }
            None
        }

        if let (Some(check_tuple), Some(extends_tuple)) = (
            isUnaryTupleTypeNode(&checkNode),
            isUnaryTupleTypeNode(&extendsNode),
        ) {
            self.getImpliedConstraint(
                ty,
                check_tuple.elem_types[0].bind(check_tuple.clone().into()),
                extends_tuple.elem_types[0].bind(extends_tuple.clone().into()),
            )
        } else if {
            let check_node_ty = self.getTypeFromTypeNode(checkNode);
            self.getActualTypeVariable(check_node_ty) == ty
        } {
            Some(self.getTypeFromTypeNode(extendsNode))
        } else {
            None
        }
    }

    fn getConditionalFlowTypeOfType(&mut self, ty: TypeId, node: BoundNode) -> TypeId {
        let mut constraints = Vec::new();
        let mut covariant = true;
        let mut node = Some(node);
        while let Some(n) = node {
            if isStatement(&n)
            /* || node.kind == SyntaxKind.JSDocComment*/
            {
                break;
            }
            let parent = n.parent();
            if let Some(parent) = &parent {
                // only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but
                // often get used in indexed accesses where they behave sortof invariantly, but our checking is lax
                if matches!(
                    parent,
                    BoundNode::Param(_)
                        | BoundNode::ParamWithoutDecorators(_)
                        | BoundNode::TsAmbientParam(_)
                        | BoundNode::TsParamProp(_)
                ) {
                    covariant = !covariant;
                }
                // Always substitute on type parameters, regardless of variance, since even
                // in contravariant positions, they may rely on substituted constraints to be valid
                if covariant
                    || self.types[ty]
                        .get_flags()
                        .intersects(TypeFlags::TypeVariable)
                {
                    if let BoundNode::TsConditionalType(p) = parent {
                        if n == p.true_type.bind(parent.clone()) {
                            let constraint = self.getImpliedConstraint(
                                ty,
                                p.check_type.bind(parent.clone()),
                                p.extends_type.bind(parent.clone()),
                            );
                            if let Some(constraint) = constraint {
                                constraints.push(constraint);
                            }
                        }
                    }
                }
            }
            node = parent;
        }
        if !constraints.is_empty() {
            constraints.push(ty);
            let intersection = self.getIntersectionType(&constraints, None, None);
            self.getSubstitutionType(ty, intersection)
        } else {
            ty
        }
    }

    // TODO:
    // isJSDocTypeReference

    fn checkNoTypeArguments(&mut self, node: BoundNode, symbol: Option<SymbolId>) -> bool {
        let hasTypeArguments = match &node {
            BoundNode::TsTypeRef(t) => t
                .type_params
                .as_ref()
                .map(|p| !p.params.is_empty())
                .unwrap_or_default(),
            BoundNode::TsExprWithTypeArgs(n) => n
                .type_args
                .as_ref()
                .map(|p| !p.params.is_empty())
                .unwrap_or_default(),
            BoundNode::Ident(_) => false,
            _ => {
                dbg!(&node);
                todo!()
            }
        };
        if hasTypeArguments {
            todo!();
            // error(node, Diagnostics.Type_0_is_not_generic, symbol ? symbolToString(symbol) : (node as TypeReferenceNode).typeName ? declarationNameToString((node as TypeReferenceNode).typeName) : anon);
            // return false;
        }
        true
    }

    // TODO:
    // getIntendedTypeFromJSDocTypeReference
    // TODO:
    // getTypeFromJSDocNullableTypeNode

    fn getTypeFromTypeReference(&mut self, node: BoundNode) -> TypeId {
        match self.getNodeLinks(node.clone()).resolvedType {
            Some(t) => t,
            None => {
                // TODO:
                // handle LS queries on the `const` in `x as const` by resolving to the type of `x`
                // if isConstTypeReference(node) && isAssertionExpression(node.parent) {
                //     self.getNodeLinks_mut(node).resolvedSymbol = unknownSymbol;
                //     let ty = self.checkExpressionCached(node.parent.expression);
                //     self.getNodeLinks_mut(node).resolvedType = ty;
                //     return ty;
                // }
                let mut symbol = None;
                let mut ty = None;
                let meaning = SymbolFlags::Type;
                // TODO: jsdoc
                // if isJSDocTypeReference(node) {
                //     ty = getIntendedTypeFromJSDocTypeReference(node);
                //     if (!ty) {
                //         symbol = resolveTypeReferenceName(node, meaning, /*ignoreErrors*/ true);
                //         if (symbol === unknownSymbol) {
                //             symbol = resolveTypeReferenceName(node, meaning | SymbolFlags::Value);
                //         }
                //         else {
                //             resolveTypeReferenceName(node, meaning); // Resolve again to mark errors, if any
                //         }
                //         ty = getTypeReferenceType(node, symbol);
                //     }
                // }
                let ty = match ty {
                    Some(t) => t,
                    None => {
                        let sym = self.resolveTypeReferenceName(&node, meaning, false);
                        symbol = Some(sym);
                        self.getTypeReferenceType(node.clone(), sym)
                    }
                };
                // Cache both the resolved symbol and the resolved type. The resolved symbol is needed when we check the
                // type reference in checkTypeReferenceNode.
                let links = self.getNodeLinks_mut(node);
                links.resolvedSymbol = symbol;
                links.resolvedType = Some(ty);

                ty
            }
        }
    }

    fn typeArgumentsFromTypeReferenceNode(&mut self, node: &BoundNode) -> Option<Rc<Vec<TypeId>>> {
        let type_args = match node {
            BoundNode::TsTypeRef(t) => t.type_params.as_ref(),
            BoundNode::Ident(_) => None,
            _ => {
                dbg!(node);
                todo!()
            }
        };
        type_args.map(|args| {
            Rc::new(
                args.params
                    .iter()
                    .map(|arg| self.getTypeFromTypeNode(arg.bind(node.clone())))
                    .collect(),
            )
        })
    }
    // TODO:
    // getTypeFromTypeQueryNode

    fn getTypeOfGlobalSymbol(&mut self, symbol: Option<SymbolId>, arity: u8) -> TypeId {
        fn getTypeDeclaration(symbol: &Symbol) -> Option<BoundNode> {
            todo!();
            // let declarations = symbol.declarations;
            // if (declarations) {
            //     for declaration in declarations {
            //         switch (declaration.kind) {
            //             case SyntaxKind.ClassDeclaration:
            //             case SyntaxKind.InterfaceDeclaration:
            //             case SyntaxKind.EnumDeclaration:
            //                 return declaration;
            //         }
            //     }
            // }
        }

        let symbol = match symbol {
            Some(s) => s,
            None => {
                return if arity > 0 {
                    self.emptyGenericType
                } else {
                    self.emptyObjectType
                }
            }
        };

        let type_id = self.getDeclaredTypeOfSymbol(symbol);
        let ty = &self.types[type_id];
        if !(ty.get_flags().intersects(TypeFlags::Object)) {
            todo!("error");
            // error(
            //     getTypeDeclaration(symbol),
            //     Diagnostics.Global_type_0_must_be_a_class_or_interface_type,
            //     symbolName(&symbol),
            // );
            // return if arity > 0 {
            //     self.emptyGenericType
            // } else {
            //     self.emptyObjectType
            // };
        }
        // TODO:
        // if (length((ty as InterfaceType).typeParameters) != arity) {
        //     todo!("error");
        //     // error(
        //     //     getTypeDeclaration(symbol),
        //     //     Diagnostics.Global_type_0_must_have_1_type_parameter_s,
        //     //     symbolName(&symbol),
        //     //     arity,
        //     // );
        //     // return if arity > 0 {
        //     //     self.emptyGenericType
        //     // } else {
        //     //     self.emptyObjectType
        //     // };
        // }
        type_id
    }

    // TODO:
    // getGlobalValueSymbol

    fn getGlobalTypeSymbol(&mut self, name: JsWord, reportErrors: bool) -> Option<SymbolId> {
        self.getGlobalSymbol(name, SymbolFlags::Type/*, reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined*/)
    }

    // TODO:
    // getGlobalTypeAliasSymbol

    fn getGlobalSymbol(
        &mut self,
        name: JsWord,
        meaning: SymbolFlags, /*, diagnostic: DiagnosticMessage | undefined*/
    ) -> Option<SymbolId> {
        // Don't track references for global symbols anyway, so value if `isReference` is arbitrary
        self.resolveName(
            None,
            name.clone(),
            meaning,
            /*diagnostic,*/ Some(name),
            false,
            false,
        )
    }

    // function getGlobalType(name: JsWord, arity: 0, reportErrors: true): ObjectType;
    // function getGlobalType(name: JsWord, arity: 0, reportErrors: boolean): ObjectType | undefined;
    // function getGlobalType(name: JsWord, arity: number, reportErrors: true): GenericType;
    // function getGlobalType(name: JsWord, arity: number, reportErrors: boolean): GenericType | undefined;
    // function getGlobalType(name: JsWord, arity: number, reportErrors: boolean): ObjectType | undefined
    fn getGlobalType(&mut self, name: JsWord, arity: u8, reportErrors: bool) -> Option<TypeId> {
        let symbol = self.getGlobalTypeSymbol(name, reportErrors);

        if symbol.is_some() || reportErrors {
            Some(self.getTypeOfGlobalSymbol(symbol, arity))
        } else {
            None
        }
    }

    // TODO:
    // getGlobalTypedPropertyDescriptorType
    // TODO:
    // getGlobalTemplateStringsArrayType
    // TODO:
    // getGlobalImportMetaType
    // TODO:
    // getGlobalImportMetaExpressionType
    // TODO:
    // getGlobalImportCallOptionsType
    // TODO:
    // getGlobalESSymbolConstructorSymbol
    // TODO:
    // getGlobalESSymbolConstructorTypeSymbol
    // TODO:
    // getGlobalESSymbolType
    // TODO:
    // getGlobalPromiseType
    // TODO:
    // getGlobalPromiseLikeType
    // TODO:
    // getGlobalPromiseConstructorSymbol
    // TODO:
    // getGlobalPromiseConstructorLikeType
    // TODO:
    // getGlobalAsyncIterableType
    // TODO:
    // getGlobalAsyncIteratorType
    // TODO:
    // getGlobalAsyncIterableIteratorType
    // TODO:
    // getGlobalAsyncGeneratorType
    // TODO:
    // getGlobalIterableType
    // TODO:
    // getGlobalIteratorType
    // TODO:
    // getGlobalIterableIteratorType
    // TODO:
    // getGlobalGeneratorType
    // TODO:
    // getGlobalIteratorYieldResultType
    // TODO:
    // getGlobalIteratorReturnResultType

    fn getGlobalTypeOrUndefined(&mut self, name: JsWord, arity: u8) -> Option<TypeId> {
        let symbol = self.getGlobalSymbol(name, SymbolFlags::Type /*, None*/);
        symbol.map(|sym| self.getTypeOfGlobalSymbol(Some(sym), arity))
    }

    // TODO:
    // getGlobalExtractSymbol
    // TODO:
    // getGlobalOmitSymbol
    // TODO:
    // getGlobalAwaitedSymbol
    // TODO:
    // getGlobalBigIntType

    /**
     * Instantiates a global type that is generic with some element type, and returns that instantiation.
     */
    fn createTypeFromGenericGlobalType(
        &mut self,
        genericGlobalType: TypeId,
        typeArguments: &[TypeId],
    ) -> TypeId {
        if genericGlobalType != self.emptyGenericType {
            self.createTypeReference(genericGlobalType, Some(Rc::new(typeArguments.into())))
        } else {
            self.emptyObjectType
        }
    }

    // TODO:
    // createTypedPropertyDescriptorType
    // TODO:
    // createIterableType

    fn createArrayType(&mut self, elementType: TypeId, readonly: bool) -> TypeId {
        self.createTypeFromGenericGlobalType(
            if readonly {
                self.globalReadonlyArrayType()
            } else {
                self.globalArrayType()
            },
            &[elementType],
        )
    }

    // TODO:
    // getRestTypeElementFlags

    fn getArrayOrTupleTargetType(&mut self, node: BoundNode) -> TypeId {
        let readonly = isReadonlyTypeOperator(&node.parent().unwrap());
        if let Some(elementType) = getArrayElementTypeNode(&node) {
            return if readonly {
                self.globalReadonlyArrayType()
            } else {
                self.globalArrayType()
            };
        }
        todo!();
        // let elementFlags = map((node as TupleTypeNode).elements, getTupleElementFlags);
        // let missingName = some((node as TupleTypeNode).elements, e => e.kind != SyntaxKind.NamedTupleMember);
        // self.getTupleTargetType(elementFlags, readonly, /*associatedNames*/ if missingName {undefined} else{(node as TupleTypeNode).elements as readonly NamedTupleMember[]})
    }

    // Return true if the given type reference node is directly aliased or if it needs to be deferred
    // because it is possibly contained in a circular chain of eagerly resolved types.
    fn isDeferredTypeReferenceNode(
        &mut self,
        node: &BoundNode,
        hasDefaultTypeArguments: bool,
    ) -> bool {
        self.getAliasSymbolForTypeNode(node).is_some()
            || isResolvedByTypeAlias(node)
                && (if let BoundNode::TsArrayType(t) = node {
                    self.mayResolveTypeAlias(&t.elem_type.bind(node.clone()))
                } else if let BoundNode::TsTupleType(t) = node {
                    t.elem_types
                        .iter()
                        .any(|e| self.mayResolveTypeAlias(&e.bind(node.clone())))
                } else if let BoundNode::TsTypeRef(r) = node {
                    hasDefaultTypeArguments
                        || r.type_params
                            .as_ref()
                            .map(|params| {
                                params.params.iter().any(|p| {
                                    self.mayResolveTypeAlias(&p.bind(params.bind(node.clone())))
                                })
                            })
                            .unwrap_or_default()
                } else {
                    unreachable!()
                })
    }

    // Return true if resolving the given node (i.e. getTypeFromTypeNode) possibly causes resolution
    // of a type alias.
    fn mayResolveTypeAlias(&mut self, node: &BoundNode) -> bool {
        match node {
            BoundNode::TsTypeRef(t) => {
                // TODO: jsodc:
                // isJSDocTypeReference(node) ||
                let sym = self.resolveTypeReferenceName(&node, SymbolFlags::Type, false);
                self.symbols[sym].flags().intersects(SymbolFlags::TypeAlias)
            }
            BoundNode::TsTypeQuery(_) => true,
            BoundNode::TsTypeOperator(o) => {
                o.op != ast::TsTypeOperatorOp::Unique
                    && self.mayResolveTypeAlias(&o.type_ann.bind(node.clone()))
            }
            // TODO: jsdoc:
            // BoundNode::JSDocOptionalType(_)|
            // BoundNode::JSDocNullableType(_)|
            // BoundNode::JSDocNonNullableType(_)|
            // BoundNode::JSDocTypeExpression(_)
            BoundNode::TsParenthesizedType(t) => {
                self.mayResolveTypeAlias(&t.type_ann.bind(node.clone()))
            }
            BoundNode::TsOptionalType(t) => {
                self.mayResolveTypeAlias(&t.type_ann.bind(node.clone()))
            }
            BoundNode::TsRestType(t) => {
                if let ast::TsType::TsArrayType(a) = &t.type_ann {
                    self.mayResolveTypeAlias(&a.elem_type.bind(a.bind(node.clone())))
                } else {
                    true
                }
            }
            BoundNode::TsUnionType(u) => u
                .types
                .iter()
                .any(|t| self.mayResolveTypeAlias(&t.bind(node.clone()))),
            BoundNode::TsIntersectionType(i) => i
                .types
                .iter()
                .any(|t| self.mayResolveTypeAlias(&t.bind(node.clone()))),
            BoundNode::TsIndexedAccessType(i) => {
                self.mayResolveTypeAlias(&i.obj_type.bind(node.clone()))
                    || self.mayResolveTypeAlias(&i.index_type.bind(node.clone()))
            }
            BoundNode::TsConditionalType(c) => {
                self.mayResolveTypeAlias(&c.check_type.bind(node.clone()))
                    || self.mayResolveTypeAlias(&c.extends_type.bind(node.clone()))
                    || self.mayResolveTypeAlias(&c.true_type.bind(node.clone()))
                    || self.mayResolveTypeAlias(&c.false_type.bind(node.clone()))
            }
            _ => false,
        }
    }

    fn getTypeFromArrayOrTupleTypeNode(&mut self, node: BoundNode) -> TypeId {
        match self.getNodeLinks(node.clone()).resolvedType {
            Some(resolved) => resolved,
            None => {
                let target = self.getArrayOrTupleTargetType(node.clone());
                if target == self.emptyGenericType {
                    let ty = self.emptyObjectType;
                    self.getNodeLinks_mut(node).resolvedType = Some(ty);
                    return ty;
                }
                if !matches!(&node,
                    BoundNode::TsTupleType(t) if t
                    .elem_types.iter()
                    .any(|e| getTupleElementFlags(e, &node).intersects(ElementFlags::Variadic) )
                ) && self.isDeferredTypeReferenceNode(&node, false)
                {
                    todo!();
                    // let ty = if node.kind == SyntaxKind.TupleType && node.elements.length == 0 {
                    //     target
                    // } else {
                    //     createDeferredTypeReference(target, node, /*mapper*/ undefined)
                    // };
                    // self.getNodeLinks_mut(node).resolvedType = Some(ty);
                    // return ty;
                }

                let elementTypes = match &node {
                    BoundNode::TsArrayType(a) => {
                        vec![self.getTypeFromTypeNode(a.elem_type.bind(node.clone()))]
                    }
                    BoundNode::TsTupleType(t) => t
                        .elem_types
                        .iter()
                        .map(|t| self.getTypeFromTypeNode(t.bind(node.clone())))
                        .collect(),
                    _ => unreachable!(),
                };

                let ty = self.createNormalizedTypeReference(target, Some(elementTypes.into()));
                self.getNodeLinks_mut(node).resolvedType = Some(ty);
                ty
            }
        }
    }

    fn createTupleType(
        &mut self,
        elementTypes: Rc<Vec<TypeId>>,
        elementFlags: Option<Vec<ElementFlags>>,
        readonly: bool,
        namedMemberDeclarations: Option<Vec<BoundNode>>,
    ) -> TypeId {
        let tupleTarget = self.getTupleTargetType(
            elementFlags.unwrap_or_else(|| {
                todo!();
                // map(elementTypes, _ => ElementFlags.Required)
            }),
            readonly,
            namedMemberDeclarations,
        );
        if tupleTarget == self.emptyGenericType {
            self.emptyObjectType
        } else if !elementTypes.is_empty() {
            self.createNormalizedTypeReference(tupleTarget, Some(elementTypes))
        } else {
            tupleTarget
        }
    }

    fn getTupleTargetType(
        &mut self,
        elementFlags: Vec<ElementFlags>,
        readonly: bool,
        namedMemberDeclarations: Option<Vec<BoundNode>>,
    ) -> TypeId {
        if elementFlags.len() == 1 && elementFlags[0].intersects(ElementFlags::Rest) {
            // [...X[]] is equivalent to just X[]
            return if readonly {
                self.globalReadonlyArrayType()
            } else {
                self.globalArrayType()
            };
        }
        let mut make_key = || {
            let mut s = ahash::AHasher::default();
            // $val.hash(&mut s);
            // TODO: could this loop be replaced with just hashing the vec? e.g. `elementFlags.hash(&mut s)`
            for &f in elementFlags.iter() {
                if f.intersects(ElementFlags::Required) {
                    '#'.hash(&mut s);
                } else if f.intersects(ElementFlags::Optional) {
                    '?'.hash(&mut s);
                } else if f.intersects(ElementFlags::Rest) {
                    '.'.hash(&mut s);
                } else {
                    '*'.hash(&mut s);
                }
            }
            readonly.hash(&mut s);
            namedMemberDeclarations.hash(&mut s);
            TupleTypeKey(s.finish())
        };
        let key = make_key();
        match self.tupleTypes.get(&key) {
            Some(ty) => *ty,
            None => {
                let ty =
                    self.createTupleTargetType(elementFlags, readonly, namedMemberDeclarations);
                self.tupleTypes.insert(key, ty);
                ty
            }
        }
    }

    // We represent tuple types as type references to synthesized generic interface types created by
    // this function. The types are of the form:
    //
    //   interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
    //
    // Note that the generic type created by this function has no symbol associated with it. The same
    // is true for each of the synthesized type parameters.
    fn createTupleTargetType(
        &mut self,
        elementFlags: Vec<ElementFlags>,
        readonly: bool,
        namedMemberDeclarations: Option<Vec<BoundNode>>,
    ) -> TypeId {
        let arity = elementFlags.len();
        let minLength = elementFlags
            .iter()
            .filter(|f| f.intersects(ElementFlags::Required | ElementFlags::Variadic))
            .count();
        let mut typeParameters = None;
        let mut properties = Vec::new();
        let mut combinedFlags = ElementFlags::default();
        if arity != 0 {
            let mut type_params = Vec::with_capacity(arity);
            for i in 0..arity {
                let typeParameter = self.createTypeParameter(None);
                type_params.push(typeParameter);
                let flags = elementFlags[i];
                combinedFlags |= flags;
                if !combinedFlags.intersects(ElementFlags::Variable) {
                    let property = self.createSymbol(
                        SymbolFlags::Property
                            | (if flags.intersects(ElementFlags::Optional) {
                                SymbolFlags::Optional
                            } else {
                                SymbolFlags::default()
                            }),
                        JsWord::from(i.to_string()),
                        Some(if readonly {
                            CheckFlags::Readonly
                        } else {
                            CheckFlags::default()
                        }),
                    );
                    // TODO: maybe use d.get(i) rather that d[i]; i'm not sure if the index will always be in-bounds.
                    self.get_transient_sym_mut(property)
                        .symbol_links
                        .tupleLabelDeclaration =
                        namedMemberDeclarations.as_ref().map(|d| d[i].clone());
                    self.get_transient_sym_mut(property).symbol_links.ty = Some(typeParameter);
                    properties.push(property);
                }
            }
            typeParameters = Some(type_params);
        }
        let fixedLength = properties.len();
        let lengthSymbol = self.createSymbol(SymbolFlags::Property, js_word!("length"), None);
        if combinedFlags.intersects(ElementFlags::Variable) {
            self.get_transient_sym_mut(lengthSymbol).symbol_links.ty = Some(self.numberType);
        } else {
            todo!();
            // let literalTypes = [];
            // for (let i = minLength; i <= arity; i++) {
            //     literalTypes.push(getNumberLiteralType(i))
            // };
            // lengthSymbol.ty = getUnionType(literalTypes);
        }
        properties.push(lengthSymbol);

        // +1 because thisType gets allocated first.
        let ty_id = self.types.next_index() + 1;

        let thisType = Type::TypeParameter(TypeParameter {
            instantiable_type: InstantiableType::default(),
            type_base: TypeBase::new(TypeFlags::TypeParameter, None),
            constraint: Some(ty_id),
            default: None,
            target: None,
            mapper: None,
            isThisType: true,
            resolvedDefaultType: None,
        });
        let thisType = self.types.push(thisType);

        let instantiations = new_ahash_map![(self.getTypeListId(typeParameters.as_ref()), ty_id,)];

        let typeParameters = typeParameters.map(Rc::new);

        let ty = TupleType {
            generic_type_base: GenericTypeBase {
                instantiations,
                variances: Default::default(),
            },
            type_reference: TypeReferenceBase {
                target: Some(ty_id),
                resolvedTypeArguments: typeParameters.clone(),
                ..Default::default()
            },
            object_type_base: ObjectTypeBase::new(ObjectFlags::Tuple | ObjectFlags::Reference),
            type_base: TypeBase::new(TypeFlags::Object, None),
            interface_type: InterfaceTypeBase {
                localTypeParameters: typeParameters.clone(),
                typeParameters,
                thisType: Some(thisType),
                declared_members: Some(DeclaredMembers {
                    declaredProperties: Rc::new(properties),
                    declaredCallSignatures: Default::default(),
                    declaredConstructSignatures: Default::default(),
                    declaredIndexInfos: Default::default(),
                }),
                ..Default::default()
            },
            elementFlags: Rc::new(elementFlags),
            minLength,
            fixedLength,
            hasRestElement: combinedFlags.intersects(ElementFlags::Variable),
            combinedFlags,
            readonly,
            labeledElementDeclarations: namedMemberDeclarations.map(Rc::new).unwrap_or_default(),
        };

        self.types.push(Type::TupleType(ty))
    }

    fn createNormalizedTypeReference(
        &mut self,
        target: TypeId,
        typeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        if self.types[target]
            .get_object_flags()
            .intersects(ObjectFlags::Tuple)
        {
            todo!();
            // self.createNormalizedTupleType(target, typeArguments.unwrap())
        } else {
            self.createTypeReference(target, typeArguments)
        }
    }

    // TODO:
    // createNormalizedTupleType
    // TODO:
    // sliceTupleType
    // TODO:
    // getKnownKeysOfTupleType
    // TODO:
    // getStartElementCount
    // TODO:
    // getEndElementCount
    // TODO:
    // getTypeFromOptionalTypeNode
    // TODO:
    // getTypeId

    fn addTypeToUnion(
        &mut self,
        typeSet: &mut Vec<TypeId>,
        mut includes: TypeFlags,
        ty: TypeId,
    ) -> TypeFlags {
        let flags = self.types[ty].get_flags();
        if flags.intersects(TypeFlags::Union) {
            if self.isNamedUnionType(ty) {
                includes |= TypeFlags::Union;
            }
            return self.addTypesToUnion(
                typeSet,
                includes,
                self.types[ty]
                    .unwrap_as_union_or_intersection()
                    .types
                    .clone()
                    .as_ref(),
            );
        }
        // We ignore 'never' types in unions
        if !flags.intersects(TypeFlags::Never) {
            includes |= flags & TypeFlags::IncludesMask;
            if ty == self.wildcardType {
                includes |= TypeFlags::IncludesWildcard
            };
            if !self.strictNullChecks && flags.intersects(TypeFlags::Nullable) {
                if !self.types[ty]
                    .get_object_flags()
                    .intersects(ObjectFlags::ContainsWideningType)
                {
                    includes |= TypeFlags::IncludesNonWideningType
                };
            } else {
                // TODO: this whole block (and binarySearchKey's impl) is very janky. Try to refactor using Vec::binary_search.
                // See `insertType`
                let len = typeSet.len();
                let index = if len != 0 && ty > typeSet[len - 1] {
                    !(len as isize)
                } else {
                    binarySearchKey(typeSet, ty, |t, _| t, |a, b| a.cmp(&b), None)
                };
                if index < 0 {
                    typeSet.insert(!index as usize, ty);
                }
            }
        }
        includes
    }

    // Add the given types to the given type set. Order is preserved, duplicates are removed,
    // and nested types of the given kind are flattened into the set.
    fn addTypesToUnion(
        &mut self,
        typeSet: &mut Vec<TypeId>,
        mut includes: TypeFlags,
        types: &[TypeId],
    ) -> TypeFlags {
        for ty in types {
            includes = self.addTypeToUnion(typeSet, includes, *ty);
        }
        includes
    }

    fn removeSubtypes(&mut self, types: Vec<TypeId>, hasObjectTypes: bool) -> Option<Vec<TypeId>> {
        let id = self.getTypeListId(Some(&types));
        let cached = self.subtypeReductionCache.get(&id);
        if cached.is_some() {
            return cached.cloned();
        }
        // We assume that redundant primitive types have already been removed from the types array and that there
        // are no any and unknown types in the array. Thus, the only possible supertypes for primitive types are empty
        // object types, and if none of those are present we can exclude primitive types from the subtype check.
        let hasEmptyObject = hasObjectTypes
            && types.iter().any(|&t| {
                self.types[t].get_flags().intersects(TypeFlags::Object)
                    && !self.isGenericMappedType(t)
                    && {
                        let resolved = self.resolveStructuredTypeMembers(t);
                        self.isEmptyResolvedType(resolved)
                    }
            });
        let len = types.len();
        let mut i = len;
        let mut count = 0;
        while i > 0 {
            i -= 1;
            let source = types[i];
            if hasEmptyObject
                || self.types[source]
                    .get_flags()
                    .intersects(TypeFlags::StructuredOrInstantiable)
            {
                todo!();
                // Find the first property with a unit type, if any. When constituents have a property by the same name
                // but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype
                // reduction of large discriminated union types.
                // const keyProperty = source.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) ?
                //     find(getPropertiesOfType(source), p => isUnitType(getTypeOfSymbol(p))) :
                //     undefined;
                // const keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));
                // for (const target of types) {
                //     if (source !== target) {
                //         if (count === 100000) {
                //             // After 100000 subtype checks we estimate the remaining amount of work by assuming the
                //             // same ratio of checks per element. If the estimated number of remaining type checks is
                //             // greater than 1M we deem the union type too complex to represent. This for example
                //             // caps union types at 1000 unique object types.
                //             const estimatedCount = (count / (len - i)) * len;
                //             if (estimatedCount > 1000000) {
                //                 tracing?.instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit", { typeIds: types.map(t => t.id) });
                //                 error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                //                 return undefined;
                //             }
                //         }
                //         count++;
                //         if (keyProperty && target.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)) {
                //             const t = getTypeOfPropertyOfType(target, keyProperty.escapedName);
                //             if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {
                //                 continue;
                //             }
                //         }
                //         if (isTypeRelatedTo(source, target, strictSubtypeRelation) && (
                //             !(getObjectFlags(getTargetType(source)) & ObjectFlags.Class) ||
                //             !(getObjectFlags(getTargetType(target)) & ObjectFlags.Class) ||
                //             isTypeDerivedFrom(source, target))) {
                //             orderedRemoveItemAt(types, i);
                //             break;
                //         }
                //     }
                // }
            }
        }
        self.subtypeReductionCache.insert(id, types.clone());
        Some(types)
    }

    fn removeRedundantLiteralTypes(
        &self,
        types: &mut Vec<TypeId>,
        includes: TypeFlags,
        reduceVoidUndefined: bool,
    ) {
        let mut i = types.len();
        while i > 0 {
            i -= 1;
            let t = types[i];
            let flags = self.types[t].get_flags();
            let remove = flags.intersects(
                TypeFlags::StringLiteral | TypeFlags::TemplateLiteral | TypeFlags::StringMapping,
            ) && includes.intersects(TypeFlags::String)
                || flags.intersects(TypeFlags::NumberLiteral)
                    && includes.intersects(TypeFlags::Number)
                || flags.intersects(TypeFlags::BigIntLiteral)
                    && includes.intersects(TypeFlags::BigInt)
                || flags.intersects(TypeFlags::UniqueESSymbol)
                    && includes.intersects(TypeFlags::ESSymbol)
                || reduceVoidUndefined
                    && flags.intersects(TypeFlags::Undefined)
                    && includes.intersects(TypeFlags::Void)
                || self.isFreshLiteralType(t)
                    && containsType(types, self.types[t].get_literal_regular_type());
            if remove {
                types.remove(i);
            }
        }
    }

    // TODO:
    // removeStringLiteralsMatchedByTemplateLiterals

    fn isNamedUnionType(&self, ty: TypeId) -> bool {
        self.types[ty].get_flags().intersects(TypeFlags::Union)
            && (self.types[ty].get_aliasSymbol().is_some()
                || self.types[ty].unwrap_as_union_type_base().origin.is_some())
    }

    // TODO:
    // addNamedUnions
    // TODO:
    // createOriginUnionOrIntersectionType

    // We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
    // flag is specified we also reduce the constituent type set to only include types that aren't subtypes
    // of other types. Subtype reduction is expensive for large union types and is possible only when union
    // types are known not to circularly reference themselves (as is the case with union types created by
    // expression constructs such as array literals and the || and ?: operators). Named types can
    // circularly reference themselves and therefore cannot be subtype reduced during their declaration.
    // For example, "type Item = string | (() => Item" is a named type that circularly references itself.
    fn getUnionType(
        &mut self,
        types: &[TypeId],
        unionReduction: Option<UnionReduction>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
        origin: Option<TypeId>,
    ) -> TypeId {
        let unionReduction = unionReduction.unwrap_or(UnionReduction::Literal);
        if types.is_empty() {
            return self.neverType;
        }
        if types.len() == 1 {
            return types[0];
        }
        let mut typeSet = Vec::new();
        let includes = self.addTypesToUnion(&mut typeSet, TypeFlags::default(), types);
        if unionReduction != UnionReduction::None {
            if includes.intersects(TypeFlags::AnyOrUnknown) {
                todo!();
                // return includes & TypeFlags::Any ?
                //     includes & TypeFlags::IncludesWildcard ? wildcardType : anyType :
                //     includes & TypeFlags::Null || containsType(typeSet, unknownType) ? unknownType : nonNullUnknownType;
            }
            if self.exactOptionalPropertyTypes && includes.intersects(TypeFlags::Undefined) {
                todo!();
                // let missingIndex = binarySearch(typeSet, missingType, getTypeId, compareValues);
                // if (missingIndex >= 0 && containsType(typeSet, undefinedType)) {
                //     orderedRemoveItemAt(typeSet, missingIndex);
                // }
            }
            if includes.intersects(
                TypeFlags::Literal
                    | TypeFlags::UniqueESSymbol
                    | TypeFlags::TemplateLiteral
                    | TypeFlags::StringMapping,
            ) || includes.intersects(TypeFlags::Void)
                && includes.intersects(TypeFlags::Undefined)
            {
                self.removeRedundantLiteralTypes(
                    &mut typeSet,
                    includes,
                    unionReduction == UnionReduction::Subtype,
                );
            }
            if includes.intersects(TypeFlags::StringLiteral)
                && includes.intersects(TypeFlags::TemplateLiteral)
            {
                todo!();
                // removeStringLiteralsMatchedByTemplateLiterals(typeSet);
            }
            if unionReduction == UnionReduction::Subtype {
                if let Some(types) =
                    self.removeSubtypes(typeSet, includes.intersects(TypeFlags::Object))
                {
                    typeSet = types;
                } else {
                    return self.errorType;
                }
            }
            if typeSet.is_empty() {
                return if includes.intersects(TypeFlags::Null) {
                    if includes.intersects(TypeFlags::IncludesNonWideningType) {
                        self.nullType
                    } else {
                        self.nullWideningType
                    }
                } else if includes.intersects(TypeFlags::Undefined) {
                    if includes.intersects(TypeFlags::IncludesNonWideningType) {
                        self.undefinedType
                    } else {
                        self.undefinedWideningType
                    }
                } else {
                    self.neverType
                };
            }
        }
        if origin.is_none() && includes.intersects(TypeFlags::Union) {
            todo!();
            // const namedUnions: Type[] = [];
            // addNamedUnions(namedUnions, types);
            // const reducedTypes: Type[] = [];
            // for (const t of typeSet) {
            //     if (!some(namedUnions, union => containsType((union as UnionType).types, t))) {
            //         reducedTypes.push(t);
            //     }
            // }
            // if (!aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0) {
            //     return namedUnions[0];
            // }
            // // We create a denormalized origin type only when the union was created from one or more named unions
            // // (unions with alias symbols or origins) and when there is no overlap between those named unions.
            // const namedTypesCount = reduceLeft(namedUnions, (sum, union) => sum + (union as UnionType).types.length, 0);
            // if (namedTypesCount + reducedTypes.length === typeSet.length) {
            //     for (const t of namedUnions) {
            //         insertType(reducedTypes, t);
            //     }
            //     origin = createOriginUnionOrIntersectionType(TypeFlags::Union, reducedTypes);
            // }
        }
        let objectFlags = (if includes.intersects(TypeFlags::NotPrimitiveUnion) {
            ObjectFlags::empty()
        } else {
            ObjectFlags::PrimitiveUnion
        }) | (if includes.intersects(TypeFlags::Intersection) {
            ObjectFlags::ContainsIntersections
        } else {
            ObjectFlags::empty()
        });
        self.getUnionTypeFromSortedList(
            typeSet,
            objectFlags,
            aliasSymbol,
            aliasTypeArguments,
            origin,
        )
    }

    fn getUnionOrIntersectionTypePredicate(
        &mut self,
        signatures: &[SignatureId],
        kind: Option<TypeFlags>,
    ) -> Option<TypePredicate> {
        let mut first = None;
        let mut types = Vec::new();
        for &sig in signatures {
            let pred = self.getTypePredicateOfSignature(sig);
            if pred.is_none()
                || matches!(
                    pred,
                    Some(
                        TypePredicate::AssertsThisTypePredicate { .. }
                            | TypePredicate::AssertsIdentifierTypePredicate { .. }
                    )
                )
            {
                if kind != Some(TypeFlags::Intersection) {
                    continue;
                } else {
                    return None; // intersections demand all members be type predicates for the result to have a predicate
                }
            }
            let pred = pred.unwrap();

            if let Some(first) = &first {
                if !typePredicateKindsMatch(first, &pred) {
                    // No common type predicate.
                    return None;
                }
            } else {
                first = Some(pred.clone());
            }
            types.push(pred.ty().unwrap());
        }
        if let Some(first) = first {
            let compositeType = self.getUnionOrIntersectionType(&types, kind, None);
            Some(match first {
                TypePredicate::ThisTypePredicate { .. }
                | TypePredicate::AssertsThisTypePredicate { .. } => unreachable!(),
                TypePredicate::IdentifierTypePredicate {
                    parameterName,
                    parameterIndex,
                    ..
                } => TypePredicate::IdentifierTypePredicate {
                    parameterName,
                    parameterIndex,
                    ty: compositeType,
                },
                TypePredicate::AssertsIdentifierTypePredicate {
                    parameterName,
                    parameterIndex,
                    ..
                } => TypePredicate::AssertsIdentifierTypePredicate {
                    parameterName,
                    parameterIndex,
                    ty: Some(compositeType),
                },
            })
        } else {
            // No signatures had a type predicate.
            None
        }
    }

    /// This function assumes the constituent type list is sorted and deduplicated.
    fn getUnionTypeFromSortedList(
        &mut self,
        types: Vec<TypeId>,
        objectFlags: ObjectFlags,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
        origin: Option<TypeId>,
    ) -> TypeId {
        if types.is_empty() {
            return self.neverType;
        }
        if types.len() == 1 {
            return types[0];
        }
        let typeKey = if let Some(origin) = origin {
            if self.types[origin].get_flags().intersects(TypeFlags::Union) {
                let types = self.types[origin]
                    .unwrap_as_union_or_intersection()
                    .types
                    .as_ref();
                hash!['|', self.getTypeListId(Some(types))]
            } else if self.types[origin]
                .get_flags()
                .intersects(TypeFlags::Intersection)
            {
                let types = self.types[origin]
                    .unwrap_as_union_or_intersection()
                    .types
                    .as_ref();
                hash!['&', self.getTypeListId(Some(types))]
            } else {
                todo!();
                // origin type id alone is insufficient, as `keyof x` may resolve to multiple WIP values while `x` is still resolving
                // hash![
                //     '#',
                //     (origin as IndexType).ty,
                //     '|',
                //     self.getTypeListId(Some(&types))
                // ]
            }
        } else {
            self.getTypeListId(Some(&types)).0
        };
        let id = UnionTypeKey(hash![
            typeKey,
            self.getAliasId(aliasSymbol, aliasTypeArguments.as_ref().map(|a| a.as_ref()))
        ]);
        match self.unionTypes.get(&id) {
            Some(ty) => *ty,
            None => {
                let types = Rc::new(types);
                let mut ty = UnionType {
                    union_or_intersection_type: UnionOrIntersectionType {
                        objectFlags: objectFlags
                            | self.getPropagatingFlagsOfTypes(&types, TypeFlags::Nullable),
                        types: types.clone(),
                        ..Default::default()
                    },
                    type_base: TypeBase::new(TypeFlags::Union, None),
                    union_type_base: UnionTypeBase {
                        origin,
                        ..Default::default()
                    },
                };
                ty.type_base.aliasSymbol = aliasSymbol;
                ty.type_base.aliasTypeArguments = aliasTypeArguments;
                if types.len() == 2
                    && self.types[types[0]]
                        .get_flags()
                        .intersects(TypeFlags::BooleanLiteral)
                    && self.types[types[1]]
                        .get_flags()
                        .intersects(TypeFlags::BooleanLiteral)
                {
                    ty.type_base.flags |= TypeFlags::Boolean;
                    // TODO:
                    // (ty as UnionType & IntrinsicType).intrinsicName = "boolean";
                }
                let ty = self.types.push(Type::UnionType(ty));
                self.unionTypes.insert(id, ty);
                ty
            }
        }
    }

    fn getTypeFromUnionTypeNode(&mut self, node: Rc<TsUnionType>) -> TypeId {
        let bound_node = BoundNode::TsUnionType(node.clone());
        match self.getNodeLinks(bound_node.clone()).resolvedType {
            Some(resolvedType) => resolvedType,
            None => {
                let aliasSymbol = self.getAliasSymbolForTypeNode(&bound_node);
                // TODO: bad collect
                let types = node
                    .types
                    .iter()
                    .map(|t| self.getTypeFromTypeNode(t.bind(bound_node.clone())))
                    .collect::<Vec<_>>();
                let aliasTypeArguments = self.getTypeArgumentsForAliasSymbol(aliasSymbol);
                let resolvedType = self.getUnionType(
                    &types,
                    Some(UnionReduction::Literal),
                    aliasSymbol,
                    aliasTypeArguments,
                    None,
                );
                self.getNodeLinks_mut(node.into()).resolvedType = Some(resolvedType);
                resolvedType
            }
        }
    }

    fn addTypeToIntersection(
        &mut self,
        typeSet: &mut IndexSet<TypeId>,
        mut includes: TypeFlags,
        mut ty: TypeId,
    ) -> TypeFlags {
        let flags = self.types[ty].get_flags();
        if flags.intersects(TypeFlags::Intersection) {
            let types = self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone();
            return self.addTypesToIntersection(typeSet, includes, &types);
        }
        if self.isEmptyAnonymousObjectType(ty) {
            if !includes.intersects(TypeFlags::IncludesEmptyObject) {
                includes |= TypeFlags::IncludesEmptyObject;
                typeSet.insert(ty);
            }
        } else {
            if flags.intersects(TypeFlags::AnyOrUnknown) {
                if ty == self.wildcardType {
                    includes |= TypeFlags::IncludesWildcard
                };
            } else if self.strictNullChecks || !flags.intersects(TypeFlags::Nullable) {
                if self.exactOptionalPropertyTypes && ty == self.missingType {
                    includes |= TypeFlags::IncludesMissingType;
                    ty = self.undefinedType;
                }
                if !typeSet.contains(&ty) {
                    if self.types[ty].get_flags().intersects(TypeFlags::Unit)
                        && includes.intersects(TypeFlags::Unit)
                    {
                        // We have seen two distinct unit types which means we should reduce to an
                        // empty intersection. Adding TypeFlags::NonPrimitive causes that to happen.
                        includes |= TypeFlags::NonPrimitive;
                    }
                    typeSet.insert(ty);
                }
            }
            includes |= flags & TypeFlags::IncludesMask;
        }
        includes
    }

    // Add the given types to the given type set. Order is preserved, freshness is removed from literal
    // types, duplicates are removed, and nested types of the given kind are flattened into the set.
    fn addTypesToIntersection(
        &mut self,
        typeSet: &mut IndexSet<TypeId>,
        mut includes: TypeFlags,
        types: &[TypeId],
    ) -> TypeFlags {
        for &ty in types {
            let ty = self.getRegularTypeOfLiteralType(ty);
            includes = self.addTypeToIntersection(typeSet, includes, ty);
        }
        includes
    }

    // TODO:
    // removeRedundantPrimitiveTypes

    // Check that the given type has a match in every union. A given type is matched by
    // an identical type, and a literal type is additionally matched by its corresponding
    // primitive type.
    fn eachUnionContains(&self, unionTypes: &[TypeId], ty: TypeId) -> bool {
        let ty_flags = self.types[ty].get_flags();
        for u in unionTypes {
            let types = self.types[*u]
                .unwrap_as_union_or_intersection()
                .types
                .as_ref();
            if !containsType(types, ty) {
                let primitive = if ty_flags.intersects(TypeFlags::StringLiteral) {
                    Some(self.stringType)
                } else if ty_flags.intersects(TypeFlags::NumberLiteral) {
                    Some(self.numberType)
                } else if ty_flags.intersects(TypeFlags::BigIntLiteral) {
                    Some(self.bigintType)
                } else if ty_flags.intersects(TypeFlags::UniqueESSymbol) {
                    Some(self.esSymbolType)
                } else {
                    None
                };
                if primitive.is_none() || !containsType(types, primitive.unwrap()) {
                    return false;
                }
            }
        }
        true
    }

    /// Returns `true` if the intersection of the template literals and string literals is the empty set, and should reduce to `never`.
    ///
    /// E.g. the following will reduce to `never`:
    /// ```js
    /// `get${string}` & "setX"
    /// ```
    fn extractRedundantTemplateLiterals(&mut self, types: &mut Vec<TypeId>) -> bool {
        let mut i = types.len();
        // TODO: bad collect:
        let literals = types
            .iter()
            .cloned()
            .filter(|&t| {
                self.types[t]
                    .get_flags()
                    .intersects(TypeFlags::StringLiteral)
            })
            .collect::<Vec<_>>();
        while i > 0 {
            i -= 1;
            let t = types[i];
            if !self.types[t]
                .get_flags()
                .intersects(TypeFlags::TemplateLiteral)
            {
                continue;
            };
            for &t2 in &literals {
                if self.isTypeSubtypeOf(t2, t) {
                    // eg, ``get${T}` & "getX"` is just `"getX"`
                    types.remove(i);
                    break;
                } else if self.isPatternLiteralType(t) {
                    return true;
                }
            }
        }
        false
    }

    fn eachIsUnionContaining(&self, types: &[TypeId], flag: TypeFlags) -> bool {
        types.iter().all(|&t| {
            if self.types[t].get_flags().intersects(TypeFlags::Union) {
                self.types[t]
                    .unwrap_as_union_or_intersection()
                    .types
                    .iter()
                    .any(|&tt| self.types[tt].get_flags().intersects(flag))
            } else {
                false
            }
        })
    }

    // TODO:
    // removeFromEach

    // If the given list of types contains more than one union of primitive types, replace the
    // first with a union containing an intersection of those primitive types, then remove the
    // other unions and return true. Otherwise, do nothing and return false.
    fn intersectUnionsOfPrimitiveTypes(&mut self, types: &mut Vec<TypeId>) -> bool {
        let mut unionTypes = None;
        let index = types.iter().position(|&t| {
            self.types[t]
                .get_object_flags()
                .intersects(ObjectFlags::PrimitiveUnion)
        });
        let index = match index {
            Some(index) => index,
            None => return false,
        };
        let mut i = index + 1;
        // Remove all but the first union of primitive types and collect them in
        // the unionTypes array.
        while i < types.len() {
            let t = types[i];
            if self.types[t]
                .get_object_flags()
                .intersects(ObjectFlags::PrimitiveUnion)
            {
                unionTypes.get_or_insert_with(|| vec![types[index]]).push(t);
                types.remove(i);
            } else {
                i += 1;
            }
        }
        let unionTypes = match unionTypes {
            Some(unionTypes) => unionTypes,
            // Return false if there was only one union of primitive types
            None => return false,
        };
        // We have more than one union of primitive types, now intersect them. For each
        // type in each union we check if the type is matched in every union and if so
        // we include it in the result.
        let mut checked = Vec::new();
        let mut result = Vec::new();
        for &u in &unionTypes {
            for &t in self.types[u].unwrap_as_union_or_intersection().types.iter() {
                if insertType(&mut checked, t) {
                    if self.eachUnionContains(&unionTypes, t) {
                        insertType(&mut result, t);
                    }
                }
            }
        }
        // Finally replace the first union with the result
        types[index] =
            self.getUnionTypeFromSortedList(result, ObjectFlags::PrimitiveUnion, None, None, None);
        true
    }

    fn createIntersectionType(
        &mut self,
        types: Vec<TypeId>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let types = Rc::new(types);
        let objectFlags = self.getPropagatingFlagsOfTypes(&types, TypeFlags::Nullable);
        let ty = IntersectionType {
            union_or_intersection_type: UnionOrIntersectionType {
                objectFlags,
                types,
                ..UnionOrIntersectionType::default()
            },
            type_base: TypeBase {
                flags: TypeFlags::Intersection,
                aliasSymbol,
                aliasTypeArguments,
                ..TypeBase::default()
            },
            resolvedApparentType: None,
        };
        self.types.push(Type::IntersectionType(ty))
    }

    // We normalize combinations of intersection and union types based on the distributive property of the '&'
    // operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
    // types with union type constituents into equivalent union types with intersection type constituents and
    // effectively ensure that union types are always at the top level in type representations.
    //
    // We do not perform structural deduplication on intersection types. Intersection types are created only by the &
    // type operator and we can't reduce those because we want to support recursive intersection types. For example,
    // a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
    // Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
    // for intersections of types with signatures can be deterministic.
    fn getIntersectionType(
        &mut self,
        types: &[TypeId],
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let mut typeMembershipMap = IndexSet::default();
        let includes =
            self.addTypesToIntersection(&mut typeMembershipMap, TypeFlags::empty(), types);
        let mut typeSet = typeMembershipMap.into_ordered_vec();
        // An intersection type is considered empty if it contains
        // the type never, or
        // more than one unit type or,
        // an object type and a nullable type (null or undefined), or
        // a string-like type and a type known to be non-string-like, or
        // a number-like type and a type known to be non-number-like, or
        // a symbol-like type and a type known to be non-symbol-like, or
        // a void-like type and a type known to be non-void-like, or
        // a non-primitive type and a type known to be primitive.
        if includes.intersects(TypeFlags::Never) {
            todo!();
            // return contains(typeSet, silentNeverType) ? silentNeverType : neverType;
        }
        if self.strictNullChecks
            && includes.intersects(TypeFlags::Nullable)
            && includes.intersects(
                TypeFlags::Object | TypeFlags::NonPrimitive | TypeFlags::IncludesEmptyObject,
            )
            || includes.intersects(TypeFlags::NonPrimitive)
                && includes.intersects(TypeFlags::DisjointDomains & !TypeFlags::NonPrimitive)
            || includes.intersects(TypeFlags::StringLike)
                && includes.intersects(TypeFlags::DisjointDomains & !TypeFlags::StringLike)
            || includes.intersects(TypeFlags::NumberLike)
                && includes.intersects(TypeFlags::DisjointDomains & !TypeFlags::NumberLike)
            || includes.intersects(TypeFlags::BigIntLike)
                && includes.intersects(TypeFlags::DisjointDomains & !TypeFlags::BigIntLike)
            || includes.intersects(TypeFlags::ESSymbolLike)
                && includes.intersects(TypeFlags::DisjointDomains & !TypeFlags::ESSymbolLike)
            || includes.intersects(TypeFlags::VoidLike)
                && includes.intersects(TypeFlags::DisjointDomains & !TypeFlags::VoidLike)
        {
            return self.neverType;
        }
        if includes.intersects(TypeFlags::TemplateLiteral)
            && includes.intersects(TypeFlags::StringLiteral)
            && self.extractRedundantTemplateLiterals(&mut typeSet)
        {
            return self.neverType;
        }
        if includes.intersects(TypeFlags::Any) {
            todo!();
            // return includes & TypeFlags::IncludesWildcard ? wildcardType : anyType;
        }
        if !self.strictNullChecks && includes.intersects(TypeFlags::Nullable) {
            return if includes.intersects(TypeFlags::Undefined) {
                self.undefinedType
            } else {
                self.nullType
            };
        }
        if includes.intersects(TypeFlags::String) && includes.intersects(TypeFlags::StringLiteral)
            || includes.intersects(TypeFlags::Number)
                && includes.intersects(TypeFlags::NumberLiteral)
            || includes.intersects(TypeFlags::BigInt)
                && includes.intersects(TypeFlags::BigIntLiteral)
            || includes.intersects(TypeFlags::ESSymbol)
                && includes.intersects(TypeFlags::UniqueESSymbol)
        {
            todo!();
            // removeRedundantPrimitiveTypes(typeSet, includes);
        }
        if includes.intersects(TypeFlags::IncludesEmptyObject)
            && includes.intersects(TypeFlags::Object)
        {
            todo!();
            // orderedRemoveItemAt(typeSet, findIndex(typeSet, isEmptyAnonymousObjectType));
        }
        if includes.intersects(TypeFlags::IncludesMissingType) {
            todo!();
            // typeSet[typeSet.indexOf(undefinedType)] = missingType;
        }
        if typeSet.is_empty() {
            return self.unknownType;
        }
        if typeSet.len() == 1 {
            return typeSet[0];
        }
        let make_intersection_type_key = || {
            // TODO: a bit janky:
            let type_list = self.getTypeListId(Some(&typeSet));
            let alias_id =
                self.getAliasId(aliasSymbol, aliasTypeArguments.as_ref().map(|v| v.as_ref()));
            IntersectionTypeKey(hash![type_list, alias_id])
        };
        let id = make_intersection_type_key();
        match self.intersectionTypes.get(&id) {
            Some(result) => *result,
            None => {
                let result = if includes.intersects(TypeFlags::Union) {
                    if self.intersectUnionsOfPrimitiveTypes(&mut typeSet) {
                        todo!();
                        // When the intersection creates a reduced set (which might mean that *all* union types have
                        // disappeared), we restart the operation to get a new set of combined flags. Once we have
                        // reduced we'll never reduce again, so this occurs at most once.
                        // getIntersectionType(typeSet, aliasSymbol, aliasTypeArguments)
                    } else if self.eachIsUnionContaining(&typeSet, TypeFlags::Undefined) {
                        todo!();
                        // let undefinedOrMissingType = exactOptionalPropertyTypes && some(typeSet, t => containsType((t as UnionType).types, missingType)) ? missingType : undefinedType;
                        // removeFromEach(typeSet, TypeFlags::Undefined);
                        // getUnionType([getIntersectionType(typeSet), undefinedOrMissingType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments)
                    } else if self.eachIsUnionContaining(&typeSet, TypeFlags::Null) {
                        todo!();
                        // removeFromEach(typeSet, TypeFlags::Null);
                        // getUnionType([getIntersectionType(typeSet), nullType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments)
                    } else {
                        todo!();
                        // We are attempting to construct a type of the form X & (A | B) & (C | D). Transform this into a type of
                        // the form X & A & C | X & A & D | X & B & C | X & B & D. If the estimated size of the resulting union type
                        // exceeds 100000 constituents, report an error.
                        // if (!checkCrossProductUnion(typeSet)) {
                        //     return errorType;
                        // }
                        // let constituents = getCrossProductIntersections(typeSet);
                        // // We attach a denormalized origin type when at least one constituent of the cross-product union is an
                        // // intersection (i.e. when the intersection didn't just reduce one or more unions to smaller unions).
                        // let origin = some(constituents, t => !!(t.flags & TypeFlags::Intersection)) ? createOriginUnionOrIntersectionType(TypeFlags::Intersection, typeSet) : undefined;
                        // getUnionType(constituents, UnionReduction.Literal, aliasSymbol, aliasTypeArguments, origin)
                    }
                } else {
                    self.createIntersectionType(typeSet, aliasSymbol, aliasTypeArguments)
                };
                self.intersectionTypes.insert(id, result);
                result
            }
        }
    }

    // TODO:
    // getCrossProductUnionSize
    // TODO:
    // checkCrossProductUnion
    // TODO:
    // getCrossProductIntersections

    fn getTypeFromIntersectionTypeNode(&mut self, node: Rc<TsIntersectionType>) -> TypeId {
        let bound_node = BoundNode::TsIntersectionType(node.clone());
        match self.getNodeLinks(bound_node.clone()).resolvedType {
            Some(t) => t,
            None => {
                let aliasSymbol = self.getAliasSymbolForTypeNode(&bound_node);
                // TODO: bad collect
                let types = node
                    .types
                    .iter()
                    .map(|t| self.getTypeFromTypeNode(t.bind(bound_node.clone())))
                    .collect::<Vec<_>>();
                let aliasTypeArguments = self.getTypeArgumentsForAliasSymbol(aliasSymbol);
                let resolvedType =
                    self.getIntersectionType(&types, aliasSymbol, aliasTypeArguments);
                self.getNodeLinks_mut(bound_node).resolvedType = Some(resolvedType);
                resolvedType
            }
        }
    }

    fn createIndexType(&mut self, ty: TypeId, stringsOnly: bool) -> TypeId {
        let ty = IndexType {
            instantiable_type: InstantiableType::default(),
            type_base: TypeBase::new(TypeFlags::Index, None),
            ty,
            stringsOnly,
        };
        self.types.push(Type::IndexType(ty))
    }

    fn createOriginIndexType(&mut self, ty: TypeId) -> TypeId {
        let res = IndexType {
            instantiable_type: InstantiableType::default(),
            type_base: createOriginType(TypeFlags::Index),
            ty,
            stringsOnly: false,
        };
        self.types.push(Type::IndexType(res))
    }

    fn getIndexTypeForGenericType(&mut self, ty: TypeId, stringsOnly: bool) -> TypeId {
        macro_rules! get_or_set_prop {
            ($ty:expr, $prop:ident) => {
                match $ty.$prop {
                    Some($prop) => $prop,
                    None => {
                        let $prop = self.createIndexType(ty, stringsOnly);
                        $ty.$prop = Some($prop);
                        $prop
                    }
                }
            };
        }
        if stringsOnly {
            if self.types[ty].as_instantiable_type_mut().is_some() {
                get_or_set_prop!(
                    self.types[ty].as_instantiable_type_mut().unwrap(),
                    resolvedStringIndexType
                )
            } else {
                get_or_set_prop!(
                    self.types[ty].unwrap_as_union_or_intersection_mut(),
                    resolvedStringIndexType
                )
            }
        } else {
            if self.types[ty].as_instantiable_type_mut().is_some() {
                get_or_set_prop!(
                    self.types[ty].as_instantiable_type_mut().unwrap(),
                    resolvedIndexType
                )
            } else {
                get_or_set_prop!(
                    self.types[ty].unwrap_as_union_or_intersection_mut(),
                    resolvedIndexType
                )
            }
        }
    }

    // TODO:
    // getIndexTypeForMappedType

    // Ordinarily we reduce a keyof M, where M is a mapped type { [P in K as N<P>]: X }, to simply N<K>. This however presumes
    // that N distributes over union types, i.e. that N<A | B | C> is equivalent to N<A> | N<B> | N<C>. Specifically, we only
    // want to perform the reduction when the name type of a mapped type is distributive with respect to the type variable
    // introduced by the 'in' clause of the mapped type. Note that non-generic types are considered to be distributive because
    // they're the same type regardless of what's being distributed over.
    fn hasDistributiveNameType(&mut self, mappedType: TypeId) -> bool {
        let typeVariable = self.getTypeParameterFromMappedType(mappedType);
        let ty = self
            .getNameTypeFromMappedType(mappedType)
            .unwrap_or(typeVariable);
        return isDistributive(self, typeVariable, ty);
        fn isDistributive(checker: &mut Checker, typeVariable: TypeId, ty: TypeId) -> bool {
            let ty_flags = checker.types[ty].get_flags();
            if ty_flags.intersects(
                TypeFlags::AnyOrUnknown
                    | TypeFlags::Primitive
                    | TypeFlags::Never
                    | TypeFlags::TypeParameter
                    | TypeFlags::Object
                    | TypeFlags::NonPrimitive,
            ) {
                return true;
            }
            match &checker.types[ty] {
                Type::ConditionalType(t) => {
                    checker.conditional_roots[t.root].isDistributive && t.checkType == typeVariable
                }
                Type::TemplateLiteralType(t) => t
                    .types
                    .clone()
                    .iter()
                    .all(|&t| isDistributive(checker, typeVariable, t)),
                Type::UnionType(t) => t
                    .union_or_intersection_type
                    .types
                    .clone()
                    .iter()
                    .all(|&t| isDistributive(checker, typeVariable, t)),
                Type::IntersectionType(t) => t
                    .union_or_intersection_type
                    .types
                    .clone()
                    .iter()
                    .all(|&t| isDistributive(checker, typeVariable, t)),
                Type::IndexedAccessType(t) => {
                    let object_type = t.objectType;
                    let index_type = t.indexType;
                    isDistributive(checker, typeVariable, object_type)
                        && isDistributive(checker, typeVariable, index_type)
                }
                Type::SubstitutionType(t) => isDistributive(checker, typeVariable, t.substitute),
                Type::StringMappingType(t) => isDistributive(checker, typeVariable, t.ty),
                _ => false,
            }
        }
    }

    fn getLiteralTypeFromPropertyName(&mut self, name: BoundPropName) -> TypeId {
        if let BoundPropName::Ident(name) = name {
            self.getStringLiteralType(unescapeLeadingUnderscores(&name.sym))
        } else {
            let ty = if let BoundPropName::Computed(name) = name {
                todo!();
                // self.checkComputedPropertyName(name)
            } else {
                self.checkExpression(name.into(), None, false)
            };
            self.getRegularTypeOfLiteralType(ty)
        }
    }

    fn getLiteralTypeFromProperty(
        &mut self,
        prop: SymbolId,
        include: TypeFlags,
        includeNonPublic: bool,
    ) -> TypeId {
        if includeNonPublic
            || !self
                .getDeclarationModifierFlagsFromSymbol(prop, false)
                .intersects(ModifierFlags::NonPublicAccessibilityModifier)
        {
            let sym = self.getLateBoundSymbol(prop);
            let mut ty = self.getSymbolLinks(sym).nameType;
            if ty.is_none() {
                ty = if self.symbols[prop].escapedName()
                    == &JsWord::from(InternalSymbolName::Default)
                {
                    Some(self.getStringLiteralType(&JsWord::from(InternalSymbolName::Default)))
                } else if let Some(name) =
                    getNameOfDeclaration(self.symbols[prop].valueDeclaration().as_ref().unwrap())
                {
                    let prop_name = match name {
                        DeclName::Ident(n) => BoundPropName::Ident(n),
                        DeclName::String(n) => BoundPropName::Str(n),
                        DeclName::Number(n) => BoundPropName::Num(n),
                        DeclName::ComputedProperty(n) => BoundPropName::Computed(n),
                        _ => unreachable!(),
                    };
                    Some(self.getLiteralTypeFromPropertyName(prop_name))
                } else if !isKnownSymbol(&self.symbols[prop]) {
                    todo!();
                    // Some(self.getStringLiteralType(self.symbolName(prop)))
                } else {
                    None
                };
            }
            if let Some(ty) = ty {
                if self.types[ty].get_flags().intersects(include) {
                    return ty;
                }
            }
        }
        self.neverType
    }

    fn isKeyTypeIncluded(&self, keyType: TypeId, include: TypeFlags) -> bool {
        if self.types[keyType].get_flags().intersects(include) {
            true
        } else if let Type::IntersectionType(keyType) = &self.types[keyType] {
            keyType
                .union_or_intersection_type
                .types
                .clone()
                .iter()
                .any(|&t| self.isKeyTypeIncluded(t, include))
        } else {
            false
        }
    }

    fn getLiteralTypeFromProperties(
        &mut self,
        ty: TypeId,
        include: TypeFlags,
        includeOrigin: bool,
    ) -> TypeId {
        let origin = if includeOrigin
            && (self.types[ty]
                .get_object_flags()
                .intersects(ObjectFlags::ClassOrInterface | ObjectFlags::Reference)
                || self.types[ty].get_aliasSymbol().is_some())
        {
            Some(self.createOriginIndexType(ty))
        } else {
            None
        };

        let propertyTypes = self.getPropertiesOfType(ty).clone();
        let indexKeyTypes = self.getIndexInfosOfType(ty).clone();
        // TODO: bad intermidiary vec
        let mut types = Vec::with_capacity(propertyTypes.len() + indexKeyTypes.len());
        types.extend(
            propertyTypes
                .iter()
                .map(|&prop| self.getLiteralTypeFromProperty(prop, include, false)),
        );
        types.extend(indexKeyTypes.iter().map(|&info| {
            if info != self.enumNumberIndexInfo
                && self.isKeyTypeIncluded(self.index_infos[info].keyType, include)
            {
                if self.index_infos[info].keyType == self.stringType
                    && include.intersects(TypeFlags::Number)
                {
                    todo!();
                    // self.stringOrNumberType
                } else {
                    self.index_infos[info].keyType
                }
            } else {
                self.neverType
            }
        }));
        self.getUnionType(&types, Some(UnionReduction::Literal), None, None, origin)
    }

    fn getIndexType(
        &mut self,
        mut ty: TypeId,
        stringsOnly: Option<bool>,
        noIndexSignatures: bool,
    ) -> TypeId {
        let stringsOnly = stringsOnly.unwrap_or(self.keyofStringsOnly);
        ty = self.getReducedType(ty);
        let ty_flags = self.types[ty].get_flags();
        if ty_flags.intersects(TypeFlags::Union) {
            todo!();
            // self.getIntersectionType(
            //     map((ty as UnionType).types, |t| {
            //         getIndexType(t, stringsOnly, noIndexSignatures)
            //     }),
            //     None,
            //     None,
            // )
        } else if ty_flags.intersects(TypeFlags::Intersection) {
            todo!();
            // self.getUnionType(map((ty as IntersectionType).types, |t| {
            //     getIndexType(t, stringsOnly, noIndexSignatures)
            // }))
        } else if ty_flags.intersects(TypeFlags::InstantiableNonPrimitive)
            || self.isGenericTupleType(ty)
            || self.isGenericMappedType(ty) && !self.hasDistributiveNameType(ty)
        {
            self.getIndexTypeForGenericType(ty, stringsOnly)
        } else if self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::Mapped)
        {
            todo!();
            // self.getIndexTypeForMappedType(ty as MappedType, stringsOnly, noIndexSignatures)
        } else if ty == self.wildcardType {
            self.wildcardType
        } else if ty_flags.intersects(TypeFlags::Unknown) {
            self.neverType
        } else if ty_flags.intersects(TypeFlags::Any | TypeFlags::Never) {
            self.keyofConstraintType()
        } else {
            self.getLiteralTypeFromProperties(
                ty,
                if noIndexSignatures {
                    TypeFlags::StringLiteral
                } else {
                    TypeFlags::StringLike
                } | if stringsOnly {
                    TypeFlags::empty()
                } else {
                    TypeFlags::NumberLike | TypeFlags::ESSymbolLike
                },
                stringsOnly == self.keyofStringsOnly && !noIndexSignatures,
            )
        }
    }

    // TODO:
    // getExtractStringType
    // TODO:
    // getIndexTypeOrString

    fn getTypeFromTypeOperatorNode(&mut self, node: &Rc<TsTypeOperator>) -> TypeId {
        let bound_node = BoundNode::TsTypeOperator(node.clone());
        match self.getNodeLinks(bound_node.clone()).resolvedType {
            Some(resolvedType) => resolvedType,
            None => {
                let resolvedType = match node.op {
                    ast::TsTypeOperatorOp::KeyOf => {
                        let ty = self.getTypeFromTypeNode(node.type_ann.bind(bound_node.clone()));
                        self.getIndexType(ty, None, false)
                    }
                    ast::TsTypeOperatorOp::Unique => {
                        todo!();
                        // if matches!(node.type_ann, ast::TsType::TsKeywordType(k) if k.kind == ast::TsKeywordTypeKind::TsSymbolKeyword) {
                        //     self.getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(
                        //         bound_node.parent(),
                        //     ))
                        // } else {
                        //     self.errorType
                        // }
                    }
                    ast::TsTypeOperatorOp::ReadOnly => {
                        self.getTypeFromTypeNode(node.type_ann.bind(bound_node.clone()))
                    }
                };
                self.getNodeLinks_mut(bound_node).resolvedType = Some(resolvedType);
                resolvedType
            }
        }
    }

    // TODO:
    // getTypeFromTemplateTypeNode
    // TODO:
    // getTemplateLiteralType
    // TODO:
    // getTemplateStringForType
    // TODO:
    // createTemplateLiteralType
    // TODO:
    // getStringMappingType
    // TODO:
    // applyStringMapping
    // TODO:
    // getStringMappingTypeForGenericType
    // TODO:
    // createStringMappingType
    // TODO:
    // createIndexedAccessType

    /**
     * Returns if a type is or consists of a JSLiteral object type
     * In addition to objects which are directly literals,
     * * unions where every element is a jsliteral
     * * intersections where at least one element is a jsliteral
     * * and instantiable types constrained to a jsliteral
     * Should all count as literals and not print errors on access or assignment of possibly existing properties.
     * This mirrors the behavior of the index signature propagation, to which this behaves similarly (but doesn't affect assignability or inference).
     */
    fn isJSLiteralType(&mut self, ty: TypeId) -> bool {
        if self.noImplicitAny {
            return false; // Flag is meaningless under `noImplicitAny` mode
        }
        if self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::JSLiteral)
        {
            return true;
        }
        if self.types[ty].get_flags().intersects(TypeFlags::Union) {
            return self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
                .iter()
                .all(|&t| self.isJSLiteralType(t));
        }
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Intersection)
        {
            return self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
                .iter()
                .any(|&t| self.isJSLiteralType(t));
        }
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Instantiable)
        {
            let constraint = self.getResolvedBaseConstraint(ty);
            return constraint != ty && self.isJSLiteralType(constraint);
        }
        false
    }

    fn getPropertyNameFromIndex(
        &mut self,
        indexType: TypeId,
        accessNode: Option<BoundNode>,
    ) -> Option<JsWord> {
        if self.isTypeUsableAsPropertyName(indexType) {
            Some(self.getPropertyNameFromType(indexType))
        } else if accessNode.is_some() && isPropertyName(accessNode.as_ref().unwrap()) {
            todo!();
            // late bound names are handled in the first branch, so here we only need to handle normal names
            // self.getPropertyNameForPropertyNameNode(accessNode.unwrap())
        } else {
            None
        }
    }

    fn isUncalledFunctionReference(&self, node: &BoundNode, symbol: SymbolId) -> bool {
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::Function | SymbolFlags::Method)
        {
            todo!();
            // const parent = findAncestor(node.parent, n => !isAccessExpression(n)) || node.parent;
            // if (isCallLikeExpression(parent)) {
            //     return isCallOrNewExpression(parent) && isIdentifier(node) && hasMatchingArgument(parent, node);
            // }
            // return every(symbol.declarations, d => !isFunctionLike(d) || !!(getCombinedNodeFlags(d) & NodeFlags.Deprecated));
        }
        true
    }

    fn getPropertyTypeForIndexType(
        &mut self,
        originalObjectType: TypeId,
        objectType: TypeId,
        indexType: TypeId,
        fullIndexType: TypeId,
        accessNode: Option<BoundNode>,
        accessFlags: AccessFlags,
    ) -> Option<TypeId> {
        let accessExpression = if matches!(&accessNode, Some(BoundNode::MemberExpr(m)) if m.computed)
        {
            accessNode.clone()
        } else {
            None
        };
        let propName = if matches!(accessNode, Some(BoundNode::PrivateName(_))) {
            None
        } else {
            self.getPropertyNameFromIndex(indexType, accessNode.clone())
        };

        if let Some(propName) = &propName {
            if accessFlags.intersects(AccessFlags::Contextual) {
                return self
                    .getTypeOfPropertyOfContextualType(objectType, propName.clone())
                    .or(Some(self.anyType));
            }
            let prop = self.getPropertyOfType(objectType, propName, false);
            if let Some(prop) = prop {
                // TODO: depreciation message:
                // if accessFlags.intersects(AccessFlags::ReportDeprecated)
                //     && accessNode.is_some()
                //     && !self.symbols[prop].declarations().is_empty()
                //     && self
                //         .getDeclarationNodeFlagsFromSymbol(prop)
                //         .intersects(NodeFlags::Deprecated)
                //     && self.isUncalledFunctionReference(accessNode.as_ref().unwrap(), prop)
                // {
                //     todo!();
                //     // let deprecatedNode = accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode);
                //     // addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName as string);
                // }
                if let Some(accessExpression) = accessExpression {
                    todo!();
                    // markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol));
                    // if (isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression))) {
                    //     error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop));
                    //     return undefined;
                    // }
                    // if accessFlags.intersects(AccessFlags::CacheSymbol) {
                    //     todo!();
                    //     // getNodeLinks(accessNode!).resolvedSymbol = prop;
                    // }
                    // if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
                    //     return autoType;
                    // }
                }
                let propType = self.getTypeOfSymbol(prop);
                return Some(
                    if accessExpression.is_some()
                        && getAssignmentTargetKind(accessExpression.clone().unwrap())
                            != AssignmentKind::Definite
                    {
                        self.getFlowTypeOfReference(
                            &accessExpression.unwrap(),
                            propType,
                            propType,
                            None,
                        )
                    } else {
                        propType
                    },
                );
            }
            // TODO: calling is_numeric_literal_name then ecma_string_to_number is a little redundant
            // as is_numeric_literal_name calls ecma_string_to_number internally. Maybe refactor so
            // is_numeric_literal_name becomes somthing like `as_numeric_literal_name` returns
            // Option<numeric_val>, instead of bool, which we could use below. Then other callers of
            // is_numeric_literal_name who don't care about the return value can call a new version
            // of is_numeric_literal_name that is just as_numeric_literal_name().is_some()
            if self.everyType(objectType, |checker, ty| checker.isTupleType(ty))
                && is_numeric_literal_name(propName)
                && ecma_string_to_number(propName) >= 0.0
            {
                todo!();
                // if (accessNode && everyType(objectType, t => !(t as TupleTypeReference).target.hasRestElement) && !(accessFlags & AccessFlags.NoTupleBoundsCheck)) {
                //     const indexNode = getIndexNodeForAccessExpression(accessNode);
                //     if (isTupleType(objectType)) {
                //         error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2,
                //             typeToString(objectType), getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName));
                //     }
                //     else {
                //         error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType));
                //     }
                // }
                // errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType));
                // return mapType(objectType, t => {
                //     const restType = getRestTypeOfTupleType(t as TupleTypeReference) || undefinedType;
                //     return accessFlags & AccessFlags.IncludeUndefined ? getUnionType([restType, undefinedType]) : restType;
                // });
            }
        }
        if !self.types[indexType]
            .get_flags()
            .intersects(TypeFlags::Nullable)
            && self.isTypeAssignableToKind(
                indexType,
                TypeFlags::StringLike | TypeFlags::NumberLike | TypeFlags::ESSymbolLike,
                false,
            )
        {
            if self.types[objectType]
                .get_flags()
                .intersects(TypeFlags::Any | TypeFlags::Never)
            {
                return Some(objectType);
            }
            // If no index signature is applicable, we default to the string index signature. In effect, this means the string
            // index signature applies even when accessing with a symbol-like type.
            let indexInfo = self
                .getApplicableIndexInfo(objectType, indexType)
                .or_else(|| self.getIndexInfoOfType(objectType, self.stringType));
            if let Some(indexInfo) = indexInfo {
                todo!();
                // if (accessFlags & AccessFlags.NoIndexSignatures && indexInfo.keyType !== numberType) {
                //     if (accessExpression) {
                //         error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType));
                //     }
                //     return undefined;
                // }
                // if (accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(indexType, TypeFlags::String | TypeFlags::Number)) {
                //     const indexNode = getIndexNodeForAccessExpression(accessNode);
                //     error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                //     return accessFlags & AccessFlags.IncludeUndefined ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
                // }
                // errorIfWritingToReadonlyIndex(indexInfo);
                // return accessFlags & AccessFlags.IncludeUndefined ? getUnionType([indexInfo.type, undefinedType]) : indexInfo.type;
            }
            if self.types[indexType]
                .get_flags()
                .intersects(TypeFlags::Never)
            {
                return Some(self.neverType);
            }
            if self.isJSLiteralType(objectType) {
                return Some(self.anyType);
            }
            if accessExpression.is_some() && !self.isConstEnumObjectType(objectType) {
                if self.isObjectLiteralType(objectType) {
                    todo!();
                    // if (noImplicitAny && indexType.flags & (TypeFlags::StringLiteral | TypeFlags::NumberLiteral)) {
                    //     diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType)));
                    //     return undefinedType;
                    // }
                    // else if (indexType.flags & (TypeFlags::Number | TypeFlags::String)) {
                    //     const types = map((objectType as ResolvedType).properties, property => {
                    //         return getTypeOfSymbol(property);
                    //     });
                    //     return getUnionType(append(types, undefinedType));
                    // }
                }

                if self.types[objectType].get_symbol() == &Some(self.globalThisSymbol)
                    && propName.is_some()
                    // Check if the global this symbol exports this prop, and if that prop is block scoped.
                    && self.symbol_tables[self.symbols[self.globalThisSymbol].exports().unwrap()]
                        .get(propName.as_ref().unwrap())
                        .map(|prop_sym| {
                            self.symbols[*prop_sym]
                                .flags()
                                .intersects(SymbolFlags::BlockScoped)
                        })
                        .unwrap_or_default()
                {
                    todo!();
                    // error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType));
                } else if self.noImplicitAny
                    && !self.compilerOptions.suppressImplicitAnyIndexErrors
                    && !accessFlags.intersects(AccessFlags::SuppressNoImplicitAnyError)
                {
                    todo!();
                    // if (propName !== undefined && typeHasStaticProperty(propName, objectType)) {
                    //     const typeName = typeToString(objectType);
                    //     error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName as string, typeName, typeName + "[" + getTextOfNode(accessExpression.argumentExpression) + "]");
                    // }
                    // else if (getIndexTypeOfType(objectType, numberType)) {
                    //     error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
                    // }
                    // else {
                    //     let suggestion: string | undefined;
                    //     if (propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(propName as string, objectType))) {
                    //         if (suggestion !== undefined) {
                    //             error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName as string, typeToString(objectType), suggestion);
                    //         }
                    //     }
                    //     else {
                    //         const suggestion = getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType);
                    //         if (suggestion !== undefined) {
                    //             error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion);
                    //         }
                    //         else {
                    //             let errorInfo: DiagnosticMessageChain | undefined;
                    //             if (indexType.flags & TypeFlags::EnumLiteral) {
                    //                 errorInfo = chainDiagnosticMessages(/* details */ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType));
                    //             }
                    //             else if (indexType.flags & TypeFlags::UniqueESSymbol) {
                    //                 const symbolName = getFullyQualifiedName((indexType as UniqueESSymbolType).symbol, accessExpression);
                    //                 errorInfo = chainDiagnosticMessages(/* details */ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + symbolName + "]", typeToString(objectType));
                    //             }
                    //             else if (indexType.flags & TypeFlags::StringLiteral) {
                    //                 errorInfo = chainDiagnosticMessages(/* details */ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType));
                    //             }
                    //             else if (indexType.flags & TypeFlags::NumberLiteral) {
                    //                 errorInfo = chainDiagnosticMessages(/* details */ undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as NumberLiteralType).value, typeToString(objectType));
                    //             }
                    //             else if (indexType.flags & (TypeFlags::Number | TypeFlags::String)) {
                    //                 errorInfo = chainDiagnosticMessages(/* details */ undefined, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType));
                    //             }

                    //             errorInfo = chainDiagnosticMessages(
                    //                 errorInfo,
                    //                 Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType)
                    //             );
                    //             diagnostics.add(createDiagnosticForNodeFromMessageChain(accessExpression, errorInfo));
                    //         }
                    //     }
                    // }
                }
                return None;
            }
        }
        if self.isJSLiteralType(objectType) {
            return Some(self.anyType);
        }
        if let Some(accessNode) = accessNode {
            todo!();
            // const indexNode = getIndexNodeForAccessExpression(accessNode);
            // if (indexType.flags & (TypeFlags::StringLiteral | TypeFlags::NumberLiteral)) {
            //     error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, "" + (indexType as StringLiteralType | NumberLiteralType).value, typeToString(objectType));
            // }
            // else if (indexType.flags & (TypeFlags::String | TypeFlags::Number)) {
            //     error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
            // }
            // else {
            //     error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
            // }
        }
        if self.isTypeAny(Some(indexType)) {
            return Some(indexType);
        }
        return None;

        // function errorIfWritingToReadonlyIndex(indexInfo: IndexInfo | undefined): void {
        //     if (indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression))) {
        //         error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
        //     }
        // }
    }

    // TODO:
    // getIndexNodeForAccessExpression

    fn isPatternLiteralPlaceholderType(&self, ty: TypeId) -> bool {
        self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Any | TypeFlags::String | TypeFlags::Number | TypeFlags::BigInt)
    }

    fn isPatternLiteralType(&self, ty: TypeId) -> bool {
        if let Type::TemplateLiteralType(t) = &self.types[ty] {
            t.types
                .iter()
                .all(|t| self.isPatternLiteralPlaceholderType(*t))
        } else {
            false
        }
    }

    fn isGenericType(&mut self, ty: TypeId) -> bool {
        !self.getGenericObjectFlags(ty).is_empty()
    }

    fn isGenericObjectType(&mut self, ty: TypeId) -> bool {
        self.getGenericObjectFlags(ty)
            .intersects(ObjectFlags::IsGenericObjectType)
    }

    fn isGenericIndexType(&mut self, ty: TypeId) -> bool {
        self.getGenericObjectFlags(ty)
            .intersects(ObjectFlags::IsGenericIndexType)
    }

    fn getGenericObjectFlags(&mut self, ty: TypeId) -> ObjectFlags {
        let ty_flags = self.types[ty].get_flags();
        if ty_flags.intersects(TypeFlags::UnionOrIntersection) {
            todo!();
            // if (!((ty as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericTypeComputed)) {
            //     (ty as UnionOrIntersectionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |
            //         reduceLeft((ty as UnionOrIntersectionType).types, (flags, t) => flags | getGenericObjectFlags(t), 0);
            // }
            // return (ty as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericType;
        }
        if ty_flags.intersects(TypeFlags::Substitution) {
            todo!();
            // if (!((ty as SubstitutionType).objectFlags & ObjectFlags.IsGenericTypeComputed)) {
            //     (ty as SubstitutionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |
            //         getGenericObjectFlags((ty as SubstitutionType).substitute) | getGenericObjectFlags((ty as SubstitutionType).baseType);
            // }
            // return (ty as SubstitutionType).objectFlags & ObjectFlags.IsGenericType;
        }
        let mut flags = if ty_flags.intersects(TypeFlags::InstantiableNonPrimitive)
            || self.isGenericMappedType(ty)
            || self.isGenericTupleType(ty)
        {
            ObjectFlags::IsGenericObjectType
        } else {
            ObjectFlags::default()
        };
        if ty_flags.intersects(
            TypeFlags::InstantiableNonPrimitive
                | TypeFlags::Index
                | TypeFlags::TemplateLiteral
                | TypeFlags::StringMapping,
        ) && !self.isPatternLiteralType(ty)
        {
            flags.insert(ObjectFlags::IsGenericIndexType)
        }
        flags
    }

    fn isThisTypeParameter(&self, ty: TypeId) -> bool {
        if let Type::TypeParameter(t) = &self.types[ty] {
            t.isThisType
        } else {
            false
        }
    }

    fn getSimplifiedType(&mut self, ty: TypeId, writing: bool) -> TypeId {
        let type_flags = self.types[ty].get_flags();
        if type_flags.intersects(TypeFlags::IndexedAccess) {
            todo!();
            // getSimplifiedIndexedAccessType(ty as IndexedAccessType, writing)
        } else if type_flags.intersects(TypeFlags::Conditional) {
            todo!();
            // getSimplifiedConditionalType(ty as ConditionalType, writing)
        } else {
            ty
        }
    }

    // TODO:
    // distributeIndexOverObjectType
    // TODO:
    // distributeObjectOverIndexType
    // TODO:
    // getSimplifiedIndexedAccessType
    // TODO:
    // isConditionalTypeAlwaysTrueDisregardingInferTypes
    // TODO:
    // getSimplifiedConditionalType
    // TODO:
    // isIntersectionEmpty
    // TODO:
    // substituteIndexedMappedType

    fn getIndexedAccessType(
        &mut self,
        objectType: TypeId,
        indexType: TypeId,
        accessFlags: Option<AccessFlags>,
        accessNode: Option<BoundNode>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let has_access_node = accessNode.is_some();
        self.getIndexedAccessTypeOrUndefined(
            objectType,
            indexType,
            accessFlags,
            accessNode,
            aliasSymbol,
            aliasTypeArguments,
        )
        .unwrap_or(if has_access_node {
            self.errorType
        } else {
            self.unknownType
        })
    }

    fn indexTypeLessThan(&mut self, indexType: TypeId, limit: usize) -> bool {
        self.everyType(indexType, |checker, t| {
            if checker.types[t]
                .get_flags()
                .intersects(TypeFlags::StringOrNumberLiteral)
            {
                // let propName = checker.getPropertyNameFromType(t);
                todo!();
                // if isNumericLiteralName(propName) {
                //     let index = +propName;
                //     return index >= 0 && index < limit;
                // }
            }
            return false;
        })
    }

    fn getIndexedAccessTypeOrUndefined(
        &mut self,
        objectType: TypeId,
        mut indexType: TypeId,
        accessFlags: Option<AccessFlags>,
        accessNode: Option<BoundNode>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> Option<TypeId> {
        let mut accessFlags = accessFlags.unwrap_or_default();
        if objectType == self.wildcardType || indexType == self.wildcardType {
            return Some(self.wildcardType);
        }
        // If the object type has a string index signature and no other members we know that the result will
        // always be the type of that index signature and we can simplify accordingly.
        if self.isStringIndexSignatureOnlyType(objectType)
            && !self.types[indexType]
                .get_flags()
                .intersects(TypeFlags::Nullable)
            && self.isTypeAssignableToKind(indexType, TypeFlags::String | TypeFlags::Number, false)
        {
            indexType = self.stringType;
        }
        // In noUncheckedIndexedAccess mode, indexed access operations that occur in an expression in a read position and resolve to
        // an index signature have 'undefined' included in their type.
        if self.compilerOptions.noUncheckedIndexedAccess
            && accessFlags.intersects(AccessFlags::ExpressionPosition)
        {
            accessFlags |= AccessFlags::IncludeUndefined
        };
        // If the index type is generic, or if the object type is generic and doesn't originate in an expression and
        // the operation isn't exclusively indexing the fixed (non-variadic) portion of a tuple type, we are performing
        // a higher-order index access where we cannot meaningfully access the properties of the object type. Note that
        // for a generic T and a non-generic K, we eagerly resolve T[K] if it originates in an expression. This is to
        // preserve backwards compatibility. For example, an element access 'this["foo"]' has always been resolved
        // eagerly using the constraint type of 'this' at the given location.
        if self.isGenericIndexType(indexType)
            || (if matches!(&accessNode, Some(n) if !matches!(n, BoundNode::TsIndexedAccessType(_)))
            {
                self.isGenericTupleType(objectType)
                    && !self.indexTypeLessThan(
                        indexType,
                        unwrap_as!(
                            &self.types[self.types[objectType]
                                .unwrap_as_type_reference()
                                .target
                                .unwrap()],
                            Type::TupleType(t),
                            t
                        )
                        .fixedLength,
                    )
            } else {
                self.isGenericObjectType(objectType)
                    && !(self.isTupleType(objectType)
                        && self.indexTypeLessThan(
                            indexType,
                            unwrap_as!(
                                &self.types[self.types[objectType]
                                    .unwrap_as_type_reference()
                                    .target
                                    .unwrap()],
                                Type::TupleType(t),
                                t
                            )
                            .fixedLength,
                        ))
            })
        {
            todo!();
            // if (objectType.flags & TypeFlags::AnyOrUnknown) {
            //     return objectType;
            // }
            // // Defer the operation by creating an indexed access type.
            // const persistentAccessFlags = accessFlags & AccessFlags::Persistent;
            // const id = objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments);
            // let type = indexedAccessTypes.get(id);
            // if (!type) {
            //     indexedAccessTypes.set(id, type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments));
            // }

            // return type;
        }
        // In the following we resolve T[K] to the type of the property in T selected by K.
        // We treat boolean as different from other unions to improve errors;
        // skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
        let apparentObjectType = self.getReducedApparentType(objectType);
        if self.types[indexType]
            .get_flags()
            .intersects(TypeFlags::Union)
            && !self.types[indexType]
                .get_flags()
                .intersects(TypeFlags::Boolean)
        {
            todo!();
            // const propTypes: Type[] = [];
            // let wasMissingProp = false;
            // for (const t of (indexType as UnionType).types) {
            //     const propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags | (wasMissingProp ? AccessFlags::SuppressNoImplicitAnyError : 0));
            //     if (propType) {
            //         propTypes.push(propType);
            //     }
            //     else if (!accessNode) {
            //         // If there's no error node, we can immeditely stop, since error reporting is off
            //         return undefined;
            //     }
            //     else {
            //         // Otherwise we set a flag and return at the end of the loop so we still mark all errors
            //         wasMissingProp = true;
            //     }
            // }
            // if (wasMissingProp) {
            //     return undefined;
            // }
            // return accessFlags & AccessFlags::Writing
            //     ? getIntersectionType(propTypes, aliasSymbol, aliasTypeArguments)
            //     : getUnionType(propTypes, UnionReduction.Literal, aliasSymbol, aliasTypeArguments);
        }
        self.getPropertyTypeForIndexType(
            objectType,
            apparentObjectType,
            indexType,
            indexType,
            accessNode,
            accessFlags | AccessFlags::CacheSymbol | AccessFlags::ReportDeprecated,
        )
    }

    fn getTypeFromIndexedAccessTypeNode(&mut self, node: Rc<TsIndexedAccessType>) -> TypeId {
        let bound_node = BoundNode::TsIndexedAccessType(node.clone());
        match self.getNodeLinks(bound_node.clone()).resolvedType {
            Some(resolvedType) => resolvedType,
            None => {
                let objectType = self.getTypeFromTypeNode(node.obj_type.bind(bound_node.clone()));
                let indexType = self.getTypeFromTypeNode(node.index_type.bind(bound_node.clone()));
                let potentialAlias = self.getAliasSymbolForTypeNode(&bound_node);
                let aliasTypeArguments = self.getTypeArgumentsForAliasSymbol(potentialAlias);
                let resolved = self.getIndexedAccessType(
                    objectType,
                    indexType,
                    Some(AccessFlags::None),
                    Some(bound_node.clone()),
                    potentialAlias,
                    aliasTypeArguments,
                );
                let resolvedType = if matches!(&self.types[resolved], Type::IndexedAccessType(t) if t.objectType == objectType
                && t.indexType == indexType)
                {
                    self.getConditionalFlowTypeOfType(resolved, bound_node.clone())
                } else {
                    resolved
                };
                self.getNodeLinks_mut(bound_node).resolvedType = Some(resolvedType);
                resolvedType
            }
        }
    }

    fn getTypeFromMappedTypeNode(&mut self, node: Rc<TsMappedType>) -> TypeId {
        let bound_node = BoundNode::TsMappedType(node.clone());
        match self.getNodeLinks(bound_node.clone()).resolvedType {
            Some(resolvedType) => resolvedType,
            None => {
                let aliasSymbol = self.getAliasSymbolForTypeNode(&bound_node);
                let resolvedType = MappedType {
                    anonymous_type: AnonymousTypeBase::default(),
                    object_type_base: ObjectTypeBase::new(ObjectFlags::Mapped),
                    type_base: TypeBase {
                        flags: TypeFlags::Object,
                        aliasSymbol,
                        aliasTypeArguments: self.getTypeArgumentsForAliasSymbol(aliasSymbol),
                        symbol: self.node_data(bound_node.clone()).symbol,
                        ..Default::default()
                    },
                    declaration: node,
                    typeParameter: None,
                    constraintType: None,
                    nameType: None,
                    templateType: None,
                    modifiersType: None,
                    resolvedApparentType: None,
                    containsError: false,
                };
                let resolvedType = self.types.push(Type::MappedType(resolvedType));
                self.getNodeLinks_mut(bound_node).resolvedType = Some(resolvedType);
                // Eagerly resolve the constraint type which forces an error if the constraint type circularly
                // references itself through one or more type aliases.
                self.getConstraintTypeFromMappedType(resolvedType);
                resolvedType
            }
        }
    }

    fn getActualTypeVariable(&mut self, ty: TypeId) -> TypeId {
        if let Type::SubstitutionType(ty) = &self.types[ty] {
            return ty.baseType;
        }
        if let Type::IndexedAccessType(ty) = &self.types[ty] {
            if self.types[ty.objectType]
                .get_flags()
                .intersects(TypeFlags::Substitution)
                || self.types[ty.indexType]
                    .get_flags()
                    .intersects(TypeFlags::Substitution)
            {
                let objectType = ty.objectType;
                let indexType = ty.indexType;
                let objectType = self.getActualTypeVariable(objectType);
                let indexType = self.getActualTypeVariable(indexType);
                return self.getIndexedAccessType(objectType, indexType, None, None, None, None);
            }
        }
        ty
    }

    fn isTypicalNondistributiveConditional(&self, root: ConditionalRootId) -> bool {
        fn isSingletonTupleType(node: &ast::TsType) -> bool {
            if let ast::TsType::TsTupleType(tuple) = node {
                if tuple.elem_types.len() == 1 {
                    let elem = tuple.elem_types.first().unwrap();
                    return !matches!(
                        elem.ty,
                        ast::TsType::TsRestType(_) | ast::TsType::TsOptionalType(_)
                    );
                }
            }
            false
        }

        let root = &self.conditional_roots[root];
        !root.isDistributive
            && isSingletonTupleType(&root.node.check_type)
            && isSingletonTupleType(&root.node.extends_type)
    }

    /// We syntactually check for common nondistributive conditional shapes and unwrap them into
    /// the intended comparison - we do this so we can check if the unwrapped types are generic or
    /// not and appropriately defer condition calculation
    fn unwrapNondistributiveConditionalTuple(
        &mut self,
        root: ConditionalRootId,
        ty: TypeId,
    ) -> TypeId {
        if self.isTypicalNondistributiveConditional(root) && self.isTupleType(ty) {
            *self.getTypeArguments(ty).first().unwrap()
        } else {
            ty
        }
    }

    fn getConditionalType(
        &mut self,
        root: ConditionalRootId,
        mapper: Option<Rc<TypeMapper>>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let mut result;
        // TODO: remove type ann:
        let mut extraTypes: Option<Vec<TypeId>> = None;
        let mut tailCount = 0;
        // We loop here for an immediately nested conditional type in the false position, effectively treating
        // types of the form 'A extends B ? X : C extends D ? Y : E extends F ? Z : ...' as a single construct for
        // purposes of resolution. We also loop here when resolution of a conditional type ends in resolution of
        // another (or, through recursion, possibly the same) conditional type. In the potentially tail-recursive
        // cases we increment the tail recursion counter and stop after 1000 iterations.
        loop {
            if tailCount == 1000 {
                todo!();
                // error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
                // result = errorType;
                // break;
            }
            let isUnwrapped = self.isTypicalNondistributiveConditional(root);
            let checkType = self.getActualTypeVariable(self.conditional_roots[root].checkType);
            let checkType = self.unwrapNondistributiveConditionalTuple(root, checkType);
            let checkType = self.instantiateType(checkType, mapper.clone());
            let checkTypeInstantiable = self.isGenericType(checkType);
            let extendsType = self.unwrapNondistributiveConditionalTuple(
                root,
                self.conditional_roots[root].extendsType,
            );
            let extendsType = self.instantiateType(extendsType, mapper.clone());
            if checkType == self.wildcardType || extendsType == self.wildcardType {
                return self.wildcardType;
            }
            let mut combinedMapper = None;
            if let Some(inferTypeParameters) =
                self.conditional_roots[root].inferTypeParameters.clone()
            {
                let context = self.createInferenceContext(
                    inferTypeParameters,
                    None,
                    InferenceFlags::None,
                    None,
                );
                if !checkTypeInstantiable {
                    // We don't want inferences from constraints as they may cause us to eagerly resolve the
                    // conditional type instead of deferring resolution. Also, we always want strict function
                    // types rules (i.e. proper contravariance) for inferences.
                    self.inferTypes(
                        context,
                        checkType,
                        extendsType,
                        Some(InferencePriority::NoConstraints | InferencePriority::AlwaysStrict),
                        false,
                    );
                }
                // It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the
                // those type parameters are used in type references (see getInferredTypeParameterConstraint). For
                // that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.
                let inference_context_mapper = self.inference_contexts[context].mapper.clone();
                combinedMapper = Some(if let Some(mapper) = &mapper {
                    TypeMapper::combineTypeMappers(
                        Some(inference_context_mapper.clone()),
                        mapper.clone(),
                    )
                } else {
                    inference_context_mapper
                });
            }
            // Instantiate the extends type including inferences for 'infer T' type parameters
            let inferredExtendsType = if combinedMapper.is_some() {
                let ty = self.unwrapNondistributiveConditionalTuple(
                    root,
                    self.conditional_roots[root].extendsType,
                );
                self.instantiateType(ty, combinedMapper.clone())
            } else {
                extendsType
            };
            // We attempt to resolve the conditional type only when the check and extends types are non-generic
            if !checkTypeInstantiable && !self.isGenericType(inferredExtendsType) {
                todo!();
                // Return falseType for a definitely false extends check. We check an instantiations of the two
                // types with type parameters mapped to the wildcard type, the most permissive instantiations
                // possible (the wildcard type is assignable to and from all types). If those are not related,
                // then no instantiations will be and we can just return the false branch type.
                // if (!(inferredExtendsType.flags & TypeFlags::AnyOrUnknown) && ((checkType.flags & TypeFlags::Any && !isUnwrapped) || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {
                //     // Return union of trueType and falseType for 'any' since it matches anything
                //     if (checkType.flags & TypeFlags::Any && !isUnwrapped) {
                //         (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));
                //     }
                //     // If falseType is an immediately nested conditional type that isn't distributive or has an
                //     // identical checkType, switch to that type and loop.
                //     let falseType = getTypeFromTypeNode(root.node.falseType);
                //     if (falseType.flags & TypeFlags::Conditional) {
                //         let newRoot = (falseType as ConditionalType).root;
                //         if (newRoot.node.parent == root.node && (!newRoot.isDistributive || newRoot.checkType == root.checkType)) {
                //             root = newRoot;
                //             continue;
                //         }
                //         if (canTailRecurse(falseType, mapper)) {
                //             continue;
                //         }
                //     }
                //     result = instantiateType(falseType, mapper);
                //     break;
                // }
                // // Return trueType for a definitely true extends check. We check instantiations of the two
                // // types with type parameters mapped to their restrictive form, i.e. a form of the type parameter
                // // that has no constraint. This ensures that, for example, the type
                // //   type Foo<T extends { x: any }> = T extends { x: string } ? string : number
                // // doesn't immediately resolve to 'string' instead of being deferred.
                // if (inferredExtendsType.flags & TypeFlags::AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {
                //     let trueType = getTypeFromTypeNode(root.node.trueType);
                //     let trueMapper = combinedMapper || mapper;
                //     if (canTailRecurse(trueType, trueMapper)) {
                //         continue;
                //     }
                //     result = instantiateType(trueType, trueMapper);
                //     break;
                // }
            }
            // Return a deferred type for a check that is neither definitely true nor definitely false
            let cond_type = ConditionalType {
                instantiable_type: InstantiableType::default(),
                type_base: TypeBase {
                    flags: TypeFlags::Conditional,
                    symbol: None,
                    pattern: None,
                    aliasSymbol: aliasSymbol.or(self.conditional_roots[root].aliasSymbol),
                    aliasTypeArguments: if aliasSymbol.is_some() {
                        aliasTypeArguments
                    } else {
                        self.instantiateTypesOptionalWithOptionalMapper(
                            self.conditional_roots[root].aliasTypeArguments.clone(),
                            mapper.clone(),
                        )
                    },
                    aliasTypeArgumentsContainsMarker: false,
                    permissiveInstantiation: None,
                    restrictiveInstantiation: None,
                    immediateBaseConstraint: None,
                    widened: None,
                },
                root,
                checkType: self
                    .instantiateType(self.conditional_roots[root].checkType, mapper.clone()),
                extendsType: self
                    .instantiateType(self.conditional_roots[root].extendsType, mapper.clone()),
                resolvedTrueType: None,
                resolvedFalseType: None,
                resolvedInferredTrueType: None,
                resolvedDefaultConstraint: None,
                mapper,
                combinedMapper,
            };
            result = self.types.push(Type::ConditionalType(cond_type));
            break;
        }
        return if let Some(mut extraTypes) = extraTypes {
            extraTypes.push(result);
            self.getUnionType(&extraTypes, None, None, None, None)
        } else {
            result
        };
        // We tail-recurse for generic conditional types that (a) have not already been evaluated and cached, and
        // (b) are non distributive, have a check type that is unaffected by instantiation, or have a non-union check
        // type. Note that recursion is possible only through aliased conditional types, so we only increment the tail
        // recursion counter for those.
        fn canTailRecurse(newType: TypeId, newMapper: Option<TypeMapper>) -> bool {
            todo!();
            // if (newType.flags & TypeFlags::Conditional && newMapper) {
            //     const newRoot = (newType as ConditionalType).root;
            //     if (newRoot.outerTypeParameters) {
            //         const typeParamMapper = combineTypeMappers((newType as ConditionalType).mapper, newMapper);
            //         const typeArguments = map(newRoot.outerTypeParameters, t => getMappedType(t, typeParamMapper));
            //         const newRootMapper = createTypeMapper(newRoot.outerTypeParameters, typeArguments);
            //         const newCheckType = newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined;
            //         if (!newCheckType || newCheckType === newRoot.checkType || !(newCheckType.flags & (TypeFlags::Union | TypeFlags::Never))) {
            //             root = newRoot;
            //             mapper = newRootMapper;
            //             aliasSymbol = undefined;
            //             aliasTypeArguments = undefined;
            //             if (newRoot.aliasSymbol) {
            //                 tailCount++;
            //             }
            //             return true;
            //         }
            //     }
            // }
            // return false;
        }
    }

    // TODO:
    // getTrueTypeFromConditionalType
    // TODO:
    // getFalseTypeFromConditionalType
    // TODO:
    // getInferredTrueTypeFromConditionalType

    fn getInferTypeParameters(&mut self, node: Rc<TsConditionalType>) -> Option<Vec<TypeId>> {
        let mut result: Option<Vec<TypeId>> = None;
        if let Some(locals) = self.node_data(node.into()).locals {
            // TODO: bad collect:
            for symbol in self.symbol_tables[locals]
                .values()
                .cloned()
                .collect::<Vec<_>>()
            {
                if self.symbols[symbol]
                    .flags()
                    .intersects(SymbolFlags::TypeParameter)
                {
                    let t = self.getDeclaredTypeOfSymbol(symbol);
                    match &mut result {
                        Some(res) => {
                            res.push(t);
                        }
                        None => result = Some(vec![t]),
                    }
                }
            }
        }
        result
    }

    fn getTypeFromConditionalTypeNode(&mut self, node: Rc<TsConditionalType>) -> TypeId {
        let bound_node = BoundNode::TsConditionalType(node.clone());
        match self.getNodeLinks(bound_node.clone()).resolvedType {
            Some(resolvedType) => resolvedType,
            None => {
                let checkType = self.getTypeFromTypeNode(node.check_type.bind(bound_node.clone()));
                let aliasSymbol = self.getAliasSymbolForTypeNode(&bound_node);
                let aliasTypeArguments = self.getTypeArgumentsForAliasSymbol(aliasSymbol);
                let allOuterTypeParameters = self.getOuterTypeParameters(bound_node.clone(), true);
                let outerTypeParameters = if aliasTypeArguments.is_some() {
                    allOuterTypeParameters.map(Rc::new)
                } else {
                    todo!();
                    //  filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node))
                };
                let root = ConditionalRoot {
                    node: node.clone(),
                    checkType,
                    extendsType: self
                        .getTypeFromTypeNode(node.extends_type.bind(bound_node.clone())),
                    isDistributive: self.types[checkType]
                        .get_flags()
                        .intersects(TypeFlags::TypeParameter),
                    inferTypeParameters: self.getInferTypeParameters(node).map(Rc::new),
                    outerTypeParameters: outerTypeParameters.clone(),
                    instantiations: AHashMap::default(),
                    aliasSymbol,
                    aliasTypeArguments,
                };
                let root = self.conditional_roots.push(root);
                let resolvedType = self.getConditionalType(root, None, None, None);
                if outerTypeParameters.is_some() {
                    let type_list_id =
                        self.getTypeListId(outerTypeParameters.as_ref().map(|v| v.as_ref()));
                    self.conditional_roots[root]
                        .instantiations
                        .insert(type_list_id.0, resolvedType);
                }
                self.getNodeLinks_mut(bound_node).resolvedType = Some(resolvedType);
                resolvedType
            }
        }
    }

    fn getTypeFromInferTypeNode(&mut self, node: Rc<TsInferType>) -> TypeId {
        let bound_node = BoundNode::TsInferType(node.clone());
        match self.getNodeLinks(bound_node.clone()).resolvedType {
            Some(resolvedType) => resolvedType,
            None => {
                let type_param_symbol = self
                    .getSymbolOfNode(node.type_param.bind(bound_node.clone()))
                    .unwrap();
                let resolvedType = self.getDeclaredTypeOfTypeParameter(type_param_symbol);
                self.getNodeLinks_mut(bound_node).resolvedType = Some(resolvedType);
                resolvedType
            }
        }
    }

    // TODO:
    // getIdentifierChain
    // TODO:
    // getTypeFromImportTypeNode
    // TODO:
    // resolveImportSymbolType

    fn getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(&mut self, node: BoundNode) -> TypeId {
        match self.getNodeLinks(node.clone()).resolvedType {
            Some(ty) => ty,
            None => {
                // Deferred resolution of members is handled by resolveObjectTypeMembers
                let symbol = self.node_data(node.clone()).symbol.unwrap();
                let members = self.getMembersOfSymbol(symbol);
                let aliasSymbol = self.getAliasSymbolForTypeNode(&node);
                let ty = if self.symbol_tables[members].is_empty() && aliasSymbol.is_none() {
                    self.emptyTypeLiteralType
                } else {
                    // TODO: this is intentioanlly different from TSC. Is it correct?
                    let ty = self.types.push(Type::AnonymousType(AnonymousType {
                        anonymous_type: Default::default(),
                        object_type_base: ObjectTypeBase::new(ObjectFlags::Anonymous),
                        type_base: TypeBase::new(TypeFlags::Object, Some(symbol)),
                    }));
                    *self.types[ty].get_aliasSymbol_mut() = aliasSymbol;
                    *self.types[ty].get_aliasTypeArguments_mut() =
                        self.getTypeArgumentsForAliasSymbol(aliasSymbol);
                    // TODO: jsdoc:
                    // if isJSDocTypeLiteral(node) && node.isArrayType {
                    //     ty = self.createArrayType(ty);
                    // }
                    ty
                };
                self.getNodeLinks_mut(node).resolvedType = Some(ty);
                ty
            }
        }
    }

    fn getAliasSymbolForTypeNode(&mut self, node: &BoundNode) -> Option<SymbolId> {
        let mut host = node.parent().unwrap();
        // TODO: jsdoc: || isJSDocTypeExpression(host)
        while matches!(host, BoundNode::TsParenthesizedType(_))
            || matches!(&host, BoundNode::TsTypeOperator(o) if o.op == ast::TsTypeOperatorOp::ReadOnly)
        {
            host = host.parent().unwrap();
        }
        if isTypeAlias(&host) {
            self.getSymbolOfNode(host)
        } else {
            None
        }
    }

    fn getTypeArgumentsForAliasSymbol(
        &mut self,
        symbol: Option<SymbolId>,
    ) -> Option<Rc<Vec<TypeId>>> {
        symbol.and_then(|s| self.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(s))
    }

    // TODO:
    // isNonGenericObjectType
    // TODO:
    // isEmptyObjectTypeOrSpreadsIntoEmptyObject
    // TODO:
    // tryMergeUnionOfObjectTypeAndEmptyObject
    // TODO:
    // getSpreadType
    // TODO:
    // isSpreadableProperty
    // TODO:
    // getSpreadSymbol
    // TODO:
    // getIndexInfoWithReadonly

    fn createStringLiteralType(&mut self, value: JsWord) -> TypeId {
        let ty = StringLiteralType::new(value, self.types.next_index());
        self.types.push(Type::StringLiteralType(ty))
    }

    // TODO:
    // createLiteralType

    fn getFreshTypeOfLiteralType(&mut self, ty: TypeId) -> TypeId {
        if self.types[ty].get_flags().intersects(TypeFlags::Literal) {
            return match self.types[ty].get_literal_fresh_type() {
                Some(fresh) => fresh,
                None => {
                    let fresh_type_id = self.types.next_index();
                    let literal_type = LiteralType {
                        freshType: Some(fresh_type_id),
                        regularType: ty,
                    };
                    let fresh_type = match &self.types[ty] {
                        Type::StringLiteralType(t) => {
                            self.types.push(Type::StringLiteralType(StringLiteralType {
                                literal_type,
                                type_base: TypeBase::new(t.type_base.flags, t.type_base.symbol),
                                value: t.value.clone(),
                            }))
                        }
                        Type::NumberLiteralType(t) => {
                            self.types.push(Type::NumberLiteralType(NumberLiteralType {
                                literal_type,
                                type_base: TypeBase::new(t.type_base.flags, t.type_base.symbol),
                                value: t.value,
                            }))
                        }
                        Type::BigIntLiteralType(t) => {
                            self.types.push(Type::BigIntLiteralType(BigIntLiteralType {
                                literal_type,
                                type_base: TypeBase::new(t.type_base.flags, t.type_base.symbol),
                                value: t.value.clone(),
                            }))
                        }
                        // TODO: FreshableIntrinsicType?
                        _ => unreachable!(),
                    };
                    debug_assert_eq!(fresh_type_id, fresh_type);

                    self.types[ty].set_literal_fresh_type(fresh_type);
                    fresh_type
                }
            };
        }
        ty
    }

    fn getRegularTypeOfLiteralType(&mut self, ty: TypeId) -> TypeId {
        let flags = self.types[ty].get_flags();
        if flags.intersects(TypeFlags::Literal) {
            self.types[ty].get_literal_regular_type()
        } else if flags.intersects(TypeFlags::Union) {
            match self.types[ty].unwrap_as_union_type_base().regularType {
                Some(regular_ty) => regular_ty,
                None => {
                    let regular_ty = self.mapType(
                        ty,
                        &mut |checker, t| checker.getRegularTypeOfLiteralType(t),
                        false,
                    );
                    self.types[ty].unwrap_as_union_type_base_mut().regularType = Some(regular_ty);
                    regular_ty
                }
            }
        } else {
            ty
        }
    }

    fn isFreshLiteralType(&self, ty: TypeId) -> bool {
        self.types[ty].get_flags().intersects(TypeFlags::Literal)
            && self.types[ty].get_literal_fresh_type() == Some(ty)
    }

    fn getStringLiteralType(&mut self, value: &JsWord) -> TypeId {
        match self.stringLiteralTypes.get(value) {
            Some(t) => *t,
            None => {
                let t = self.createStringLiteralType(value.clone());
                self.stringLiteralTypes.insert(value.clone(), t);
                t
            }
        }
    }

    fn getNumberLiteralType(&mut self, value: f64) -> TypeId {
        let decoded = integer_decode(value);
        match self.numberLiteralTypes.get(&decoded) {
            Some(ty) => *ty,
            None => {
                let ty = NumberLiteralType::new(value, self.types.next_index());
                let ty = self.types.push(Type::NumberLiteralType(ty));
                self.numberLiteralTypes.insert(decoded, ty);
                ty
            }
        }
    }

    // TODO:
    // getBigIntLiteralType
    // TODO:
    // getEnumLiteralType

    fn getTypeFromLiteralTypeNode(&mut self, node: &Rc<TsLitType>) -> TypeId {
        // TODO: I dont think this branch is possible for our AST
        // if (node.literal.kind == SyntaxKind.NullKeyword) {
        //     return self.nullType;
        // }
        let bound_node = BoundNode::TsLitType(node.clone());
        match self.getNodeLinks(bound_node.clone()).resolvedType {
            Some(resolvedType) => resolvedType,
            None => {
                let ty = self.checkExpression(node.lit.bind(bound_node.clone()), None, false);
                let ty = self.getRegularTypeOfLiteralType(ty);
                self.getNodeLinks_mut(bound_node).resolvedType = Some(ty);
                ty
            }
        }
    }

    // TODO:
    // createUniqueESSymbolType
    // TODO:
    // getESSymbolLikeTypeForNode

    fn getThisType(&mut self, node: BoundNode) -> TypeId {
        todo!();
        // let container = getThisContainer(node, /*includeArrowFunctions*/ false);
        // let parent = container && container.parent;
        // if parent && (isClassLike(parent) || parent.kind == SyntaxKind.InterfaceDeclaration) {
        //     if (!isStatic(container)
        //         && (!isConstructorDeclaration(container)
        //             || isNodeDescendantOf(node, container.body)))
        //     {
        //         return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(
        //             parent as ClassLikeDeclaration | InterfaceDeclaration,
        //         ))
        //         .thisType
        //         .unwrap();
        //     }
        // }

        // // inside x.prototype = { ... }
        // if parent
        //     && isObjectLiteralExpression(parent)
        //     && isBinaryExpression(parent.parent)
        //     && getAssignmentDeclarationKind(parent.parent) == AssignmentDeclarationKind.Prototype
        // {
        //     return getDeclaredTypeOfClassOrInterface(
        //         getSymbolOfNode(parent.parent.left).unwrap().parent.unwrap(),
        //     )
        //     .thisType
        //     .unwrap();
        // }
        // // /** @return {this} */
        // // x.prototype.m = function() { ... }
        // let host = if node.flags & NodeFlags.JSDoc {
        //     getHostSignatureFromJSDoc(node)
        // } else {
        //     None
        // };
        // if host
        //     && isFunctionExpression(host)
        //     && isBinaryExpression(host.parent)
        //     && getAssignmentDeclarationKind(host.parent)
        //         == AssignmentDeclarationKind.PrototypeProperty
        // {
        //     return getDeclaredTypeOfClassOrInterface(
        //         getSymbolOfNode(host.parent.left).unwrap().parent.unwrap(),
        //     )
        //     .thisType
        //     .unwrap();
        // }
        // // inside constructor function C() { ... }
        // if isJSConstructor(container) && isNodeDescendantOf(node, container.body) {
        //     return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(container))
        //         .thisType
        //         .unwrap();
        // }
        // error(
        //     node,
        //     Diagnostics
        //         .A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface,
        // );
        // self.errorType
    }
    fn getTypeFromThisTypeNode(&mut self, node: BoundNode) -> TypeId {
        match self.getNodeLinks(node.clone()).resolvedType {
            Some(resolved_type) => resolved_type,
            None => {
                let resolved_type = self.getThisType(node.clone());
                self.getNodeLinks_mut(node).resolvedType = Some(resolved_type);
                resolved_type
            }
        }
    }

    // TODO:
    // getTypeFromRestTypeNode

    // TODO:
    // getTypeFromNamedTupleTypeNode

    fn getTypeFromTypeNode(&mut self, node: BoundNode) -> TypeId {
        let ty = self.getTypeFromTypeNodeWorker(node.clone());
        self.getConditionalFlowTypeOfType(ty, node)
    }

    fn getTypeFromTypeNodeWorker(&mut self, node: BoundNode) -> TypeId {
        use self::ast::TsKeywordTypeKind as KK;
        match &node {
            // TODO: jsdoc
            // BoundNode::JSDocAllType(_)
            // | BoundNode::JSDocUnknownType(_)
            BoundNode::TsKeywordType(t) if t.kind == KK::TsAnyKeyword => self.anyType,
            BoundNode::TsKeywordType(t) if t.kind == KK::TsUnknownKeyword => self.unknownType,
            BoundNode::TsKeywordType(t) if t.kind == KK::TsStringKeyword => self.stringType,
            BoundNode::TsKeywordType(t) if t.kind == KK::TsNumberKeyword => self.numberType,
            BoundNode::TsKeywordType(t) if t.kind == KK::TsBigIntKeyword => self.bigintType,
            BoundNode::TsKeywordType(t) if t.kind == KK::TsBooleanKeyword => self.booleanType(),
            BoundNode::TsKeywordType(t) if t.kind == KK::TsSymbolKeyword => self.esSymbolType,
            BoundNode::TsKeywordType(t) if t.kind == KK::TsVoidKeyword => self.voidType,
            BoundNode::TsKeywordType(t) if t.kind == KK::TsUndefinedKeyword => self.undefinedType,
            BoundNode::TsKeywordType(t) if t.kind == KK::TsNullKeyword => {
                // TODO(rbuckton): `NullKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service.
                self.nullType
            }
            BoundNode::TsKeywordType(t) if t.kind == KK::TsNeverKeyword => self.neverType,
            BoundNode::TsKeywordType(t) if t.kind == KK::TsObjectKeyword => {
                if isBoundNodeInJSFile(&node) && !self.noImplicitAny {
                    self.anyType
                } else {
                    self.nonPrimitiveType
                }
            }
            BoundNode::TsKeywordType(t) if t.kind == KK::TsIntrinsicKeyword => {
                self.intrinsicMarkerType
            }
            BoundNode::ThisExpr(_) => {
                // TODO(rbuckton): `ThisKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service and because of `isPartOfTypeNode`.
                self.getTypeFromThisTypeNode(node)
            }
            BoundNode::TsThisType(_) => self.getTypeFromThisTypeNode(node),
            BoundNode::TsLitType(n) => self.getTypeFromLiteralTypeNode(n),
            BoundNode::TsTypeRef(_) => self.getTypeFromTypeReference(node),
            BoundNode::TsTypePredicate(t) => {
                if t.asserts {
                    self.voidType
                } else {
                    self.booleanType()
                }
            }
            BoundNode::TsExprWithTypeArgs(_) => self.getTypeFromTypeReference(node),
            BoundNode::TsTypeQuery(_) => {
                todo!();
                // self.getTypeFromTypeQueryNode(node)
            }
            BoundNode::TsArrayType(_) | BoundNode::TsTupleType(_) => {
                self.getTypeFromArrayOrTupleTypeNode(node)
            }
            BoundNode::TsOptionalType(_) => {
                todo!();
                // self.getTypeFromOptionalTypeNode(node)
            }
            BoundNode::TsUnionType(t) => self.getTypeFromUnionTypeNode(t.clone()),
            BoundNode::TsIntersectionType(t) => self.getTypeFromIntersectionTypeNode(t.clone()),
            // TODO: jsdoc:
            // BoundNode::JSDocNullableType(_) => self.getTypeFromJSDocNullableTypeNode(node),
            // BoundNode::JSDocOptionalType(_) => {
            //     todo!();
            //     // self.addOptionality(getTypeFromTypeNode((node as JSDocOptionalType).type))
            // }
            BoundNode::TsTupleElement(_) => {
                todo!();
                // self.getTypeFromNamedTupleTypeNode(node)
            }
            // TODO: jsdoc:
            // BoundNode::JSDocNonNullableType(_)
            // | BoundNode::JSDocTypeExpression(_)
            BoundNode::TsParenthesizedType(n) => {
                self.getTypeFromTypeNode(n.type_ann.bind(node.clone()))
            }
            BoundNode::TsRestType(_) => {
                todo!();
                // self.getTypeFromRestTypeNode(node)
            }
            // TODO: jsdoc:
            // BoundNode::JSDocVariadicType(_) => {
            //     self.getTypeFromJSDocVariadicType(node as JSDocVariadicType)
            // }
            // TODO: jsdoc:
            // BoundNode::JSDocTypeLiteral(_)
            // | BoundNode::JSDocFunctionType(_)
            // | BoundNode::JSDocSignature(_)
            BoundNode::TsFnType(_) | BoundNode::TsConstructorType(_) | BoundNode::TsTypeLit(_) => {
                self.getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
            }
            BoundNode::TsTypeOperator(n) => self.getTypeFromTypeOperatorNode(n),
            BoundNode::TsIndexedAccessType(n) => self.getTypeFromIndexedAccessTypeNode(n.clone()),
            BoundNode::TsMappedType(n) => self.getTypeFromMappedTypeNode(n.clone()),
            BoundNode::TsConditionalType(n) => self.getTypeFromConditionalTypeNode(n.clone()),
            BoundNode::TsInferType(n) => self.getTypeFromInferTypeNode(n.clone()),
            BoundNode::TsTplLitType(_) => {
                todo!();
                // self.getTypeFromTemplateTypeNode(node)
            }
            BoundNode::TsImportType(_) => {
                todo!();
                // self.getTypeFromImportTypeNode(node)
            }
            // This function assumes that an identifier, qualified name, or property access expression is a type expression
            // Callers should first ensure this by calling `isPartOfTypeNode`
            // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.
            BoundNode::Ident(_) | BoundNode::TsQualifiedName(_) => {
                if let Some(symbol) = self.getSymbolAtLocation(node, false) {
                    self.getDeclaredTypeOfSymbol(symbol)
                } else {
                    self.errorType
                }
            }
            // This function assumes that an identifier, qualified name, or property access expression is a type expression
            // Callers should first ensure this by calling `isPartOfTypeNode`
            // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.
            BoundNode::MemberExpr(m) if !m.computed => {
                if let Some(symbol) = self.getSymbolAtLocation(node, false) {
                    self.getDeclaredTypeOfSymbol(symbol)
                } else {
                    self.errorType
                }
            }
            _ => self.errorType,
        }
    }

    fn instantiateList<T, M, I>(
        &mut self,
        items: &Rc<Vec<T>>,
        mapper: M,
        mut instantiator: I,
    ) -> Rc<Vec<T>>
    where
        T: PartialEq + Copy,
        M: Clone,
        I: FnMut(&mut Checker, T, M) -> T,
    {
        let mut i = 0;
        while i < items.len() {
            let item = items[i];
            let mapped = instantiator(self, item, mapper.clone());
            if item != mapped {
                let mut result = Vec::with_capacity(items.len());
                result.extend(&items[..i]);
                result.push(mapped);
                i += 1;
                while i < items.len() {
                    result.push(instantiator(self, items[i], mapper.clone()));
                    i += 1;
                }
                return Rc::new(result);
            }

            i += 1;
        }

        items.clone()
    }

    fn instantiateTypes(
        &mut self,
        types: Rc<Vec<TypeId>>,
        mapper: Rc<TypeMapper>,
    ) -> Rc<Vec<TypeId>> {
        self.instantiateList(&types, mapper, |checker, ty, mapper| {
            checker.instantiateType(ty, Some(mapper))
        })
    }

    fn instantiateTypesOptional(
        &mut self,
        types: Option<Rc<Vec<TypeId>>>,
        mapper: Rc<TypeMapper>,
    ) -> Option<Rc<Vec<TypeId>>> {
        types.map(|t| self.instantiateTypes(t, mapper))
    }

    fn instantiateTypesOptionalWithOptionalMapper(
        &mut self,
        types: Option<Rc<Vec<TypeId>>>,
        mapper: Option<Rc<TypeMapper>>,
    ) -> Option<Rc<Vec<TypeId>>> {
        types.map(|types| {
            // Copied from instantiateTypes
            self.instantiateList(&types, mapper, |checker, ty, mapper| {
                checker.instantiateType(ty, mapper)
            })
        })
    }

    fn instantiateSignatures(
        &mut self,
        signatures: Rc<Vec<SignatureId>>,
        mapper: Rc<TypeMapper>,
    ) -> Rc<Vec<SignatureId>> {
        self.instantiateList(&signatures, mapper, |checker, sig, mapper| {
            checker.instantiateSignature(sig, mapper, false)
        })
    }

    fn instantiateIndexInfos(
        &mut self,
        indexInfos: Rc<Vec<IndexInfoId>>,
        mapper: Rc<TypeMapper>,
    ) -> Rc<Vec<IndexInfoId>> {
        self.instantiateList(&indexInfos, mapper, |checker, info, mapper| {
            checker.instantiateIndexInfo(info, mapper)
        })
    }

    fn createTypeMapper(
        &self,
        sources: Rc<Vec<TypeId>>,
        targets: Option<Rc<Vec<TypeId>>>,
    ) -> Rc<TypeMapper> {
        if sources.len() == 1 {
            let target = if let Some(targets) = targets {
                targets[0]
            } else {
                self.anyType
            };
            TypeMapper::makeUnaryTypeMapper(sources[0], target)
        } else {
            TypeMapper::makeArrayTypeMapper(sources, targets)
        }
    }

    fn getMappedType(&mut self, ty: TypeId, mapper: Rc<TypeMapper>) -> TypeId {
        match mapper.as_ref() {
            TypeMapper::Simple { source, target } => {
                if ty == *source {
                    *target
                } else {
                    ty
                }
            }
            TypeMapper::Array { sources, targets } => {
                for (i, &source) in sources.iter().enumerate() {
                    if ty == source {
                        return if let Some(targets) = targets {
                            targets[i]
                        } else {
                            self.anyType
                        };
                    }
                }
                ty
            }
            TypeMapper::Function { func } => {
                return func(self, ty);
            }
            TypeMapper::Composite { mapper1, mapper2 } => {
                let t1 = self.getMappedType(ty, mapper1.clone());
                if t1 != ty {
                    self.instantiateType(t1, Some(mapper2.clone()))
                } else {
                    self.getMappedType(t1, mapper2.clone())
                }
            }
            TypeMapper::Merged { mapper1, mapper2 } => {
                let t1 = self.getMappedType(ty, mapper1.clone());
                self.getMappedType(t1, mapper2.clone())
            }
        }
    }

    fn createTypeEraser(&self, sources: Rc<Vec<TypeId>>) -> Rc<TypeMapper> {
        self.createTypeMapper(sources, None)
    }

    // TODO:
    // mergeTypeMappers
    // TODO:
    // prependTypeMapping
    // TODO:
    // appendTypeMapping
    // TODO:
    // getRestrictiveTypeParameter

    fn cloneTypeParameter(&mut self, typeParameter: TypeId) -> TypeId {
        let sym = unwrap_as!(
            &self.types[typeParameter],
            Type::TypeParameter(t),
            t.get_symbol().clone()
        );
        let result = self.createTypeParameter(sym);
        unwrap_as!(&mut self.types[result], Type::TypeParameter(t), t).target = Some(typeParameter);
        result
    }

    fn instantiateTypePredicate(
        &mut self,
        predicate: TypePredicate,
        mapper: Option<Rc<TypeMapper>>,
    ) -> TypePredicate {
        let mut predicate = predicate.clone();
        match &mut predicate {
            TypePredicate::ThisTypePredicate { ty } => {
                *ty = self.instantiateType(*ty, mapper);
            }
            TypePredicate::IdentifierTypePredicate { ty, .. } => {
                *ty = self.instantiateType(*ty, mapper);
            }
            TypePredicate::AssertsThisTypePredicate { ty } => {
                *ty = self.instantiateTypeOptional(*ty, mapper);
            }
            TypePredicate::AssertsIdentifierTypePredicate { ty, .. } => {
                *ty = self.instantiateTypeOptional(*ty, mapper);
            }
        }
        predicate
    }

    fn instantiateSignature(
        &mut self,
        signature: SignatureId,
        mut mapper: Rc<TypeMapper>,
        eraseTypeParameters: bool,
    ) -> SignatureId {
        let mut freshTypeParameters = None;
        if let Some(sig_type_params) = self.signatures[signature].typeParameters.clone() {
            if !eraseTypeParameters {
                // First create a fresh set of type parameters, then include a mapping from the old to the
                // new type parameters in the mapper function. Finally store this mapper in the new type
                // parameters such that we can use it when instantiating constraints.
                let mut fresh_type_params = sig_type_params.as_ref().clone();
                for t in &mut fresh_type_params {
                    *t = self.cloneTypeParameter(*t);
                }
                let fresh_type_params = Rc::new(fresh_type_params);
                mapper = TypeMapper::combineTypeMappers(
                    Some(self.createTypeMapper(sig_type_params, Some(fresh_type_params.clone()))),
                    mapper,
                );
                for tp in fresh_type_params.iter() {
                    unwrap_as!(&mut self.types[*tp], Type::TypeParameter(t), t).mapper =
                        Some(mapper.clone());
                }
                freshTypeParameters = Some(fresh_type_params);
            }
        }

        let sig = &self.signatures[signature];
        let declaration = sig.declaration.clone();
        let minArgumentCount = sig.minArgumentCount;
        let flags = sig.flags & SignatureFlags::PropagatingFlags;
        let parameters = sig.parameters.clone();
        let this_parameter = sig
            .thisParameter
            .clone()
            .map(|p| self.instantiateSymbol(p, mapper.clone()));
        let parameters =
            self.instantiateList(&parameters, mapper.clone(), |checker, sym, mapper| {
                checker.instantiateSymbol(sym, mapper)
            });
        // Don't compute resolvedReturnType and resolvedTypePredicate now,
        // because using `mapper` now could trigger inferences to become fixed. (See `createInferenceContext`.)
        // See GH#17600.
        let result = self.createSignature(
            declaration,
            freshTypeParameters,
            this_parameter,
            parameters.into(),
            /*resolvedReturnType*/ None,
            // /*resolvedTypePredicate*/ None,
            minArgumentCount,
            flags,
        );
        self.signatures[result].target = Some(signature);
        self.signatures[result].mapper = Some(mapper);
        result
    }

    fn instantiateSymbol(&mut self, mut symbol: SymbolId, mut mapper: Rc<TypeMapper>) -> SymbolId {
        let original_sym = symbol;
        if let Some(ty) = self.getSymbolLinks(original_sym).ty {
            if self.couldContainTypeVariables(ty) {
                // If the type of the symbol is already resolved, and if that type could not possibly
                // be affected by instantiation, simply return the symbol itself.
                return symbol;
            }
        }
        if getCheckFlags(&self.symbols[symbol]).intersects(CheckFlags::Instantiated) {
            // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
            // type mappers. This ensures that original type identities are properly preserved and that aliases
            // always reference a non-aliases.
            let links = self.getSymbolLinks(original_sym);
            symbol = links.target.unwrap();
            mapper = TypeMapper::combineTypeMappers(links.mapper.clone(), mapper);
        }
        // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
        // also transient so that we can just store data on it directly.
        let check_flags = CheckFlags::Instantiated
            | getCheckFlags(&self.symbols[symbol])
                & (CheckFlags::Readonly
                    | CheckFlags::Late
                    | CheckFlags::OptionalParameter
                    | CheckFlags::RestParameter);
        let result_id = self.createSymbol(
            self.symbols[symbol].flags(),
            self.symbols[symbol].escapedName().clone(),
            Some(check_flags),
        );
        let declarations = self.symbols[symbol].declarations().clone();
        let parent = self.symbols[symbol].parent();
        let valueDeclaration = self.symbols[symbol].valueDeclaration().clone();
        let result = self.get_transient_sym_mut(result_id);
        result.declarations = declarations;
        result.parent = parent;
        result.symbol_links.target = Some(symbol);
        result.symbol_links.mapper = Some(mapper);
        if valueDeclaration.is_some() {
            self.get_transient_sym_mut(result_id).valueDeclaration = valueDeclaration;
        }
        if self.getSymbolLinks(original_sym).nameType.is_some() {
            self.get_transient_sym_mut(result_id).symbol_links.nameType =
                self.getSymbolLinks(original_sym).nameType;
        }
        result_id
    }

    fn getObjectTypeInstantiation(
        &mut self,
        ty: TypeId,
        mapper: Rc<TypeMapper>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let objectFlags = self.types[ty].get_object_flags();
        let declaration = if objectFlags.intersects(ObjectFlags::Reference) {
            self.types[ty]
                .unwrap_as_type_reference()
                .node
                .clone()
                .unwrap()
        } else {
            let sym = self.types[ty].get_symbol().unwrap();
            self.symbols[sym].declarations()[0].clone()
        };
        let links = self.getNodeLinks(declaration.clone());
        let target = if objectFlags.intersects(ObjectFlags::Reference) {
            links.resolvedType.unwrap()
        } else if objectFlags.intersects(ObjectFlags::Instantiated) {
            todo!();
            // ty.target.unwrap()
        } else {
            ty
        };
        let typeParameters = match &links.outerTypeParameters {
            Some(p) => p.clone(),
            None => {
                // The first time an anonymous type is instantiated we compute and store a list of the type
                // parameters that are in scope (and therefore potentially referenced). For type literals that
                // aren't the right hand side of a generic type alias declaration we optimize by reducing the
                // set of type parameters to those that are possibly referenced in the literal.
                let outerTypeParameters = self.getOuterTypeParameters(declaration.clone(), true);
                if self.isJSConstructor(Some(declaration.clone())) {
                    todo!();
                    // const templateTagParameters = self.getTypeParametersFromDeclaration(declaration as DeclarationWithTypeParameters);
                    // outerTypeParameters = addRange(outerTypeParameters, templateTagParameters);
                }
                let mut typeParameters = outerTypeParameters.unwrap_or_default();
                let target_ty = &self.types[target];
                let target_sym = &self.symbols[target_ty.get_symbol().unwrap()];
                typeParameters = if (target_ty
                    .get_object_flags()
                    .intersects(ObjectFlags::Reference)
                    || target_sym.flags().intersects(SymbolFlags::Method)
                    || target_sym.flags().intersects(SymbolFlags::TypeLiteral))
                    && target_ty.get_aliasTypeArguments().is_none()
                {
                    let allDeclarations = if objectFlags.intersects(ObjectFlags::Reference) {
                        vec![declaration.clone()]
                    } else {
                        let sym = self.types[ty].get_symbol().unwrap();
                        // TODO: bad clone:
                        self.symbols[sym].declarations().clone()
                    };
                    typeParameters
                        .into_iter()
                        .filter(|tp| {
                            allDeclarations
                                .iter()
                                .any(|d| self.isTypeParameterPossiblyReferenced(*tp, d.clone()))
                        })
                        .collect()
                } else {
                    typeParameters
                };
                let typeParameters = Rc::new(typeParameters);
                self.getNodeLinks_mut(declaration.clone())
                    .outerTypeParameters = Some(typeParameters.clone());
                typeParameters
            }
        };
        if !typeParameters.is_empty() {
            // We are instantiating an anonymous type that has one or more type parameters in scope. Apply the
            // mapper to the type parameters to produce the effective list of type arguments, and compute the
            // instantiation cache key from the type IDs of the type arguments.
            let combinedMapper = TypeMapper::combineTypeMappers(
                self.types[ty].get_type_mapper().cloned(),
                mapper.clone(),
            );
            let typeArguments = typeParameters
                .iter()
                .map(|t| self.getMappedType(*t, combinedMapper.clone()))
                .collect::<Vec<_>>();
            let typeArguments = Rc::new(typeArguments);
            let newAliasSymbol = aliasSymbol.or(*self.types[ty].get_aliasSymbol());
            let newAliasTypeArguments = if aliasSymbol.is_some() {
                aliasTypeArguments
            } else {
                self.instantiateTypesOptional(
                    self.types[ty].get_aliasTypeArguments().clone(),
                    mapper,
                )
            };
            // TODO:
            fn todo_hash(a: u64, b: u64) -> TypeList {
                TypeList(hash![a, b])
            }
            let id = todo_hash(
                self.getTypeListId(Some(typeArguments.as_ref())).0,
                self.getAliasId(
                    newAliasSymbol,
                    newAliasTypeArguments.as_ref().map(|v| v.as_ref()),
                ),
            );
            if self.types[target].unwrap_instantiations().is_empty() {
                let key = todo_hash(
                    self.getTypeListId(Some(typeParameters.as_ref())).0,
                    self.getAliasId(
                        *self.types[target].get_aliasSymbol(),
                        self.types[target]
                            .get_aliasTypeArguments()
                            .as_ref()
                            .map(|v| v.as_ref()),
                    ),
                );
                self.types[target]
                    .unwrap_instantiations_mut()
                    .insert(key, target);
            }
            return match self.types[target].unwrap_instantiations().get(&id) {
                Some(result) => *result,
                None => {
                    let newMapper = self.createTypeMapper(typeParameters, Some(typeArguments));
                    let result = if self.types[target]
                        .get_object_flags()
                        .intersects(ObjectFlags::Reference)
                    {
                        self.createDeferredTypeReference(
                            self.types[ty].unwrap_as_type_reference().target.unwrap(),
                            self.types[ty]
                                .unwrap_as_type_reference()
                                .node
                                .clone()
                                .unwrap(),
                            Some(newMapper),
                            newAliasSymbol,
                            newAliasTypeArguments,
                        )
                    } else if self.types[target]
                        .get_object_flags()
                        .intersects(ObjectFlags::Mapped)
                    {
                        self.instantiateMappedType(
                            target,
                            newMapper,
                            newAliasSymbol,
                            newAliasTypeArguments,
                        )
                    } else {
                        self.instantiateAnonymousType(
                            target,
                            newMapper,
                            newAliasSymbol,
                            newAliasTypeArguments,
                        )
                    };
                    self.types[target]
                        .unwrap_instantiations_mut()
                        .insert(id, result);
                    result
                }
            };
        }
        ty
    }

    // TODO:
    // maybeTypeParameterReference

    fn isTypeParameterPossiblyReferenced(&mut self, tp: TypeId, node: BoundNode) -> bool {
        // If the type parameter doesn't have exactly one declaration, if there are invening statement blocks
        // between the node and the type parameter declaration, if the node contains actual references to the
        // type parameter, or if the node contains type queries, we consider the type parameter possibly referenced.
        if let Some(sym) = self.types[tp].get_symbol() {
            if let Some(container) = self.symbols[*sym].declarations().first().cloned() {
                let mut n = Some(node.clone());
                while n.as_ref() != Some(&container) {
                    if let Some(inner) = n {
                        if matches!(inner, BoundNode::BlockStmt(_))
                            || matches!(&inner,BoundNode::TsConditionalType(t)if contains_reference(self,tp, t.extends_type.bind(inner.clone())))
                        {
                            return true;
                        }
                        n = inner.parent();
                    } else {
                        return true;
                    }
                }
                return contains_reference(self, tp, node);
            }
        }
        return true;

        fn contains_reference(checker: &mut Checker, tp: TypeId, node: BoundNode) -> bool {
            let mut visitor = Visitor {
                checker,
                tp,
                found: false,
            };

            node.visit_with(&mut visitor);
            return visitor.found;
        }

        struct Visitor<'c> {
            checker: &'c mut Checker,
            tp: TypeId,
            found: bool,
        }

        macro_rules! visit_method {
            ([$([$name:ident, $N:ident]$(,)?)*]) => {
                $(
                    #[inline]
                    fn $name(&mut self, n: &Rc<ast::$N>, parent: Option<BoundNode>) {
                        self.found |= n.function.return_type.is_none() && n.function.body.is_some();
                        let node = n.bind_to_opt_parent(parent);
                        let fn_node = Some(n.function.bind(node));
                        if !self.found {
                            n.function.type_params.visit_with(self, fn_node.clone());
                        }
                        if !self.found {
                            n.function.params.visit_with(self, fn_node.clone());
                        }
                        if !self.found {
                            n.function.return_type.visit_with(self, fn_node);
                        }
                    }
                )*

            };
        }

        impl<'c> Visit for Visitor<'c> {
            fn visit_ts_this_type(&mut self, n: &Rc<ast::TsThisType>, parent: Option<BoundNode>) {
                self.found |=
                    unwrap_as!(&self.checker.types[self.tp], Type::TypeParameter(t), t).isThisType;
            }

            fn visit_ident(&mut self, n: &Rc<ast::Ident>, parent: Option<BoundNode>) {
                if !self.found {
                    let node = n.bind_to_opt_parent(parent);
                    self.found = !unwrap_as!(&self.checker.types[self.tp], Type::TypeParameter(t), t)
                            .isThisType
                            && isPartOfTypeNode(&node)
                            && maybeTypeParameterReference(&node)
                            // use worker because we're looking for === equality
                            && self.checker.getTypeFromTypeNodeWorker(node) == self.tp;
                }
            }

            fn visit_ts_type_query(&mut self, n: &Rc<ast::TsTypeQuery>, parent: Option<BoundNode>) {
                self.found |= true;
            }

            visit_method!([
                [visit_private_method, PrivateMethod],
                [visit_class_method, ClassMethod],
                [visit_method_prop, MethodProp],
            ]);

            fn visit_ts_method_signature(
                &mut self,
                n: &Rc<ast::TsMethodSignature>,
                parent: Option<BoundNode>,
            ) {
                let node = Some(n.bind_to_opt_parent(parent));
                if !self.found {
                    n.type_params.visit_with(self, node.clone());
                }
                if !self.found {
                    n.params.visit_with(self, node.clone());
                }
                if !self.found {
                    n.type_ann.visit_with(self, node);
                }
            }
        }

        // TODO: remove
        // fn containsReference(checker: &mut Checker, tp: TypeId, node: BoundNode) -> bool {
        //     match node {
        //         BoundNode::TsThisType(_) => {
        //             unwrap_as!(&checker.types[tp], Type::TypeParameter(t), t).isThisType
        //         }
        //         BoundNode::Ident(_) => {
        //             !unwrap_as!(&checker.types[tp], Type::TypeParameter(t), t).isThisType
        //                 && isPartOfTypeNode(node)
        //                 && maybeTypeParameterReference(node)
        //                 && checker.getTypeFromTypeNodeWorker(node) == tp // use worker because we're looking for === equality
        //         }
        //         BoundNode::TsTypeQuery(_) => true,
        //         BoundNode::PrivateMethod(n) => {
        //             n.function.return_type.is_none() && n.function.body.is_some()
        //                 || n.function
        //                     .type_params
        //                     .as_ref()
        //                     .map(|tps| {
        //                         tps.params.iter().any(|p| {
        //                             containsReference(
        //                                 checker,
        //                                 tp,
        //                                 p.bind(tps.bind(n.function.bind(node))),
        //                             )
        //                         })
        //                     })
        //                     .unwrap_or_default()
        //                 || n.function
        //                     .params
        //                     .iter()
        //                     .any(|p| containsReference(checker, tp, p.bind(n.function.bind(node))))
        //                 || n.function.return_type.is_some()
        //                     && containsReference(
        //                         checker,
        //                         tp,
        //                         n.function.return_type.unwrap().bind(n.function.bind(node)),
        //                     )
        //         }
        //         BoundNode::ClassMethod(n) => {
        //             n.function.return_type.is_none() && n.function.body.is_some()
        //                 || n.function
        //                     .type_params
        //                     .as_ref()
        //                     .map(|tps| {
        //                         tps.params.iter().any(|p| {
        //                             containsReference(
        //                                 checker,
        //                                 tp,
        //                                 p.bind(tps.bind(n.function.bind(node))),
        //                             )
        //                         })
        //                     })
        //                     .unwrap_or_default()
        //                 || n.function
        //                     .params
        //                     .iter()
        //                     .any(|p| containsReference(checker, tp, p.bind(n.function.bind(node))))
        //                 || n.function.return_type.is_some()
        //                     && containsReference(
        //                         checker,
        //                         tp,
        //                         n.function.return_type.unwrap().bind(n.function.bind(node)),
        //                     )
        //         }
        //         BoundNode::MethodProp(n) => {
        //             n.function.return_type.is_none() && n.function.body.is_some()
        //                 || n.function
        //                     .type_params
        //                     .as_ref()
        //                     .map(|tps| {
        //                         tps.params.iter().any(|p| {
        //                             containsReference(
        //                                 checker,
        //                                 tp,
        //                                 p.bind(tps.bind(n.function.bind(node))),
        //                             )
        //                         })
        //                     })
        //                     .unwrap_or_default()
        //                 || n.function
        //                     .params
        //                     .iter()
        //                     .any(|p| containsReference(checker, tp, p.bind(n.function.bind(node))))
        //                 || n.function.return_type.is_some()
        //                     && containsReference(
        //                         checker,
        //                         tp,
        //                         n.function.return_type.unwrap().bind(n.function.bind(node)),
        //                     )
        //         }
        //         BoundNode::TsMethodSignature(n) => {
        //             n.type_params
        //                 .map(|tps| {
        //                     tps.params
        //                         .iter()
        //                         .any(|p| containsReference(checker, tp, p.bind(tps.bind(node))))
        //                 })
        //                 .unwrap_or_default()
        //                 || n.params
        //                     .iter()
        //                     .any(|p| containsReference(checker, tp, p.bind(node)))
        //                 || n.type_ann.is_some()
        //                     && containsReference(checker, tp, n.type_ann.unwrap().bind(node))
        //         }
        //         _ => !!forEachChild(node, containsReference),
        //     }
        // }
    }

    fn getHomomorphicTypeVariable(&mut self, ty: TypeId) -> Option<TypeId> {
        debug_assert!(matches!(&self.types[ty], Type::MappedType(_)));
        let constraintType = self.getConstraintTypeFromMappedType(ty);
        if self.types[constraintType]
            .get_flags()
            .intersects(TypeFlags::Index)
        {
            let constraintType = unwrap_as!(&self.types[constraintType], Type::IndexType(t), t);
            let typeVariable = self.getActualTypeVariable(constraintType.ty);
            if self.types[typeVariable]
                .get_flags()
                .intersects(TypeFlags::TypeParameter)
            {
                return Some(typeVariable);
            }
        }
        None
    }

    fn instantiateMappedType(
        &mut self,
        ty: TypeId,
        mapper: Rc<TypeMapper>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        // For a homomorphic mapped type { [P in keyof T]: X }, where T is some type variable, the mapping
        // operation depends on T as follows:
        // * If T is a primitive type no mapping is performed and the result is simply T.
        // * If T is a union type we distribute the mapped type over the union.
        // * If T is an array we map to an array where the element type has been transformed.
        // * If T is a tuple we map to a tuple where the element types have been transformed.
        // * Otherwise we map to an object type where the type of each property has been transformed.
        // For example, when T is instantiated to a union type A | B, we produce { [P in keyof A]: X } |
        // { [P in keyof B]: X }, and when when T is instantiated to a union type A | undefined, we produce
        // { [P in keyof A]: X } | undefined.
        if let Some(typeVariable) = self.getHomomorphicTypeVariable(ty) {
            let mappedTypeVariable = self.instantiateType(typeVariable, Some(mapper.clone()));
            if typeVariable != mappedTypeVariable {
                todo!();
                // return self.mapTypeWithAlias(self.getReducedType(mappedTypeVariable), |t|  {
                //     if (t.flags & (TypeFlags::AnyOrUnknown | TypeFlags::InstantiableNonPrimitive | TypeFlags::Object | TypeFlags::Intersection) && t != wildcardType && !isErrorType(t)) {
                //         if (!ty.declaration.nameType) {
                //             if (isArrayType(t)) {
                //                 return self.instantiateMappedArrayType(t, ty, prependTypeMapping(typeVariable, t, mapper));
                //             }
                //             if (isGenericTupleType(t)) {
                //                 return self.instantiateMappedGenericTupleType(t, ty, typeVariable, mapper);
                //             }
                //             if (isTupleType(t)) {
                //                 return self.instantiateMappedTupleType(t, ty, prependTypeMapping(typeVariable, t, mapper));
                //             }
                //         }
                //         return self.instantiateAnonymousType(ty, prependTypeMapping(typeVariable, t, mapper));
                //     }
                //     return t;
                // }, aliasSymbol, aliasTypeArguments);
            }
        }
        // If the constraint type of the instantiation is the wildcard type, return the wildcard type.
        let constraint_ty = self.getConstraintTypeFromMappedType(ty);
        if self.instantiateType(constraint_ty, Some(mapper.clone())) == self.wildcardType {
            self.wildcardType
        } else {
            self.instantiateAnonymousType(ty, mapper, aliasSymbol, aliasTypeArguments)
        }
    }

    // TODO:
    // getModifiedReadonlyState
    // TODO:
    // instantiateMappedGenericTupleType
    // TODO:
    // instantiateMappedArrayType
    // TODO:
    // instantiateMappedTupleType
    // TODO:
    // instantiateMappedTypeTemplate

    fn instantiateAnonymousType(
        &mut self,
        ty: TypeId,
        mapper: Rc<TypeMapper>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let objectFlags = self.types[ty].get_object_flags();
        if let Type::MappedType(t) = &self.types[ty] {
            let mut result = MappedType {
                anonymous_type: AnonymousTypeBase {
                    target: Some(ty),
                    ..Default::default()
                },
                object_type_base: ObjectTypeBase::new(objectFlags | ObjectFlags::Instantiated),
                type_base: TypeBase::new(TypeFlags::Object, *self.types[ty].get_symbol()),
                declaration: t.declaration.clone(),
                typeParameter: None,
                constraintType: None,
                nameType: None,
                templateType: None,
                modifiersType: None,
                resolvedApparentType: None,
                containsError: false,
            };

            // C.f. instantiateSignature
            let origTypeParameter = self.getTypeParameterFromMappedType(ty);
            let freshTypeParameter = self.cloneTypeParameter(origTypeParameter);
            result.typeParameter = Some(freshTypeParameter);
            let mapper = TypeMapper::combineTypeMappers(
                Some(TypeMapper::makeUnaryTypeMapper(
                    origTypeParameter,
                    freshTypeParameter,
                )),
                mapper,
            );
            unwrap_as!(
                &mut self.types[freshTypeParameter],
                Type::TypeParameter(t),
                t
            )
            .mapper = Some(mapper.clone());

            result.anonymous_type.mapper = Some(mapper.clone());
            result.type_base.aliasSymbol = aliasSymbol.or(*self.types[ty].get_aliasSymbol());
            result.type_base.aliasTypeArguments = if aliasSymbol.is_some() {
                aliasTypeArguments
            } else {
                self.instantiateTypesOptional(
                    self.types[ty].get_aliasTypeArguments().clone(),
                    mapper,
                )
            };
            self.types.push(Type::MappedType(result))
        } else {
            let type_base = TypeBase {
                flags: TypeFlags::Object,
                symbol: *self.types[ty].get_symbol(),
                aliasSymbol: aliasSymbol.or(*self.types[ty].get_aliasSymbol()),
                aliasTypeArguments: if aliasSymbol.is_some() {
                    aliasTypeArguments
                } else {
                    self.instantiateTypesOptional(
                        self.types[ty].get_aliasTypeArguments().clone(),
                        mapper.clone(),
                    )
                },
                ..Default::default()
            };
            self.types.push(Type::AnonymousType(AnonymousType {
                anonymous_type: AnonymousTypeBase {
                    target: Some(ty),
                    mapper: Some(mapper),
                    instantiations: Default::default(),
                },
                object_type_base: ObjectTypeBase::new(objectFlags | ObjectFlags::Instantiated),
                type_base,
            }))
        }
    }

    fn getConditionalTypeInstantiation(
        &mut self,
        ty: TypeId,
        mapper: Rc<TypeMapper>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let root = unwrap_as!(&self.types[ty], Type::ConditionalType(t), t).root;
        if let Some(outerTypeParameters) = self.conditional_roots[root].outerTypeParameters.clone()
        {
            // We are instantiating a conditional type that has one or more type parameters in scope. Apply the
            // mapper to the type parameters to produce the effective list of type arguments, and compute the
            // instantiation cache key from the type IDs of the type arguments.
            let typeArguments = outerTypeParameters
                .iter()
                .map(|&t| self.getMappedType(t, mapper.clone()))
                .collect::<Vec<_>>();
            let make_instantiation_cache_key = || {
                let type_list_id = self.getTypeListId(Some(&typeArguments));
                let alias_id =
                    self.getAliasId(aliasSymbol, aliasTypeArguments.as_ref().map(|v| v.as_ref()));
                hash![type_list_id, alias_id]
            };
            let id = make_instantiation_cache_key();
            return match self.conditional_roots[root].instantiations.get(&id) {
                Some(result) => *result,
                None => {
                    let newMapper =
                        self.createTypeMapper(outerTypeParameters, Some(Rc::new(typeArguments)));
                    let checkType = self.conditional_roots[root].checkType;
                    let distributionType = if self.conditional_roots[root].isDistributive {
                        Some(self.getMappedType(checkType, newMapper.clone()))
                    } else {
                        None
                    };
                    // Distributive conditional types are distributed over union types. For example, when the
                    // distributive conditional type T extends U ? X : Y is instantiated with A | B for T, the
                    // result is (A extends U ? X : Y) | (B extends U ? X : Y).
                    let result = if distributionType.is_some()
                        && checkType != distributionType.unwrap()
                        && self.types[distributionType.unwrap()]
                            .get_flags()
                            .intersects(TypeFlags::Union | TypeFlags::Never)
                    {
                        todo!();
                        // self.mapTypeWithAlias(
                        //     distributionType.unwrap(),
                        //     |t| {
                        //         self.getConditionalType(
                        //             root,
                        //             self.prependTypeMapping(checkType, t, newMapper),
                        //             None,
                        //             None,
                        //         )
                        //     },
                        //     aliasSymbol,
                        //     aliasTypeArguments,
                        // )
                    } else {
                        self.getConditionalType(
                            root,
                            Some(newMapper),
                            aliasSymbol,
                            aliasTypeArguments,
                        )
                    };
                    self.conditional_roots[root]
                        .instantiations
                        .insert(id, result);
                    result
                }
            };
        }
        ty
    }

    fn instantiateType(&mut self, ty: TypeId, mapper: Option<Rc<TypeMapper>>) -> TypeId {
        if let Some(mapper) = mapper {
            self.instantiateTypeWithAlias(ty, mapper, None, None)
        } else {
            ty
        }
    }
    fn instantiateTypeOptional(
        &mut self,
        ty: Option<TypeId>,
        mapper: Option<Rc<TypeMapper>>,
    ) -> Option<TypeId> {
        if let (Some(ty), Some(mapper)) = (ty, mapper) {
            Some(self.instantiateTypeWithAlias(ty, mapper, None, None))
        } else {
            ty
        }
    }

    fn instantiateTypeWithAlias(
        &mut self,
        ty: TypeId,
        mapper: Rc<TypeMapper>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        if !self.couldContainTypeVariables(ty) {
            return ty;
        }
        if self.instantiationDepth == 100 || self.instantiationCount >= 5000000 {
            todo!()
            // We have reached 100 recursive type instantiations, or 5M type instantiations caused by the same statement
            // or expression. There is a very high likelyhood we're dealing with a combination of infinite generic types
            // that perpetually generate new type identities, so we stop the recursion here by yielding the error type.
            // tracing?.instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit", { typeId: ty.id, instantiationDepth, instantiationCount });
            // error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
            // return errorType;
        }
        // self.totalInstantiationCount+=1;
        self.instantiationCount += 1;
        self.instantiationDepth += 1;
        let result = self.instantiateTypeWorker(ty, mapper, aliasSymbol, aliasTypeArguments);
        self.instantiationDepth -= 1;
        result
    }

    fn instantiateTypeWorker(
        &mut self,
        ty: TypeId,
        mapper: Rc<TypeMapper>,
        aliasSymbol: Option<SymbolId>,
        aliasTypeArguments: Option<Rc<Vec<TypeId>>>,
    ) -> TypeId {
        let flags = self.types[ty].get_flags();
        if flags.intersects(TypeFlags::TypeParameter) {
            return self.getMappedType(ty, mapper);
        }
        if flags.intersects(TypeFlags::Object) {
            let objectFlags = self.types[ty].get_object_flags();
            if objectFlags
                .intersects(ObjectFlags::Reference | ObjectFlags::Anonymous | ObjectFlags::Mapped)
            {
                if objectFlags.intersects(ObjectFlags::Reference)
                    && self.types[ty].unwrap_as_type_reference().node.is_none()
                {
                    let resolvedTypeArguments = self.types[ty]
                        .unwrap_as_type_reference()
                        .resolvedTypeArguments
                        .clone();
                    let newTypeArguments =
                        self.instantiateTypesOptional(resolvedTypeArguments.clone(), mapper);
                    let eq = match (&newTypeArguments, &resolvedTypeArguments) {
                        (Some(new), Some(resolved)) => Rc::ptr_eq(new, resolved),
                        (None, None) => true,
                        _ => false,
                    };
                    return if !eq {
                        self.createNormalizedTypeReference(
                            self.types[ty].unwrap_as_type_reference().target.unwrap(),
                            newTypeArguments,
                        )
                    } else {
                        ty
                    };
                }
                if objectFlags.intersects(ObjectFlags::ReverseMapped) {
                    todo!();
                    // return instantiateReverseMappedType(ty as ReverseMappedType, mapper);
                }
                return self.getObjectTypeInstantiation(
                    ty,
                    mapper,
                    aliasSymbol,
                    aliasTypeArguments,
                );
            }
            return ty;
        }
        if flags.intersects(TypeFlags::UnionOrIntersection) {
            todo!();
            // const origin = ty_flags & TypeFlags::Union ? (ty as UnionType).origin : undefined;
            // const types = origin && origin.flags & TypeFlags::UnionOrIntersection ? (origin as UnionOrIntersectionType).types : (ty as UnionOrIntersectionType).types;
            // const newTypes = instantiateTypes(types, mapper);
            // if (newTypes === types && aliasSymbol === ty.aliasSymbol) {
            //     return ty;
            // }
            // const newAliasSymbol = aliasSymbol || ty.aliasSymbol;
            // const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(ty.aliasTypeArguments, mapper);
            // return flags & TypeFlags::Intersection || origin && origin.flags & TypeFlags::Intersection ?
            //     getIntersectionType(newTypes, newAliasSymbol, newAliasTypeArguments) :
            //     getUnionType(newTypes, UnionReduction.Literal, newAliasSymbol, newAliasTypeArguments);
        }
        if flags.intersects(TypeFlags::Index) {
            todo!();
            // return getIndexType(instantiateType((ty as IndexType).ty, mapper));
        }
        if flags.intersects(TypeFlags::TemplateLiteral) {
            todo!();
            // return getTemplateLiteralType((ty as TemplateLiteralType).texts, instantiateTypes((ty as TemplateLiteralType).types, mapper));
        }
        if flags.intersects(TypeFlags::StringMapping) {
            todo!();
            // return getStringMappingType((ty as StringMappingType).symbol, instantiateType((ty as StringMappingType).ty, mapper));
        }
        if flags.intersects(TypeFlags::IndexedAccess) {
            todo!();
            // const newAliasSymbol = aliasSymbol || ty.aliasSymbol;
            // const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(ty.aliasTypeArguments, mapper);
            // return getIndexedAccessType(instantiateType((ty as IndexedAccessType).objectType, mapper), instantiateType((ty as IndexedAccessType).indexType, mapper), (ty as IndexedAccessType).accessFlags, /*accessNode*/ undefined, newAliasSymbol, newAliasTypeArguments);
        }
        if let Type::ConditionalType(t) = &self.types[ty] {
            return self.getConditionalTypeInstantiation(
                ty,
                TypeMapper::combineTypeMappers(t.mapper.clone(), mapper),
                aliasSymbol,
                aliasTypeArguments,
            );
        }
        if flags.intersects(TypeFlags::Substitution) {
            todo!();
            // const maybeVariable = instantiateType((ty as SubstitutionType).baseType, mapper);
            // if (maybeVariable.flags & TypeFlags::TypeVariable) {
            //     return getSubstitutionType(maybeVariable as TypeVariable, instantiateType((ty as SubstitutionType).substitute, mapper));
            // }
            // else {
            //     const sub = instantiateType((ty as SubstitutionType).substitute, mapper);
            //     if (sub.flags & TypeFlags::AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(maybeVariable), getRestrictiveInstantiation(sub))) {
            //         return maybeVariable;
            //     }
            //     return sub;
            // }
        }
        ty
    }

    // TODO:
    // instantiateReverseMappedType
    // TODO:
    // getPermissiveInstantiation
    // TODO:
    // getRestrictiveInstantiation

    fn instantiateIndexInfo(&mut self, info: IndexInfoId, mapper: Rc<TypeMapper>) -> IndexInfoId {
        let ty = self.instantiateType(self.index_infos[info].ty, Some(mapper));
        let old = &self.index_infos[info];
        let new = IndexInfo {
            keyType: old.keyType,
            ty,
            isReadonly: old.isReadonly,
            declaration: old.declaration.clone(),
        };
        self.index_infos.push(new)
    }

    // TODO:
    // getTypeWithoutSignatures

    fn isTypeIdenticalTo(&mut self, source: TypeId, target: TypeId) -> bool {
        self.isTypeRelatedTo(source, target, self.identityRelation)
    }

    // TODO:
    // compareTypesIdentical

    fn compareTypesAssignable(&mut self, source: TypeId, target: TypeId) -> Ternary {
        if self.isTypeRelatedTo(source, target, self.assignableRelation) {
            Ternary::True
        } else {
            Ternary::False
        }
    }

    // TODO:
    // compareTypesSubtypeOf

    fn isTypeSubtypeOf(&mut self, source: TypeId, target: TypeId) -> bool {
        self.isTypeRelatedTo(source, target, self.subtypeRelation)
    }

    fn isTypeAssignableTo(&mut self, source: TypeId, target: TypeId) -> bool {
        self.isTypeRelatedTo(source, target, self.assignableRelation)
    }

    // TODO:
    // isTypeDerivedFrom
    // TODO:
    // isTypeComparableTo
    // TODO:
    // areTypesComparable
    // TODO:
    // checkTypeAssignableTo
    // TODO:
    // checkTypeAssignableToAndOptionallyElaborate
    // TODO:
    // checkTypeRelatedToAndOptionallyElaborate
    // TODO:
    // isOrHasGenericConditional
    // TODO:
    // elaborateError
    // TODO:
    // elaborateDidYouMeanToCallOrConstruct
    // TODO:
    // elaborateArrowFunction
    // TODO:
    // getBestMatchIndexedAccessTypeOrUndefined
    // TODO:
    // checkExpressionForMutableLocationWithContextualType
    // TODO:
    // elaborateElementwise
    // TODO:
    // generateJsxAttributes
    // TODO:
    // generateJsxChildren
    // TODO:
    // getElaborationElementForJsxChild
    // TODO:
    // elaborateJsxComponents
    // TODO:
    // generateLimitedTupleElements
    // TODO:
    // elaborateArrayLiteral
    // TODO:
    // generateObjectLiteralElements
    // TODO:
    // elaborateObjectLiteral
    // TODO:
    // checkTypeComparableTo
    // TODO:
    // isSignatureAssignableTo
    // TODO:
    // isAnySignature
    // TODO:
    // compareSignaturesRelated
    // TODO:
    // compareTypePredicateRelatedTo
    // TODO:
    // isImplementationCompatibleWithOverload

    fn isEmptyResolvedType(&self, t: TypeId) -> bool {
        let ty = unwrap_as!(&self.types[t], Type::ResolvedType(t), t);
        t != self.anyFunctionType
            && ty.object_type_base.properties.is_empty()
            && ty.object_type_base.callSignatures.is_empty()
            && ty.object_type_base.constructSignatures.is_empty()
            && ty.object_type_base.indexInfos.is_empty()
    }

    fn isEmptyObjectType(&mut self, ty: TypeId) -> bool {
        let flags = self.types[ty].get_flags();
        if flags.intersects(TypeFlags::Object) {
            if !self.isGenericMappedType(ty) {
                self.resolveStructuredTypeMembers(ty);
                self.isEmptyResolvedType(ty)
            } else {
                false
            }
        } else if flags.intersects(TypeFlags::NonPrimitive) {
            true
        } else if flags.intersects(TypeFlags::Union) {
            self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
                .iter()
                .any(|&t| self.isEmptyObjectType(t))
        } else if flags.intersects(TypeFlags::Intersection) {
            self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
                .iter()
                .all(|&t| self.isEmptyObjectType(t))
        } else {
            false
        }
    }

    fn isEmptyAnonymousObjectType(&mut self, ty: TypeId) -> bool {
        !!(self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::Anonymous)
            && (matches!(&self.types[ty], Type::ResolvedType(t) if t.object_type_base.members.is_some())
                && self.isEmptyResolvedType(ty)
                || self.types[ty]
                    .get_symbol()
                    .clone()
                    .map(|s| {
                        if self.symbols[s].flags().intersects(SymbolFlags::TypeLiteral) {
                            let members = self.getMembersOfSymbol(s);
                            self.symbol_tables[members].is_empty()
                        } else {
                            false
                        }
                    })
                    .unwrap_or_default()))
    }

    fn isStringIndexSignatureOnlyType(&mut self, ty: TypeId) -> bool {
        self.types[ty].get_flags().intersects(TypeFlags::Object)
            && !self.isGenericMappedType(ty)
            && self.getPropertiesOfType(ty).len() == 0
            && self.getIndexInfosOfType(ty).len() == 1
            && self.getIndexInfoOfType(ty, self.stringType).is_some()
            || self.types[ty]
                .get_flags()
                .intersects(TypeFlags::UnionOrIntersection)
                && self.types[ty]
                    .unwrap_as_union_or_intersection()
                    .types
                    .clone()
                    .iter()
                    .all(|&t| self.isStringIndexSignatureOnlyType(t))
            || false
    }

    // TODO:
    // isEnumTypeRelatedTo
    // TODO:
    // isSimpleTypeRelatedTo

    fn isTypeRelatedTo(
        &mut self,
        mut source: TypeId,
        mut target: TypeId,
        relation: TypeRelationTableId,
    ) -> bool {
        if self.isFreshLiteralType(source) {
            source = self.types[source].get_literal_regular_type();
        }
        if self.isFreshLiteralType(target) {
            target = self.types[target].get_literal_regular_type();
        }
        if source == target {
            return true;
        }
        if relation != self.identityRelation {
            todo!();
            // if relation == comparableRelation && !(target.flags & TypeFlags::Never) && self.isSimpleTypeRelatedTo(target, source, relation) || self.isSimpleTypeRelatedTo(source, target, relation) {
            //     return true;
            // }
        } else {
            if self.types[source].get_flags() != self.types[target].get_flags() {
                return false;
            }
            if self.types[source]
                .get_flags()
                .intersects(TypeFlags::Singleton)
            {
                return true;
            }
        }
        if self.types[source].get_flags().intersects(TypeFlags::Object)
            && self.types[target].get_flags().intersects(TypeFlags::Object)
        {
            todo!();
            // let related = relation.get(getRelationKey(source, target, IntersectionState.None, relation));
            // if (related != undefined) {
            //     return !!(related & RelationComparisonResult.Succeeded);
            // }
        }
        if self.types[source]
            .get_flags()
            .intersects(TypeFlags::StructuredOrInstantiable)
            || self.types[target]
                .get_flags()
                .intersects(TypeFlags::StructuredOrInstantiable)
        {
            todo!();
            // return checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined);
        }
        false
    }

    // TODO:
    // isIgnoredJsxProperty
    // TODO:
    // getNormalizedType
    // TODO:
    // checkTypeRelatedTo
    // TODO:
    // typeCouldHaveTopLevelSingletonTypes
    // TODO:
    // getExactOptionalUnassignableProperties
    // TODO:
    // isExactOptionalPropertyMismatch
    // TODO:
    // getExactOptionalProperties
    // TODO:
    // getBestMatchingType
    // TODO:
    // discriminateTypeByDiscriminableItems
    // TODO:
    // discriminateTypeByDiscriminableItems
    // TODO:
    // discriminateTypeByDiscriminableItems
    // TODO:
    // isWeakType
    // TODO:
    // hasCommonProperties
    // TODO:
    // getMarkerTypeReference
    // TODO:
    // getAliasVariances
    // TODO:
    // getVariancesWorker
    // TODO:
    // getVariances
    // TODO:
    // hasCovariantVoidArgument
    // TODO:
    // isUnconstrainedTypeParameter
    // TODO:
    // isNonDeferredTypeReference
    // TODO:
    // isTypeReferenceWithGenericArguments
    // TODO:
    // getTypeReferenceId
    // TODO:
    // getRelationKey
    // TODO:
    // forEachProperty
    // TODO:
    // getDeclaringClass
    // TODO:
    // getTypeOfPropertyInBaseClass
    // TODO:
    // isPropertyInClassDerivedFrom
    // TODO:
    // isValidOverrideOf
    // TODO:
    // isClassDerivedFromDeclaringClasses

    // Return true if the given type is deeply nested. We consider this to be the case when structural type comparisons
    // for 5 or more occurrences or instantiations of the type have been recorded on the given stack. It is possible,
    // though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely
    // expanding. Effectively, we will generate a false positive when two types are structurally equal to at least 5
    // levels, but unequal at some level beyond that.
    // In addition, this will also detect when an indexed access has been chained off of 5 or more times (which is essentially
    // the dual of the structural comparison), and likewise mark the type as deeply nested, potentially adding false positives
    // for finite but deeply expanding indexed accesses (eg, for `Q[P1][P2][P3][P4][P5]`).
    // It also detects when a recursive type reference has expanded 5 or more times, eg, if the true branch of
    // `type A<T> = null extends T ? [A<NonNullable<T>>] : [T]`
    // has expanded into `[A<NonNullable<NonNullable<NonNullable<NonNullable<NonNullable<T>>>>>>]`
    // in such cases we need to terminate the expansion, and we do so here.
    fn isDeeplyNestedType(&mut self, ty: TypeId, stack: &Vec<TypeId>, depth: usize) -> bool {
        if depth >= 5 {
            todo!();
            // let identity = self.getRecursionIdentity(ty);
            // let mut count = 0;
            // for  i in 0..depth {
            //     if self.getRecursionIdentity(stack[i]) == identity {
            //         count+=1;
            //         if count >= 5 {
            //             return true;
            //         }
            //     }
            // }
        }
        false
    }

    // The recursion identity of a type is an object identity that is shared among multiple instantiations of the type.
    // We track recursion identities in order to identify deeply nested and possibly infinite type instantiations with
    // the same origin. For example, when type parameters are in scope in an object type such as { x: T }, all
    // instantiations of that type have the same recursion identity. The default recursion identity is the object
    // identity of the type, meaning that every type is unique. Generally, types with constituents that could circularly
    // reference the type have a recursion identity that differs from the object identity.
    fn getRecursionIdentity(&self, mut ty: TypeId) -> RecursionIdentity {
        let flags = self.types[ty].get_flags();
        // Object and array literals are known not to contain recursive references and don't need a recursion identity.
        if flags.intersects(TypeFlags::Object) && !self.isObjectOrArrayLiteralType(ty) {
            // TODO: I think this should be `self.types[ty].get_object_flags().intersects(ObjectFlags::Reference)`,
            // but the current version matches TSC. I think TSC is wrong.
            // if !self.types[ty].get_object_flags().is_empty() && ObjectFlags::Reference && (ty as TypeReference).node {
            //     // Deferred type references are tracked through their associated AST node. This gives us finer
            //     // granularity than using their associated target because each manifest type reference has a
            //     // unique AST node.
            //     return (ty as TypeReference).node.unwrap();
            // }
            if self.types[ty]
                .get_object_flags()
                .intersects(ObjectFlags::Reference)
            {
                if let Some(node) = &self.types[ty].unwrap_as_type_reference().node {
                    // Deferred type references are tracked through their associated AST node. This gives us finer
                    // granularity than using their associated target because each manifest type reference has a
                    // unique AST node.
                    return RecursionIdentity(hash![node]);
                }
            }
            if let Some(sym) = self.types[ty].get_symbol() {
                if !(self.types[ty]
                    .get_object_flags()
                    .intersects(ObjectFlags::Anonymous)
                    && self.symbols[*sym].flags().intersects(SymbolFlags::Class))
                {
                    // We track all object types that have an associated symbol (representing the origin of the type), but
                    // exclude the static side of classes from this check since it shares its symbol with the instance side.
                    return RecursionIdentity(hash![sym]);
                }
            }
            if self.isTupleType(ty) {
                // Tuple types are tracked through their target type
                let target = unwrap_as!(&self.types[ty], Type::TupleTypeReference(t), t).target;
                return RecursionIdentity(hash![target]);
            }
        }
        if flags.intersects(TypeFlags::TypeParameter) {
            return RecursionIdentity(hash![self.types[ty].get_symbol()]);
        }
        if let Type::IndexedAccessType(t) = &self.types[ty] {
            // Identity is the leftmost object type in a chain of indexed accesses, eg, in A[P][Q] it is A
            ty = t.objectType;
            while let Type::IndexedAccessType(t) = &self.types[ty] {
                ty = t.objectType;
            }
            return RecursionIdentity(hash![ty]);
        }
        if let Type::ConditionalType(t) = &self.types[ty] {
            // The root object represents the origin of the conditional type
            return RecursionIdentity(hash![t.root]);
        }
        RecursionIdentity(hash![ty])
    }

    // TODO:
    // isPropertyIdenticalTo

    fn compareProperties<C>(
        &mut self,
        sourceProp: SymbolId,
        targetProp: SymbolId,
        compareTypes: C,
    ) -> Ternary
    where
        C: FnMut(TypeId, TypeId) -> Ternary,
    {
        // Two members are considered identical when
        // - they are public properties with identical names, optionality, and types,
        // - they are private or protected properties originating in the same declaration and having identical types
        if sourceProp == targetProp {
            return Ternary::True;
        }
        todo!();
        // let sourcePropAccessibility = getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlags::NonPublicAccessibilityModifier;
        // let targetPropAccessibility = getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlags::NonPublicAccessibilityModifier;
        // if (sourcePropAccessibility != targetPropAccessibility) {
        //     return Ternary::False;
        // }
        // if (sourcePropAccessibility) {
        //     if (getTargetSymbol(sourceProp) != getTargetSymbol(targetProp)) {
        //         return Ternary::False;
        //     }
        // }
        // else {
        //     if ((sourceProp.flags & SymbolFlags::Optional) != (targetProp.flags & SymbolFlags::Optional)) {
        //         return Ternary::False;
        //     }
        // }
        // if (isReadonlySymbol(sourceProp) != isReadonlySymbol(targetProp)) {
        //     return Ternary::False;
        // }
        // return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
    }

    fn isMatchingSignature(
        &mut self,
        source: SignatureId,
        target: SignatureId,
        partialMatch: bool,
    ) -> bool {
        let sourceParameterCount = self.getParameterCount(source);
        let targetParameterCount = self.getParameterCount(target);
        let sourceMinArgumentCount = self.getMinArgumentCount(source, None);
        let targetMinArgumentCount = self.getMinArgumentCount(target, None);
        let sourceHasRestParameter = self.hasEffectiveRestParameter(source);
        let targetHasRestParameter = self.hasEffectiveRestParameter(target);
        // A source signature matches a target signature if the two signatures have the same number of required,
        // optional, and rest parameters.
        if sourceParameterCount == targetParameterCount
            && sourceMinArgumentCount == targetMinArgumentCount
            && sourceHasRestParameter == targetHasRestParameter
        {
            return true;
        }
        // A source signature partially matches a target signature if the target signature has no fewer required
        // parameters
        if partialMatch && sourceMinArgumentCount <= targetMinArgumentCount {
            return true;
        }
        false
    }

    /**
     * See signatureRelatedTo, compareSignaturesIdentical
     */
    fn compareSignaturesIdentical<C>(
        &mut self,
        source: SignatureId,
        target: SignatureId,
        partialMatch: bool,
        ignoreThisTypes: bool,
        ignoreReturnTypes: bool,
        mut compareTypes: C,
    ) -> Ternary
    where
        C: FnMut(&mut Checker, TypeId, TypeId) -> Ternary,
    {
        // TODO (drosen): De-duplicate code between related functions.
        if source == target {
            return Ternary::True;
        }
        if !self.isMatchingSignature(source, target, partialMatch) {
            return Ternary::False;
        }
        // Check that the two signatures have the same number of type parameters.
        if self.signatures[source].typeParameters.length()
            != self.signatures[target].typeParameters.length()
        {
            return Ternary::False;
        }
        // Check that type parameter constraints and defaults match. If they do, instantiate the source
        // signature with the type parameters of the target signature and continue the comparison.
        if self.signatures[target].typeParameters.is_some() {
            todo!();
            //    const mapper = createTypeMapper(source.typeParameters!, target.typeParameters);
            //    for (let i = 0; i < target.typeParameters.length; i++) {
            //        const s = source.typeParameters![i];
            //        const t = target.typeParameters[i];
            //        if (!(s === t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) &&
            //            compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))) {
            //            return Ternary.False;
            //        }
            //    }
            //    source = instantiateSignature(source, mapper, /*eraseTypeParameters*/ true);
        }
        let mut result = Ternary::True;
        if !ignoreThisTypes {
            let sourceThisType = self.getThisTypeOfSignature(source);
            if let Some(sourceThisType) = sourceThisType {
                let targetThisType = self.getThisTypeOfSignature(target);
                if let Some(targetThisType) = targetThisType {
                    let related = compareTypes(self, sourceThisType, targetThisType);
                    if related == Ternary::False {
                        return Ternary::False;
                    }
                    result &= related;
                }
            }
        }
        let targetLen = self.getParameterCount(target);
        for i in 0..targetLen {
            let s = self.getTypeAtPosition(source, i);
            let t = self.getTypeAtPosition(target, i);
            let related = compareTypes(self, t, s);
            if related == Ternary::False {
                return Ternary::False;
            }
            result &= related;
        }
        if !ignoreReturnTypes {
            todo!();
            //    let sourceTypePredicate = getTypePredicateOfSignature(source);
            //    let targetTypePredicate = getTypePredicateOfSignature(target);
            //    result &= sourceTypePredicate || targetTypePredicate ?
            //        compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) :
            //        compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
        }
        result
    }

    // TODO:
    // compareTypePredicatesIdentical
    // TODO:
    // literalTypesWithSameBaseType
    // TODO:
    // getSupertypeOrUnion
    // TODO:
    // getCommonSupertype
    // TODO:
    // getCommonSubtype

    fn isArrayType(&self, ty: TypeId) -> bool {
        self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::Reference)
            && (self.types[ty].unwrap_as_type_reference().target == self.globalArrayType
                || self.types[ty].unwrap_as_type_reference().target == self.globalReadonlyArrayType)
    }

    // TODO:
    // isReadonlyArrayType
    // TODO:
    // isMutableArrayOrTuple

    fn getElementTypeOfArrayType(&mut self, ty: TypeId) -> Option<TypeId> {
        if self.isArrayType(ty) {
            todo!();
            // self.getTypeArguments(ty)[0]
        } else {
            None
        }
    }

    fn isArrayLikeType(&mut self, ty: TypeId) -> bool {
        // A type is array-like if it is a reference to the global Array or global ReadonlyArray type,
        // or if it is not the undefined or null type and if it is assignable to ReadonlyArray<any>
        self.isArrayType(ty)
            || !self.types[ty].get_flags().intersects(TypeFlags::Nullable)
                && self.isTypeAssignableTo(ty, self.anyReadonlyArrayType())
    }

    // TODO:
    // getSingleBaseForNonAugmentingSubtype
    // TODO:
    // isEmptyLiteralType
    // TODO:
    // isEmptyArrayLiteralType
    // TODO:
    // isTupleLikeType
    // TODO:
    // isArrayOrTupleLikeType
    // TODO:
    // getTupleElementType
    // TODO:
    // isNeitherUnitTypeNorNever

    fn isUnitType(&self, ty: TypeId) -> bool {
        self.types[ty].get_flags().intersects(TypeFlags::Unit)
    }

    // TODO:
    // isUnitLikeType
    // TODO:
    // extractUnitType

    fn isLiteralType(&self, ty: TypeId) -> bool {
        let flags = self.types[ty].get_flags();
        if flags.intersects(TypeFlags::Boolean) {
            true
        } else if flags.intersects(TypeFlags::Union) {
            if flags.intersects(TypeFlags::EnumLiteral) {
                true
            } else {
                self.types[ty]
                    .unwrap_as_union_or_intersection()
                    .types
                    .iter()
                    .all(|&t| self.isUnitType(t))
            }
        } else {
            self.isUnitType(ty)
        }
    }

    fn getBaseTypeOfLiteralType(&mut self, ty: TypeId) -> TypeId {
        let flags = self.types[ty].get_flags();
        if flags.intersects(TypeFlags::EnumLiteral) {
            todo!();
            // getBaseTypeOfEnumLiteralType(ty as LiteralType)
        } else if flags.intersects(TypeFlags::StringLiteral) {
            self.stringType
        } else if flags.intersects(TypeFlags::NumberLiteral) {
            self.numberType
        } else if flags.intersects(TypeFlags::BigIntLiteral) {
            self.bigintType
        } else if flags.intersects(TypeFlags::BooleanLiteral) {
            self.booleanType()
        } else if flags.intersects(TypeFlags::Union) {
            todo!();
            // mapType(ty as UnionType, getBaseTypeOfLiteralType)
        } else {
            ty
        }
    }

    fn getWidenedLiteralType(&mut self, ty: TypeId) -> TypeId {
        let ty_flags = self.types[ty].get_flags();
        if ty_flags.intersects(TypeFlags::EnumLiteral) && self.isFreshLiteralType(ty) {
            todo!();
            // self.getBaseTypeOfEnumLiteralType(ty)
        } else if ty_flags.intersects(TypeFlags::StringLiteral) && self.isFreshLiteralType(ty) {
            self.stringType
        } else if ty_flags.intersects(TypeFlags::NumberLiteral) && self.isFreshLiteralType(ty) {
            self.numberType
        } else if ty_flags.intersects(TypeFlags::BigIntLiteral) && self.isFreshLiteralType(ty) {
            self.bigintType
        } else if ty_flags.intersects(TypeFlags::BooleanLiteral) && self.isFreshLiteralType(ty) {
            self.booleanType()
        } else if ty_flags.intersects(TypeFlags::Union) {
            self.mapType(
                ty,
                &mut |checker, t| checker.getWidenedLiteralType(t),
                false,
            )
        } else {
            ty
        }
    }

    fn getWidenedUniqueESSymbolType(&mut self, ty: TypeId) -> TypeId {
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::UniqueESSymbol)
        {
            self.esSymbolType
        } else if self.types[ty].get_flags().intersects(TypeFlags::Union) {
            self.mapType(
                ty,
                &mut |checker, t| checker.getWidenedUniqueESSymbolType(t),
                false,
            )
        } else {
            ty
        }
    }

    fn getWidenedLiteralLikeTypeForContextualType(
        &mut self,
        ty: TypeId,
        contextualType: Option<TypeId>,
    ) -> TypeId {
        if !self.isLiteralOfContextualType(ty, contextualType) {
            let ty = self.getWidenedLiteralType(ty);
            self.getWidenedUniqueESSymbolType(ty)
        } else {
            ty
        }
    }

    fn getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(
        &mut self,
        ty: Option<TypeId>,
        contextualSignatureReturnType: Option<TypeId>,
        isAsync: bool,
    ) -> Option<TypeId> {
        if let Some(ty) = ty {
            if self.isUnitType(ty) {
                let contextualType =
                    if let Some(contextualSignatureReturnType) = contextualSignatureReturnType {
                        if isAsync {
                            todo!();
                            // self.getPromisedTypeOfPromise(contextualSignatureReturnType)
                        } else {
                            Some(contextualSignatureReturnType)
                        }
                    } else {
                        None
                    };
                return Some(self.getWidenedLiteralLikeTypeForContextualType(ty, contextualType));
            }
        }
        ty
    }

    // TODO:
    // getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded

    // Check if a Type was written as a tuple type literal.
    // Prefer using isTupleLikeType() unless the use of `elementTypes`/`getTypeArguments` is required.
    // TODO: maybe replace with `if let Type::TupleTypeReference(t)`, since most callers go on to use unwrap_as! anyway.
    // We can the simplify callers
    fn isTupleType(&self, ty: TypeId) -> bool {
        match &self.types[ty] {
            Type::TupleTypeReference(_) => true,
            _ if self.types[ty]
                .get_object_flags()
                .intersects(ObjectFlags::Reference) =>
            {
                // This should be unreachable
                todo!()
            }
            _ => false,
        }
        // self.types[ty].get_object_flags().intersects(ObjectFlags::Reference) && (ty as TypeReference).target.objectFlags & ObjectFlags.Tuple
    }

    fn isGenericTupleType(&self, ty: TypeId) -> bool {
        if self.isTupleType(ty) {
            let target = unwrap_as!(&self.types[ty], Type::TupleTypeReference(t), t).target;
            unwrap_as!(&self.types[target], Type::TupleType(t), t)
                .combinedFlags
                .intersects(ElementFlags::Variadic)
        } else {
            false
        }
    }

    // TODO:
    // isSingleElementGenericTupleType
    // TODO:
    // getRestTypeOfTupleType
    // TODO:
    // getRestArrayTypeOfTupleType
    // TODO:
    // getElementTypeOfSliceOfTupleType
    // TODO:
    // isTupleTypeStructureMatching

    fn isZeroBigInt(&self, ty: TypeId) -> bool {
        unwrap_as!(&self.types[ty], Type::BigIntLiteralType(t), t)
            .value
            .sign()
            == num_bigint::Sign::NoSign
    }

    // TODO:
    // getFalsyFlagsOfTypes

    // Returns the String, Number, Boolean, StringLiteral, NumberLiteral, BooleanLiteral, Void, Undefined, or Null
    // flags for the string, number, boolean, "", 0, false, void, undefined, or null types respectively. Returns
    // no flags for all other types (including non-falsy literal types).
    fn getFalsyFlags(&self, ty: TypeId) -> TypeFlags {
        let type_flags = self.types[ty].get_flags();
        if type_flags.intersects(TypeFlags::Union) {
            todo!();
            // getFalsyFlagsOfTypes((ty as UnionType).types)
        } else if type_flags.intersects(TypeFlags::StringLiteral) {
            if unwrap_as!(&self.types[ty], Type::StringLiteralType(t), t).value == js_word!("") {
                TypeFlags::StringLiteral
            } else {
                TypeFlags::empty()
            }
        } else if type_flags.intersects(TypeFlags::NumberLiteral) {
            if unwrap_as!(&self.types[ty], Type::NumberLiteralType(t), t).value == 0f64 {
                TypeFlags::NumberLiteral
            } else {
                TypeFlags::empty()
            }
        } else if type_flags.intersects(TypeFlags::BigIntLiteral) {
            todo!();
            // if isZeroBigInt(ty as BigIntLiteralType) {
            //     TypeFlags::BigIntLiteral
            // } else {
            //     TypeFlags::empty()
            // }
        } else if type_flags.intersects(TypeFlags::BooleanLiteral) {
            if (ty == self.falseType || ty == self.regularFalseType) {
                TypeFlags::BooleanLiteral
            } else {
                TypeFlags::empty()
            }
        } else {
            type_flags & TypeFlags::PossiblyFalsy
        }
    }

    // TODO:
    // removeDefinitelyFalsyTypes
    // TODO:
    // extractDefinitelyFalsyTypes
    // TODO:
    // getDefinitelyFalsyPartOfType
    // TODO:
    // getNullableType

    fn getOptionalType(&mut self, ty: TypeId, isProperty: bool) -> TypeId {
        debug_assert!(self.strictNullChecks);
        if self.types[ty].get_flags().intersects(TypeFlags::Undefined) {
            ty
        } else {
            self.getUnionType(
                &[
                    ty,
                    if isProperty {
                        self.missingType
                    } else {
                        self.undefinedType
                    },
                ],
                None,
                None,
                None,
                None,
            )
        }
    }

    fn getGlobalNonNullableTypeInstantiation(&mut self, ty: TypeId) -> TypeId {
        // First reduce away any constituents that are assignable to 'undefined' or 'null'. This not only eliminates
        // 'undefined' and 'null', but also higher-order types such as a type parameter 'U extends undefined | null'
        // that isn't eliminated by a NonNullable<T> instantiation.
        let reducedType = self.getTypeWithFacts(ty, TypeFacts::NEUndefinedOrNull);
        if self.deferredGlobalNonNullableTypeAlias.is_none() {
            // self.deferredGlobalNonNullableTypeAlias = self.getGlobalSymbol("NonNullable" as __String, SymbolFlags::TypeAlias, /*diagnostic*/ undefined) || unknownSymbol;
            self.deferredGlobalNonNullableTypeAlias = self
                .getGlobalSymbol(JsWord::from("NonNullable"), SymbolFlags::TypeAlias)
                .or(Some(self.unknownSymbol));
        }
        // If the NonNullable<T> type is available, return an instantiation. Otherwise just return the reduced type.
        if self.deferredGlobalNonNullableTypeAlias.unwrap() != self.unknownSymbol {
            self.getTypeAliasInstantiation(
                self.deferredGlobalNonNullableTypeAlias.unwrap(),
                Some(Rc::new(vec![reducedType])),
                None,
                None,
            )
        } else {
            reducedType
        }
    }

    fn getNonNullableType(&mut self, ty: TypeId) -> TypeId {
        if self.strictNullChecks {
            self.getGlobalNonNullableTypeInstantiation(ty)
        } else {
            ty
        }
    }

    // TODO:
    // addOptionalTypeMarker
    // TODO:
    // removeOptionalTypeMarker
    // TODO:
    // propagateOptionalTypeMarker

    // TODO:
    // fn getOptionalExpressionType(&mut self, exprType: TypeId, expression: &BoundNode) -> TypeId {
    //     if isExpressionOfOptionalChainRoot(expression) {
    //         todo!();
    //         // self.getNonNullableType(exprType)
    //     } else if isOptionalChain(expression) {
    //         todo!();
    //         // self.removeOptionalTypeMarker(exprType)
    //     } else {
    //         exprType
    //     }
    // }

    fn removeMissingType(&mut self, ty: TypeId, isOptional: bool) -> TypeId {
        if self.exactOptionalPropertyTypes && isOptional {
            self.removeType(ty, self.missingType)
        } else {
            ty
        }
    }

    // TODO:
    // containsMissingType
    // TODO:
    // removeMissingOrUndefinedType
    // TODO:
    // isCoercibleUnderDoubleEquals

    /**
     * Return true if type was inferred from an object literal, written as an object type literal, or is the shape of a module
     * with no call or construct signatures.
     */
    fn isObjectTypeWithInferableIndex(&mut self, ty: TypeId) -> bool {
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Intersection)
        {
            self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
                .iter()
                .all(|&t| self.isObjectTypeWithInferableIndex(t))
        } else {
            (self.types[ty].get_symbol().is_some()
                && self.symbols[self.types[ty].get_symbol().unwrap()]
                    .flags()
                    .intersects(
                        SymbolFlags::ObjectLiteral
                            | SymbolFlags::TypeLiteral
                            | SymbolFlags::Enum
                            | SymbolFlags::ValueModule,
                    )
                && !self.typeHasCallOrConstructSignatures(ty))
                || (self.types[ty]
                    .get_object_flags()
                    .intersects(ObjectFlags::ReverseMapped)
                    && self.isObjectTypeWithInferableIndex(
                        unwrap_as!(&self.types[ty], Type::ReverseMappedType(t), t).source,
                    ))
        }
    }

    fn createSymbolWithType(&mut self, source_id: SymbolId, ty: Option<TypeId>) -> SymbolId {
        let source = &self.symbols[source_id];
        let mut symbol = TransientSymbol {
            flags: source.flags() | SymbolFlags::Transient,
            escapedName: source.escapedName().clone(),
            // TODO: maybe bad clone:
            declarations: source.declarations().clone(),
            valueDeclaration: source.valueDeclaration().clone(),
            members: None,
            exports: None,
            globalExports: None,
            mergeId: None,
            parent: source.parent(),
            exportSymbol: None,
            constEnumOnlyModule: false,
            isReferenced: SymbolFlags::default(),
            isReplaceableByMethod: false,
            isAssigned: false,
            assignmentDeclarationMembers: AHashMap::default(),
            symbol_links: SymbolLinks::default(),
            check_flags: getCheckFlags(source) & CheckFlags::Readonly,
        };
        symbol.symbol_links.ty = ty;
        symbol.symbol_links.target = Some(source_id);
        symbol.symbol_links.nameType = self.getSymbolLinks(source_id).nameType;
        self.symbols.push(Symbol::TransientSymbol(symbol))
    }

    fn transformTypeOfMembers<F>(&mut self, ty: TypeId, mut f: F) -> SymbolTableId
    where
        F: FnMut(&mut Checker, TypeId) -> TypeId,
    {
        let properties = self.getPropertiesOfObjectType(ty);
        let members = SymbolTable::from_iter(properties.clone().iter().map(|&property| {
            let original = self.getTypeOfSymbol(property);
            let updated = f(self, original);
            let symbol = if updated == original {
                property
            } else {
                self.createSymbolWithType(property, Some(updated))
            };
            (self.symbols[property].escapedName().clone(), symbol)
        }));
        self.symbol_tables.push(members)
    }

    /**
     * If the the provided object literal is subject to the excess properties check,
     * create a new that is exempt. Recursively mark object literal members as exempt.
     * Leave signatures alone since they are not subject to the check.
     */
    fn getRegularTypeOfObjectLiteral(&mut self, ty: TypeId) -> TypeId {
        if !(self.isObjectLiteralType(ty)
            && self.types[ty]
                .get_object_flags()
                .intersects(ObjectFlags::FreshLiteral))
        {
            return ty;
        }
        if let Type::FreshObjectLiteralType(t) = &self.types[ty] {
            return t.regularType;
        }

        let members = self.transformTypeOfMembers(ty, |checker, prop_type| {
            checker.getRegularTypeOfObjectLiteral(prop_type)
        });
        let resolved = self.types[ty].unwrap_object_type_base();
        let regularType = self.createAnonymousType(
            self.types[ty].get_symbol().clone(),
            members,
            resolved.callSignatures.clone(),
            resolved.constructSignatures.clone(),
            resolved.indexInfos.clone(),
        );
        *self.types[regularType].get_flags_mut() = self.types[ty].get_flags();
        let additional_regularType_object_flags =
            self.types[ty].get_object_flags() & !ObjectFlags::FreshLiteral;
        *self.types[regularType].get_object_flags_mut() |= additional_regularType_object_flags;
        let old = std::mem::replace(&mut self.types[ty], Type::Dummy);
        self.types[ty] = Type::FreshObjectLiteralType(FreshObjectLiteralType {
            resolved_type: unwrap_as!(old, Type::ResolvedType(t), t),
            // TODO: I think regularType is supposed to be a resolved type.
            regularType,
        });
        regularType
    }

    fn createWideningContext(
        &mut self,
        parent: Option<WideningContextId>,
        propertyName: Option<JsWord>,
        siblings: Option<Rc<Vec<TypeId>>>,
    ) -> WideningContextId {
        self.widening_contexts.push(WideningContext {
            parent,
            propertyName,
            siblings,
            resolvedProperties: None,
        })
    }

    fn resolveSiblingsOfContext(&mut self, context: WideningContextId) {
        if self.widening_contexts[context].siblings.is_none() {
            let mut siblings = Vec::new();
            let parent = self.widening_contexts[context].parent.unwrap();
            self.resolveSiblingsOfContext(parent);
            for &ty in self.widening_contexts[parent]
                .siblings
                .clone()
                .unwrap()
                .iter()
            {
                if self.isObjectLiteralType(ty) {
                    let propertyName = self.widening_contexts[context]
                        .propertyName
                        .clone()
                        .unwrap();
                    let prop = self.getPropertyOfObjectType(ty, &propertyName);
                    if let Some(prop) = prop {
                        let prop_ty = self.getTypeOfSymbol(prop);
                        self.forEachType(prop_ty, |_, t| {
                            siblings.push(t);
                        });
                    }
                }
            }
            self.widening_contexts[context].siblings = Some(Rc::new(siblings));
        }
    }

    fn resolvePropertiesOfContext(&mut self, context: WideningContextId) {
        if self.widening_contexts[context].resolvedProperties.is_none() {
            let mut names = AHashSet::new();
            self.resolveSiblingsOfContext(context);
            for &t in self.widening_contexts[context]
                .siblings
                .clone()
                .unwrap()
                .iter()
            {
                if self.isObjectLiteralType(t)
                    && !self.types[t]
                        .get_object_flags()
                        .intersects(ObjectFlags::ContainsSpread)
                {
                    names.extend(self.getPropertiesOfType(t).iter().copied());
                }
            }
            self.widening_contexts[context].resolvedProperties = Some(Rc::new(names));
        }
    }

    fn getWidenedProperty(
        &mut self,
        prop: SymbolId,
        context: Option<WideningContextId>,
    ) -> SymbolId {
        if !self.symbols[prop].flags().intersects(SymbolFlags::Property) {
            // Since get accessors already widen their return value there is no need to
            // widen accessor based properties here.
            return prop;
        }
        let original = self.getTypeOfSymbol(prop);
        let propContext = context.map(|ctx| {
            self.createWideningContext(
                Some(ctx),
                Some(self.symbols[prop].escapedName().clone()),
                None,
            )
        });
        let widened = self.getWidenedTypeWithContext(original, propContext);
        if widened == original {
            prop
        } else {
            self.createSymbolWithType(prop, Some(widened))
        }
    }

    fn getUndefinedProperty(&mut self, prop: SymbolId) -> SymbolId {
        let escapedName = self.symbols[prop].escapedName();
        match self.undefinedProperties.get(escapedName) {
            Some(cached) => *cached,
            None => {
                let result = self.createSymbolWithType(prop, Some(self.missingType));
                *self.symbols[result].flags_mut() |= SymbolFlags::Optional;
                let escapedName = self.symbols[prop].escapedName();
                self.undefinedProperties.insert(escapedName.clone(), result);
                result
            }
        }
    }

    fn getWidenedTypeOfObjectLiteral(
        &mut self,
        ty: TypeId,
        context: Option<WideningContextId>,
    ) -> TypeId {
        let members = self.symbol_tables.push(SymbolTable::new());
        for &prop in self.getPropertiesOfObjectType(ty).iter() {
            let widened_prop = self.getWidenedProperty(prop, context);
            self.symbol_tables[members]
                .insert(self.symbols[prop].escapedName().clone(), widened_prop);
        }
        if let Some(context) = context {
            self.resolvePropertiesOfContext(context);
            for &prop in self.widening_contexts[context]
                .resolvedProperties
                .as_ref()
                .unwrap()
                .clone()
                .iter()
            {
                if !self.symbol_tables[members].contains_key(self.symbols[prop].escapedName()) {
                    let undefined_prop = self.getUndefinedProperty(prop);
                    self.symbol_tables[members]
                        .insert(self.symbols[prop].escapedName().clone(), undefined_prop);
                }
            }
        }
        let indexInfos = Rc::new(
            self.getIndexInfosOfType(ty)
                .iter()
                .map(|&info| {
                    let ty = self.getWidenedType(self.index_infos[info].ty);
                    self.createIndexInfo(
                        self.index_infos[info].keyType,
                        ty,
                        self.index_infos[info].isReadonly,
                        None,
                    )
                })
                .collect(),
        );
        let result = self.createAnonymousType(
            *self.types[ty].get_symbol(),
            members,
            Rc::default(),
            Rc::default(),
            indexInfos,
            // TODO: use sameMap from TSC:
            // sameMap(self.getIndexInfosOfType(ty), |info| {
            //     self.createIndexInfo(
            //         self.index_infos[info].keyType,
            //         self.getWidenedType(self.index_infos[info].ty),
            //         self.index_infos[info].isReadonly,
            //         None,
            //     )
            // }),
        );
        // Retain js literal flag through widening
        let retained_flags = self.types[ty].get_object_flags()
            & (ObjectFlags::JSLiteral | ObjectFlags::NonInferrableType);
        *self.types[result].get_object_flags_mut() |= retained_flags;
        result
    }

    fn getWidenedType(&mut self, ty: TypeId) -> TypeId {
        self.getWidenedTypeWithContext(ty, None)
    }

    fn getWidenedTypeWithContext(
        &mut self,
        ty: TypeId,
        context: Option<WideningContextId>,
    ) -> TypeId {
        if self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::RequiresWidening)
        {
            if context.is_none() && self.types[ty].get_widened().is_some() {
                return self.types[ty].get_widened().unwrap();
            }
            let mut result = if self.types[ty]
                .get_flags()
                .intersects(TypeFlags::Any | TypeFlags::Nullable)
            {
                Some(self.anyType)
            } else if self.isObjectLiteralType(ty) {
                Some(self.getWidenedTypeOfObjectLiteral(ty, context))
            } else if self.types[ty].get_flags().intersects(TypeFlags::Union) {
                todo!();
                // const unionContext = context || createWideningContext(/*parent*/ undefined, /*propertyName*/ undefined, (ty as UnionType).types);
                // const widenedTypes = sameMap((ty as UnionType).types, t => t.flags & TypeFlags::Nullable ? t : getWidenedTypeWithContext(t, unionContext));
                // // Widening an empty object literal transitions from a highly restrictive type to
                // // a highly inclusive one. For that reason we perform subtype reduction here if the
                // // union includes empty object types (e.g. reducing {} | string to just {}).
                // getUnionType(widenedTypes, some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal)
            } else if self.types[ty]
                .get_flags()
                .intersects(TypeFlags::Intersection)
            {
                todo!();
                // getIntersectionType(sameMap((ty as IntersectionType).types, getWidenedType))
            } else if self.isArrayType(ty) || self.isTupleType(ty) {
                todo!();
                // createTypeReference(ty.target, sameMap(getTypeArguments(ty), getWidenedType))
            } else {
                None
            };
            if result.is_some() && context.is_none() {
                *self.types[ty].get_widened_mut() = result;
            }
            return result.unwrap_or(ty);
        }
        ty
    }

    // TODO:
    // reportWideningErrorsInType
    // TODO:
    // reportImplicitAny

    fn reportErrorsFromWidening(
        &mut self,
        declaration: BoundNode,
        ty: TypeId,
        wideningKind: Option<WideningKind>,
    ) {
        // if self.produceDiagnostics && self.noImplicitAny && self.types[ty].object_flags().intersects(ObjectFlags::ContainsWideningType) && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration as FunctionLikeDeclaration)) {
        //     // Report implicit any error within type if possible, otherwise report error on declaration
        //     todo!();
        //     // if !reportWideningErrorsInType(ty) {
        //     //     reportImplicitAny(declaration, ty, wideningKind);
        //     // }
        // }
        if self.produceDiagnostics
            && self.noImplicitAny
            && self.types[ty]
                .get_object_flags()
                .intersects(ObjectFlags::ContainsWideningType)
        {
            // Report implicit any error within type if possible, otherwise report error on declaration
            todo!();
            // if !reportWideningErrorsInType(ty) {
            //     reportImplicitAny(declaration, ty, wideningKind);
            // }
        }
    }

    fn applyToParameterTypes(
        &mut self,
        source: SignatureId,
        target: SignatureId,
        mut callback: impl FnMut(&mut Checker, TypeId, TypeId),
    ) {
        let sourceCount = self.getParameterCount(source);
        let targetCount = self.getParameterCount(target);
        let sourceRestType = self.getEffectiveRestType(source);
        let targetRestType = self.getEffectiveRestType(target);
        let targetNonRestCount = if targetRestType.is_some() {
            targetCount - 1
        } else {
            targetCount
        };
        let paramCount = if sourceRestType.is_some() {
            targetNonRestCount
        } else {
            cmp::min(sourceCount, targetNonRestCount)
        };
        let sourceThisType = self.getThisTypeOfSignature(source);
        if let Some(sourceThisType) = sourceThisType {
            let targetThisType = self.getThisTypeOfSignature(target);
            if let Some(targetThisType) = targetThisType {
                callback(self, sourceThisType, targetThisType);
            }
        }
        for i in 0..paramCount {
            let source = self.getTypeAtPosition(source, i);
            let target = self.getTypeAtPosition(target, i);
            callback(self, source, target);
        }
        if let Some(targetRestType) = targetRestType {
            let sourceRestType = self.getRestTypeAtPosition(source, paramCount);
            callback(self, sourceRestType, targetRestType);
        }
    }

    fn applyToReturnTypes(
        &mut self,
        source: SignatureId,
        target: SignatureId,
        mut callback: impl FnMut(&mut Checker, TypeId, TypeId),
    ) {
        let sourceTypePredicate = self.getTypePredicateOfSignature(source);
        let targetTypePredicate = self.getTypePredicateOfSignature(target);
        if let (Some(sourceTypePredicate), Some(targetTypePredicate)) =
            (sourceTypePredicate, targetTypePredicate)
        {
            if typePredicateKindsMatch(&sourceTypePredicate, &targetTypePredicate) {
                if let (Some(source_ty), Some(target_ty)) =
                    (sourceTypePredicate.ty(), targetTypePredicate.ty())
                {
                    return callback(self, source_ty, target_ty);
                }
            }
        }
        let source = self.getReturnTypeOfSignature(source);
        let target = self.getReturnTypeOfSignature(target);
        callback(self, source, target);
    }

    fn createInferenceContext(
        &mut self,
        typeParameters: Rc<Vec<TypeId>>,
        signature: Option<SignatureId>,
        flags: InferenceFlags,
        compareTypes: Option<fn(&mut Checker, TypeId, TypeId, bool) -> Ternary>,
    ) -> InferenceContextId {
        fn cmp(
            checker: &mut Checker,
            source: TypeId,
            target: TypeId,
            _reportErrors: bool,
        ) -> Ternary {
            checker.compareTypesAssignable(source, target)
        }
        self.createInferenceContextWorker(
            typeParameters
                .iter()
                .cloned()
                .map(InferenceInfo::new)
                .collect(),
            signature,
            flags,
            compareTypes.unwrap_or(cmp),
        )
    }

    fn cloneInferenceContext(
        &mut self,
        context: Option<InferenceContextId>,
        extraFlags: Option<InferenceFlags>,
    ) -> Option<InferenceContextId> {
        context.map(|id| {
            let ctx = &self.inference_contexts[id];
            self.createInferenceContextWorker(
                ctx.inferences.clone(),
                ctx.signature,
                ctx.flags | extraFlags.unwrap_or_default(),
                ctx.compareTypes,
            )
        })
    }

    fn createInferenceContextWorker(
        &mut self,
        inferences: Vec<InferenceInfo>,
        signature: Option<SignatureId>,
        flags: InferenceFlags,
        compareTypes: fn(&mut Checker, TypeId, TypeId, bool) -> Ternary,
    ) -> InferenceContextId {
        let context_id = self.inference_contexts.next_index();
        let context = InferenceContext {
            inferences,
            signature,
            flags,
            compareTypes,
            mapper: TypeMapper::makeFunctionTypeMapper(move |checker, t| {
                checker.mapToInferredType(context_id, t, true)
            }),
            nonFixingMapper: TypeMapper::makeFunctionTypeMapper(move |checker, t| {
                checker.mapToInferredType(context_id, t, false)
            }),
            returnMapper: None,
            inferredTypeParameters: None,
        };
        self.inference_contexts.push(context)
    }

    fn mapToInferredType(&mut self, context: InferenceContextId, t: TypeId, fix: bool) -> TypeId {
        let mut inferences = &mut self.inference_contexts[context].inferences;
        let mut i = 0;
        while i < inferences.len() {
            let inference = &inferences[i];
            if t == inference.typeParameter {
                if fix && !inference.isFixed {
                    clearCachedInferences(&mut inferences);
                    inferences[i].isFixed = true;
                }
                return self.getInferredType(context, i);
            }
            i += 1;
        }
        t
    }

    // TODO:
    // cloneInferenceInfo

    fn cloneInferredPartOfContext(
        &mut self,
        context: InferenceContextId,
    ) -> Option<InferenceContextId> {
        let ctx = &self.inference_contexts[context];
        let mut inferences = Vec::new();
        let mut found = false;
        for inference in ctx.inferences.iter().filter(|i| hasInferenceCandidates(*i)) {
            if !found {
                // Only allocate the vec if we have an element to push.
                inferences.reserve(ctx.inferences.len());
                found = true;
            }
            inferences.push(inference.clone());
        }
        if found {
            Some(self.createInferenceContextWorker(
                inferences,
                ctx.signature,
                ctx.flags,
                ctx.compareTypes,
            ))
        } else {
            None
        }
    }

    fn getMapperFromContext(&self, context: Option<InferenceContextId>) -> Option<Rc<TypeMapper>> {
        context.map(|ctx| self.inference_contexts[ctx].mapper.clone())
    }

    // Return true if the given type could possibly reference a type parameter for which
    // we perform type inference (i.e. a type parameter of a generic function). We cache
    // results for union and intersection types for performance reasons.
    fn couldContainTypeVariables(&mut self, ty: TypeId) -> bool {
        let objectFlags = self.types[ty].get_object_flags();
        if objectFlags.intersects(ObjectFlags::CouldContainTypeVariablesComputed) {
            return objectFlags.intersects(ObjectFlags::CouldContainTypeVariables);
        }
        let ty_flags = self.types[ty].get_flags();
        let result = ty_flags.intersects(TypeFlags::Instantiable)
            || ty_flags.intersects(TypeFlags::Object)
                && !self.isNonGenericTopLevelType(ty)
                && (objectFlags.intersects(ObjectFlags::Reference)
                    && (self.types[ty].unwrap_as_type_reference().node.is_some()
                        || self
                            .getTypeArguments(ty)
                            .iter()
                            .any(|a| self.couldContainTypeVariables(*a)))
                    || objectFlags.intersects(ObjectFlags::Anonymous)
                        && self.types[ty]
                            .get_symbol()
                            .map(|s| {
                                self.symbols[s].flags().intersects(
                                    SymbolFlags::Function
                                        | SymbolFlags::Method
                                        | SymbolFlags::Class
                                        | SymbolFlags::TypeLiteral
                                        | SymbolFlags::ObjectLiteral,
                                ) && !self.symbols[s].declarations().is_empty()
                            })
                            .unwrap_or_default()
                    || objectFlags.intersects(
                        ObjectFlags::Mapped
                            | ObjectFlags::ReverseMapped
                            | ObjectFlags::ObjectRestType,
                    ))
            || ty_flags.intersects(TypeFlags::UnionOrIntersection)
                && !ty_flags.intersects(TypeFlags::EnumLiteral)
                && !self.isNonGenericTopLevelType(ty)
                // TODO: remove clone of vec:
                && self.types[ty]
                    .unwrap_as_union_or_intersection()
                    .types
                    .clone()
                    .iter()
                    .any(|t| self.couldContainTypeVariables(*t));
        if ty_flags.intersects(TypeFlags::ObjectFlagsType) {
            let mut new_flags = ObjectFlags::CouldContainTypeVariablesComputed;
            if result {
                new_flags.insert(ObjectFlags::CouldContainTypeVariables)
            }
            *self.types[ty].get_object_flags_mut() |= new_flags;
        }
        result
    }

    fn isNonGenericTopLevelType(&mut self, ty: TypeId) -> bool {
        if let Some(aliasSymbol) = self.types[ty].get_aliasSymbol() {
            if self.types[ty].get_aliasTypeArguments().is_none() {
                let decl = self.getDeclarationOfKind(*aliasSymbol, |d| {
                    matches!(d, BoundNode::TsTypeAliasDecl(_))
                });
                if let Some(decl) = decl {
                    return findAncestor(decl.parent(), |n| {
                        if matches!(n, BoundNode::Script(_) | BoundNode::Module(_)) {
                            Some(true)
                        } else if matches!(n, BoundNode::TsModuleDecl(_)) {
                            Some(false)
                        } else {
                            None
                        }
                    })
                    .is_some();
                }
            }
        }

        false
    }

    // TODO:
    // isTypeParameterAtTopLevel
    // TODO:
    // createEmptyObjectTypeFromStringLiteral
    // TODO:
    // inferTypeForHomomorphicMappedType
    // TODO:
    // isPartiallyInferableType
    // TODO:
    // createReverseMappedType
    // TODO:
    // getTypeOfReverseMappedSymbol
    // TODO:
    // inferReverseMappedType

    fn getUnmatchedProperties(
        &mut self,
        source: TypeId,
        target: TypeId,
        requireOptionalProperties: bool,
        matchDiscriminantProperties: bool,
    ) -> Vec<SymbolId> {
        self.getPropertiesOfType(target)
            .iter()
            .cloned()
            .filter(|&targetProp| {
                // TODO: remove this when we support static private identifier fields and find other solutions to get privateNamesAndStaticFields test to pass
                if self.isStaticPrivateIdentifierProperty(targetProp) {
                    return false;
                }
                if requireOptionalProperties
                    || !(self.symbols[targetProp]
                        .flags()
                        .intersects(SymbolFlags::Optional)
                        || getCheckFlags(&self.symbols[targetProp]).intersects(CheckFlags::Partial))
                {
                    todo!()
                    // let sourceProp = getPropertyOfType(source, targetProp.escapedName);
                    // if (!sourceProp) {
                    //     return true;
                    // }
                    // else if (matchDiscriminantProperties) {
                    //     let targetType = getTypeOfSymbol(targetProp);
                    //     if (targetType.flags & TypeFlags::Unit) {
                    //         let sourceType = getTypeOfSymbol(sourceProp);
                    //         if (!(sourceType.flags & TypeFlags::Any || getRegularTypeOfLiteralType(sourceType) === getRegularTypeOfLiteralType(targetType))) {
                    //             return true;
                    //         }
                    //     }
                    // }
                }
                false
            })
            .collect()
    }

    fn getUnmatchedProperty(
        &mut self,
        source: TypeId,
        target: TypeId,
        requireOptionalProperties: bool,
        matchDiscriminantProperties: bool,
    ) -> Option<SymbolId> {
        // todo: getUnmatchedProperties allocated a vec, but we only use the first prop.
        // maybe use iterators, but this had some issues. Maybe make two versions of getUnmatchedProperties,
        // one that returns the first prop, and one that returns a vec (some ither callers expect a vec).
        self.getUnmatchedProperties(
            source,
            target,
            requireOptionalProperties,
            matchDiscriminantProperties,
        )
        .first()
        .copied()
    }

    fn tupleTypesDefinitelyUnrelated(&self, source: TypeId, target: TypeId) -> bool {
        let source = unwrap_as!(&self.types[source], Type::TupleTypeReference(t), t);
        let target = unwrap_as!(&self.types[target], Type::TupleTypeReference(t), t);
        let source_target = unwrap_as!(&self.types[source.target], Type::TupleType(t), t);
        let target_target = unwrap_as!(&self.types[target.target], Type::TupleType(t), t);
        !target_target
            .combinedFlags
            .intersects(ElementFlags::Variadic)
            && target_target.minLength > source_target.minLength
            || !target_target.hasRestElement
                && (source_target.hasRestElement
                    || target_target.fixedLength < source_target.fixedLength)
    }

    fn typesDefinitelyUnrelated(&mut self, source: TypeId, target: TypeId) -> bool {
        // Two tuple types with incompatible arities are definitely unrelated.
        // Two object types that each have a property that is unmatched in the other are definitely unrelated.
        if self.isTupleType(source) && self.isTupleType(target) {
            self.tupleTypesDefinitelyUnrelated(source, target)
        } else {
            self.getUnmatchedProperty(source, target, false, true)
                .is_some()
                && self
                    .getUnmatchedProperty(target, source, false, false)
                    .is_some()
        }
    }

    fn getTypeFromInference(
        &mut self,
        context: InferenceContextId,
        index: usize,
    ) -> Option<TypeId> {
        let inference = &self.inference_contexts[context].inferences[index];
        if let Some(candidates) = &inference.candidates {
            // TODO: bad clone of Vec:
            Some(self.getUnionType(
                &candidates.clone(),
                Some(UnionReduction::Subtype),
                None,
                None,
                None,
            ))
        } else if let Some(contraCandidates) = &inference.contraCandidates {
            // TODO: bad clone of Vec:
            Some(self.getIntersectionType(&contraCandidates.clone(), None, None))
        } else {
            None
        }
    }
    // TODO:
    // hasSkipDirectInferenceFlag
    // TODO:
    // isFromInferenceBlockedSource
    // TODO:
    // templateLiteralTypesDefinitelyUnrelated
    // TODO:
    // isValidBigIntString
    // TODO:
    // isValidTypeForTemplateLiteralPlaceholder
    // TODO:
    // inferTypesFromTemplateLiteralType
    // TODO:
    // getStringLikeTypeForType
    // TODO:
    // inferFromLiteralPartsToTemplateLiteral

    // fn inferTypes<'a, 'b, I>(
    //     &mut self,
    //     inferences: I,
    //     originalSource: TypeId,
    //     originalTarget: TypeId,
    //     priority: Option<InferencePriority>,
    //     contravariant: bool,
    // ) where
    //     'a: 'b,
    //     I: AsInferenceInfos<'a, 'b>,
    fn inferTypes(
        &mut self,
        inferences: InferenceContextId,
        originalSource: TypeId,
        originalTarget: TypeId,
        priority: Option<InferencePriority>,
        mut contravariant: bool,
    ) {
        #[derive(PartialEq, Eq, Hash, Clone, Copy)]
        struct VisitedKey(TypeId, TypeId);
        let mut priority = priority.unwrap_or_default();

        let mut bivariant = false;
        let mut propagationType = None;
        let mut inferencePriority = InferencePriority::MaxValue;
        let mut allowComplexConstraintInference = true;
        let mut visited = AHashMap::default();
        let mut sourceStack = Vec::new();
        let mut targetStack = Vec::new();
        let mut expandingFlags = ExpandingFlags::None;
        inferFromTypes(
            self,
            inferences,
            &mut priority,
            &mut contravariant,
            &mut bivariant,
            &mut propagationType,
            &mut inferencePriority,
            &mut allowComplexConstraintInference,
            &mut visited,
            &mut sourceStack,
            &mut targetStack,
            &mut expandingFlags,
            originalSource,
            originalTarget,
        );

        fn inferFromTypes(
            checker: &mut Checker,
            inferences: InferenceContextId,
            priority: &mut InferencePriority,
            contravariant: &mut bool,
            bivariant: &mut bool,
            propagationType: &mut Option<TypeId>,
            inferencePriority: &mut InferencePriority,
            allowComplexConstraintInference: &mut bool,
            visited: &mut AHashMap<VisitedKey, InferencePriority>,
            sourceStack: &mut Vec<RecursionIdentity>,
            targetStack: &mut Vec<RecursionIdentity>,
            expandingFlags: &mut ExpandingFlags,

            mut source: TypeId,
            target: TypeId,
        ) {
            if !checker.couldContainTypeVariables(target) {
                return;
            }
            if source == checker.wildcardType {
                // We are inferring from an 'any' type. We want to infer this type for every type parameter
                // referenced in the target type, so we record it as the propagation type and infer from the
                // target to itself. Then, as we find candidates we substitute the propagation type.
                // const savePropagationType = propagationType;
                // propagationType = source;
                // inferFromTypes(target, target);
                // propagationType = savePropagationType;
                // return;
                todo!();
            }
            if checker.types[source].get_aliasSymbol().is_some()
                && checker.types[source].get_aliasTypeArguments().is_some()
                && checker.types[source].get_aliasSymbol()
                    == checker.types[target].get_aliasSymbol()
            {
                // Source and target are types originating in the same generic type alias declaration.
                // Simply infer from source type arguments to target type arguments.
                // inferFromTypeArguments(source.aliasTypeArguments, target.aliasTypeArguments!, getAliasVariances(source.aliasSymbol));
                // return;
                todo!();
            }
            let source_flags = checker.types[source].get_flags();
            if source == target && source_flags.intersects(TypeFlags::UnionOrIntersection) {
                // When source and target are the same union or intersection type, just relate each constituent
                // type to itself.
                // for (const t of (source as UnionOrIntersectionType).types) {
                //     inferFromTypes(t, t);
                // }
                // return;
                todo!();
            }
            let target_flags = checker.types[target].get_flags();
            if target_flags.intersects(TypeFlags::Union) {
                // First, infer between identically matching source and target constituents and remove the
                // matching types.
                // const [tempSources, tempTargets] = inferFromMatchingTypes(source.flags & TypeFlags::Union ? (source as UnionType).types : [source], (target as UnionType).types, isTypeOrBaseIdenticalTo);
                // // Next, infer between closely matching source and target constituents and remove
                // // the matching types. Types closely match when they are instantiations of the same
                // // object type or instantiations of the same type alias.
                // const [sources, targets] = inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy);
                // if (targets.length === 0) {
                //     return;
                // }
                // target = getUnionType(targets);
                // if (sources.length === 0) {
                //     // All source constituents have been matched and there is nothing further to infer from.
                //     // However, simply making no inferences is undesirable because it could ultimately mean
                //     // inferring a type parameter constraint. Instead, make a lower priority inference from
                //     // the full source to whatever remains in the target. For example, when inferring from
                //     // string to 'string | T', make a lower priority inference of string for T.
                //     inferWithPriority(source, target, InferencePriority.NakedTypeVariable);
                //     return;
                // }
                // source = getUnionType(sources);
                todo!();
            } else if target_flags.intersects(TypeFlags::Intersection)
                && checker.types[target]
                    .unwrap_as_union_or_intersection()
                    .types
                    .clone()
                    .iter()
                    .any(|&t| {
                        todo!();
                        // hasInferenceInfoForType(checker, inferences, t)
                        //     || (checker.isGenericMappedType(t)
                        //         && hasInferenceInfoForType(
                        //             checker,
                        //             inferences,
                        //             checker
                        //                 .getHomomorphicTypeVariable(t)
                        //                 .unwrap_or(checker.neverType),
                        //         ))
                    })
            {
                // We reduce intersection types only when they contain naked type parameters. For example, when
                // inferring from 'string[] & { extra: any }' to 'string[] & T' we want to remove string[] and
                // infer { extra: any } for T. But when inferring to 'string[] & Iterable<T>' we want to keep the
                // string[] on the source side and infer string for T.
                // Likewise, we consider a homomorphic mapped type constrainted to the target type parameter as similar to a "naked type variable"
                // in such scenarios.
                // if (!(source_flags & TypeFlags::Union)) {
                //     // Infer between identically matching source and target constituents and remove the matching types.
                //     const [sources, targets] = inferFromMatchingTypes(source_flags & TypeFlags::Intersection ? (source as IntersectionType).types : [source], (target as IntersectionType).types, isTypeIdenticalTo);
                //     if (sources.length === 0 || targets.length === 0) {
                //         return;
                //     }
                //     source = getIntersectionType(sources);
                //     target = getIntersectionType(targets);
                // }
                todo!();
            } else if target_flags.intersects(TypeFlags::IndexedAccess | TypeFlags::Substitution) {
                // target = getActualTypeVariable(target);
                todo!();
            }
            if target_flags.intersects(TypeFlags::TypeVariable) {
                // If target is a type parameter, make an inference, unless the source type contains
                // the anyFunctionType (the wildcard type that's used to avoid contextually typing functions).
                // Because the anyFunctionType is internal, it should not be exposed to the user by adding
                // it as an inference candidate. Hopefully, a better candidate will come along that does
                // not contain anyFunctionType when we come back to this argument for its second round
                // of inference. Also, we exclude inferences for silentNeverType (which is used as a wildcard
                // when constructing types from type parameters that had no inference candidates).
                // if (getObjectFlags(source) & ObjectFlags.NonInferrableType || source === nonInferrableAnyType || source === silentNeverType ||
                //     (priority & InferencePriority.ReturnType && (source === autoType || source === autoArrayType)) || isFromInferenceBlockedSource(source)) {
                //     return;
                // }
                // const inference = getInferenceInfoForType(target);
                // if (inference) {
                //     if (!inference.isFixed) {
                //         if (inference.priority === undefined || priority < inference.priority) {
                //             inference.candidates = undefined;
                //             inference.contraCandidates = undefined;
                //             inference.topLevel = true;
                //             inference.priority = priority;
                //         }
                //         if (priority === inference.priority) {
                //             const candidate = propagationType || source;
                //             // We make contravariant inferences only if we are in a pure contravariant position,
                //             // i.e. only if we have not descended into a bivariant position.
                //             if (contravariant && !bivariant) {
                //                 if (!contains(inference.contraCandidates, candidate)) {
                //                     inference.contraCandidates = append(inference.contraCandidates, candidate);
                //                     clearCachedInferences(inferences);
                //                 }
                //             }
                //             else if (!contains(inference.candidates, candidate)) {
                //                 inference.candidates = append(inference.candidates, candidate);
                //                 clearCachedInferences(inferences);
                //             }
                //         }
                //         if (!(priority & InferencePriority.ReturnType) && target_flags & TypeFlags::TypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, target as TypeParameter)) {
                //             inference.topLevel = false;
                //             clearCachedInferences(inferences);
                //         }
                //     }
                //     inferencePriority = Math.min(inferencePriority, priority);
                //     return;
                // }
                // else {
                //     // Infer to the simplified version of an indexed access, if possible, to (hopefully) expose more bare type parameters to the inference engine
                //     const simplified = getSimplifiedType(target, /*writing*/ false);
                //     if (simplified !== target) {
                //         invokeOnce(source, simplified, inferFromTypes);
                //     }
                //     else if (target_flags & TypeFlags::IndexedAccess) {
                //         const indexType = getSimplifiedType((target as IndexedAccessType).indexType, /*writing*/ false);
                //         // Generally simplifications of instantiable indexes are avoided to keep relationship checking correct, however if our target is an access, we can consider
                //         // that key of that access to be "instantiated", since we're looking to find the infernce goal in any way we can.
                //         if (indexType.flags & TypeFlags::Instantiable) {
                //             const simplified = distributeIndexOverObjectType(getSimplifiedType((target as IndexedAccessType).objectType, /*writing*/ false), indexType, /*writing*/ false);
                //             if (simplified && simplified !== target) {
                //                 invokeOnce(source, simplified, inferFromTypes);
                //             }
                //         }
                //     }
                // }
                todo!();
            }
            if checker.types[source]
                .get_object_flags()
                .intersects(ObjectFlags::Reference)
                && checker.types[target]
                    .get_object_flags()
                    .intersects(ObjectFlags::Reference)
                && (checker.types[source].unwrap_as_type_reference().target
                    == checker.types[target].unwrap_as_type_reference().target
                    || checker.isArrayType(source) && checker.isArrayType(target))
                && !(checker.types[source]
                    .unwrap_as_type_reference()
                    .node
                    .is_some()
                    && checker.types[target]
                        .unwrap_as_type_reference()
                        .node
                        .is_some())
            {
                // If source and target are references to the same generic type, infer from type arguments
                // inferFromTypeArguments(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), getVariances((source as TypeReference).target));
                todo!();
            } else if source_flags.intersects(TypeFlags::Index)
                && target_flags.intersects(TypeFlags::Index)
            {
                // contravariant = !contravariant;
                // inferFromTypes((source as IndexType).type, (target as IndexType).type);
                // contravariant = !contravariant;
                todo!();
            } else if (checker.isLiteralType(source) || source_flags.intersects(TypeFlags::String))
                && target_flags.intersects(TypeFlags::Index)
            {
                // const empty = createEmptyObjectTypeFromStringLiteral(source);
                // contravariant = !contravariant;
                // inferWithPriority(empty, (target as IndexType).type, InferencePriority.LiteralKeyof);
                // contravariant = !contravariant;
                todo!();
            } else if source_flags.intersects(TypeFlags::IndexedAccess)
                && target_flags.intersects(TypeFlags::IndexedAccess)
            {
                // inferFromTypes((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType);
                // inferFromTypes((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType);
                todo!();
            } else if source_flags.intersects(TypeFlags::StringMapping)
                && target_flags.intersects(TypeFlags::StringMapping)
            {
                // if ((source as StringMappingType).symbol === (target as StringMappingType).symbol) {
                //     inferFromTypes((source as StringMappingType).type, (target as StringMappingType).type);
                // }
                todo!();
            } else if source_flags.intersects(TypeFlags::Substitution) {
                // inferFromTypes((source as SubstitutionType).baseType, target);
                // const oldPriority = priority;
                // priority |= InferencePriority.SubstituteSource;
                // inferFromTypes((source as SubstitutionType).substitute, target); // Make substitute inference at a lower priority
                // priority = oldPriority;
                todo!();
            } else if target_flags.intersects(TypeFlags::Conditional) {
                // invokeOnce(source, target, inferToConditionalType);
                todo!();
            } else if target_flags.intersects(TypeFlags::UnionOrIntersection) {
                // inferToMultipleTypes(source, (target as UnionOrIntersectionType).types, target_flags);
                todo!();
            } else if source_flags.intersects(TypeFlags::Union) {
                // Source is a union or intersection type, infer from each constituent type
                // const sourceTypes = (source as UnionOrIntersectionType).types;
                // for (const sourceType of sourceTypes) {
                //     inferFromTypes(sourceType, target);
                // }
                todo!();
            } else if target_flags.intersects(TypeFlags::TemplateLiteral) {
                // inferToTemplateLiteralType(source, target as TemplateLiteralType);
                todo!();
            } else {
                source = checker.getReducedType(source);
                if !(priority.intersects(InferencePriority::NoConstraints)
                    && source_flags.intersects(TypeFlags::Intersection | TypeFlags::Instantiable))
                {
                    let apparentSource = checker.getApparentType(source);
                    // getApparentType can return _any_ type, since an indexed access or conditional may simplify to any other type.
                    // If that occurs and it doesn't simplify to an object or intersection, we'll need to restart `inferFromTypes`
                    // with the simplified source.
                    if apparentSource != source
                        && *allowComplexConstraintInference
                        && !checker.types[apparentSource]
                            .get_flags()
                            .intersects(TypeFlags::Object | TypeFlags::Intersection)
                    {
                        // TODO: The `allowComplexConstraintInference` flag is a hack! This forbids inference from complex constraints within constraints!
                        // This isn't required algorithmically, but rather is used to lower the memory burden caused by performing inference
                        // that is _too good_ in projects with complicated constraints (eg, fp-ts). In such cases, if we did not limit ourselves
                        // here, we might produce more valid inferences for types, causing us to do more checks and perform more instantiations
                        // (in addition to the extra stack depth here) which, in turn, can push the already close process over its limit.
                        // TL;DR: If we ever become generally more memory efficient (or our resource budget ever increases), we should just
                        // remove this `allowComplexConstraintInference` flag.
                        *allowComplexConstraintInference = false;
                        return inferFromTypes(
                            checker,
                            inferences,
                            priority,
                            contravariant,
                            bivariant,
                            propagationType,
                            inferencePriority,
                            allowComplexConstraintInference,
                            visited,
                            sourceStack,
                            targetStack,
                            expandingFlags,
                            apparentSource,
                            target,
                        );
                    }
                    source = apparentSource;
                }
                if source_flags.intersects(TypeFlags::Object | TypeFlags::Intersection) {
                    invokeOnce(
                        checker,
                        inferences,
                        priority,
                        contravariant,
                        bivariant,
                        propagationType,
                        inferencePriority,
                        allowComplexConstraintInference,
                        visited,
                        sourceStack,
                        targetStack,
                        expandingFlags,
                        source,
                        target,
                        inferFromObjectTypes,
                    );
                }
            }
        }

        fn inferWithPriority(
            checker: &mut Checker,
            inferences: InferenceContextId,
            priority: &mut InferencePriority,
            contravariant: &mut bool,
            bivariant: &mut bool,
            propagationType: &mut Option<TypeId>,
            inferencePriority: &mut InferencePriority,
            allowComplexConstraintInference: &mut bool,
            visited: &mut AHashMap<VisitedKey, InferencePriority>,
            sourceStack: &mut Vec<RecursionIdentity>,
            targetStack: &mut Vec<RecursionIdentity>,
            expandingFlags: &mut ExpandingFlags,

            source: TypeId,
            target: TypeId,
            newPriority: InferencePriority,
        ) {
            let savePriority = *priority;
            *priority |= newPriority;
            inferFromTypes(
                checker,
                inferences,
                priority,
                contravariant,
                bivariant,
                propagationType,
                inferencePriority,
                allowComplexConstraintInference,
                visited,
                sourceStack,
                targetStack,
                expandingFlags,
                source,
                target,
            );
            *priority = savePriority;
        }

        fn invokeOnce<F>(
            checker: &mut Checker,
            inferences: InferenceContextId,
            priority: &mut InferencePriority,
            contravariant: &mut bool,
            bivariant: &mut bool,
            propagationType: &mut Option<TypeId>,
            inferencePriority: &mut InferencePriority,
            allowComplexConstraintInference: &mut bool,
            visited: &mut AHashMap<VisitedKey, InferencePriority>,
            sourceStack: &mut Vec<RecursionIdentity>,
            targetStack: &mut Vec<RecursionIdentity>,
            expandingFlags: &mut ExpandingFlags,

            source: TypeId,
            target: TypeId,
            mut action: F,
        ) where
            F: FnMut(
                &mut Checker,
                InferenceContextId,
                &mut InferencePriority,
                &mut bool,
                &mut bool,
                &mut Option<TypeId>,
                &mut InferencePriority,
                &mut bool,
                &mut AHashMap<VisitedKey, InferencePriority>,
                &mut Vec<RecursionIdentity>,
                &mut Vec<RecursionIdentity>,
                &mut ExpandingFlags,

                TypeId,
                TypeId,
            ),
        {
            let key = VisitedKey(source, target);
            let status = visited.get(&key);
            if let Some(status) = status {
                *inferencePriority = cmp::min(*inferencePriority, *status);
                return;
            }
            visited.insert(key, InferencePriority::Circularity);
            let saveInferencePriority = *inferencePriority;
            *inferencePriority = InferencePriority::MaxValue;
            // We stop inferring and report a circularity if we encounter duplicate recursion identities on both
            // the source side and the target side.
            let saveExpandingFlags = *expandingFlags;
            let sourceIdentity = checker.getRecursionIdentity(source);
            let targetIdentity = checker.getRecursionIdentity(target);
            if sourceStack.contains(&sourceIdentity) {
                *expandingFlags |= ExpandingFlags::Source
            };
            if targetStack.contains(&targetIdentity) {
                *expandingFlags |= ExpandingFlags::Target
            };
            if *expandingFlags != ExpandingFlags::Both {
                sourceStack.push(sourceIdentity);
                targetStack.push(targetIdentity);
                action(
                    checker,
                    inferences,
                    priority,
                    contravariant,
                    bivariant,
                    propagationType,
                    inferencePriority,
                    allowComplexConstraintInference,
                    visited,
                    sourceStack,
                    targetStack,
                    expandingFlags,
                    source,
                    target,
                );
                targetStack.pop();
                sourceStack.pop();
            } else {
                *inferencePriority = InferencePriority::Circularity;
            }
            *expandingFlags = saveExpandingFlags;
            visited.insert(key, *inferencePriority);
            *inferencePriority = cmp::min(*inferencePriority, saveInferencePriority);
        }

        // function inferFromMatchingTypes(sources: Type[], targets: Type[], matches: (s: Type, t: Type) => boolean): [Type[], Type[]] {
        //     let matchedSources: Type[] | undefined;
        //     let matchedTargets: Type[] | undefined;
        //     for (const t of targets) {
        //         for (const s of sources) {
        //             if (matches(s, t)) {
        //                 inferFromTypes(s, t);
        //                 matchedSources = appendIfUnique(matchedSources, s);
        //                 matchedTargets = appendIfUnique(matchedTargets, t);
        //             }
        //         }
        //     }
        //     return [
        //         matchedSources ? filter(sources, t => !contains(matchedSources, t)) : sources,
        //         matchedTargets ? filter(targets, t => !contains(matchedTargets, t)) : targets,
        //     ];
        // }

        // function inferFromTypeArguments(sourceTypes: readonly Type[], targetTypes: readonly Type[], variances: readonly VarianceFlags[]) {
        //     const count = sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length;
        //     for (let i = 0; i < count; i++) {
        //         if (i < variances.length && (variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Contravariant) {
        //             inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);
        //         }
        //         else {
        //             inferFromTypes(sourceTypes[i], targetTypes[i]);
        //         }
        //     }
        // }

        fn inferFromContravariantTypes(
            checker: &mut Checker,
            inferences: InferenceContextId,
            priority: &mut InferencePriority,
            contravariant: &mut bool,
            bivariant: &mut bool,
            propagationType: &mut Option<TypeId>,
            inferencePriority: &mut InferencePriority,
            allowComplexConstraintInference: &mut bool,
            visited: &mut AHashMap<VisitedKey, InferencePriority>,
            sourceStack: &mut Vec<RecursionIdentity>,
            targetStack: &mut Vec<RecursionIdentity>,
            expandingFlags: &mut ExpandingFlags,

            source: TypeId,
            target: TypeId,
        ) {
            if checker.strictFunctionTypes || priority.intersects(InferencePriority::AlwaysStrict) {
                *contravariant = !*contravariant;
                inferFromTypes(
                    checker,
                    inferences,
                    priority,
                    contravariant,
                    bivariant,
                    propagationType,
                    inferencePriority,
                    allowComplexConstraintInference,
                    visited,
                    sourceStack,
                    targetStack,
                    expandingFlags,
                    source,
                    target,
                );
                *contravariant = !*contravariant;
            } else {
                inferFromTypes(
                    checker,
                    inferences,
                    priority,
                    contravariant,
                    bivariant,
                    propagationType,
                    inferencePriority,
                    allowComplexConstraintInference,
                    visited,
                    sourceStack,
                    targetStack,
                    expandingFlags,
                    source,
                    target,
                );
            }
        }

        fn getInferenceInfoForType(
            checker: &mut Checker,
            inferences: InferenceContextId,
            ty: TypeId,
        ) -> Option<&InferenceInfo> {
            if checker.types[ty]
                .get_flags()
                .intersects(TypeFlags::TypeVariable)
            {
                for inference in &checker.inference_contexts[inferences].inferences {
                    if ty == inference.typeParameter {
                        return Some(inference);
                    }
                }
            }
            return None;
        }

        fn hasInferenceInfoForType(
            checker: &mut Checker,
            inferences: InferenceContextId,
            ty: TypeId,
        ) -> bool {
            getInferenceInfoForType(checker, inferences, ty).is_some()
        }

        // function getSingleTypeVariableFromIntersectionTypes(types: Type[]) {
        //     let typeVariable: Type | undefined;
        //     for (const type of types) {
        //         const t = type.flags & TypeFlags::Intersection && find((type as IntersectionType).types, t => !!getInferenceInfoForType(t));
        //         if (!t || typeVariable && t !== typeVariable) {
        //             return undefined;
        //         }
        //         typeVariable = t;
        //     }
        //     return typeVariable;
        // }

        // function inferToMultipleTypes(source: Type, targets: Type[], targetFlags: TypeFlags) {
        //     let typeVariableCount = 0;
        //     if (targetFlags & TypeFlags::Union) {
        //         let nakedTypeVariable: Type | undefined;
        //         const sources = source.flags & TypeFlags::Union ? (source as UnionType).types : [source];
        //         const matched = new Array<boolean>(sources.length);
        //         let inferenceCircularity = false;
        //         // First infer to types that are not naked type variables. For each source type we
        //         // track whether inferences were made from that particular type to some target with
        //         // equal priority (i.e. of equal quality) to what we would infer for a naked type
        //         // parameter.
        //         for (const t of targets) {
        //             if (getInferenceInfoForType(t)) {
        //                 nakedTypeVariable = t;
        //                 typeVariableCount++;
        //             }
        //             else {
        //                 for (let i = 0; i < sources.length; i++) {
        //                     const saveInferencePriority = inferencePriority;
        //                     inferencePriority = InferencePriority.MaxValue;
        //                     inferFromTypes(sources[i], t);
        //                     if (inferencePriority === priority) matched[i] = true;
        //                     inferenceCircularity = inferenceCircularity || inferencePriority === InferencePriority.Circularity;
        //                     inferencePriority = Math.min(inferencePriority, saveInferencePriority);
        //                 }
        //             }
        //         }
        //         if (typeVariableCount === 0) {
        //             // If every target is an intersection of types containing a single naked type variable,
        //             // make a lower priority inference to that type variable. This handles inferring from
        //             // 'A | B' to 'T & (X | Y)' where we want to infer 'A | B' for T.
        //             const intersectionTypeVariable = getSingleTypeVariableFromIntersectionTypes(targets);
        //             if (intersectionTypeVariable) {
        //                 inferWithPriority(source, intersectionTypeVariable, InferencePriority.NakedTypeVariable);
        //             }
        //             return;
        //         }
        //         // If the target has a single naked type variable and no inference circularities were
        //         // encountered above (meaning we explored the types fully), create a union of the source
        //         // types from which no inferences have been made so far and infer from that union to the
        //         // naked type variable.
        //         if (typeVariableCount === 1 && !inferenceCircularity) {
        //             const unmatched = flatMap(sources, (s, i) => matched[i] ? undefined : s);
        //             if (unmatched.length) {
        //                 inferFromTypes(getUnionType(unmatched), nakedTypeVariable!);
        //                 return;
        //             }
        //         }
        //     }
        //     else {
        //         // We infer from types that are not naked type variables first so that inferences we
        //         // make from nested naked type variables and given slightly higher priority by virtue
        //         // of being first in the candidates array.
        //         for (const t of targets) {
        //             if (getInferenceInfoForType(t)) {
        //                 typeVariableCount++;
        //             }
        //             else {
        //                 inferFromTypes(source, t);
        //             }
        //         }
        //     }
        //     // Inferences directly to naked type variables are given lower priority as they are
        //     // less specific. For example, when inferring from Promise<string> to T | Promise<T>,
        //     // we want to infer string for T, not Promise<string> | string. For intersection types
        //     // we only infer to single naked type variables.
        //     if (targetFlags & TypeFlags::Intersection ? typeVariableCount === 1 : typeVariableCount > 0) {
        //         for (const t of targets) {
        //             if (getInferenceInfoForType(t)) {
        //                 inferWithPriority(source, t, InferencePriority.NakedTypeVariable);
        //             }
        //         }
        //     }
        // }

        // function inferToMappedType(source: Type, target: MappedType, constraintType: Type): boolean {
        //     if (constraintType.flags & TypeFlags::Union) {
        //         let result = false;
        //         for (const type of (constraintType as UnionType).types) {
        //             result = inferToMappedType(source, target, type) || result;
        //         }
        //         return result;
        //     }
        //     if (constraintType.flags & TypeFlags::Index) {
        //         // We're inferring from some source type S to a homomorphic mapped type { [P in keyof T]: X },
        //         // where T is a type variable. Use inferTypeForHomomorphicMappedType to infer a suitable source
        //         // type and then make a secondary inference from that type to T. We make a secondary inference
        //         // such that direct inferences to T get priority over inferences to Partial<T>, for example.
        //         const inference = getInferenceInfoForType((constraintType as IndexType).type);
        //         if (inference && !inference.isFixed && !isFromInferenceBlockedSource(source)) {
        //             const inferredType = inferTypeForHomomorphicMappedType(source, target, constraintType as IndexType);
        //             if (inferredType) {
        //                 // We assign a lower priority to inferences made from types containing non-inferrable
        //                 // types because we may only have a partial result (i.e. we may have failed to make
        //                 // reverse inferences for some properties).
        //                 inferWithPriority(inferredType, inference.typeParameter,
        //                     getObjectFlags(source) & ObjectFlags.NonInferrableType ?
        //                         InferencePriority.PartialHomomorphicMappedType :
        //                         InferencePriority.HomomorphicMappedType);
        //             }
        //         }
        //         return true;
        //     }
        //     if (constraintType.flags & TypeFlags::TypeParameter) {
        //         // We're inferring from some source type S to a mapped type { [P in K]: X }, where K is a type
        //         // parameter. First infer from 'keyof S' to K.
        //         inferWithPriority(getIndexType(source), constraintType, InferencePriority.MappedTypeConstraint);
        //         // If K is constrained to a type C, also infer to C. Thus, for a mapped type { [P in K]: X },
        //         // where K extends keyof T, we make the same inferences as for a homomorphic mapped type
        //         // { [P in keyof T]: X }. This enables us to make meaningful inferences when the target is a
        //         // Pick<T, K>.
        //         const extendedConstraint = getConstraintOfType(constraintType);
        //         if (extendedConstraint && inferToMappedType(source, target, extendedConstraint)) {
        //             return true;
        //         }
        //         // If no inferences can be made to K's constraint, infer from a union of the property types
        //         // in the source to the template type X.
        //         const propTypes = map(getPropertiesOfType(source), getTypeOfSymbol);
        //         const indexTypes = map(getIndexInfosOfType(source), info => info !== enumNumberIndexInfo ? info.type : neverType);
        //         inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target));
        //         return true;
        //     }
        //     return false;
        // }

        // function inferToConditionalType(source: Type, target: ConditionalType) {
        //     if (source.flags & TypeFlags::Conditional) {
        //         inferFromTypes((source as ConditionalType).checkType, target.checkType);
        //         inferFromTypes((source as ConditionalType).extendsType, target.extendsType);
        //         inferFromTypes(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target));
        //         inferFromTypes(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target));
        //     }
        //     else {
        //         const savePriority = priority;
        //         priority |= contravariant ? InferencePriority.ContravariantConditional : 0;
        //         const targetTypes = [getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)];
        //         inferToMultipleTypes(source, targetTypes, target.flags);
        //         priority = savePriority;
        //     }
        // }

        // function inferToTemplateLiteralType(source: Type, target: TemplateLiteralType) {
        //     const matches = inferTypesFromTemplateLiteralType(source, target);
        //     const types = target.types;
        //     // When the target template literal contains only placeholders (meaning that inference is intended to extract
        //     // single characters and remainder strings) and inference fails to produce matches, we want to infer 'never' for
        //     // each placeholder such that instantiation with the inferred value(s) produces 'never', a type for which an
        //     // assignment check will fail. If we make no inferences, we'll likely end up with the constraint 'string' which,
        //     // upon instantiation, would collapse all the placeholders to just 'string', and an assignment check might
        //     // succeed. That would be a pointless and confusing outcome.
        //     if (matches || every(target.texts, s => s.length === 0)) {
        //         for (let i = 0; i < types.length; i++) {
        //             inferFromTypes(matches ? matches[i] : neverType, types[i]);
        //         }
        //     }
        // }

        fn inferFromObjectTypes(
            checker: &mut Checker,
            inferences: InferenceContextId,
            priority: &mut InferencePriority,
            contravariant: &mut bool,
            bivariant: &mut bool,
            propagationType: &mut Option<TypeId>,
            inferencePriority: &mut InferencePriority,
            allowComplexConstraintInference: &mut bool,
            visited: &mut AHashMap<VisitedKey, InferencePriority>,
            sourceStack: &mut Vec<RecursionIdentity>,
            targetStack: &mut Vec<RecursionIdentity>,
            expandingFlags: &mut ExpandingFlags,

            source: TypeId,
            target: TypeId,
        ) {
            if checker.types[source]
                .get_object_flags()
                .intersects(ObjectFlags::Reference)
                && checker.types[target]
                    .get_object_flags()
                    .intersects(ObjectFlags::Reference)
                && (checker.types[source].unwrap_as_type_reference().target
                    == checker.types[target].unwrap_as_type_reference().target
                    || checker.isArrayType(source) && checker.isArrayType(target))
            {
                todo!();
                // If source and target are references to the same generic type, infer from type arguments
                // inferFromTypeArguments(getTypeArguments(source as TypeReference), getTypeArguments(target as TypeReference), getVariances((source as TypeReference).target));
                // return;
            }
            if checker.isGenericMappedType(source) && checker.isGenericMappedType(target) {
                todo!();
                // The source and target types are generic types { [P in S]: X } and { [P in T]: Y }, so we infer
                // from S to T and from X to Y.
                // inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target));
                // inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target));
                // const sourceNameType = getNameTypeFromMappedType(source);
                // const targetNameType = getNameTypeFromMappedType(target);
                // if (sourceNameType && targetNameType) inferFromTypes(sourceNameType, targetNameType);
            }
            if let Type::MappedType(t) = &checker.types[target] {
                if t.declaration.name_type.is_none() {
                    todo!();
                    // const constraintType = getConstraintTypeFromMappedType(target as MappedType);
                    // if (inferToMappedType(source, target as MappedType, constraintType)) {
                    //     return;
                    // }
                }
            }
            // Infer from the members of source and target only if the two types are possibly related
            if !checker.typesDefinitelyUnrelated(source, target) {
                if checker.isArrayType(source) || checker.isTupleType(source) {
                    if checker.isTupleType(target) {
                        todo!();
                        // const sourceArity = getTypeReferenceArity(source);
                        // const targetArity = getTypeReferenceArity(target);
                        // const elementTypes = getTypeArguments(target);
                        // const elementFlags = target.target.elementFlags;
                        // // When source and target are tuple types with the same structure (fixed, variadic, and rest are matched
                        // // to the same kind in each position), simply infer between the element types.
                        // if (isTupleType(source) && isTupleTypeStructureMatching(source, target)) {
                        //     for (let i = 0; i < targetArity; i++) {
                        //         inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
                        //     }
                        //     return;
                        // }
                        // const startLength = isTupleType(source) ? Math.min(source.target.fixedLength, target.target.fixedLength) : 0;
                        // const endLength = Math.min(isTupleType(source) ? getEndElementCount(source.target, ElementFlags.Fixed) : 0,
                        //     target.target.hasRestElement ? getEndElementCount(target.target, ElementFlags.Fixed) : 0);
                        // // Infer between starting fixed elements.
                        // for (let i = 0; i < startLength; i++) {
                        //     inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
                        // }
                        // if (!isTupleType(source) || sourceArity - startLength - endLength === 1 && source.target.elementFlags[startLength] & ElementFlags.Rest) {
                        //     // Single rest element remains in source, infer from that to every element in target
                        //     const restType = getTypeArguments(source)[startLength];
                        //     for (let i = startLength; i < targetArity - endLength; i++) {
                        //         inferFromTypes(elementFlags[i] & ElementFlags.Variadic ? createArrayType(restType) : restType, elementTypes[i]);
                        //     }
                        // }
                        // else {
                        //     const middleLength = targetArity - startLength - endLength;
                        //     if (middleLength === 2 && elementFlags[startLength] & elementFlags[startLength + 1] & ElementFlags.Variadic && isTupleType(source)) {
                        //         // Middle of target is [...T, ...U] and source is tuple type
                        //         const targetInfo = getInferenceInfoForType(elementTypes[startLength]);
                        //         if (targetInfo && targetInfo.impliedArity !== undefined) {
                        //             // Infer slices from source based on implied arity of T.
                        //             inferFromTypes(sliceTupleType(source, startLength, endLength + sourceArity - targetInfo.impliedArity), elementTypes[startLength]);
                        //             inferFromTypes(sliceTupleType(source, startLength + targetInfo.impliedArity, endLength), elementTypes[startLength + 1]);
                        //         }
                        //     }
                        //     else if (middleLength === 1 && elementFlags[startLength] & ElementFlags.Variadic) {
                        //         // Middle of target is exactly one variadic element. Infer the slice between the fixed parts in the source.
                        //         // If target ends in optional element(s), make a lower priority a speculative inference.
                        //         const endsInOptional = target.target.elementFlags[targetArity - 1] & ElementFlags.Optional;
                        //         const sourceSlice = isTupleType(source) ? sliceTupleType(source, startLength, endLength) : createArrayType(getTypeArguments(source)[0]);
                        //         inferWithPriority(sourceSlice, elementTypes[startLength], endsInOptional ? InferencePriority.SpeculativeTuple : 0);
                        //     }
                        //     else if (middleLength === 1 && elementFlags[startLength] & ElementFlags.Rest) {
                        //         // Middle of target is exactly one rest element. If middle of source is not empty, infer union of middle element types.
                        //         const restType = isTupleType(source) ? getElementTypeOfSliceOfTupleType(source, startLength, endLength) : getTypeArguments(source)[0];
                        //         if (restType) {
                        //             inferFromTypes(restType, elementTypes[startLength]);
                        //         }
                        //     }
                        // }
                        // // Infer between ending fixed elements
                        // for (let i = 0; i < endLength; i++) {
                        //     inferFromTypes(getTypeArguments(source)[sourceArity - i - 1], elementTypes[targetArity - i - 1]);
                        // }
                        // return;
                    }
                    if checker.isArrayType(target) {
                        todo!();
                        // inferFromIndexTypes(source, target);
                        // return;
                    }
                }
                inferFromProperties(
                    checker,
                    inferences,
                    priority,
                    contravariant,
                    bivariant,
                    propagationType,
                    inferencePriority,
                    allowComplexConstraintInference,
                    visited,
                    sourceStack,
                    targetStack,
                    expandingFlags,
                    source,
                    target,
                );
                inferFromSignatures(
                    checker,
                    inferences,
                    priority,
                    contravariant,
                    bivariant,
                    propagationType,
                    inferencePriority,
                    allowComplexConstraintInference,
                    visited,
                    sourceStack,
                    targetStack,
                    expandingFlags,
                    source,
                    target,
                    SignatureKind::Call,
                );
                inferFromSignatures(
                    checker,
                    inferences,
                    priority,
                    contravariant,
                    bivariant,
                    propagationType,
                    inferencePriority,
                    allowComplexConstraintInference,
                    visited,
                    sourceStack,
                    targetStack,
                    expandingFlags,
                    source,
                    target,
                    SignatureKind::Construct,
                );
                inferFromIndexTypes(
                    checker,
                    inferences,
                    priority,
                    contravariant,
                    bivariant,
                    propagationType,
                    inferencePriority,
                    allowComplexConstraintInference,
                    visited,
                    sourceStack,
                    targetStack,
                    expandingFlags,
                    source,
                    target,
                );
            }
        }

        fn inferFromProperties(
            checker: &mut Checker,
            inferences: InferenceContextId,
            priority: &mut InferencePriority,
            contravariant: &mut bool,
            bivariant: &mut bool,
            propagationType: &mut Option<TypeId>,
            inferencePriority: &mut InferencePriority,
            allowComplexConstraintInference: &mut bool,
            visited: &mut AHashMap<VisitedKey, InferencePriority>,
            sourceStack: &mut Vec<RecursionIdentity>,
            targetStack: &mut Vec<RecursionIdentity>,
            expandingFlags: &mut ExpandingFlags,

            source: TypeId,
            target: TypeId,
        ) {
            let properties = checker.getPropertiesOfObjectType(target);
            for &targetProp in properties.clone().iter() {
                let name = &checker.symbols[targetProp].escapedName().clone();
                let sourceProp = checker.getPropertyOfType(source, name, false);
                if let Some(sourceProp) = sourceProp {
                    let source = checker.getTypeOfSymbol(sourceProp);
                    let target = checker.getTypeOfSymbol(targetProp);
                    inferFromTypes(
                        checker,
                        inferences,
                        priority,
                        contravariant,
                        bivariant,
                        propagationType,
                        inferencePriority,
                        allowComplexConstraintInference,
                        visited,
                        sourceStack,
                        targetStack,
                        expandingFlags,
                        source,
                        target,
                    );
                }
            }
        }

        fn inferFromSignatures(
            checker: &mut Checker,
            inferences: InferenceContextId,
            priority: &mut InferencePriority,
            contravariant: &mut bool,
            bivariant: &mut bool,
            propagationType: &mut Option<TypeId>,
            inferencePriority: &mut InferencePriority,
            allowComplexConstraintInference: &mut bool,
            visited: &mut AHashMap<VisitedKey, InferencePriority>,
            sourceStack: &mut Vec<RecursionIdentity>,
            targetStack: &mut Vec<RecursionIdentity>,
            expandingFlags: &mut ExpandingFlags,
            source: TypeId,
            target: TypeId,
            kind: SignatureKind,
        ) {
            let sourceSignatures = checker.getSignaturesOfType(source, kind);
            let targetSignatures = checker.getSignaturesOfType(target, kind);
            let sourceLen = sourceSignatures.len();
            let targetLen = targetSignatures.len();
            let len = if sourceLen < targetLen {
                sourceLen
            } else {
                targetLen
            };
            let skipParameters = checker.types[source]
                .get_object_flags()
                .intersects(ObjectFlags::NonInferrableType);
            for i in 0..len {
                let source = checker.getBaseSignature(sourceSignatures[sourceLen - len + i]);
                let target = checker.getErasedSignature(targetSignatures[targetLen - len + i]);
                inferFromSignature(
                    checker,
                    inferences,
                    priority,
                    contravariant,
                    bivariant,
                    propagationType,
                    inferencePriority,
                    allowComplexConstraintInference,
                    visited,
                    sourceStack,
                    targetStack,
                    expandingFlags,
                    source,
                    target,
                    skipParameters,
                );
            }
        }

        fn inferFromSignature(
            checker: &mut Checker,
            inferences: InferenceContextId,
            priority: &mut InferencePriority,
            contravariant: &mut bool,
            bivariant: &mut bool,
            propagationType: &mut Option<TypeId>,
            inferencePriority: &mut InferencePriority,
            allowComplexConstraintInference: &mut bool,
            visited: &mut AHashMap<VisitedKey, InferencePriority>,
            sourceStack: &mut Vec<RecursionIdentity>,
            targetStack: &mut Vec<RecursionIdentity>,
            expandingFlags: &mut ExpandingFlags,

            source: SignatureId,
            target: SignatureId,
            skipParameters: bool,
        ) {
            if !skipParameters {
                let saveBivariant = *bivariant;
                let target_decl = &checker.signatures[target].declaration;
                // Once we descend into a bivariant signature we remain bivariant for all nested inferences
                *bivariant = *bivariant
                    || matches!(
                        target_decl,
                        Some(
                            BoundNode::PrivateMethod(_)
                                | BoundNode::ClassMethod(_)
                                | BoundNode::MethodProp(_)
                                | BoundNode::TsMethodSignature(_)
                                | BoundNode::Constructor(_)
                        )
                    );
                checker.applyToParameterTypes(source, target, |checker, source, target| {
                    inferFromContravariantTypes(
                        checker,
                        inferences,
                        priority,
                        contravariant,
                        bivariant,
                        propagationType,
                        inferencePriority,
                        allowComplexConstraintInference,
                        visited,
                        sourceStack,
                        targetStack,
                        expandingFlags,
                        source,
                        target,
                    )
                });
                *bivariant = saveBivariant;
            }
            checker.applyToReturnTypes(source, target, |checker, source, target| {
                inferFromTypes(
                    checker,
                    inferences,
                    priority,
                    contravariant,
                    bivariant,
                    propagationType,
                    inferencePriority,
                    allowComplexConstraintInference,
                    visited,
                    sourceStack,
                    targetStack,
                    expandingFlags,
                    source,
                    target,
                );
            });
        }

        fn inferFromIndexTypes(
            checker: &mut Checker,
            inferences: InferenceContextId,
            priority: &mut InferencePriority,
            contravariant: &mut bool,
            bivariant: &mut bool,
            propagationType: &mut Option<TypeId>,
            inferencePriority: &mut InferencePriority,
            allowComplexConstraintInference: &mut bool,
            visited: &mut AHashMap<VisitedKey, InferencePriority>,
            sourceStack: &mut Vec<RecursionIdentity>,
            targetStack: &mut Vec<RecursionIdentity>,
            expandingFlags: &mut ExpandingFlags,

            source: TypeId,
            target: TypeId,
        ) {
            // Inferences across mapped type index signatures are pretty much the same a inferences to homomorphic variables
            let newPriority = if checker.types[source]
                .get_object_flags()
                .intersects(ObjectFlags::Mapped)
                && checker.types[target]
                    .get_object_flags()
                    .intersects(ObjectFlags::Mapped)
            {
                InferencePriority::HomomorphicMappedType
            } else {
                InferencePriority::default()
            };
            let indexInfos = checker.getIndexInfosOfType(target);
            if checker.isObjectTypeWithInferableIndex(source) {
                todo!();
                // for targetInfo in indexInfos.iter() {
                //     let propTypes = Vec::new();
                //     for prop in getPropertiesOfType(source) {
                //         if (isApplicableIndexType(
                //             getLiteralTypeFromProperty(
                //                 prop,
                //                 TypeFlags::StringOrNumberLiteralOrUnique,
                //             ),
                //             targetInfo.keyType,
                //         )) {
                //             let propType = getTypeOfSymbol(prop);
                //             propTypes.push(if prop.flags & SymbolFlags::Optional {
                //                 removeMissingOrUndefinedType(propType)
                //             } else {
                //                 propType
                //             });
                //         }
                //     }
                //     for info in checker.getIndexInfosOfType(source).iter() {
                //         if checker.isApplicableIndexType(info.keyType, targetInfo.keyType) {
                //             propTypes.push(info.ty);
                //         }
                //     }
                //     if (propTypes.length) {
                //         inferWithPriority(
                //             checker,
                //             inferences,
                //             priority,
                //             bivariant,
                //             propagationType,
                //             inferencePriority,
                //             allowComplexConstraintInference,
                //             visited,
                //             sourceStack,
                //             targetStack,
                //             expandingFlags,
                //             getUnionType(propTypes),
                //             targetInfo.ty,
                //             priority,
                //         );
                //     }
                // }
            }
            for &targetInfo in indexInfos.iter() {
                let sourceInfo =
                    checker.getApplicableIndexInfo(source, checker.index_infos[targetInfo].keyType);
                if let Some(sourceInfo) = sourceInfo {
                    inferWithPriority(
                        checker,
                        inferences,
                        priority,
                        contravariant,
                        bivariant,
                        propagationType,
                        inferencePriority,
                        allowComplexConstraintInference,
                        visited,
                        sourceStack,
                        targetStack,
                        expandingFlags,
                        checker.index_infos[sourceInfo].ty,
                        checker.index_infos[targetInfo].ty,
                        newPriority,
                    );
                }
            }
        }
    }

    // TODO:
    // isTypeOrBaseIdenticalTo
    // TODO:
    // isTypeCloselyMatchedBy
    // TODO:
    // hasPrimitiveConstraint

    fn isObjectLiteralType(&self, ty: TypeId) -> bool {
        self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::ObjectLiteral)
    }

    fn isObjectOrArrayLiteralType(&self, ty: TypeId) -> bool {
        self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::ObjectLiteral | ObjectFlags::ArrayLiteral)
    }

    // TODO:
    // unionObjectAndArrayLiteralCandidates
    // TODO:
    // getContravariantInference
    // TODO:
    // getCovariantInference

    fn getInferredType(&mut self, context: InferenceContextId, index: usize) -> TypeId {
        macro_rules! inference {
            () => {
                self.inference_contexts[context].inferences[index]
            };
        }
        if inference!().inferredType.is_none() {
            let mut inferredType = None;
            if let Some(signature) = self.inference_contexts[context].signature {
                let inferredCovariantType = if inference!().candidates.is_some() {
                    todo!();
                    // self.getCovariantInference(inference, signature)
                } else {
                    None
                };
                if inference!().contraCandidates.is_some() {
                    todo!();
                    // let inferredContravariantType = self.getContravariantInference(inference);
                    // // If we have both co- and contra-variant inferences, we prefer the contra-variant inference
                    // // unless the co-variant inference is a subtype and not 'never'.
                    // inferredType = if inferredCovariantType
                    //     && !inferredCovariantType.flags.intersects(TypeFlags::Never)
                    //     && isTypeSubtypeOf(inferredCovariantType, inferredContravariantType)
                    // {
                    //     inferredCovariantType
                    // } else {
                    //     inferredContravariantType
                    // };
                } else if inferredCovariantType.is_some() {
                    inferredType = inferredCovariantType;
                } else if self.inference_contexts[context]
                    .flags
                    .intersects(InferenceFlags::NoDefault)
                {
                    // We use silentNeverType as the wildcard that signals no inferences.
                    inferredType = Some(self.silentNeverType);
                } else {
                    // Infer either the default or the empty object type when no inferences were
                    // made. It is important to remember that in this case, inference still
                    // succeeds, meaning there is no error for not having inference candidates. An
                    // inference error only occurs when there are *conflicting* candidates, i.e.
                    // candidates with no common supertype.
                    let defaultType = self.getDefaultFromTypeParameter(inference!().typeParameter);
                    if let Some(defaultType) = defaultType {
                        // Instantiate the default type. Any forward reference to a type
                        // parameter should be instantiated to the empty object type.
                        inferredType = Some(self.instantiateType(
                            defaultType,
                            Some(TypeMapper::mergeTypeMappers(
                                Some(TypeMapper::createBackreferenceMapper(context, index)),
                                self.inference_contexts[context].nonFixingMapper.clone(),
                            )),
                        ));
                    }
                }
            } else {
                inferredType = self.getTypeFromInference(context, index);
            }

            inference!().inferredType = inferredType.or(Some(
                self.getDefaultTypeArgumentType(
                    self.inference_contexts[context]
                        .flags
                        .intersects(InferenceFlags::AnyDefault),
                ),
            ));

            let constraint = self.getConstraintOfTypeParameter(inference!().typeParameter);
            if let Some(constraint) = constraint {
                let instantiatedConstraint = self.instantiateType(
                    constraint,
                    Some(self.inference_contexts[context].nonFixingMapper.clone()),
                );
                if inferredType.is_none() || {
                    let target =
                        self.getTypeWithThisArgument(instantiatedConstraint, inferredType, false);
                    (self.inference_contexts[context].compareTypes)(
                        self,
                        inferredType.unwrap(),
                        target,
                        false,
                    ) == Ternary::False
                } {
                    inferredType = Some(instantiatedConstraint);
                    inference!().inferredType = Some(instantiatedConstraint);
                }
            }
        }

        inference!().inferredType.unwrap()
    }

    fn getDefaultTypeArgumentType(&self, isInJavaScriptFile: bool) -> TypeId {
        if isInJavaScriptFile {
            self.anyType
        } else {
            self.unknownType
        }
    }

    fn getInferredTypes(&mut self, context: InferenceContextId) -> Vec<TypeId> {
        let mut result = Vec::new();
        for i in 0..self.inference_contexts[context].inferences.len() {
            result.push(self.getInferredType(context, i));
        }
        result
    }

    // TODO:
    // getCannotFindNameDiagnosticForName

    fn getResolvedSymbol(&mut self, node: &Rc<Ident>) -> SymbolId {
        let bound_node = BoundNode::Ident(node.clone());
        match self.getNodeLinks(bound_node.clone()).resolvedSymbol {
            Some(s) => s,
            None => {
                let resolved = self
                    .resolveName(
                        Some(bound_node.clone()),
                        node.sym.clone(),
                        SymbolFlags::Value | SymbolFlags::ExportValue,
                        /*getCannotFindNameDiagnosticForName(node),*/
                        Some(node.sym.clone()),
                        !isWriteOnlyAccess(&bound_node),
                        false,
                    )
                    .unwrap_or(self.unknownSymbol);
                self.getNodeLinks_mut(bound_node).resolvedSymbol = Some(resolved);
                resolved
            }
        }
    }

    // TODO:
    // isInTypeQuery
    // TODO:
    // getFlowCacheKey

    fn isMatchingReference(&mut self, source: &BoundNode, target: &BoundNode) -> bool {
        match target {
            BoundNode::ParenExpr(t) => {
                return self.isMatchingReference(source, &t.expr.bind(target.clone()));
            }
            BoundNode::TsNonNullExpr(t) => {
                return self.isMatchingReference(source, &t.expr.bind(target.clone()));
            }
            BoundNode::AssignExpr(t) => {
                return self.isMatchingReference(source, &t.left.bind(target.clone()));
            }
            BoundNode::BinExpr(_) => {
                todo!();
                // return (isAssignmentExpression(target)
                //     && isMatchingReference(source, target.left))
                //     || (isBinaryExpression(target)
                //         && target.operatorToken.kind == SyntaxKind.CommaToken
                //         && isMatchingReference(source, target.right));
            }
            _ => {}
        }
        match source {
            BoundNode::MetaPropExpr(s) => {
                if let BoundNode::MetaPropExpr(t) = target {
                    s.meta.sym == t.meta.sym && s.prop.sym == t.prop.sym
                } else {
                    false
                }
            }
            BoundNode::Ident(s) => {
                if let BoundNode::Ident(t) = target {
                    self.getResolvedSymbol(s) == self.getResolvedSymbol(t)
                } else if let BoundNode::BindingIdent(t) = target {
                    self.getResolvedSymbol(s)
                        == self.getResolvedSymbol(&Ident::new(t.id.clone(), Some(target.clone())))
                } else {
                    dbg!(target);
                    todo!("see below");
                    // if matches!(
                    //     target,
                    //     BoundNode::ArrayPat(_)
                    //         | BoundNode::RestPat(_)
                    //         | BoundNode::ObjectPat(_)
                    //         | BoundNode::AssignPat(_)
                    //         | BoundNode::KeyValuePatProp(_)
                    //         | BoundNode::AssignPatProp(_)
                    // ) {
                    // dbg!(target);
                    // todo!("see below");
                    // }
                    // // (target.kind == SyntaxKind.VariableDeclaration
                    // //     || target.kind == SyntaxKind.BindingElement)
                    // //     && self.getExportSymbolOfValueSymbolIfExported(self.getResolvedSymbol(
                    // //         s,
                    // //     )) == self.getSymbolOfNode(target.clone())
                    // if matches!(target, BoundNode::VarDeclarator(_)) {
                    //     let source_sym = self.getResolvedSymbol(s);
                    //     Some(self.getExportSymbolOfValueSymbolIfExported(source_sym))
                    //         == self.getSymbolOfNode(target.clone())
                    // } else {
                    //     false
                    // }
                }
            }
            BoundNode::PrivateName(_) => {
                todo!();
                // if isThisInTypeQuery(source) {
                //     target.kind == SyntaxKind.ThisKeyword
                // } else {
                //     target.kind == SyntaxKind.Identifier
                //         && getResolvedSymbol(source as Identifier)
                //             == getResolvedSymbol(target as Identifier)
                //         || (target.kind == SyntaxKind.VariableDeclaration
                //             || target.kind == SyntaxKind.BindingElement)
                //             && getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(
                //                 source as Identifier,
                //             )) == getSymbolOfNode(target)
                // }
            }
            BoundNode::ThisExpr(_) => matches!(target, BoundNode::ThisExpr(_)),
            BoundNode::Super(_) => matches!(target, BoundNode::Super(_)),
            BoundNode::TsNonNullExpr(s) => {
                self.isMatchingReference(&s.expr.bind(source.clone()), target)
            }
            BoundNode::ParenExpr(s) => {
                self.isMatchingReference(&s.expr.bind(source.clone()), target)
            }
            BoundNode::MemberExpr(s) => {
                if let BoundNode::MemberExpr(t) = target {
                    self.getAccessedPropertyNameOfMemberExpr(s)
                        == self.getAccessedPropertyNameOfMemberExpr(t)
                        && self.isMatchingReference(
                            &s.obj.bind(source.clone()),
                            &t.obj.bind(target.clone()),
                        )
                } else {
                    false
                }
            }
            BoundNode::TsQualifiedName(s) => {
                if let BoundNode::MemberExpr(t) = target {
                    Some(s.right.sym.clone()) == self.getAccessedPropertyNameOfMemberExpr(t)
                        && self.isMatchingReference(
                            &s.left.bind(source.clone()),
                            &t.obj.bind(target.clone()),
                        )
                } else {
                    false
                }
            }
            BoundNode::BinExpr(_) => {
                todo!();
                // return (isBinaryExpression(source)
                //     && source.operatorToken.kind == SyntaxKind.CommaToken
                //     && self.isMatchingReference(source.right, target));
            }
            _ => false,
        }
    }

    fn getPropertyAccess(&mut self, expr: &BoundNode) -> Option<BoundNode> {
        if matches!(expr, BoundNode::MemberExpr(_)) {
            return Some(expr.clone());
        }
        if let BoundNode::Ident(i) = expr {
            todo!();
            // let symbol = getResolvedSymbol(expr);
            // if (isConstVariable(symbol)) {
            //     let declaration = symbol.valueDeclaration!;
            //     // Given 'const x = obj.kind', allow 'x' as an alias for 'obj.kind'
            //     if (isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isAccessExpression(declaration.initializer)) {
            //         return declaration.initializer;
            //     }
            //     // Given 'const { kind: x } = obj', allow 'x' as an alias for 'obj.kind'
            //     if (isBindingElement(declaration) && !declaration.initializer) {
            //         let parent = declaration.parent.parent;
            //         if (isVariableDeclaration(parent) && !parent.type && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer))) {
            //             return declaration;
            //         }
            //     }
            // }
        }
        None
    }

    // fn getAccessedPropertyName(&mut self, access: AccessExpression | BindingElement) -> Option<JsWord> {
    fn getAccessedPropertyName(&mut self, access: &BoundNode) -> Option<JsWord> {
        todo!("see below and getAccessedPropertyNameOfMemberExpr");
        // let propertyName;
        // if access.kind == SyntaxKind.PropertyAccessExpression {
        //     access.name.escapedText
        // } else if access.kind == SyntaxKind.ElementAccessExpression
        //     && isStringOrNumericLiteralLike(access.argumentExpression)
        // {
        //     escapeLeadingUnderscores(access.argumentExpression.text)
        // } else if access.kind == SyntaxKind.BindingElement
        //     && (propertyName = getDestructuringPropertyName(access))
        // {
        //     escapeLeadingUnderscores(propertyName)
        // } else {
        //     None
        // }
    }
    fn getAccessedPropertyNameOfMemberExpr(&mut self, access: &Rc<MemberExpr>) -> Option<JsWord> {
        if access.computed {
            match &access.prop {
                // TODO: escapeLeadingUnderscores:
                ast::Expr::Lit(ast::Lit::Num(_)) => todo!(),
                ast::Expr::Lit(ast::Lit::Str(s)) => Some(s.value.clone()),
                ast::Expr::Tpl(t) if t.exprs.is_empty() => {
                    Some(get_text_of_no_substitution_template(t.as_ref()))
                }
                _ => None,
            }
        } else {
            Some(unwrap_as!(&access.prop, ast::Expr::Ident(p), p).sym.clone())
        }
    }

    fn containsMatchingReference(&mut self, mut source: BoundNode, target: &BoundNode) -> bool {
        while let BoundNode::MemberExpr(s) = &source {
            source = s.obj.bind(source.clone());
            if self.isMatchingReference(&source, target) {
                return true;
            }
        }
        false
    }

    fn optionalChainContainsReference(&mut self, source: &BoundNode, target: &BoundNode) -> bool {
        todo!();
        // while (isOptionalChain(source)) {
        //     source = source.expression;
        //     if (isMatchingReference(source, target)) {
        //         return true;
        //     }
        // }
        // return false;
    }

    fn isDiscriminantProperty(&mut self, ty: Option<TypeId>, name: &JsWord) -> bool {
        if let Some(ty) = ty {
            if self.types[ty].get_flags().intersects(TypeFlags::Union) {
                if let Some(prop) = self.getUnionOrIntersectionProperty(ty, name, false) {
                    if getCheckFlags(&self.symbols[prop]).intersects(CheckFlags::SyntheticProperty)
                    {
                        todo!();
                        // if ((prop as TransientSymbol).isDiscriminantProperty == undefined) {
                        //     (prop as TransientSymbol).isDiscriminantProperty =
                        //         ((prop as TransientSymbol).checkFlags & CheckFlags.Discriminant) == CheckFlags.Discriminant &&
                        //         !self.isGenericType(self.getTypeOfSymbol(prop));
                        // }
                        // return !!(prop as TransientSymbol).isDiscriminantProperty;
                    }
                }
            }
        }
        false
    }

    // TODO:
    // findDiscriminantProperties
    // TODO:
    // mapTypesByKeyProperty
    // TODO:
    // getKeyPropertyName
    // TODO:
    // getConstituentTypeForKeyType
    // TODO:
    // getMatchingUnionConstituentForType
    // TODO:
    // getMatchingUnionConstituentForObjectLiteral
    // TODO:
    // isOrContainsMatchingReference
    // TODO:
    // hasMatchingArgument
    // TODO:
    // getFlowNodeId
    // TODO:
    // typeMaybeAssignableTo
    // TODO:
    // getAssignmentReducedType

    fn isFunctionObjectType(&mut self, ty: TypeId) -> bool {
        // We do a quick check for a "bind" property before performing the more expensive subtype
        // check. This gives us a quicker out in the common case where an object type is not a function.
        let resolved_id = self.resolveStructuredTypeMembers(ty);
        let resolved = unwrap_as!(&self.types[resolved_id], Type::ResolvedType(t), t);
        !resolved.object_type_base.callSignatures.is_empty()
            || !resolved.object_type_base.constructSignatures.is_empty()
            || self.symbol_tables[resolved.object_type_base.members.unwrap()]
                .contains_key(&JsWord::from("bind"))
                && self.isTypeSubtypeOf(ty, self.globalFunctionType())
    }

    fn getTypeFacts(&mut self, ty: TypeId, ignoreObjects: bool) -> TypeFacts {
        let flags = self.types[ty].get_flags();
        if flags.intersects(TypeFlags::String) {
            return if self.strictNullChecks {
                TypeFacts::StringStrictFacts
            } else {
                TypeFacts::StringFacts
            };
        }
        if let Type::StringLiteralType(t) = &self.types[ty] {
            let isEmpty = &t.value == "";
            return if self.strictNullChecks {
                if isEmpty {
                    TypeFacts::EmptyStringStrictFacts
                } else {
                    TypeFacts::NonEmptyStringStrictFacts
                }
            } else {
                if isEmpty {
                    TypeFacts::EmptyStringFacts
                } else {
                    TypeFacts::NonEmptyStringFacts
                }
            };
        }
        if flags.intersects(TypeFlags::Number | TypeFlags::Enum) {
            return if self.strictNullChecks {
                TypeFacts::NumberStrictFacts
            } else {
                TypeFacts::NumberFacts
            };
        }
        if let Type::NumberLiteralType(t) = &self.types[ty] {
            let isZero = t.value == 0f64;
            return if self.strictNullChecks {
                if isZero {
                    TypeFacts::ZeroNumberStrictFacts
                } else {
                    TypeFacts::NonZeroNumberStrictFacts
                }
            } else {
                if isZero {
                    TypeFacts::ZeroNumberFacts
                } else {
                    TypeFacts::NonZeroNumberFacts
                }
            };
        }
        if flags.intersects(TypeFlags::BigInt) {
            return if self.strictNullChecks {
                TypeFacts::BigIntStrictFacts
            } else {
                TypeFacts::BigIntFacts
            };
        }
        if flags.intersects(TypeFlags::BigIntLiteral) {
            let isZero = self.isZeroBigInt(ty);
            return if self.strictNullChecks {
                if isZero {
                    TypeFacts::ZeroBigIntStrictFacts
                } else {
                    TypeFacts::NonZeroBigIntStrictFacts
                }
            } else {
                if isZero {
                    TypeFacts::ZeroBigIntFacts
                } else {
                    TypeFacts::NonZeroBigIntFacts
                }
            };
        }
        if flags.intersects(TypeFlags::Boolean) {
            return if self.strictNullChecks {
                TypeFacts::BooleanStrictFacts
            } else {
                TypeFacts::BooleanFacts
            };
        }
        if flags.intersects(TypeFlags::BooleanLike) {
            return if self.strictNullChecks {
                if ty == self.falseType || ty == self.regularFalseType {
                    TypeFacts::FalseStrictFacts
                } else {
                    TypeFacts::TrueStrictFacts
                }
            } else {
                if ty == self.falseType || ty == self.regularFalseType {
                    TypeFacts::FalseFacts
                } else {
                    TypeFacts::TrueFacts
                }
            };
        }
        if flags.intersects(TypeFlags::Object) && !ignoreObjects {
            return if self.types[ty]
                .get_object_flags()
                .intersects(ObjectFlags::Anonymous)
                && self.isEmptyObjectType(ty)
            {
                if self.strictNullChecks {
                    TypeFacts::EmptyObjectStrictFacts
                } else {
                    TypeFacts::EmptyObjectFacts
                }
            } else if self.isFunctionObjectType(ty) {
                if self.strictNullChecks {
                    TypeFacts::FunctionStrictFacts
                } else {
                    TypeFacts::FunctionFacts
                }
            } else {
                if self.strictNullChecks {
                    TypeFacts::ObjectStrictFacts
                } else {
                    TypeFacts::ObjectFacts
                }
            };
        }
        if flags.intersects(TypeFlags::Void | TypeFlags::Undefined) {
            return TypeFacts::UndefinedFacts;
        }
        if flags.intersects(TypeFlags::Null) {
            return TypeFacts::NullFacts;
        }
        if flags.intersects(TypeFlags::ESSymbolLike) {
            return if self.strictNullChecks {
                TypeFacts::SymbolStrictFacts
            } else {
                TypeFacts::SymbolFacts
            };
        }
        if flags.intersects(TypeFlags::NonPrimitive) {
            return if self.strictNullChecks {
                TypeFacts::ObjectStrictFacts
            } else {
                TypeFacts::ObjectFacts
            };
        }
        if flags.intersects(TypeFlags::Never) {
            return TypeFacts::None;
        }
        if flags.intersects(TypeFlags::Instantiable) {
            todo!();
            // return if !isPatternLiteralType(ty) {
            //     let ty = self.getBaseConstraintOfType(ty).unwrap_or(self.unknownType);
            //     self.getTypeFacts(ty, ignoreObjects)
            // } else if self.strictNullChecks {
            //     TypeFacts::NonEmptyStringStrictFacts
            // } else {
            //     TypeFacts::NonEmptyStringFacts
            // };
        }
        if flags.intersects(TypeFlags::Union) {
            todo!();
            // return reduceLeft((ty as UnionType).types, (facts, t) => facts | getTypeFacts(t, ignoreObjects), TypeFacts::None);
        }
        if flags.intersects(TypeFlags::Intersection) {
            todo!();
            // When an intersection contains a primitive type we ignore object type constituents as they are
            // presumably type tags. For example, in string & { __kind__: "name" } we ignore the object type.
            // ignoreObjects ||= maybeTypeOfKind(ty, TypeFlags::Primitive);
            // return reduceLeft((ty as UnionType).types, (facts, t) => facts & getTypeFacts(t, ignoreObjects), TypeFacts::All);
        }
        TypeFacts::All
    }

    fn getTypeWithFacts(&mut self, ty: TypeId, include: TypeFacts) -> TypeId {
        self.filterType(ty, |checker, t| {
            checker.getTypeFacts(t, false).intersects(include)
        })
    }

    // TODO:
    // getTypeWithDefault
    // TODO:
    // getTypeOfDestructuredProperty
    // TODO:
    // getTypeOfDestructuredArrayElement

    fn includeUndefinedInIndexSignature(&mut self, ty: Option<TypeId>) -> Option<TypeId> {
        ty.map(|ty| {
            if self.compilerOptions.noUncheckedIndexedAccess {
                todo!();
                // self.getUnionType([ty, self.undefinedType])
            } else {
                ty
            }
        })
    }

    // TODO:
    // getTypeOfDestructuredSpreadExpression
    // TODO:
    // getAssignedTypeOfBinaryExpression
    // TODO:
    // getAssignedTypeOfArrayLiteralElement
    // TODO:
    // getAssignedTypeOfSpreadExpression
    // TODO:
    // getAssignedTypeOfPropertyAssignment
    // TODO:
    // getAssignedTypeOfShorthandPropertyAssignment
    // TODO:
    // getAssignedType
    // TODO:
    // getInitialTypeOfBindingElement
    // TODO:
    // getTypeOfInitializer
    // TODO:
    // getInitialTypeOfVariableDeclaration
    // TODO:
    // getInitialType
    // TODO:
    // isEmptyArrayAssignment
    // TODO:
    // getReferenceCandidate

    // TODO:
    // getTypeOfSwitchClause
    // TODO:
    // getSwitchClauseTypes
    // TODO:
    // getSwitchClauseTypeOfWitnesses
    // TODO:
    // getSwitchClauseTypeOfWitnesses
    // TODO:
    // getSwitchClauseTypeOfWitnesses
    // TODO:
    // eachTypeContainedIn

    fn isTypeSubsetOf(&mut self, source: TypeId, target: TypeId) -> bool {
        source == target
            || self.types[target].get_flags().intersects(TypeFlags::Union)
                && self.isTypeSubsetOfUnion(source, target)
    }

    // fn isTypeSubsetOfUnion(&mut self,source: TypeId, target: UnionType) -> bool{
    fn isTypeSubsetOfUnion(&mut self, source: TypeId, target: TypeId) -> bool {
        todo!();
        // if (source.flags & TypeFlags.Union) {
        //     for t in (source as UnionType).types {
        //         if (!self.containsType(target.types, t)) {
        //             return false;
        //         }
        //     }
        //     return true;
        // }
        // if (source.flags & TypeFlags.EnumLiteral && self.getBaseTypeOfEnumLiteralType(source as LiteralType) == target) {
        //     return true;
        // }
        // return containsType(target.types, source);
    }

    fn forEachType<F>(&mut self, ty: TypeId, mut f: F)
    where
        F: FnMut(&mut Checker, TypeId),
    {
        if self.types[ty].get_flags().intersects(TypeFlags::Union) {
            for &t in self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
                .iter()
            {
                f(self, ty);
            }
        } else {
            f(self, ty);
        }
    }

    fn someType<F>(&mut self, ty: TypeId, mut f: F) -> bool
    where
        F: FnMut(&mut Checker, TypeId) -> bool,
    {
        if self.types[ty].get_flags().intersects(TypeFlags::Union) {
            // TODO: bad clone:
            self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
                .iter()
                .any(|t| f(self, *t))
        } else {
            f(self, ty)
        }
    }

    fn everyType<F>(&mut self, ty: TypeId, mut f: F) -> bool
    where
        F: FnMut(&mut Checker, TypeId) -> bool,
    {
        if let Type::UnionType(t) = &self.types[ty] {
            t.union_or_intersection_type
                .types
                .clone()
                .iter()
                .all(|&t| f(self, t))
        } else {
            f(self, ty)
        }
    }

    // TODO:
    // everyContainedType

    fn filterType<F>(&mut self, ty: TypeId, mut f: F) -> TypeId
    where
        F: FnMut(&mut Checker, TypeId) -> bool,
    {
        if self.types[ty].get_flags().intersects(TypeFlags::Union) {
            todo!();
            // let types = (ty as UnionType).types;
            // let filtered = filter(types, f);
            // if (filtered === types) {
            //     return ty;
            // }
            // let origin = (ty as UnionType).origin;
            // let newOrigin: Type | undefined;
            // if (origin && origin.flags & TypeFlags::Union) {
            //     // If the origin type is a (denormalized) union type, filter its non-union constituents. If that ends
            //     // up removing a smaller number of types than in the normalized constituent set (meaning some of the
            //     // filtered types are within nested unions in the origin), then we can't construct a new origin type.
            //     // Otherwise, if we have exactly one type left in the origin set, return that as the filtered type.
            //     // Otherwise, construct a new filtered origin type.
            //     let originTypes = (origin as UnionType).types;
            //     let originFiltered = filter(originTypes, t => !!(t.flags & TypeFlags::Union) || f(t));
            //     if (originTypes.length - originFiltered.length === types.length - filtered.length) {
            //         if (originFiltered.length === 1) {
            //             return originFiltered[0];
            //         }
            //         newOrigin = createOriginUnionOrIntersectionType(TypeFlags::Union, originFiltered);
            //     }
            // }
            // return getUnionTypeFromSortedList(filtered, (ty as UnionType).objectFlags, /*aliasSymbol*/ undefined, /*aliasTypeArguments*/ undefined, newOrigin);
        }
        if self.types[ty].get_flags().intersects(TypeFlags::Never) || f(self, ty) {
            ty
        } else {
            self.neverType
        }
    }

    fn removeType(&mut self, ty: TypeId, targetType: TypeId) -> TypeId {
        self.filterType(ty, |_, t| t != targetType)
    }

    // TODO:
    // countTypes

    // Apply a mapping function to a type and return the resulting type. If the source type
    // is a union type, the mapping function is applied to each constituent type and a union
    // of the resulting types is returned.
    // function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined;
    fn mapType<F>(&mut self, ty: TypeId, mapper: &mut F, noReductions: bool) -> TypeId
    where
        F: FnMut(&mut Checker, TypeId) -> TypeId,
    {
        self.mapTypeOptional(
            ty,
            &mut |checker, ty| Some(mapper(checker, ty)),
            noReductions,
        )
        .unwrap()
    }

    // Apply a mapping function to a type and return the resulting type. If the source type
    // is a union type, the mapping function is applied to each constituent type and a union
    // of the resulting types is returned.
    // function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined;
    fn mapTypeOptional<F>(
        &mut self,
        ty: TypeId,
        mapper: &mut F,
        noReductions: bool,
    ) -> Option<TypeId>
    where
        F: FnMut(&mut Checker, TypeId) -> Option<TypeId>,
    {
        if self.types[ty].get_flags().intersects(TypeFlags::Never) {
            return Some(ty);
        }
        if !self.types[ty].get_flags().intersects(TypeFlags::Union) {
            return mapper(self, ty);
        }
        let origin = self.types[ty].unwrap_as_union_type_base().origin;
        let types = if origin.is_some()
            && self.types[origin.unwrap()]
                .get_flags()
                .intersects(TypeFlags::Union)
        {
            self.types[origin.unwrap()]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
        } else {
            self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
        };
        let mut mappedTypes = Vec::new();
        let mut changed = false;
        for &t in types.iter() {
            let mapped = if self.types[t].get_flags().intersects(TypeFlags::Union) {
                self.mapTypeOptional(t, mapper, noReductions)
            } else {
                mapper(self, t)
            };
            changed |= Some(t) != mapped;
            if let Some(mapped) = mapped {
                mappedTypes.push(mapped);
            }
        }
        if changed {
            if !mappedTypes.is_empty() {
                Some(self.getUnionType(
                    &mappedTypes,
                    Some(if noReductions {
                        UnionReduction::None
                    } else {
                        UnionReduction::Literal
                    }),
                    None,
                    None,
                    None,
                ))
            } else {
                None
            }
        } else {
            Some(ty)
        }
    }

    // TODO:
    // mapTypeWithAlias
    // TODO:
    // getConstituentCount
    // TODO:
    // extractTypesOfKind
    // TODO:
    // replacePrimitivesWithLiterals

    // TODO: move functions to flow.rs?

    // TODO:
    // createEvolvingArrayType
    // TODO:
    // getEvolvingArrayType
    // TODO:
    // addEvolvingArrayElementType
    // TODO:
    // createFinalArrayType
    // TODO:
    // getFinalArrayType

    fn finalizeEvolvingArrayType(&mut self, ty: TypeId) -> TypeId {
        if let Type::EvolvingArrayType(t) = &self.types[ty] {
            todo!()
        //    self.getFinalArrayType(t)
        } else {
            ty
        }
    }

    // TODO:
    // getElementTypeOfEvolvingArrayType

    fn isEvolvingArrayTypeList(&self, types: &Vec<TypeId>) -> bool {
        let mut hasEvolvingArrayType = false;
        for &t in types {
            if !self.types[t].get_flags().intersects(TypeFlags::Never) {
                if !self.types[t]
                    .get_object_flags()
                    .intersects(ObjectFlags::EvolvingArray)
                {
                    return false;
                }
                hasEvolvingArrayType = true;
            }
        }
        hasEvolvingArrayType
    }

    // Return true if the given node is 'x' in an 'x.length', x.push(value)', 'x.unshift(value)' or
    // 'x[n] = value' operation, where 'n' is an expression of type any, undefined, or a number-like type.
    fn isEvolvingArrayOperationTarget(&mut self, node: BoundNode) -> bool {
        let root = getReferenceRoot(node);
        let parent = root.parent();
        let mut isLengthPushOrUnshift = false;
        if let Some(parent @ BoundNode::MemberExpr(m)) = &parent {
            if !m.computed {
                if let ast::Expr::Ident(prop) = &m.prop {
                    isLengthPushOrUnshift = prop.sym == js_word!("length")
                        || matches!(parent.parent(), Some(BoundNode::CallExpr(_)))
                            && isPushOrUnshiftIdentifier(&prop.sym);
                }
            }
        }
        let mut isElementAssignment = false;
        if let Some(parent @ BoundNode::MemberExpr(m)) = &parent {
            if m.computed {
                if m.obj.bind(parent.clone()) == root {
                    if let Some(grand_parent @ BoundNode::AssignExpr(a)) = &parent.parent() {
                        todo!();
                        // if a.left.bind(grand_parent) == parent {
                        //     if !isAssignmentTarget(grand_parent)
                        //         && isTypeAssignableToKind(
                        //             getTypeOfExpression(m.prop),
                        //             TypeFlags::NumberLike,
                        //         )
                        //     {
                        //         isElementAssignment = true;
                        //     }
                        // }
                    }
                }
            }
        }
        isLengthPushOrUnshift || isElementAssignment
    }

    fn getExplicitTypeOfSymbol(
        &mut self,
        symbol: SymbolId, /*, diagnostic?: Diagnostic*/
    ) -> Option<TypeId> {
        if self.symbols[symbol].flags().intersects(
            SymbolFlags::Function
                | SymbolFlags::Method
                | SymbolFlags::Class
                | SymbolFlags::ValueModule,
        ) {
            return Some(self.getTypeOfSymbol(symbol));
        }
        if self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::Variable | SymbolFlags::Property)
        {
            if getCheckFlags(&self.symbols[symbol]).intersects(CheckFlags::Mapped) {
                todo!();
                // let origin = (symbol as MappedSymbol).syntheticOrigin;
                // if (origin && getExplicitTypeOfSymbol(origin)) {
                //     return getTypeOfSymbol(symbol);
                // }
            }
            if let Some(declaration) = self.symbols[symbol].valueDeclaration() {
                if isDeclarationWithExplicitTypeAnnotation(&declaration.clone().into()) {
                    return Some(self.getTypeOfSymbol(symbol));
                }
                if matches!(
                    declaration,
                    BoundNode::VarDeclarator(_) | BoundNode::VarDecl(_)
                ) {
                    todo!("see below");
                }
                // if isVariableDeclaration(declaration) && declaration.parent.parent.kind === SyntaxKind.ForOfStatement {
                //     todo!();
                //     // const statement = declaration.parent.parent;
                //     // const expressionType = getTypeOfDottedName(statement.expression, /*diagnostic*/ undefined);
                //     // if (expressionType) {
                //     //     const use = statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf;
                //     //     return checkIteratedTypeOrElementType(use, expressionType, undefinedType, /*errorNode*/ undefined);
                //     // }
                // }
                // TODO: diagnostic
                // if (diagnostic) {
                //     addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol)));
                // }
            }
        }
        None
    }

    // We require the dotted function name in an assertion expression to be comprised of identifiers
    // that reference function, method, class or value module symbols; or variable, property or
    // parameter symbols with declarations that have explicit type annotations. Such references are
    // resolvable with no possibility of triggering circularities in control flow analysis.
    fn getTypeOfDottedName(
        &mut self,
        node: &BoundNode, /*, diagnostic: Diagnostic | undefined*/
    ) -> Option<TypeId> {
        // TODO: with stmts
        // if (!(node.flags & NodeFlags.InWithStatement)) {
        match node {
            BoundNode::Ident(i) => {
                let symbol = self.getResolvedSymbol(i);
                let symbol = self.getExportSymbolOfValueSymbolIfExported(symbol);
                let symbol = if self.symbols[symbol].flags().intersects(SymbolFlags::Alias) {
                    self.resolveAlias(symbol)
                } else {
                    symbol
                };
                return self.getExplicitTypeOfSymbol(symbol /*, diagnostic*/);
            }
            BoundNode::ThisExpr(_) => {
                return self.getExplicitThisType(node);
            }
            BoundNode::Super(n) => {
                return Some(self.checkSuperExpression(n));
            }
            BoundNode::MemberExpr(m) if !m.computed => {
                let ty = self.getTypeOfDottedName(&m.obj.bind(node.clone()) /*, diagnostic*/);
                if let Some(ty) = ty {
                    let mut prop = if matches!(m.prop, ast::Expr::PrivateName(_)) {
                        todo!();
                        // if (!ty.symbol) {
                        //     return undefined;
                        // }
                        // getPropertyOfType(ty, getSymbolNameForPrivateIdentifier(ty.symbol, name.escapedText))
                    } else if let ast::Expr::Ident(i) = &m.prop {
                        self.getPropertyOfType(ty, &i.sym, false)
                    } else {
                        unreachable!();
                    };
                    return prop
                        .and_then(|p| self.getExplicitTypeOfSymbol(p /*, diagnostic*/));
                }
                return None;
            }
            BoundNode::ParenExpr(_) => {
                todo!();
                // return getTypeOfDottedName((node as ParenthesizedExpression).expression, diagnostic);
            }
            _ => {}
        }
        None
        // }
    }

    fn getEffectsSignature(&mut self, node: &Rc<CallExpr>) -> Option<SignatureId> {
        let bound_node = BoundNode::CallExpr(node.clone());
        let signature = match self.getNodeLinks(bound_node.clone()).effectsSignature {
            Some(effectsSignature) => effectsSignature,
            None => {
                // A call expression parented by an expression statement is a potential assertion. Other call
                // expressions are potential type predicate function calls. In order to avoid triggering
                // circularities in control flow analysis, we use getTypeOfDottedName when resolving the call
                // target expression of an assertion.
                let funcType = if matches!(&node.parent, Some(BoundNode::ExprStmt(_))) {
                    // self.getTypeOfDottedName(node.expression, /*diagnostic*/ undefined)
                    self.getTypeOfDottedName(&node.callee.bind(bound_node.clone()))
                } else if matches!(node.callee, ast::ExprOrSuper::Expr(_)) {
                    todo!();
                    // if (isOptionalChain(node)) {
                    //     self.checkNonNullType(
                    //         self.getOptionalExpressionType(self.checkExpression(node.expression), node.expression),
                    //         node.expression
                    //     )
                    // }
                    // else {
                    //     self.checkNonNullExpression(node.expression)
                    // }
                } else {
                    None
                };
                let funcType = funcType
                    .map(|t| self.getApparentType(t))
                    .unwrap_or(self.unknownType);
                let signatures = self.getSignaturesOfType(funcType, SignatureKind::Call);
                let candidate = if signatures.len() == 1
                    && self.signatures[signatures[0]].typeParameters.is_none()
                {
                    Some(signatures[0])
                } else if signatures
                    .iter()
                    .any(|&s| self.hasTypePredicateOrNeverReturnType(s))
                {
                    Some(self.getResolvedSignature(bound_node.clone(), None, None))
                } else {
                    None
                };
                let signature = if candidate.is_some()
                    && self.hasTypePredicateOrNeverReturnType(candidate.unwrap())
                {
                    candidate.unwrap()
                } else {
                    self.unknownSignature
                };
                self.getNodeLinks_mut(bound_node).effectsSignature = Some(signature);
                signature
            }
        };
        if signature == self.unknownSignature {
            None
        } else {
            Some(signature)
        }
    }

    fn hasTypePredicateOrNeverReturnType(&mut self, signature: SignatureId) -> bool {
        if self.getTypePredicateOfSignature(signature).is_some() {
            true
        } else if let Some(decl) = &self.signatures[signature].declaration {
            let return_ty = self
                .getReturnTypeFromAnnotation(&decl.clone())
                .unwrap_or(self.unknownType);
            self.types[return_ty]
                .get_flags()
                .intersects(TypeFlags::Never)
        } else {
            false
        }
    }

    // TODO:
    // getTypePredicateArgument
    // TODO:
    // reportFlowControlError

    fn isReachableFlowNode(&mut self, flow: FlowNodeId) -> bool {
        let result = self.isReachableFlowNodeWorker(flow, false);
        self.lastFlowNode = Some(flow);
        self.lastFlowNodeReachable = result;
        result
    }

    // TODO:
    // isFalseExpression

    fn isReachableFlowNodeWorker(&mut self, mut flow: FlowNodeId, noCacheCheck: bool) -> bool {
        loop {
            if Some(flow) == self.lastFlowNode {
                return self.lastFlowNodeReachable;
            }
            let flags = self.flow_nodes[flow].flags;
            if flags.intersects(FlowFlags::Shared) {
                todo!();
                // if (!noCacheCheck) {
                //     const id = getFlowNodeId(flow);
                //     const reachable = flowNodeReachable[id];
                //     return reachable !== undefined ? reachable : (flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck*/ true));
                // }
                // noCacheCheck = false;
            }
            match &self.flow_nodes[flow].kind {
                FlowNodeKind::FlowAssignment(f) => {
                    flow = f.antecedent;
                }
                FlowNodeKind::FlowCondition(f) => {
                    flow = f.antecedent;
                }
                FlowNodeKind::FlowArrayMutation(f) => {
                    flow = f.antecedent;
                }
                FlowNodeKind::FlowCall(f) => {
                    let signature = self.getEffectsSignature(&f.node.clone());
                    if let Some(signature) = signature {
                        let predicate = self.getTypePredicateOfSignature(signature);
                        if let Some(TypePredicate::AssertsIdentifierTypePredicate {
                            parameterIndex,
                            ty,
                            ..
                        }) = predicate
                        {
                            todo!();
                            //     if !ty {
                            //     let predicateArgument = f.node.args.get(parameterIndex);
                            //     if matches!(predicateArgument, Some(ast::ExprOrSuper::Expr(a)) if self.isFalseExpression(a)) {
                            //         return false;
                            //     }
                            // }
                        }
                        let return_ty = self.getReturnTypeOfSignature(signature);
                        if self.types[return_ty]
                            .get_flags()
                            .intersects(TypeFlags::Never)
                        {
                            return false;
                        }
                    }
                    flow = unwrap_as!(&self.flow_nodes[flow].kind, FlowNodeKind::FlowCall(f), f)
                        .antecedent;
                }
                FlowNodeKind::FlowLabel(_) => {
                    if flags.intersects(FlowFlags::BranchLabel) {
                        todo!();
                        // A branching point is reachable if any branch is reachable.
                        // return some((flow as FlowLabel).antecedents, f => isReachableFlowNodeWorker(f, /*noCacheCheck*/ false));
                    } else if flags.intersects(FlowFlags::LoopLabel) {
                        todo!();
                        // const antecedents = (flow as FlowLabel).antecedents;
                        // if (antecedents === undefined || antecedents.length === 0) {
                        //     return false;
                        // }
                        // // A loop is reachable if the control flow path that leads to the top is reachable.
                        // flow = antecedents[0];
                    } else {
                        unreachable!();
                    }
                }
                FlowNodeKind::FlowSwitchClause(_) => {
                    todo!();
                    // The control flow path representing an unmatched value in a switch statement with
                    // no default clause is unreachable if the switch statement is exhaustive.
                    // if ((flow as FlowSwitchClause).clauseStart === (flow as FlowSwitchClause).clauseEnd && isExhaustiveSwitchStatement((flow as FlowSwitchClause).switchStatement)) {
                    //     return false;
                    // }
                    // flow = (flow as FlowSwitchClause).antecedent;
                }
                FlowNodeKind::FlowReduceLabel(_) => {
                    todo!();
                    // Cache is unreliable once we start adjusting labels
                    // lastFlowNode = undefined;
                    // const target = (flow as FlowReduceLabel).target;
                    // const saveAntecedents = target.antecedents;
                    // target.antecedents = (flow as FlowReduceLabel).antecedents;
                    // const result = isReachableFlowNodeWorker((flow as FlowReduceLabel).antecedent, /*noCacheCheck*/ false);
                    // target.antecedents = saveAntecedents;
                    // return result;
                }
                _ => {
                    return !flags.intersects(FlowFlags::Unreachable);
                }
            }
        }
    }

    // Return true if the given flow node is preceded by a 'super(...)' call in every possible code path
    // leading to the node.
    fn isPostSuperFlowNode(&mut self, mut flow: FlowNodeId, mut noCacheCheck: bool) -> bool {
        loop {
            let flags = self.flow_nodes[flow].flags;
            if flags.intersects(FlowFlags::Shared) {
                if !noCacheCheck {
                    return if let Some(postSuper) = self.flowNodePostSuper.get(&flow) {
                        *postSuper
                    } else {
                        let postSuper = self.isPostSuperFlowNode(flow, true);
                        self.flowNodePostSuper.insert(flow, postSuper);
                        postSuper
                    };
                }
                noCacheCheck = false;
            }
            match &self.flow_nodes[flow].kind {
                FlowNodeKind::FlowAssignment(FlowAssignment { antecedent, .. })
                | FlowNodeKind::FlowCondition(FlowCondition { antecedent, .. })
                | FlowNodeKind::FlowArrayMutation(FlowArrayMutation { antecedent, .. })
                | FlowNodeKind::FlowSwitchClause(FlowSwitchClause { antecedent, .. }) => {
                    flow = *antecedent;
                }
                FlowNodeKind::FlowCall(f) => {
                    if matches!(f.node.callee, ast::ExprOrSuper::Super(_)) {
                        return true;
                    }
                    flow = f.antecedent;
                }
                FlowNodeKind::FlowLabel(f) => {
                    if flags.intersects(FlowFlags::BranchLabel) {
                        // A branching point is post-super if every branch is post-super.
                        return f
                            .antecedents
                            .clone()
                            .iter()
                            .all(|&f| self.isPostSuperFlowNode(f, false));
                    } else if flags.intersects(FlowFlags::LoopLabel) {
                        // A loop is post-super if the control flow path that leads to the top is post-super.
                        flow = *f.antecedents.first().unwrap();
                    } else {
                        unreachable!();
                    }
                }
                FlowNodeKind::FlowReduceLabel(f) => {
                    let reduce_label_antecedent = f.antecedent;
                    let target = f.target;
                    let saveAntecedents = self.flow_nodes[target]
                        .kind
                        .unwrap_flow_label()
                        .antecedents
                        .clone();
                    self.flow_nodes[target]
                        .kind
                        .unwrap_flow_label_mut()
                        .antecedents = f.antecedents.clone();
                    let result = self.isPostSuperFlowNode(reduce_label_antecedent, false);
                    self.flow_nodes[target]
                        .kind
                        .unwrap_flow_label_mut()
                        .antecedents = saveAntecedents;
                    return result;
                }
                _ => {
                    // Unreachable nodes are considered post-super to silence errors
                    return flags.intersects(FlowFlags::Unreachable);
                }
            }
        }
    }

    fn isConstantReference(&mut self, node: &BoundNode) -> bool {
        match node {
            BoundNode::Ident(i) => {
                let symbol = self.getResolvedSymbol(i);
                self.isConstVariable(symbol)
                    || isParameterOrCatchClauseVariable(&self.symbols[symbol])
                        && !self.isSymbolAssigned(symbol)
            }
            BoundNode::MemberExpr(_) => {
                todo!();
                // The resolvedSymbol property is initialized by checkPropertyAccess or checkElementAccess before we get here.
                // isConstantReference((node as AccessExpression).expression) && isReadonlySymbol(getNodeLinks(node).resolvedSymbol || unknownSymbol)
            }
            _ => false,
        }
    }

    // TODO:
    // getTypeOfSymbolAtLocation

    // Check if a parameter or catch variable is assigned anywhere
    fn isSymbolAssigned(&mut self, symbol: SymbolId) -> bool {
        if let Some(valueDeclaration) = self.symbols[symbol].valueDeclaration() {
            let parent = getRootDeclaration(valueDeclaration.clone())
                .parent()
                .unwrap();
            let links = self.getNodeLinks_mut(parent);
            if !links.flags.intersects(NodeCheckFlags::AssignmentsMarked) {
                links.flags |= NodeCheckFlags::AssignmentsMarked;
                todo!();
                // if !self.hasParentWithAssignmentsMarked(parent) {
                //     self.markNodeAssignments(parent);
                // }
            }
            self.symbols[symbol].isAssigned()
        } else {
            false
        }
    }

    // TODO:
    // hasParentWithAssignmentsMarked
    // TODO:
    // markNodeAssignments

    fn isConstVariable(&self, symbol: SymbolId) -> bool {
        self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::Variable)
            && self
                .getDeclarationNodeFlagsFromSymbol(symbol)
                .intersects(NodeFlags::Const)
    }

    /** remove undefined from the annotated type of a parameter when there is an initializer (that doesn't include undefined) */
    fn removeOptionalityFromDeclaredType(
        &mut self,
        declaredType: TypeId,
        declaration: BoundNode,
    ) -> TypeId {
        let target = TypeSystemEntity::Symbol(self.node_data(declaration.clone()).symbol.unwrap());
        if self.pushTypeResolution(target, TypeSystemPropertyName::DeclaredType) {
            let mut annotationIncludesUndefined = false;
            if self.strictNullChecks {
                let pat = match &declaration {
                    BoundNode::Param(p) => Some(p.pat.bind(declaration.clone())),
                    BoundNode::ParamWithoutDecorators(p) => Some(p.pat.bind(declaration.clone())),
                    BoundNode::TsParamProp(p) => Some(p.param.bind(declaration.clone())),
                    _ => None,
                };
                if let Some(BoundNode::AssignPat(assign)) = pat {
                    if self
                        .getFalsyFlags(declaredType)
                        .intersects(TypeFlags::Undefined)
                    {
                        let ty = self.checkExpression(
                            assign.right.bind(assign.clone().into()),
                            None,
                            false,
                        );
                        annotationIncludesUndefined =
                            !self.getFalsyFlags(ty).intersects(TypeFlags::Undefined);
                    }
                }
            }
            self.popTypeResolution();

            if annotationIncludesUndefined {
                self.getTypeWithFacts(declaredType, TypeFacts::NEUndefined)
            } else {
                declaredType
            }
        } else {
            todo!();
            // reportCircularityError(declaration.symbol);
            // return declaredType;
        }
    }

    fn isConstraintPosition(&mut self, ty: TypeId, node: &BoundNode) -> bool {
        // In an element access obj[x], we consider obj to be in a constraint position, except when obj is of
        // a generic type without a nullable constraint and x is a generic type. This is because when both obj
        // and x are of generic types T and K, we want the resulting type to be T[K].
        match &node.parent() {
            // PropertyAccessExpression
            Some(BoundNode::MemberExpr(m)) if !m.computed => true,
            Some(parent @ BoundNode::CallExpr(c)) => &c.callee.bind(parent.clone()) == node,
            // ElementAccessExpression
            Some(parent @ BoundNode::MemberExpr(m)) => {
                todo!();
                // &m.obj.bind(parent.clone()) == node
                //     && !(self.isGenericTypeWithoutNullableConstraint(ty)
                //         && self.isGenericIndexType(self.getTypeOfExpression(m.prop)))
            }
            _ => false,
        }
    }

    fn isGenericTypeWithUnionConstraint(&mut self, ty: TypeId) -> bool {
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Instantiable)
        {
            let base = self.getBaseConstraintOrType(ty);
            self.types[base]
                .get_flags()
                .intersects(TypeFlags::Nullable | TypeFlags::Union)
        } else {
            false
        }
    }

    // TODO:
    // isGenericTypeWithoutNullableConstraint

    fn hasNonBindingPatternContextualTypeWithNoGenericTypes(&mut self, node: BoundNode) -> bool {
        // Computing the contextual type for a child of a JSX element involves resolving the type of the
        // element's tag name, so we exclude that here to avoid circularities.
        let contextualType = if matches!(node, BoundNode::Ident(_) | BoundNode::MemberExpr(_))
        /*TODO: JSX: !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName == node) &&*/
        {
            self.getContextualType(node, Some(ContextFlags::SkipBindingPatterns))
        } else {
            None
        };
        contextualType
            .map(|t| !self.isGenericType(t))
            .unwrap_or_default()
    }

    fn getNarrowableTypeForReference(
        &mut self,
        ty: TypeId,
        reference: BoundNode,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        // When the type of a reference is or contains an instantiable type with a union type constraint, and
        // when the reference is in a constraint position (where it is known we'll obtain the apparent type) or
        // has a contextual type containing no top-level instantiables (meaning constraints will determine
        // assignability), we substitute constraints for all instantiables in the type of the reference to give
        // control flow analysis an opportunity to narrow it further. For example, for a reference of a type
        // parameter type 'T extends string | undefined' with a contextual type 'string', we substitute
        // 'string | undefined' to give control flow analysis the opportunity to narrow to type 'string'.
        let substituteConstraints = !(checkMode.is_some()
            && checkMode.unwrap().intersects(CheckMode::Inferential))
            && self.someType(ty, |checker, t| checker.isGenericTypeWithUnionConstraint(t))
            && (self.isConstraintPosition(ty, &reference)
                || self.hasNonBindingPatternContextualTypeWithNoGenericTypes(reference));
        if substituteConstraints {
            todo!();
            // mapType(ty, t => t.flags & TypeFlags::Instantiable ? getBaseConstraintOrType(t) : t)
        } else {
            ty
        }
    }

    // TODO:
    // isExportOrExportExpression

    fn markAliasReferenced(&mut self, symbol: SymbolId, location: BoundNode) {
        if self.isNonLocalAlias(Some(symbol), Some(SymbolFlags::Value))
            && !isInTypeQuery(location)
            && self.getTypeOnlyAliasDeclaration(symbol).is_none()
        {
            // let target = resolveAlias(symbol);
            // if (target.flags & SymbolFlags.Value) {
            //     // An alias resolving to a const enum cannot be elided if (1) 'isolatedModules' is enabled
            //     // (because the const enum value will not be inlined), or if (2) the alias is an export
            //     // of a const enum declaration that will be preserved.
            //     if (compilerOptions.isolatedModules ||
            //         shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) ||
            //         !isConstEnumOrConstEnumOnlyModule(target)
            //     ) {
            //         markAliasSymbolAsReferenced(symbol);
            //     }
            //     else {
            //         markConstEnumAliasAsReferenced(symbol);
            //     }
            // }
        }
    }

    fn checkIdentifier(&mut self, ident: &Rc<Ident>, checkMode: Option<CheckMode>) -> TypeId {
        let symbol = self.getResolvedSymbol(ident);
        if symbol == self.unknownSymbol {
            return self.errorType;
        }

        let node = BoundNode::Ident(ident.clone());

        // As noted in ECMAScript 6 language spec, arrow functions never have an arguments objects.
        // Although in down-level emit of arrow function, we emit it using function expression which means that
        // arguments objects will be bound to the inner object; emitting arrow function natively in ES6, arguments objects
        // will be bound to non-arrow function that contain this arrow function. This results in inconsistent behavior.
        // To avoid that we will give an error to users if they use arguments objects in arrow function so that they
        // can explicitly bound arguments objects
        if symbol == self.argumentsSymbol {
            if isInPropertyInitializerOrClassStaticBlock(Some(node.clone())) {
                todo!();
                // error(node, Diagnostics.arguments_cannot_be_referenced_in_property_initializers);
                // return errorType;
            }

            let container = getContainingFunction(&node).unwrap();
            if self.languageVersion < ScriptTarget::ES2015 {
                todo!();
                // if matches!(container,BoundNode::ArrowExpr(_)) {
                //     todo!();
                //     // error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression);
                // }
                // else if hasSyntacticModifier(container, ModifierFlags::Async) {
                //     todo!();
                //     // error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method);
                // }
            }

            self.getNodeLinks_mut(container).flags |= NodeCheckFlags::CaptureArguments;
            return self.getTypeOfSymbol(symbol);
        }

        // We should only mark aliases as referenced if there isn't a local value declaration
        // for the symbol. Also, don't mark any property access expression LHS - checkPropertyAccessExpression will handle that
        if !matches!(&node.parent(), Some(p@BoundNode::MemberExpr(m)) if !m.computed && m.obj.bind(p.clone()) == node)
        {
            self.markAliasReferenced(symbol, node.clone());
        }

        let localOrExportSymbol = self.getExportSymbolOfValueSymbolIfExported(symbol);
        let sourceSymbol = if self.symbols[localOrExportSymbol]
            .flags()
            .intersects(SymbolFlags::Alias)
        {
            self.resolveAlias(localOrExportSymbol)
        } else {
            localOrExportSymbol
        };
        // TODO:
        // if sourceSymbol.declarations
        //     && getDeclarationNodeFlagsFromSymbol(sourceSymbol) & NodeFlags.Deprecated
        //     && isUncalledFunctionReference(node, sourceSymbol)
        // {
        //     todo!();
        //     // addDeprecatedSuggestion(node, sourceSymbol.declarations, node.escapedText as string);
        // }

        let mut declaration = self.symbols[localOrExportSymbol].valueDeclaration().clone();
        if let Some(decl) = &declaration {
            if self.symbols[localOrExportSymbol]
                .flags()
                .intersects(SymbolFlags::Class)
            {
                // TODO:
                // Due to the emit for class decorators, any reference to the class from inside of the class body
                // must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
                // behavior of class names in ES6.
                // if (declaration.kind == SyntaxKind.ClassDeclaration
                //     && nodeIsDecorated(declaration as ClassDeclaration))
                // {
                //     let container = getContainingClass(node);
                //     while let Some(container) = container {
                //         if container == declaration && container.name != node {
                //             self.getNodeLinks_mut(declaration).flags |=
                //                 NodeCheckFlags.ClassWithConstructorReference;
                //             self.getNodeLinks_mut(node).flags |=
                //                 NodeCheckFlags.ConstructorReferenceInClass;
                //             break;
                //         }

                //         container = getContainingClass(container);
                //     }
                // } else if declaration.kind == SyntaxKind.ClassExpression {
                //     // When we emit a class expression with static members that contain a reference
                //     // to the constructor in the initializer, we will need to substitute that
                //     // binding with an alias as the class name is not in scope.
                //     let container = getThisContainer(node, /*includeArrowFunctions*/ false);
                //     while container.kind != SyntaxKind.SourceFile {
                //         if container.parent == declaration {
                //             if isPropertyDeclaration(container) && isStatic(&container)
                //                 || isClassStaticBlockDeclaration(container)
                //             {
                //                 self.getNodeLinks_mut(declaration).flags |=
                //                     NodeCheckFlags.ClassWithConstructorReference;
                //                 self.getNodeLinks_mut(node).flags |=
                //                     NodeCheckFlags.ConstructorReferenceInClass;
                //             }
                //             break;
                //         }

                //         container =
                //             getThisContainer(container, /*includeArrowFunctions*/ false);
                //     }
                // }
            }
        }

        // TODO:
        // checkNestedBlockScopedBinding(node, symbol);

        let mut ty = self.getTypeOfSymbol(localOrExportSymbol);
        let assignmentKind = getAssignmentTargetKind(node.clone());

        if assignmentKind != AssignmentKind::None {
            if !(self.symbols[localOrExportSymbol]
                .flags()
                .intersects(SymbolFlags::Variable))
                && !(isBoundNodeInJSFile(&node)
                    && self.symbols[localOrExportSymbol]
                        .flags()
                        .intersects(SymbolFlags::ValueModule))
            {
                todo!();
                // const assignmentError = localOrExportSymbol.flags & SymbolFlags::Enum ? Diagnostics.Cannot_assign_to_0_because_it_is_an_enum
                //     : localOrExportSymbol.flags & SymbolFlags::Class ? Diagnostics.Cannot_assign_to_0_because_it_is_a_class
                //     : localOrExportSymbol.flags & SymbolFlags::Module ? Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace
                //     : localOrExportSymbol.flags & SymbolFlags::Function ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function
                //     : localOrExportSymbol.flags & SymbolFlags::Alias ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import
                //     : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable;

                // error(node, assignmentError, symbolToString(symbol));
                // return errorType;
            }
            todo!();
            // if isReadonlySymbol(localOrExportSymbol) {
            //     todo!();
            //     // if (localOrExportSymbol.flags & SymbolFlags::Variable) {
            //     //     error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol));
            //     // }
            //     // else {
            //     //     error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol));
            //     // }
            //     // return errorType;
            // }
        }

        let isAlias = self.symbols[localOrExportSymbol]
            .flags()
            .intersects(SymbolFlags::Alias);

        // We only narrow variables and parameters occurring in a non-assignment position. For all other
        // entities we simply return the declared type.
        if self.symbols[localOrExportSymbol]
            .flags()
            .intersects(SymbolFlags::Variable)
        {
            if assignmentKind == AssignmentKind::Definite {
                return ty;
            }
        } else if isAlias {
            declaration = self.getDeclarationOfAliasSymbol(symbol);
        } else {
            return ty;
        }

        if let Some(decl) = declaration {
            ty = self.getNarrowableTypeForReference(ty, node.clone(), checkMode);

            // The declaration container is the innermost function that encloses the declaration of the variable
            // or parameter. The flow container is the innermost function starting with which we analyze the control
            // flow graph to determine the control flow based type.
            let isParameter = isParameterDeclaration(decl.clone());
            let declarationContainer = getControlFlowContainer(&decl);
            let mut flowContainer = getControlFlowContainer(&node);
            let isOuterVariable = flowContainer != declarationContainer;
            let isSpreadDestructuringAssignmentTarget = matches!(node.parent(), Some(parent@BoundNode::RestPat(_)) if isDestructuringAssignmentTarget(&parent.parent().unwrap()));
            let isModuleExports = self.symbols[symbol]
                .flags()
                .intersects(SymbolFlags::ModuleExports);
            // When the control flow originates in a function expression or arrow function and we are referencing
            // a const variable or parameter from an outer function, we extend the origin of the control flow
            // analysis to include the immediately enclosing function.
            while flowContainer != declarationContainer
                && (matches!(
                    flowContainer,
                    BoundNode::FnExpr(_) | BoundNode::ArrowExpr(_)
                ) || isObjectLiteralOrClassExpressionMethodOrAccessor(&flowContainer))
                && (self.isConstVariable(localOrExportSymbol) && ty != self.autoArrayType()
                    || isParameter && !self.isSymbolAssigned(localOrExportSymbol))
            {
                flowContainer = getControlFlowContainer(&flowContainer);
            }
            // We only look for uninitialized variables in strict null checking mode, and only when we can analyze
            // the entire control flow graph from the variable's declaration (i.e. when the flow container and
            // declaration container are the same).
            let assumeInitialized = isParameter
                || isAlias
                || isOuterVariable
                || isSpreadDestructuringAssignmentTarget
                || isModuleExports
                || isBindingElement(&decl)
                || ty != self.autoType
                    && ty != self.autoArrayType()
                    && (!self.strictNullChecks
                        || self.types[ty]
                            .get_flags()
                            .intersects(TypeFlags::AnyOrUnknown | TypeFlags::Void)
                        || isInTypeQuery(node.clone())
                        || {
                            todo!() /*node.parent.kind == SyntaxKind.ExportSpecifier*/
                        })
                || matches!(node.parent(), Some(BoundNode::TsNonNullExpr(_)))
                || matches!(&decl, BoundNode::VarDeclarator(d) if d.definite)
                || is_ambient_declaration(&decl);
            let initialType = if assumeInitialized {
                if isParameter {
                    self.removeOptionalityFromDeclaredType(ty, decl)
                } else {
                    ty
                }
            } else if ty == self.autoType || ty == self.autoArrayType() {
                self.undefinedType
            } else {
                self.getOptionalType(ty, false)
            };
            let flowType = self.getFlowTypeOfReference(&node, ty, initialType, Some(flowContainer));
            // A variable is considered uninitialized when it is possible to analyze the entire control flow graph
            // from declaration to use, and when the variable's declared type doesn't include undefined but the
            // control flow based type does include undefined.
            if !self.isEvolvingArrayOperationTarget(node)
                && (ty == self.autoType || ty == self.autoArrayType())
            {
                todo!();
                // if flowType == self.autoType || flowType == self.autoArrayType() {
                //     if self.noImplicitAny {
                //         todo!();
                //         // error(getNameOfDeclaration(declaration), Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType));
                //         // error(node, Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
                //     }
                //     return self.convertAutoToAny(flowType);
                // }
            } else if !assumeInitialized
                && !self.getFalsyFlags(ty).intersects(TypeFlags::Undefined)
                && self
                    .getFalsyFlags(flowType)
                    .intersects(TypeFlags::Undefined)
            {
                todo!();
                // error(node, Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol));
                // // Return the declared type to reduce follow-on errors
                // return ty;
            }
            if assignmentKind != AssignmentKind::None {
                self.getBaseTypeOfLiteralType(flowType)
            } else {
                flowType
            }
        } else {
            ty
        }
    }

    // TODO:
    // isInsideFunctionOrInstancePropertyInitializer
    // TODO:
    // getPartOfForStatementContainingNode
    // TODO:
    // getEnclosingIterationStatement
    // TODO:
    // checkNestedBlockScopedBinding
    // TODO:
    // isBindingCapturedByNode
    // TODO:
    // isAssignedInBodyOfForStatement
    // TODO:
    // captureLexicalThis
    // TODO:
    // findFirstSuperCall

    /**
     * Check if the given class-declaration extends null then return true.
     * Otherwise, return false
     * @param classDecl a class declaration to check if it extends null
     */
    fn classDeclarationExtendsNull(&mut self, classDecl: &Rc<Class>) -> bool {
        let classSymbol = self.getSymbolOfNode(classDecl.parent.clone().unwrap());
        let classInstanceType = self.getDeclaredTypeOfSymbol(classSymbol.unwrap());
        let baseConstructorType = self.getBaseConstructorTypeOfClass(classInstanceType);

        baseConstructorType == self.nullWideningType
    }

    fn checkThisBeforeSuper(
        &mut self,
        node: &BoundNode,
        container: &BoundNode, /*, diagnosticMessage: DiagnosticMessage*/
    ) {
        let containingClassDecl = unwrap_as!(container.parent(), Some(BoundNode::Class(c)), c);
        let baseTypeNode = containingClassDecl.extends.as_ref();

        // If a containing class does not have extends clause or the class extends null
        // skip checking whether super statement is called before "this" accessing.
        if baseTypeNode.is_some() && !self.classDeclarationExtendsNull(&containingClassDecl) {
            if let Some(flowNode) = self.node_data(node.clone()).flowNode {
                if !self.isPostSuperFlowNode(flowNode, false) {
                    todo!();
                    // error(node, diagnosticMessage);
                }
            }
        }
    }

    fn checkThisInStaticClassFieldInitializerInDecoratedClass(
        &mut self,
        thisExpression: BoundNode,
        container: BoundNode,
    ) {
        let (is_static, initializer) = match &container {
            BoundNode::ClassProp(p) => (p.is_static, &p.value),
            BoundNode::PrivateProp(p) => (p.is_static, &p.value),
            _ => return,
        };
        let parent_class_decorators_has_decorators = match container.parent() {
            Some(BoundNode::Class(c)) => !c.decorators.is_empty(),
            _ => unreachable!(),
        };
        // TODO:
        // if let Some(initializer) = initializer {
        //     if is_static
        //         && textRangeContainsPositionInclusive(container.initializer, thisExpression.pos)
        //         && !parent_class_decorators.is_empty()
        //     {
        //         todo!();
        //         // error(
        //         //     thisExpression,
        //         //     Diagnostics
        //         //         .Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class,
        //         // );
        //     }
        // }
        if let Some(initializer) = initializer {
            if is_static && parent_class_decorators_has_decorators {
                todo!();
                // error(
                //     thisExpression,
                //     Diagnostics
                //         .Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class,
                // );
            }
        }
    }

    fn checkThisExpression(&mut self, node: BoundNode) -> TypeId {
        let isNodeInTypeQuery = isInTypeQuery(node.clone());
        // Stop at the first arrow function so that we can
        // tell whether 'this' needs to be captured.
        let mut container = getThisContainer(node.clone(), true);
        let mut capturedByArrowFunction = false;

        if matches!(container, BoundNode::Constructor(_)) {
            self.checkThisBeforeSuper(&node, &container/*, Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class*/);
        }

        // Now skip arrow functions to get the "real" owner of 'this'.
        if matches!(container, BoundNode::ArrowExpr(_)) {
            container = getThisContainer(container, false);
            capturedByArrowFunction = true;
        }

        self.checkThisInStaticClassFieldInitializerInDecoratedClass(
            node.clone(),
            container.clone(),
        );
        match container {
            BoundNode::TsModuleDecl(_) => {
                todo!();
                // error(
                //     node,
                //     Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body,
                // );
                // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
            }
            BoundNode::TsEnumDecl(_) => {
                todo!();
                // error(
                //     node,
                //     Diagnostics.this_cannot_be_referenced_in_current_location,
                // );
                // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
            }
            BoundNode::Constructor(_) => {
                if isInConstructorArgumentInitializer(node.clone(), &container) {
                    todo!();
                    // error(
                    //     node,
                    //     Diagnostics.this_cannot_be_referenced_in_constructor_arguments,
                    // );
                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                }
            }
            BoundNode::ComputedPropName(_) => {
                todo!();
                // error(
                //     node,
                //     Diagnostics.this_cannot_be_referenced_in_a_computed_property_name,
                // );
            }
            _ => {}
        }

        // When targeting es6, mark that we'll need to capture `this` in its lexically bound scope.
        // TODO:
        // if (!isNodeInTypeQuery && capturedByArrowFunction && languageVersion < ScriptTarget.ES2015)
        // {
        //     self.captureLexicalThis(node, container);
        // }

        let ty = self.tryGetThisTypeAt(node, true, container);
        // TODO: noImplicitThis:
        // if noImplicitThis {
        //     let globalThisType = self.getTypeOfSymbol(globalThisSymbol);
        //     if ty == globalThisType && capturedByArrowFunction {
        //         error(
        //             node,
        //             Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this,
        //         );
        //     } else if !ty {
        //         // With noImplicitThis, functions may not reference 'this' if it has type 'any'
        //         let diag = error(
        //             node,
        //             Diagnostics
        //                 .this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation,
        //         );
        //         if !isSourceFile(container) {
        //             let outsideThis = self.tryGetThisTypeAt(container);
        //             if outsideThis && outsideThis != globalThisType {
        //                 addRelatedInfo(
        //                     diag,
        //                     createDiagnosticForNode(
        //                         container,
        //                         Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container,
        //                     ),
        //                 );
        //             }
        //         }
        //     }
        // }
        ty.unwrap_or(self.anyType)
    }

    fn tryGetThisTypeAt(
        &mut self,
        node: BoundNode,
        includeGlobalThis: bool,
        container: BoundNode,
    ) -> Option<TypeId> {
        let isInJS = isBoundNodeInJSFile(&node);
        if isFunctionLike(Some(&container))
            && (!isInParameterInitializerBeforeContainingFunction(node.clone())
                || hasThisParameter(&container))
        {
            let mut thisType = self.getThisTypeOfDeclaration(container.clone());
            // TODO: jsdoc:
            // let thisType = self.getThisTypeOfDeclaration(container)
            //     || isInJS && self.getTypeForThisExpressionFromJSDoc(container);
            // Note: a parameter initializer should refer to class-this unless function-this is explicitly annotated.
            // If this is a function in a JS file, it might be a class method.
            if thisType.is_none() {
                let className = self.getClassNameFromPrototypeMethod(container.clone());
                if isInJS && className.is_some() {
                    todo!();
                    // let  classSymbol = self.checkExpression(className).symbol;
                    // if (classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlags::Function)) {
                    //     thisType = (self.getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType;
                    // }
                } else if self.isJSConstructor(Some(container.clone())) {
                    let container_sym = self.node_data(container.clone()).symbol.unwrap();
                    let container_sym = self.getMergedSymbol(container_sym);
                    let container_ty = self.getDeclaredTypeOfSymbol(container_sym);
                    thisType = self.types[container_ty].unwrap_as_interface_type().thisType;
                }
                if thisType.is_none() {
                    thisType = self.getContextualThisParameterType(container.clone());
                }
            }

            if let Some(thisType) = thisType {
                return Some(self.getFlowTypeOfReference(&node, thisType, thisType, None));
            }
        }

        if let Some(class @ BoundNode::Class(_)) = container.parent() {
            let symbol = self.getSymbolOfNode(class.parent().unwrap()).unwrap();
            let ty = if isStatic(&container) {
                self.getTypeOfSymbol(symbol)
            } else {
                let ty = self.getDeclaredTypeOfSymbol(symbol);
                self.types[ty].unwrap_as_interface_type().thisType.unwrap()
            };
            return Some(self.getFlowTypeOfReference(&node, ty, ty, None));
        }

        if matches!(container, BoundNode::Module(_) | BoundNode::Script(_)) {
            // TODO
            // look up in the source file's locals or exports
            // if container.commonJsModuleIndicator {
            //     let fileSymbol = self.getSymbolOfNode(container);
            //     return fileSymbol && self.getTypeOfSymbol(fileSymbol);
            // } else if container.externalModuleIndicator {
            //     // TODO: Maybe issue a better error than 'object is possibly undefined'
            //     return self.undefinedType;
            // } else
            if includeGlobalThis {
                return Some(self.getTypeOfSymbol(self.globalThisSymbol));
            }
        }

        None
    }

    fn getExplicitThisType(&mut self, node: &BoundNode) -> Option<TypeId> {
        debug_assert!(matches!(node, BoundNode::ThisExpr(_)));
        let container = getThisContainer(node.clone(), false);
        if isFunctionLike(Some(&container)) {
            let signature = self.getSignatureFromDeclaration(container.clone());
            if let Some(this_param) = self.signatures[signature].thisParameter {
                return self.getExplicitTypeOfSymbol(this_param);
            }
        }
        if let Some(container_parent) = container.parent() {
            if isClassLike(&container_parent) {
                let symbol = self.getSymbolOfNode(container_parent).unwrap();
                return if isStatic(&container) {
                    Some(self.getTypeOfSymbol(symbol))
                } else {
                    let ty = self.getDeclaredTypeOfSymbol(symbol);
                    self.types[ty].unwrap_as_interface_type().thisType
                };
            }
        }
        None
    }

    fn getClassNameFromPrototypeMethod(&mut self, container: BoundNode) -> Option<BoundNode> {
        // TODO: prototype methods:
        None

        // // Check if it's the RHS of a x.prototype.y = function [name]() { .... }
        // if (container.kind == SyntaxKind.FunctionExpression
        //     && isBinaryExpression(container.parent)
        //     && getAssignmentDeclarationKind(container.parent)
        //         == AssignmentDeclarationKind.PrototypeProperty)
        // {
        //     // Get the 'x' of 'x.prototype.y = container'
        //     return ((container
        //         .parent // x.prototype.y = container
        //         .left as PropertyAccessExpression) // x.prototype.y
        //         .expression as PropertyAccessExpression) // x.prototype
        //         .expression; // x
        // }
        // // x.prototype = { method() { } }
        // else if (container.kind == SyntaxKind.MethodDeclaration
        //     && container.parent.kind == SyntaxKind.ObjectLiteralExpression
        //     && isBinaryExpression(container.parent.parent)
        //     && getAssignmentDeclarationKind(container.parent.parent)
        //         == AssignmentDeclarationKind.Prototype)
        // {
        //     return (container.parent.parent.left as PropertyAccessExpression).expression;
        // }
        // // x.prototype = { method: function() { } }
        // else if (container.kind == SyntaxKind.FunctionExpression
        //     && container.parent.kind == SyntaxKind.PropertyAssignment
        //     && container.parent.parent.kind == SyntaxKind.ObjectLiteralExpression
        //     && isBinaryExpression(container.parent.parent.parent)
        //     && getAssignmentDeclarationKind(container.parent.parent.parent)
        //         == AssignmentDeclarationKind.Prototype)
        // {
        //     return (container.parent.parent.parent.left as PropertyAccessExpression).expression;
        // }
        // // Object.defineProperty(x, "method", { value: function() { } });
        // // Object.defineProperty(x, "method", { set: (x: () => void) => void });
        // // Object.defineProperty(x, "method", { get: () => function() { }) });
        // else if (container.kind == SyntaxKind.FunctionExpression
        //     && isPropertyAssignment(container.parent)
        //     && isIdentifier(container.parent.name)
        //     && (container.parent.name.escapedText == "value"
        //         || container.parent.name.escapedText == "get"
        //         || container.parent.name.escapedText == "set")
        //     && isObjectLiteralExpression(container.parent.parent)
        //     && isCallExpression(container.parent.parent.parent)
        //     && container.parent.parent.parent.arguments[2] == container.parent.parent
        //     && getAssignmentDeclarationKind(container.parent.parent.parent)
        //         == AssignmentDeclarationKind.ObjectDefinePrototypeProperty)
        // {
        //     return (container.parent.parent.parent.arguments[0] as PropertyAccessExpression)
        //         .expression;
        // }
        // // Object.defineProperty(x, "method", { value() { } });
        // // Object.defineProperty(x, "method", { set(x: () => void) {} });
        // // Object.defineProperty(x, "method", { get() { return () => {} } });
        // else if (isMethodDeclaration(container)
        //     && isIdentifier(container.name)
        //     && (container.name.escapedText == "value"
        //         || container.name.escapedText == "get"
        //         || container.name.escapedText == "set")
        //     && isObjectLiteralExpression(container.parent)
        //     && isCallExpression(container.parent.parent)
        //     && container.parent.parent.arguments[2] == container.parent
        //     && getAssignmentDeclarationKind(container.parent.parent)
        //         == AssignmentDeclarationKind.ObjectDefinePrototypeProperty)
        // {
        //     return (container.parent.parent.arguments[0] as PropertyAccessExpression).expression;
        // }
    }

    // TODO:
    // getTypeForThisExpressionFromJSDoc
    // TODO:
    // isInConstructorArgumentInitializer

    fn checkSuperExpression(&mut self, node: &Rc<Super>) -> TypeId {
        let bound_node = BoundNode::Super(node.clone());
        let isCallExpression = matches!(&node.parent, Some(BoundNode::CallExpr(p)) if p.callee == ast::ExprOrSuper::Super(node.node.clone()));

        let immediateContainer = getSuperContainer(bound_node.clone(), true);
        let mut container = immediateContainer.clone();
        let mut needToCaptureLexicalThis = false;

        // adjust the container reference in case if super is used inside arrow functions with arbitrarily deep nesting
        if !isCallExpression {
            while let Some(c @ BoundNode::ArrowExpr(_)) = container {
                container = getSuperContainer(c, true);
                needToCaptureLexicalThis = self.languageVersion < ScriptTarget::ES2015;
            }
        }

        let canUseSuperExpression =
            isLegalUsageOfSuperExpression(container.clone(), isCallExpression);
        let mut nodeCheckFlag = NodeCheckFlags::empty();

        if !canUseSuperExpression {
            todo!();
            // // issue more specific error if super is used in computed property name
            // // class A { foo() { return "1" }}
            // // class B {
            // //     [super.foo()]() {}
            // // }
            // const current = findAncestor(node, n => n === container ? "quit" : n.kind === SyntaxKind.ComputedPropertyName);
            // if (current && current.kind === SyntaxKind.ComputedPropertyName) {
            //     error(node, Diagnostics.super_cannot_be_referenced_in_a_computed_property_name);
            // }
            // else if (isCallExpression) {
            //     error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
            // }
            // else if (!container || !container.parent || !(isClassLike(container.parent) || container.parent.kind === SyntaxKind.ObjectLiteralExpression)) {
            //     error(node, Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions);
            // }
            // else {
            //     error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
            // }
            // return errorType;
        }

        // Here, canUseSuperExpression is true which means the container exists.
        let container = container.unwrap();

        if !isCallExpression && matches!(immediateContainer, Some(BoundNode::Constructor(_))) {
            todo!();
            // checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class);
        }

        if isStatic(&container) || isCallExpression {
            nodeCheckFlag = NodeCheckFlags::SuperStatic;
            // TODO:
            // if !isCallExpression &&
            //     languageVersion >= ScriptTarget.ES2015 && languageVersion <= ScriptTarget.ES2021 &&
            //     (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container)) {
            //     // for `super.x` or `super[x]` in a static initializer, mark all enclosing
            //     // block scope containers so that we can report potential collisions with
            //     // `Reflect`.
            //     forEachEnclosingBlockScopeContainer(node.parent, current => {
            //         if (!isSourceFile(current) || isExternalOrCommonJsModule(current)) {
            //             getNodeLinks(current).flags |= NodeCheckFlags.ContainsSuperPropertyInStaticInitializer;
            //         }
            //     });
            // }
        } else {
            nodeCheckFlag = NodeCheckFlags::SuperInstance;
        }

        self.getNodeLinks_mut(bound_node.clone()).flags |= nodeCheckFlag;

        // Due to how we emit async functions, we need to specialize the emit for an async method that contains a `super` reference.
        // This is due to the fact that we emit the body of an async function inside of a generator function. As generator
        // functions cannot reference `super`, we emit a helper inside of the method body, but outside of the generator. This helper
        // uses an arrow function, which is permitted to reference `super`.
        //
        // There are two primary ways we can access `super` from within an async method. The first is getting the value of a property
        // or indexed access on super, either as part of a right-hand-side expression or call expression. The second is when setting the value
        // of a property or indexed access, either as part of an assignment expression or destructuring assignment.
        //
        // The simplest case is reading a value, in which case we will emit something like the following:
        //
        //  // ts
        //  ...
        //  async asyncMethod() {
        //    let x = await super.asyncMethod();
        //    return x;
        //  }
        //  ...
        //
        //  // js
        //  ...
        //  asyncMethod() {
        //      const _super = Object.create(null, {
        //        asyncMethod: { get: () => super.asyncMethod },
        //      });
        //      return __awaiter(this, arguments, Promise, function *() {
        //          let x = yield _super.asyncMethod.call(this);
        //          return x;
        //      });
        //  }
        //  ...
        //
        // The more complex case is when we wish to assign a value, especially as part of a destructuring assignment. As both cases
        // are legal in ES6, but also likely less frequent, we only emit setters if there is an assignment:
        //
        //  // ts
        //  ...
        //  async asyncMethod(ar: Promise<any[]>) {
        //      [super.a, super.b] = await ar;
        //  }
        //  ...
        //
        //  // js
        //  ...
        //  asyncMethod(ar) {
        //      const _super = Object.create(null, {
        //        a: { get: () => super.a, set: (v) => super.a = v },
        //        b: { get: () => super.b, set: (v) => super.b = v }
        //      };
        //      return __awaiter(this, arguments, Promise, function *() {
        //          [_super.a, _super.b] = yield ar;
        //      });
        //  }
        //  ...
        //
        // Creating an object that has getter and setters instead of just an accessor function is required for destructuring assignments
        // as a call expression cannot be used as the target of a destructuring assignment while a property access can.
        //
        // For element access expressions (`super[x]`), we emit a generic helper that forwards the element access in both situations.
        if matches!(
            container,
            BoundNode::PrivateMethod(_) | BoundNode::ClassMethod(_) | BoundNode::MethodProp(_)
        ) && hasSyntacticModifier(&container, ModifierFlags::Async)
        {
            todo!();
            // if (isSuperProperty(node.parent) && isAssignmentTarget(node.parent)) {
            //     getNodeLinks(container).flags |= NodeCheckFlags.AsyncMethodWithSuperBinding;
            // }
            // else {
            //     getNodeLinks(container).flags |= NodeCheckFlags.AsyncMethodWithSuper;
            // }
        }

        if needToCaptureLexicalThis {
            todo!();
            // call expressions are allowed only in constructors so they should always capture correct 'this'
            // super property access expressions can also appear in arrow functions -
            // in this case they should also use correct lexical this
            // captureLexicalThis(node.parent, container);
        }

        if matches!(container.parent(), Some(BoundNode::ObjectLit(_))) {
            todo!();
            // if (languageVersion < ScriptTarget.ES2015) {
            //     error(node, Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher);
            //     return errorType;
            // }
            // else {
            //     // for object literal assume that type of 'super' is 'any'
            //     return anyType;
            // }
        }

        // at this point the only legal case for parent is ClassLikeDeclaration
        let class = container.parent().unwrap();
        if unwrap_as!(&class, BoundNode::Class(c), c).extends.is_none() {
            todo!();
            // error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class);
            // return errorType;
        }

        let class_sym = self.getSymbolOfNode(class.parent().unwrap()).unwrap();
        let classType = self.getDeclaredTypeOfSymbol(class_sym);
        let baseClassType = self.getBaseTypes(classType).first();
        let baseClassType = match self.getBaseTypes(classType).first() {
            Some(ty) => *ty,
            None => return self.errorType,
        };

        if matches!(container, BoundNode::Constructor(_))
            && isInConstructorArgumentInitializer(bound_node, &container)
        {
            todo!();
            // // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
            // error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments);
            // return errorType;
        }

        return if nodeCheckFlag == NodeCheckFlags::SuperStatic {
            self.getBaseConstructorTypeOfClass(classType)
        } else {
            let this_type = self.types[classType].unwrap_as_interface_type().thisType;
            self.getTypeWithThisArgument(baseClassType, this_type, false)
        };

        fn isLegalUsageOfSuperExpression(
            container: Option<BoundNode>,
            isCallExpression: bool,
        ) -> bool {
            let container = match container {
                Some(c) => c,
                None => return false,
            };

            if isCallExpression {
                // TS 1.0 SPEC (April 2014): 4.8.1
                // Super calls are only permitted in constructors of derived classes
                return matches!(container, BoundNode::Constructor(_));
            } else {
                // TS 1.0 SPEC (April 2014)
                // 'super' property access is allowed
                // - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
                // - In a static member function or static member accessor

                // topmost container must be something that is directly nested in the class declaration\object literal expression
                if let Some(parent) = container.parent() {
                    if matches!(parent, BoundNode::Class(_) | BoundNode::ObjectLit(_)) {
                        if isStatic(&container) {
                            // TODO: class static block
                            // | BoundNode::ClassStaticBlockDeclaration(_)
                            return matches!(
                                container,
                                BoundNode::PrivateMethod(_)
                                    | BoundNode::ClassMethod(_)
                                    | BoundNode::MethodProp(_)
                                    | BoundNode::TsMethodSignature(_)
                                    | BoundNode::GetterProp(_)
                                    | BoundNode::TsGetterSignature(_)
                                    | BoundNode::SetterProp(_)
                                    | BoundNode::TsSetterSignature(_)
                                    | BoundNode::ClassProp(_)
                                    | BoundNode::PrivateProp(_)
                            );
                        } else {
                            return matches!(
                                container,
                                BoundNode::PrivateMethod(_)
                                    | BoundNode::ClassMethod(_)
                                    | BoundNode::MethodProp(_)
                                    | BoundNode::TsMethodSignature(_)
                                    | BoundNode::GetterProp(_)
                                    | BoundNode::TsGetterSignature(_)
                                    | BoundNode::SetterProp(_)
                                    | BoundNode::TsSetterSignature(_)
                                    | BoundNode::ClassProp(_)
                                    | BoundNode::PrivateProp(_)
                                    | BoundNode::TsPropertySignature(_)
                                    | BoundNode::Constructor(_)
                            );
                        }
                    }
                }
            }

            return false;
        }
    }

    // TODO:
    // getContainingObjectLiteral
    // TODO:
    // getThisTypeArgument
    // TODO:
    // getThisTypeFromContextualType

    fn getContextualThisParameterType(&mut self, func: BoundNode) -> Option<TypeId> {
        if matches!(func, BoundNode::ArrowExpr(_)) {
            return None;
        }
        if isContextSensitiveFunctionOrObjectLiteralMethod(&func.into()) {
            todo!();
            // let contextualSignature = self.getContextualSignature(func);
            // if (contextualSignature) {
            //     let thisParameter = contextualSignature.thisParameter;
            //     if (thisParameter) {
            //         return self.getTypeOfSymbol(thisParameter);
            //     }
            // }
        }
        // TODO: js files:
        // TODO: noImplicitThis:
        // let inJs = isBoundNodeInJSFile(&func);
        // if noImplicitThis || inJs {
        //     let containingLiteral = self.getContainingObjectLiteral(func);
        //     if containingLiteral {
        //         // We have an object literal method. Check if the containing object literal has a contextual type
        //         // that includes a ThisType<T>. If so, T is the contextual type for 'this'. We continue looking in
        //         // any directly enclosing object literals.
        //         let contextualType = self.getApparentTypeOfContextualType(containingLiteral);
        //         let literal = containingLiteral;
        //         let ty = contextualType;
        //         while (ty) {
        //             let thisType = self.getThisTypeFromContextualType(ty);
        //             if (thisType) {
        //                 return instantiateType(
        //                     thisType,
        //                     getMapperFromContext(getInferenceContext(containingLiteral)),
        //                 );
        //             }
        //             if (literal.parent.kind != SyntaxKind.PropertyAssignment) {
        //                 break;
        //             }
        //             literal = literal.parent.parent as ObjectLiteralExpression;
        //             ty = self.getApparentTypeOfContextualType(literal);
        //         }
        //         // There was no contextual ThisType<T> for the containing object literal, so the contextual type
        //         // for 'this' is the non-null form of the contextual type for the containing object literal or
        //         // the type of the object literal itself.
        //         return self.getWidenedType(if contextualType {
        //             self.getNonNullableType(contextualType)
        //         } else {
        //             self.checkExpressionCached(containingLiteral)
        //         });
        //     }
        //     // In an assignment of the form 'obj.xxx = function(...)' or 'obj[xxx] = function(...)', the
        //     // contextual type for 'this' is 'obj'.
        //     let parent = walkUpParenthesizedExpressions(func.parent);
        //     if (parent.kind == SyntaxKind.BinaryExpression
        //         && (parent as BinaryExpression).operatorToken.kind == SyntaxKind.EqualsToken)
        //     {
        //         let target = (parent as BinaryExpression).left;
        //         if (isAccessExpression(target)) {
        //             let expression = target.expression;
        //             // Don't contextually type `this` as `exports` in `exports.Point = function(x, y) { this.x = x; this.y = y; }`
        //             if (inJs && isIdentifier(expression)) {
        //                 let sourceFile = getSourceFileOfNode(parent);
        //                 if (sourceFile.commonJsModuleIndicator
        //                     && self.getResolvedSymbol(expression) == sourceFile.symbol)
        //                 {
        //                     return None;
        //                 }
        //             }

        //             return self.getWidenedType(checkExpressionCached(expression));
        //         }
        //     }
        // }
        None
    }

    // Return contextual type of parameter or undefined if no contextual type is available
    fn getContextuallyTypedParameterType(&mut self, parameter: Parameter) -> Option<TypeId> {
        let mut func = parameter.parent();
        if matches!(func, BoundNode::Function(_)) {
            func = func.parent().unwrap();
        }
        if !isContextSensitiveFunctionOrObjectLiteralMethod(&func.clone().into()) {
            return None;
        }
        let iife = getImmediatelyInvokedFunctionExpression(func.clone());
        if let Some(iife) = iife {
            if !iife.args.is_empty() {
                todo!();
                // let args = getEffectiveCallArguments(iife);
                // let indexOfParameter = func.parameters.indexOf(parameter);
                // if (parameter.dotDotDotToken) {
                //     return getSpreadArgumentType(args, indexOfParameter, args.length, anyType, /*context*/ undefined, CheckMode.Normal);
                // }
                // let links = getNodeLinks(iife);
                // let cached = links.resolvedSignature;
                // links.resolvedSignature = anySignature;
                // let ty = if indexOfParameter < args.length
                //     {getWidenedLiteralType(checkExpression(args[indexOfParameter]))}
                //     else if {parameter.initializer} {undefined} else{undefinedWideningType};
                // links.resolvedSignature = cached;
                // return ty;
            }
        }
        let contextualSignature = self.getContextualSignature(&func);
        if let Some(contextualSignature) = contextualSignature {
            let (index, last) =
                match &func {
                    BoundNode::PrivateMethod(n) => (
                        n.function.params.iter().position(|p| parameter == p),
                        n.function.params.last().map(|p| {
                            Param::new(p.clone(), Some(n.function.bind(func.clone()))).into()
                        }),
                    ),
                    BoundNode::ClassMethod(n) => (
                        n.function.params.iter().position(|p| parameter == p),
                        n.function.params.last().map(|p| {
                            Param::new(p.clone(), Some(n.function.bind(func.clone()))).into()
                        }),
                    ),
                    BoundNode::MethodProp(n) => (
                        n.function.params.iter().position(|p| parameter == p),
                        n.function.params.last().map(|p| {
                            Param::new(p.clone(), Some(n.function.bind(func.clone()))).into()
                        }),
                    ),
                    BoundNode::FnExpr(n) => (
                        n.function.params.iter().position(|p| parameter == p),
                        n.function.params.last().map(|p| {
                            Param::new(p.clone(), Some(n.function.bind(func.clone()))).into()
                        }),
                    ),
                    BoundNode::ArrowExpr(n) => (
                        n.params.iter().position(|p| parameter == p),
                        n.params.last().map(|p| {
                            ParamWithoutDecorators::new(p.clone(), Some(func.clone())).into()
                        }),
                    ),
                    _ => todo!(),
                };
            let index = index.unwrap() - (if hasThisParameter(&func) { 1 } else { 0 });
            return if parameter.is_rest_param() && last.as_ref() == Some(&parameter) {
                todo!();
                // self.getRestTypeAtPosition(contextualSignature, index)
            } else {
                self.tryGetTypeAtPosition(contextualSignature, index)
            };
        }
        None
    }

    fn getContextualTypeForVariableLikeDeclaration(
        &mut self,
        declaration: &BoundNode,
    ) -> Option<TypeId> {
        if let Some(typeNode) = getBoundEffectiveTypeAnnotationNode(declaration) {
            return Some(self.getTypeFromTypeNode(typeNode));
        }
        match declaration {
            BoundNode::Param(p) => {
                self.getContextuallyTypedParameterType(Parameter::Param(p.clone()))
            }
            BoundNode::ParamWithoutDecorators(p) => {
                self.getContextuallyTypedParameterType(Parameter::ParamWithoutDecorators(p.clone()))
            }
            BoundNode::TsAmbientParam(p) => {
                self.getContextuallyTypedParameterType(Parameter::TsAmbientParam(p.clone()))
            }
            BoundNode::TsParamProp(p) => {
                self.getContextuallyTypedParameterType(Parameter::TsParamProp(p.clone()))
            }
            // BoundNode::BindingElement(_) => {
            //     self.getContextualTypeForBindingElement(declaration)
            // }
            BoundNode::BindingIdent(_)
            | BoundNode::ArrayPat(_)
            | BoundNode::RestPat(_)
            | BoundNode::ObjectPat(_)
            | BoundNode::AssignPat(_)
            | BoundNode::KeyValuePatProp(_)
            | BoundNode::AssignPatProp(_) => {
                dbg!(declaration);
                todo!("binding element; see above");
            }
            BoundNode::ClassProp(_) | BoundNode::PrivateProp(_) => {
                if isStatic(declaration) {
                    todo!();
                    // self.getContextualTypeForStaticPropertyDeclaration(declaration)
                } else {
                    None
                }
            }
            // By default, do nothing and return None - only the above cases have context implied by a parent
            _ => None,
        }
    }

    // TODO:
    // getContextualTypeForBindingElement
    // TODO:
    // getContextualTypeForStaticPropertyDeclaration

    // In a variable, parameter or property declaration with a type annotation,
    //   the contextual type of an initializer expression is the type of the variable, parameter or property.
    // Otherwise, in a parameter declaration of a contextually typed function expression,
    //   the contextual type of an initializer expression is the contextual type of the parameter.
    // Otherwise, in a variable or parameter declaration with a binding pattern name,
    //   the contextual type of an initializer expression is the type implied by the binding pattern.
    // Otherwise, in a binding pattern inside a variable or parameter declaration,
    //   the contextual type of an initializer expression is the type annotation of the containing declaration, if present.
    fn getContextualTypeForInitializerExpression(
        &mut self,
        node: &BoundNode,
        contextFlags: Option<ContextFlags>,
    ) -> Option<TypeId> {
        let declaration = node.parent().unwrap();
        debug_assert!(matches!(
            declaration,
            // TODO:
            // BoundNode::BindingElement(_)|
            BoundNode::VarDeclarator(_)
                | BoundNode::Param(_)
                | BoundNode::ParamWithoutDecorators(_)
                | BoundNode::TsAmbientParam(_)
                | BoundNode::TsParamProp(_)
                | BoundNode::ClassProp(_)
                | BoundNode::PrivateProp(_)
                | BoundNode::TsPropertySignature(_)
        ));
        if getInitializer(&declaration.clone().into()) == Some(node.clone().into()) {
            let result = self.getContextualTypeForVariableLikeDeclaration(&declaration);
            if result.is_some() {
                return result;
            }
            let skip_binding_patterns = if let Some(contextFlags) = contextFlags {
                contextFlags.intersects(ContextFlags::SkipBindingPatterns)
            } else {
                false
            };
            if !skip_binding_patterns {
                let name = match &declaration {
                    // TODO:
                    // BoundNode::BindingElement(_)|
                    BoundNode::VarDeclarator(n) => Some(n.name.bind(declaration.clone())),
                    BoundNode::Param(n) => Some(n.pat.bind(declaration.clone())),
                    BoundNode::ParamWithoutDecorators(n) => Some(n.pat.bind(declaration.clone())),
                    BoundNode::TsAmbientParam(n) => Some(n.pat.bind(declaration.clone())),
                    BoundNode::TsParamProp(n) => Some(n.param.bind(declaration.clone())),
                    BoundNode::ClassProp(n) => Some(n.key.bind(declaration.clone())),
                    BoundNode::PrivateProp(n) => Some(n.key.bind(declaration.clone())),
                    BoundNode::TsPropertySignature(n) => Some(n.key.bind(declaration.clone())),
                    _ => None,
                };
                if matches!(&name, Some(n) if isBindingPattern(n)) {
                    // This is less a contextual type and more an implied shape - in some cases, this may be undesirable
                    todo!();
                    // return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ true, /*reportErrors*/ false);
                }
            }
        }
        None
    }

    fn getContextualTypeForReturnExpression(&mut self, node: &BoundNode) -> Option<TypeId> {
        let func = getContainingFunction(node);
        if let Some(func) = func {
            if let Some(contextualReturnType) = self.getContextualReturnType(&func) {
                let functionFlags = getFunctionFlags(Some(&func));
                if functionFlags.intersects(FunctionFlags::Generator) {
                    // Generator or AsyncGenerator function

                    // let should_use = if functionFlags.intersects(FunctionFlags::Async) {IterationUse::AsyncGeneratorReturnType} else{IterationUse::GeneratorReturnType};
                    // let iterationTypes = getIterationTypesOfIterable(contextualReturnType, should_use, /*errorNode*/ undefined);
                    // if (!iterationTypes) {
                    //     return None;
                    // }
                    // contextualReturnType = iterationTypes.returnType;
                    // falls through to unwrap Promise for AsyncGenerators
                    todo!();
                }

                if functionFlags.intersects(FunctionFlags::Async) {
                    // Async function or AsyncGenerator function

                    // Get the awaited type without the `Awaited<T>` alias
                    // let contextualAwaitedType = mapType(contextualReturnType, getAwaitedTypeNoAlias);
                    // return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
                    todo!();
                }

                // Regular function or Generator function
                return Some(contextualReturnType);
            }
        }
        None
    }

    // TODO:
    // getContextualTypeForAwaitOperand
    // TODO:
    // getContextualTypeForYieldOperand
    // TODO:
    // isInParameterInitializerBeforeContainingFunction
    // TODO:
    // getContextualIterationType

    fn getContextualReturnType(&mut self, functionDecl: &BoundNode) -> Option<TypeId> {
        // If the containing function has a return type annotation, is a constructor, or is a get accessor whose
        // corresponding set accessor has a type annotation, return statements in the function are contextually typed
        if let Some(returnType) = self.getReturnTypeFromAnnotation(functionDecl) {
            return Some(returnType);
        }
        // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
        // and that call signature is non-generic, return statements are contextually typed by the return type of the signature
        let signature = self.getContextualSignatureForFunctionLikeDeclaration(functionDecl);
        if let Some(signature) = signature {
            if !self.isResolvingReturnTypeOfSignature(signature) {
                return Some(self.getReturnTypeOfSignature(signature));
            }
        }
        if let Some(iife) = getImmediatelyInvokedFunctionExpression(functionDecl.clone()) {
            return self.getContextualType(BoundNode::CallExpr(iife), None);
        }
        None
    }

    // In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.
    fn getContextualTypeForArgument(
        &mut self,
        callTarget: &BoundNode,
        arg: &BoundNode,
    ) -> Option<TypeId> {
        let args = self.getEffectiveCallArguments(callTarget);
        let argIndex = args.iter().position(|a| a == arg); // None for e.g. the expression of a CallExpression, or the tag of a TaggedTemplateExpression
        argIndex.map(|argIndex| self.getContextualTypeForArgumentAtIndex(callTarget, argIndex))
    }

    fn getContextualTypeForArgumentAtIndex(
        &mut self,
        callTarget: &BoundNode,
        argIndex: usize,
    ) -> TypeId {
        if isImportCall(callTarget) {
            todo!();
            // return argIndex === 0 ? stringType :
            //     argIndex === 1 ? getGlobalImportCallOptionsType(/*reportErrors*/ false) :
            //     anyType;
        }

        let resolvingSignature = self.resolvingSignature;

        // If we're already in the process of resolving the given signature, don't resolve again as
        // that could cause infinite recursion. Instead, return anySignature.
        let signature = if self.getNodeLinks(callTarget.clone()).resolvedSignature
            == Some(resolvingSignature)
        {
            resolvingSignature
        } else {
            self.getResolvedSignature(callTarget.clone(), None, None)
        };

        // TODO:
        // if (isJsxOpeningLikeElement(callTarget) && argIndex === 0) {
        //     return getEffectiveFirstArgumentForJsxSignature(signature, callTarget);
        // }
        if signatureHasRestParameter(&self.signatures[signature]) {
            let restIndex = self.signatures[signature].parameters.len() - 1;
            if argIndex >= restIndex {
                todo!();
                // return self.getIndexedAccessType(
                //     getTypeOfSymbol(self.signatures[signature].parameters[restIndex]),
                //     self.getNumberLiteralType(argIndex - restIndex),
                //     AccessFlags::Contextual,
                // );
            }
        }
        self.getTypeAtPosition(signature, argIndex)
    }

    // TODO:
    // getContextualTypeForSubstitutionExpression
    // TODO:
    // getContextualTypeForBinaryOperand
    // TODO:
    // getSymbolForExpression
    // TODO:
    // getContextualTypeForAssignmentDeclaration
    // TODO:
    // isPossiblyAliasedThisProperty
    // TODO:
    // getContextualTypeForThisPropertyAssignment

    fn isCircularMappedProperty(&mut self, symbol: SymbolId) -> bool {
        getCheckFlags(&self.symbols[symbol]).intersects(CheckFlags::Mapped)
            && self.get_transient_sym(symbol).symbol_links.ty.is_none()
            && self
                .findResolutionCycleStartIndex(
                    TypeSystemEntity::Symbol(symbol),
                    TypeSystemPropertyName::Type,
                )
                .is_some()
    }

    fn getTypeOfPropertyOfContextualType(&mut self, ty: TypeId, name: JsWord) -> Option<TypeId> {
        self.mapTypeOptional(
            ty,
            &mut |checker, t| {
                if checker.isGenericMappedType(t) {
                    todo!();
                    // let constraint = getConstraintTypeFromMappedType(t);
                    // let constraintOfConstraint = getBaseConstraintOfType(constraint) || constraint;
                    // let propertyNameType = getStringLiteralType(unescapeLeadingUnderscores(name));
                    // if (isTypeAssignableTo(propertyNameType, constraintOfConstraint)) {
                    //     return substituteIndexedMappedType(t, propertyNameType);
                    // }
                } else if checker.types[t]
                    .get_flags()
                    .intersects(TypeFlags::StructuredType)
                {
                    if let Some(prop) = checker.getPropertyOfType(t, &name, false) {
                        return if checker.isCircularMappedProperty(prop) {
                            None
                        } else {
                            Some(checker.getTypeOfSymbol(prop))
                        };
                    }
                    if checker.isTupleType(t) {
                        todo!();
                        // const restType = getRestTypeOfTupleType(t);
                        // if (restType && isNumericLiteralName(name) && +name >= 0) {
                        //     return restType;
                        // }
                    }
                    let indexInfos = checker.getIndexInfosOfStructuredType(t);
                    let keyType = checker.getStringLiteralType(unescapeLeadingUnderscores(&name));
                    return checker
                        .findApplicableIndexInfo(indexInfos, keyType)
                        .map(|i| checker.index_infos[i].ty);
                }
                None
            },
            true,
        )
    }

    // TODO:
    // getContextualTypeForObjectLiteralMethod

    fn getContextualTypeForObjectLiteralElement(
        &mut self,
        element: &ast::Prop,
        objectLiteral: &BoundNode,
        contextFlags: Option<ContextFlags>,
    ) -> Option<TypeId> {
        debug_assert!(
            !matches!(element, ast::Prop::Assign(_)),
            "Assgin prop is not valid for obj lit"
        );
        debug_assert!(matches!(objectLiteral, BoundNode::ObjectLit(_)));

        let bound_element = element.bind(objectLiteral.clone());
        let propertyAssignmentType = if matches!(element, ast::Prop::KeyValue(_)) {
            self.getContextualTypeForVariableLikeDeclaration(&bound_element)
        } else {
            None
        };
        if propertyAssignmentType.is_some() {
            return propertyAssignmentType;
        }

        if let Some(ty) = self.getApparentTypeOfContextualType(objectLiteral.clone(), contextFlags)
        {
            if self.hasBindableName(&bound_element) {
                // For a (non-symbol) computed property, there is no reason to look up the name
                // in the type. It will just be "__computed", which does not appear in any
                // SymbolTable.
                let element_symbol = self.getSymbolOfNode(bound_element).unwrap();
                let name = self.symbols[element_symbol].escapedName().clone();
                return self.getTypeOfPropertyOfContextualType(ty, name);
            }
            let name = match element {
                ast::Prop::Shorthand(p) => Some(BoundPropName::Ident(Ident::new(
                    p.clone(),
                    Some(bound_element),
                ))),
                ast::Prop::KeyValue(p) => {
                    Some(BoundPropName::from_prop_name(p.key.clone(), bound_element))
                }
                ast::Prop::Getter(p) => {
                    Some(BoundPropName::from_prop_name(p.key.clone(), bound_element))
                }
                ast::Prop::Setter(p) => {
                    Some(BoundPropName::from_prop_name(p.key.clone(), bound_element))
                }
                ast::Prop::Method(p) => {
                    Some(BoundPropName::from_prop_name(p.key.clone(), bound_element))
                }
                ast::Prop::Spread(p) => None,
                ast::Prop::Assign(_) => unreachable!(),
            };
            if let Some(name) = name {
                let nameType = self.getLiteralTypeFromPropertyName(name);
                // We avoid calling getApplicableIndexInfo here because it performs potentially expensive intersection reduction.
                return self.mapTypeOptional(
                    ty,
                    &mut |checker, t| {
                        let indexInfos = checker.getIndexInfosOfStructuredType(t);
                        checker
                            .findApplicableIndexInfo(indexInfos.clone(), nameType)
                            .map(|i| checker.index_infos[i].ty)
                    },
                    true,
                );
            }
        }
        None
    }

    // TODO:
    // getContextualTypeForElementExpression
    // TODO:
    // getContextualTypeForConditionalOperand
    // TODO:
    // getContextualTypeForChildJsxExpression
    // TODO:
    // getContextualTypeForJsxExpression
    // TODO:
    // getContextualTypeForJsxAttribute
    // TODO:
    // isPossiblyDiscriminantValue
    // TODO:
    // discriminateContextualTypeByObjectMembers
    // TODO:
    // discriminateContextualTypeByJSXAttributes

    // Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
    // be "pushed" onto a node using the contextualType property.
    fn getApparentTypeOfContextualType(
        &mut self,
        node: BoundNode,
        contextFlags: Option<ContextFlags>,
    ) -> Option<TypeId> {
        let contextualType = if let BoundNode::MethodProp(_) = &node {
            todo!();
            // self.getContextualTypeForObjectLiteralMethod(node, contextFlags)
        } else {
            self.getContextualType(node.clone(), contextFlags)
        };
        let instantiatedType =
            self.instantiateContextualType(contextualType, node.clone(), contextFlags);
        if let Some(instantiatedType) = instantiatedType {
            if !(contextFlags.is_some()
                && contextFlags
                    .unwrap()
                    .intersects(ContextFlags::NoConstraints)
                && self.types[instantiatedType]
                    .get_flags()
                    .intersects(TypeFlags::TypeVariable))
            {
                let apparentType = self.mapType(
                    instantiatedType,
                    &mut |checker, ty| checker.getApparentType(ty),
                    true,
                );
                // TODO: jsx:
                // let flags = self.types[apparentType].get_flags();
                // return if flags.intersects(TypeFlags::Union) && isObjectLiteralExpression(node) {
                //     discriminateContextualTypeByObjectMembers(node, apparentType as UnionType)
                // } else if flags.intersects(TypeFlags::Union) && isJsxAttributes(node) {
                //     discriminateContextualTypeByJSXAttributes(node, apparentType as UnionType)
                // } else {
                //     apparentType
                // };
                let flags = self.types[apparentType].get_flags();
                return if flags.intersects(TypeFlags::Union)
                    && matches!(node, BoundNode::ObjectLit(_))
                {
                    todo!();
                    // discriminateContextualTypeByObjectMembers(node, apparentType as UnionType)
                } else {
                    Some(apparentType)
                };
            }
        }
        None
    }

    // If the given contextual type contains instantiable types and if a mapper representing
    // return type inferences is available, instantiate those types using that mapper.
    fn instantiateContextualType(
        &mut self,
        contextualType: Option<TypeId>,
        node: BoundNode,
        contextFlags: Option<ContextFlags>,
    ) -> Option<TypeId> {
        if let Some(contextualType) = contextualType {
            if self.maybeTypeOfKind(contextualType, TypeFlags::Instantiable) {
                // If no inferences have been made, nothing is gained from instantiating as type parameters
                // would just be replaced with their defaults similar to the apparent type.
                if let Some(inferenceContext) = self.getInferenceContext(node) {
                    if self.inference_contexts[inferenceContext]
                        .inferences
                        .iter()
                        .any(|i| hasInferenceCandidates(i))
                    {
                        // For contextual signatures we incorporate all inferences made so far, e.g. from return
                        // types as well as arguments to the left in a function call.
                        if contextFlags
                            .map(|cf| cf.intersects(ContextFlags::Signature))
                            .unwrap_or_default()
                        {
                            return Some(
                                self.instantiateInstantiableTypes(
                                    contextualType,
                                    self.inference_contexts[inferenceContext]
                                        .nonFixingMapper
                                        .clone(),
                                ),
                            );
                        }
                        // For other purposes (e.g. determining whether to produce literal types) we only
                        // incorporate inferences made from the return type in a function call.
                        if let Some(returnMapper) = self.inference_contexts[inferenceContext]
                            .returnMapper
                            .as_ref()
                        {
                            return Some(self.instantiateInstantiableTypes(
                                contextualType,
                                returnMapper.clone(),
                            ));
                        }
                    }
                }
            }
        }
        contextualType
    }

    // This function is similar to instantiateType, except that (a) it only instantiates types that
    // are classified as instantiable (i.e. it doesn't instantiate object types), and (b) it performs
    // no reductions on instantiated union types.
    fn instantiateInstantiableTypes(&mut self, ty: TypeId, mapper: Rc<TypeMapper>) -> TypeId {
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Instantiable)
        {
            return self.instantiateType(ty, Some(mapper));
        }
        if self.types[ty].get_flags().intersects(TypeFlags::Union) {
            // TODO: bad collect
            let types = self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
                .iter()
                .map(|&t| self.instantiateInstantiableTypes(t, mapper.clone()))
                .collect::<Vec<_>>();
            return self.getUnionType(&types, Some(UnionReduction::None), None, None, None);
        }
        if self.types[ty]
            .get_flags()
            .intersects(TypeFlags::Intersection)
        {
            // TODO: bad collect
            let types = self.types[ty]
                .unwrap_as_union_or_intersection()
                .types
                .clone()
                .iter()
                .map(|&t| self.instantiateInstantiableTypes(t, mapper.clone()))
                .collect::<Vec<_>>();
            return self.getIntersectionType(&types, None, None);
        }
        ty
    }

    /**
     * Whoa! Do you really want to use this function?
     *
     * Unless you're trying to get the *non-apparent* type for a
     * value-literal type or you're authoring relevant portions of this algorithm,
     * you probably meant to use 'getApparentTypeOfContextualType'.
     * Otherwise this may not be very useful.
     *
     * In cases where you *are* working on this function, you should understand
     * when it is appropriate to use 'getContextualType' and 'getApparentTypeOfContextualType'.
     *
     *   - Use 'getContextualType' when you are simply going to propagate the result to the expression.
     *   - Use 'getApparentTypeOfContextualType' when you're going to need the members of the type.
     *
     * @param node the expression whose contextual type will be returned.
     * @returns the contextual type of an expression.
     */
    fn getContextualType(
        &mut self,
        node: BoundNode,
        contextFlags: Option<ContextFlags>,
    ) -> Option<TypeId> {
        // fn tryFindWhenConstTypeReference(node: BoundNode) {
        //     return getContextualType(node);
        // }
        // TODO
        // if (node.flags & NodeFlags.InWithStatement) {
        //     // We cannot answer semantic questions within a with block, do not proceed any further
        //     return undefined;
        // }
        if self.node_data(node.clone()).contextualType.is_some() {
            return self.node_data(node).contextualType;
        }
        if let Some(parent) = node.parent() {
            match &parent {
                // BoundNode::BindingElement(_)|
                BoundNode::VarDeclarator(_)
                | BoundNode::Param(_)
                | BoundNode::ParamWithoutDecorators(_)
                | BoundNode::TsAmbientParam(_)
                | BoundNode::TsParamProp(_)
                | BoundNode::ClassProp(_)
                | BoundNode::PrivateProp(_)
                | BoundNode::TsPropertySignature(_) => {
                    self.getContextualTypeForInitializerExpression(&node, contextFlags)
                }
                BoundNode::ArrowExpr(_) | BoundNode::ReturnStmt(_) => {
                    self.getContextualTypeForReturnExpression(&node)
                }
                BoundNode::YieldExpr(_) => {
                    todo!();
                    // self.getContextualTypeForYieldOperand(parent as YieldExpression)
                }
                BoundNode::AwaitExpr(_) => {
                    todo!();
                    // self.getContextualTypeForAwaitOperand(parent as AwaitExpression, contextFlags)
                }
                BoundNode::CallExpr(_) | BoundNode::NewExpr(_) => {
                    self.getContextualTypeForArgument(&parent, &node)
                }
                BoundNode::TsTypeAssertion(_) | BoundNode::TsAsExpr(_) => {
                    todo!();
                    // if isConstTypeReference((parent as AssertionExpression).ty) {
                    //     tryFindWhenConstTypeReference(parent as AssertionExpression)
                    // } else {
                    //     getTypeFromTypeNode((parent as AssertionExpression).ty)
                    // }
                }
                BoundNode::BinExpr(_) => {
                    todo!();
                    // getContextualTypeForBinaryOperand(node, contextFlags)
                }
                BoundNode::KeyValueProp(p) => self.getContextualTypeForObjectLiteralElement(
                    &ast::Prop::KeyValue(p.node.clone()),
                    p.parent.as_ref().unwrap(),
                    contextFlags,
                ),
                // ShorthandPropertyAssignment
                BoundNode::Ident(_) if matches!(parent.parent(), Some(BoundNode::ObjectLit(_))) => {
                    todo!();
                    // getContextualTypeForObjectLiteralElement(
                    //     parent as PropertyAssignment | ShorthandPropertyAssignment,
                    //     contextFlags,
                    // )
                }
                // BoundNode::SpreadAssignment(_)=> getContextualType(parent.parent as ObjectLiteralExpression, contextFlags),
                BoundNode::ArrayLit(_) => {
                    todo!();
                    // let arrayLiteral = parent as ArrayLiteralExpression;
                    // let ty = self.getApparentTypeOfContextualType(arrayLiteral, contextFlags);
                    // return self.getContextualTypeForElementExpression(ty, indexOfNode(arrayLiteral.elements, node));
                }
                BoundNode::CondExpr(_) => {
                    todo!();
                    // getContextualTypeForConditionalOperand(node, contextFlags)
                }
                // BoundNode::TemplateSpan(_)=>{
                //     Debug.assert(parent.parent.kind == SyntaxKind.TemplateExpression);
                //     return getContextualTypeForSubstitutionExpression(parent.parent as TemplateExpression, node);
                // }
                BoundNode::ParenExpr(_) => {
                    todo!();
                    // Like in `checkParenthesizedExpression`, an `/** @type {xyz} */` comment before a parenthesized expression acts as a type cast.
                    // let tag = isBoundNodeInJSFile(parent) ? getJSDocTypeTag(parent) : undefined;
                    // return !tag ? getContextualType(parent as ParenthesizedExpression, contextFlags) :
                    //     isJSDocTypeTag(tag) && isConstTypeReference(tag.typeExpression.ty) ? tryFindWhenConstTypeReference(parent as ParenthesizedExpression) :
                    //     getTypeFromTypeNode(tag.typeExpression.ty);
                }
                BoundNode::TsNonNullExpr(_) => self.getContextualType(parent, contextFlags),
                // BoundNode::JsxExpression(_)=> getContextualTypeForJsxExpression(parent as JsxExpression),
                // BoundNode::JsxAttribute(_)|
                // BoundNode::JsxSpreadAttribute(_)=> getContextualTypeForJsxAttribute(parent as JsxAttribute | JsxSpreadAttribute),
                // BoundNode::JsxOpeningElement(_)|
                // BoundNode::JsxSelfClosingElement(_)=> getContextualJsxElementAttributesType(parent as JsxOpeningLikeElement, contextFlags),

                // TODO: These branches are only seperate from the default branch of `None` to silence warnings during porting.
                // Replace them with a default branch of `None`.
                _ => {
                    dbg!(parent);
                    todo!()
                }
            }
        } else {
            None
        }
    }

    fn getInferenceContext(&mut self, node: BoundNode) -> Option<InferenceContextId> {
        let ancestor = findAncestor(Some(node), |n| {
            Some(self.node_data(n.clone()).inferenceContext.is_some())
        });
        ancestor.and_then(|n| self.node_data(n).inferenceContext)
    }

    // TODO:
    // getContextualJsxElementAttributesType
    // TODO:
    // getEffectiveFirstArgumentForJsxSignature
    // TODO:
    // getJsxPropsTypeFromCallSignature
    // TODO:
    // getJsxPropsTypeForSignatureFromMember
    // TODO:
    // getStaticTypeOfReferencedJsxConstructor
    // TODO:
    // getJsxManagedAttributesFromLocatedAttributes
    // TODO:
    // getJsxPropsTypeFromClassType

    // fn getIntersectedSignatures(
    //     &mut self,
    //     mut signatures: impl Iterator<Item = SignatureId>,
    // ) -> Option<SignatureId> {
    //     if self.compilerOptions.getStrictOptionValue("noImplicitAny") {
    //         let init = signatures.next();
    //         signatures.fold(init, |left, right| {
    //             // todo:
    //             // if left == right || left.is_none() {
    //             //     left
    //             // } else if self.compareTypeParametersIdentical(left.typeParameters, right.typeParameters)
    //             // {
    //             //     Some(self.combineSignaturesOfIntersectionMembers(left, right))
    //             // } else {
    //             //     None
    //             // }
    //             if let Some(left) = left {
    //                 if left == right {
    //                     Some(left)
    //                 } else if self.compareTypeParametersIdentical(
    //                     self.signatures[left].typeParameters.clone(),
    //                     self.signatures[right].typeParameters.clone(),
    //                 ) {
    //                     Some(self.combineSignaturesOfIntersectionMembers(left, right))
    //                 } else {
    //                     None
    //                 }
    //             } else {
    //                 None
    //             }
    //         })
    //     } else {
    //         None
    //     }
    // }
    fn getIntersectedSignatures(
        &mut self,
        signatures: &[SignatureId],
        mut filter_fn: impl FnMut(&mut Checker, SignatureId) -> bool,
    ) -> Option<SignatureId> {
        if self.compilerOptions.getStrictOptionValue("noImplicitAny") {
            // TODO: this is a rather janky impl of a reduce fn.
            // All to avoid allocating an intermediary Vec. Reconsider or validate.
            let mut left = signatures.first().cloned();
            for &right in signatures {
                if filter_fn(self, right) {
                    left = if let Some(left) = left {
                        if left == right {
                            Some(left)
                        } else if self.compareTypeParametersIdentical(
                            self.signatures[left].typeParameters.clone(),
                            self.signatures[right].typeParameters.clone(),
                        ) {
                            Some(self.combineSignaturesOfIntersectionMembers(left, right))
                        } else {
                            None
                        }
                    } else {
                        None
                    };
                }
            }
            left
        } else {
            None
        }
    }

    fn combineIntersectionThisParam(
        &mut self,
        left: Option<SymbolId>,
        right: Option<SymbolId>,
        mapper: Option<Rc<TypeMapper>>,
    ) -> Option<SymbolId> {
        if let (Some(left), Some(right)) = (left, right) {
            // A signature `this` type might be a read or a write position... It's very possible that it should be invariant
            // and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
            // pessimistic when contextual typing, for now, we'll union the `this` types.
            let left_ty = self.getTypeOfSymbol(left);
            let right_ty = self.getTypeOfSymbol(right);
            let right_ty = self.instantiateType(right_ty, mapper);
            let thisType = self.getUnionType(&[left_ty, right_ty], None, None, None, None);
            Some(self.createSymbolWithType(left, Some(thisType)))
        } else {
            left.or(right)
        }
    }

    fn combineIntersectionParameters(
        &mut self,
        left: SignatureId,
        right: SignatureId,
        mapper: Option<Rc<TypeMapper>>,
    ) -> Rc<Vec<SymbolId>> {
        let leftCount = self.getParameterCount(left);
        let rightCount = self.getParameterCount(right);
        let longest = if leftCount >= rightCount { left } else { right };
        let shorter = if longest == left { right } else { left };
        let longestCount = if longest == left {
            leftCount
        } else {
            rightCount
        };
        let eitherHasEffectiveRest =
            (self.hasEffectiveRestParameter(left) || self.hasEffectiveRestParameter(right));
        let needsExtraRestElement =
            eitherHasEffectiveRest && !self.hasEffectiveRestParameter(longest);
        //  +1 in case we need an extra rest element:
        let mut params = Vec::with_capacity(longestCount + 1);
        for i in 0..longestCount {
            let mut longestParamType = self.tryGetTypeAtPosition(longest, i).unwrap();
            if (longest == right) {
                longestParamType = self.instantiateType(longestParamType, mapper.clone());
            }
            let mut shorterParamType = self
                .tryGetTypeAtPosition(shorter, i)
                .unwrap_or(self.unknownType);
            if (shorter == right) {
                shorterParamType = self.instantiateType(shorterParamType, mapper.clone());
            }
            let unionParamType = self.getUnionType(
                &[longestParamType, shorterParamType],
                None,
                None,
                None,
                None,
            );
            let isRestParam =
                eitherHasEffectiveRest && !needsExtraRestElement && i == (longestCount - 1);
            let isOptional = i >= self.getMinArgumentCount(longest, None)
                && i >= self.getMinArgumentCount(shorter, None);
            let leftName = if i >= leftCount {
                None
            } else {
                Some(self.getParameterNameAtPosition(left, i, None))
            };
            let rightName = if i >= rightCount {
                None
            } else {
                Some(self.getParameterNameAtPosition(right, i, None))
            };

            let paramName = if leftName == rightName {
                leftName
            } else if leftName.is_none() {
                rightName
            } else if rightName.is_none() {
                leftName
            } else {
                None
            };
            let mut param_symbol_flags = SymbolFlags::FunctionScopedVariable;
            if isOptional && !isRestParam {
                param_symbol_flags |= SymbolFlags::Optional;
            }
            let paramSymbol = self.createSymbol(
                param_symbol_flags,
                paramName.unwrap_or_else(|| todo!() /*`arg${i}` as __String)*/),
                None,
            );
            self.get_transient_sym_mut(paramSymbol).symbol_links.ty = if isRestParam {
                todo!();
                // self.createArrayType(unionParamType)
            } else {
                Some(unionParamType)
            };
            params[i] = paramSymbol;
        }
        if needsExtraRestElement {
            todo!();
            // let restParamSymbol =
            //     self.createSymbol(SymbolFlags::FunctionScopedVariable, "args".into(),None);
            //     self.get_transient_sym_mut(restParamSymbol).symbol_links.ty =
            //     self.createArrayType(self.getTypeAtPosition(shorter, longestCount));
            // if shorter == right {
            //     self.get_transient_sym_mut(restParamSymbol).symbol_links.ty = self.instantiateType(self.get_transient_sym(restParamSymbol).symbol_links.ty, mapper);
            // }
            // params[longestCount] = restParamSymbol;
        }
        Rc::new(params)
    }

    fn combineSignaturesOfIntersectionMembers(
        &mut self,
        left: SignatureId,
        right: SignatureId,
    ) -> SignatureId {
        let typeParams = if self.signatures[left].typeParameters.is_some() {
            self.signatures[left].typeParameters.clone()
        } else {
            self.signatures[right].typeParameters.clone()
        };
        let mut paramMapper = None;
        if let (Some(left_params), Some(right_params)) = (
            self.signatures[left].typeParameters.as_ref(),
            self.signatures[right].typeParameters.as_ref(),
        ) {
            paramMapper =
                Some(self.createTypeMapper(right_params.clone(), Some(left_params.clone())));
            // We just use the type parameter defaults from the first signature
        }
        let declaration = self.signatures[left].declaration.clone();
        let params = self.combineIntersectionParameters(left, right, paramMapper.clone());
        let thisParam = self.combineIntersectionThisParam(
            self.signatures[left].thisParameter,
            self.signatures[right].thisParameter,
            paramMapper.clone(),
        );
        let minArgCount = cmp::max(
            self.signatures[left].minArgumentCount,
            self.signatures[right].minArgumentCount,
        );
        let result = self.createSignature(
            declaration,
            typeParams,
            thisParam,
            params,
            /*resolvedReturnType*/ None,
            // /*resolvedTypePredicate*/ undefined,
            minArgCount,
            (self.signatures[left].flags | self.signatures[right].flags)
                & SignatureFlags::PropagatingFlags,
        );
        self.signatures[result].compositeKind = Some(TypeFlags::Intersection);
        let compositeSignatures = if self.signatures[left].compositeKind
            == Some(TypeFlags::Intersection)
            && !self.signatures[left].compositeSignatures.is_empty()
        {
            let mut sigs = self.signatures[left].compositeSignatures.clone();
            Rc::make_mut(&mut sigs).push(right);
            sigs
        } else {
            Rc::new(vec![left, right])
        };
        self.signatures[result].compositeSignatures = compositeSignatures;
        if let Some(paramMapper) = paramMapper {
            self.signatures[result].mapper = if self.signatures[left].compositeKind
                == Some(TypeFlags::Intersection)
                && self.signatures[left].mapper.is_some()
                && !self.signatures[left].compositeSignatures.is_empty()
            {
                Some(TypeMapper::combineTypeMappers(
                    self.signatures[left].mapper.clone(),
                    paramMapper,
                ))
            } else {
                Some(paramMapper)
            };
        }
        result
    }

    // If the given type is an object or union type with a single signature, and if that signature has at
    // least as many parameters as the given function, return the signature. Otherwise return undefined.
    fn getContextualCallSignature(&mut self, ty: TypeId, node: &BoundNode) -> Option<SignatureId> {
        let signatures = self.getSignaturesOfType(ty, SignatureKind::Call);
        let mut applicableByArity = signatures
            .iter()
            .filter(|&&s| !self.isAritySmaller(s, node));
        // if applicableByArity.len() == 1 {
        //     Some(*applicableByArity[0])
        // } else {
        //     todo!();
        //     // self.getIntersectedSignatures(applicableByArity)
        // }
        if let (Some(first), None) = (applicableByArity.next(), applicableByArity.next()) {
            Some(*first)
        } else {
            // TODO it may be worth trying to reuse the above iterator.
            // let applicableByArity = signatures
            //     .iter()
            //     .filter(|&&s| !self.isAritySmaller(s, node))
            //     .cloned();
            // self.getIntersectedSignatures(applicableByArity)
            self.getIntersectedSignatures(&signatures, |checker, s| {
                !checker.isAritySmaller(s, node)
            })
        }
    }

    /** If the contextual signature has fewer parameters than the function expression, do not use it */
    fn isAritySmaller(&mut self, signature: SignatureId, target: &BoundNode) -> bool {
        macro_rules! count_ts_fn_params {
            ($params:expr) => {
                $params.iter().position(|p| match &p.pat {
                    ast::TsAmbientParamPat::Ident(n) => n.id.optional,
                    ast::TsAmbientParamPat::Array(n) => n.optional,
                    ast::TsAmbientParamPat::Rest(_) => true,
                    ast::TsAmbientParamPat::Object(n) => n.optional,
                })
            };
        }
        macro_rules! check_pat {
            ($pat:expr) => {
                match $pat {
                    ast::Pat::Ident(n) => n.id.optional,
                    ast::Pat::Array(n) => n.optional,
                    ast::Pat::Object(n) => n.optional,
                    ast::Pat::Rest(_) | ast::Pat::Assign(_) => true,
                    _ => false,
                }
            };
        }
        macro_rules! count_params {
            ($params:expr) => {
                $params.iter().position(|p| check_pat!(&p.pat))
            };
        }
        let targetParameterCount = match target {
            // todo: jsdoc
            // BoundNode::JSDocSignature
            // | BoundNode::JSDocFunctionType(_)
            BoundNode::TsCallSignatureDecl(n) => count_ts_fn_params!(n.params),
            BoundNode::TsConstructSignatureDecl(n) => count_ts_fn_params!(n.params),
            BoundNode::TsMethodSignature(n) => count_ts_fn_params!(n.params),
            BoundNode::TsIndexSignature(n) => count_ts_fn_params!(n.params),
            BoundNode::TsFnType(n) => count_ts_fn_params!(n.params),
            BoundNode::TsConstructorType(n) => count_ts_fn_params!(n.params),
            BoundNode::FnDecl(n) => count_params!(n.function.params),
            BoundNode::PrivateMethod(n) => count_params!(n.function.params),
            BoundNode::ClassMethod(n) => count_params!(n.function.params),
            BoundNode::MethodProp(n) => count_params!(n.function.params),
            BoundNode::Constructor(n) => n.params.iter().position(|p| match p {
                ast::ParamOrTsParamProp::TsParamProp(p) => match &p.param {
                    ast::TsParamPropParam::Ident(n) => n.id.optional,
                    ast::TsParamPropParam::Assign(_) => true,
                },
                ast::ParamOrTsParamProp::Param(p) => check_pat!(&p.pat),
            }),
            BoundNode::SetterProp(n) => Some(if check_pat!(&n.param.pat) { 0 } else { 1 }),
            BoundNode::FnExpr(n) => count_params!(n.function.params),
            BoundNode::ArrowExpr(n) => n.params.iter().position(|p| check_pat!(&p.pat)),
            _ => unreachable!(),
        };
        let mut targetParameterCount = targetParameterCount.unwrap_or_default();
        if hasThisParameter(target) {
            targetParameterCount -= 1;
        }
        !self.hasEffectiveRestParameter(signature)
            && self.getParameterCount(signature) < targetParameterCount
    }

    fn getContextualSignatureForFunctionLikeDeclaration(
        &mut self,
        node: &BoundNode,
    ) -> Option<SignatureId> {
        // Only function expressions, arrow functions, and object literal methods are contextually typed.
        if matches!(
            node,
            BoundNode::FnExpr(_) | BoundNode::ArrowExpr(_) | BoundNode::MethodProp(_)
        ) {
            self.getContextualSignature(node)
        } else {
            None
        }
    }

    // Return the contextual signature for a given expression node. A contextual type provides a
    // contextual signature if it has a single call signature and if that call signature is non-generic.
    // If the contextual type is a union type, get the signature from each type possible and if they are
    // all identical ignoring their return type, the result is same signature but with return type as
    // union type of return types from these signatures
    fn getContextualSignature(&mut self, node: &BoundNode) -> Option<SignatureId> {
        debug_assert!(matches!(
            node,
            BoundNode::FnExpr(_) | BoundNode::ArrowExpr(_) | BoundNode::MethodProp(_)
        ));
        let typeTagSignature = self.getSignatureOfTypeTag(node);
        if typeTagSignature.is_some() {
            return typeTagSignature;
        }
        if let Some(ty) =
            self.getApparentTypeOfContextualType(node.clone(), Some(ContextFlags::Signature))
        {
            if !self.types[ty].get_flags().intersects(TypeFlags::Union) {
                return self.getContextualCallSignature(ty, node);
            }
            todo!();
            // let signatureList: Signature[] | undefined;
            // let types = (ty as UnionType).types;
            // for (const current of types) {
            //     let signature = getContextualCallSignature(current, node);
            //     if (signature) {
            //         if (!signatureList) {
            //             // This signature will contribute to contextual union signature
            //             signatureList = [signature];
            //         }
            //         else if (!compareSignaturesIdentical(signatureList[0], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ true, /*ignoreReturnTypes*/ true, compareTypesIdentical)) {
            //             // Signatures aren't identical, do not use
            //             return undefined;
            //         }
            //         else {
            //             // Use this signature for contextual union signature
            //             signatureList.push(signature);
            //         }
            //     }
            // }
            // // Result is union of signatures collected (return type is union of return types of this signature set)
            // if (signatureList) {
            //     return signatureList.length == 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList);
            // }
        } else {
            None
        }
    }

    fn checkSpreadExpression(
        &mut self,
        node: &Rc<SpreadElement>,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        // todo:
        // if (languageVersion < ScriptTarget.ES2015) {
        //     checkExternalEmitHelpers(node, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray);
        // }

        let arrayOrIterableType =
            self.checkExpression(node.expr.bind(node.clone().into()), checkMode, false);
        self.checkIteratedTypeOrElementType(
            IterationUse::Spread,
            arrayOrIterableType,
            self.undefinedType,
            Some(node.expr.bind(node.clone().into())),
        )
    }

    // TODO:
    // checkSyntheticExpression
    // TODO:
    // hasDefaultValue
    // TODO:
    // checkArrayLiteral
    // TODO:
    // createArrayLiteralType
    // TODO:
    // isNumericName
    // TODO:
    // isNumericComputedName

    // TODO:
    // checkComputedPropertyName
    // TODO:
    // isSymbolWithNumericName
    // TODO:
    // isSymbolWithSymbolName
    // TODO:
    // getObjectLiteralIndexInfo
    // TODO:
    // getImmediateAliasedSymbol

    fn checkObjectLiteral(&mut self, node: &Rc<ObjectLit>, checkMode: Option<CheckMode>) -> TypeId {
        let bound_node = BoundNode::ObjectLit(node.clone());
        let inDestructuringPattern = isAssignmentTarget(bound_node.clone());
        // TODO: grammer checking:
        // Grammar checking
        // self.checkGrammarObjectLiteralExpression(node, inDestructuringPattern);

        let allPropertiesTable = if self.strictNullChecks {
            Some(self.symbol_tables.push(SymbolTable::new()))
        } else {
            None
        };
        let mut propertiesTable = self.symbol_tables.push(SymbolTable::new());
        let mut propertiesArray = Vec::new();
        let mut spread = self.emptyObjectType;

        let contextualType = self.getApparentTypeOfContextualType(bound_node.clone(), None);
        // TODO:
        // let contextualTypeHasPattern = contextualType.is_some()
        //     && contextualType.pattern
        //     && (contextualType.pattern.kind == SyntaxKind.ObjectBindingPattern
        //         || contextualType.pattern.kind == SyntaxKind.ObjectLiteralExpression);
        let contextualTypeHasPattern = if contextualType.is_some()
            && self.types[contextualType.unwrap()].get_pattern().is_some()
        {
            todo!("see above");
        } else {
            false
        };
        let inConstContext = isConstContext(&bound_node);
        let checkFlags = if inConstContext {
            CheckFlags::Readonly
        } else {
            CheckFlags::empty()
        };
        let isInJavascript = isBoundNodeInJSFile(&bound_node) && !isInJsonFile(Some(&bound_node));
        // TODO: jsdoc
        // let enumTag = getJSDocEnumTag(node);
        // let isJSObjectLiteral = contextualType.is_none() && isInJavascript && enumTag.is_none();
        let isJSObjectLiteral = contextualType.is_none() && isInJavascript;
        let mut objectFlags = self.freshObjectLiteralFlag;
        let mut patternWithComputedProperties = false;
        let mut hasComputedStringProperty = false;
        let mut hasComputedNumberProperty = false;
        let mut hasComputedSymbolProperty = false;

        // TODO:
        // Spreads may cause an early bail; ensure computed names are always checked (this is cached)
        // As otherwise they may not be checked until exports for the type at this position are retrieved,
        // which may never occur.
        // for elem in &node.props {
        //     if (elem.name && isComputedPropertyName(elem.name)) {
        //         checkComputedPropertyName(elem.name);
        //     }
        // }

        let mut offset = 0;
        for memberDecl in &node.props {
            let bound_member_decl = memberDecl.bind(bound_node.clone());
            let mut member = self.getSymbolOfNode(bound_member_decl).unwrap();
            let computedNameType =
                if let BoundNode::ComputedPropName(name) = memberDecl.name(bound_node.clone()) {
                    todo!();
                    // self.checkComputedPropertyName(name.into())
                } else {
                    None
                };
            match &memberDecl {
                ast::Prop::KeyValue(_) | ast::Prop::Shorthand(_) | ast::Prop::Method(_) => {
                    let mut ty = match &memberDecl {
                        ast::Prop::KeyValue(n) => self.checkPropertyAssignment(
                            &KeyValueProp::new(n.clone(), Some(bound_node.clone())),
                            checkMode,
                        ),
                        ast::Prop::Shorthand(n) => {
                            // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring
                            // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`.
                            // we don't want to say "could not find 'a'".
                            todo!();
                            // self.checkExpressionForMutableLocation(
                            //     if !inDestructuringPattern && memberDecl.objectAssignmentInitializer {
                            //         memberDecl.objectAssignmentInitializer
                            //     } else {
                            //         memberDecl.name
                            //     },
                            //     checkMode,
                            //     None,
                            //     false,
                            // )
                        }
                        ast::Prop::Method(n) => {
                            todo!();
                            // self.checkObjectLiteralMethod(memberDecl, checkMode)
                        }
                        _ => unreachable!(),
                    };
                    if isInJavascript {
                        todo!();
                        // let jsDocType = self.getTypeForDeclarationFromJSDocComment(memberDecl);
                        // if (jsDocType) {
                        //     self.checkTypeAssignableTo(ty, jsDocType, memberDecl);
                        //     ty = jsDocType;
                        // }
                        // else if (enumTag && enumTag.typeExpression) {
                        //     self.checkTypeAssignableTo(ty, self.getTypeFromTypeNode(enumTag.typeExpression), memberDecl);
                        // }
                    }
                    objectFlags |=
                        self.types[ty].get_object_flags() & ObjectFlags::PropagatingFlags;
                    let nameType = if computedNameType.is_some()
                        && self.isTypeUsableAsPropertyName(computedNameType.unwrap())
                    {
                        computedNameType
                    } else {
                        None
                    };
                    let prop = if let Some(nameType) = nameType {
                        self.createSymbol(
                            SymbolFlags::Property | self.symbols[member].flags(),
                            self.getPropertyNameFromType(nameType),
                            Some(checkFlags | CheckFlags::Late),
                        )
                    } else {
                        self.createSymbol(
                            SymbolFlags::Property | self.symbols[member].flags(),
                            self.symbols[member].escapedName().clone(),
                            Some(checkFlags),
                        )
                    };
                    if nameType.is_some() {
                        self.symbols[prop]
                            .as_transient_symbol_mut()
                            .symbol_links
                            .nameType = nameType;
                    }

                    if inDestructuringPattern {
                        todo!();
                        // If object literal is an assignment pattern and if the assignment pattern specifies a default value
                        // for the property, make the property optional.
                        // let isOptional =
                        //     (memberDecl.kind == SyntaxKind.PropertyAssignment && hasDefaultValue(memberDecl.initializer)) ||
                        //     (memberDecl.kind == SyntaxKind.ShorthandPropertyAssignment && memberDecl.objectAssignmentInitializer);
                        // if (isOptional) {
                        //     prop.flags |= SymbolFlags.Optional;
                        // }
                    } else if contextualTypeHasPattern
                        && (contextualType.is_none()
                            || !self.types[contextualType.unwrap()]
                                .get_object_flags()
                                .intersects(
                                    ObjectFlags::ObjectLiteralPatternWithComputedProperties,
                                ))
                    {
                        todo!();
                        // If object literal is contextually typed by the implied type of a binding pattern, and if the
                        // binding pattern specifies a default value for the property, make the property optional.
                        // let impliedProp = getPropertyOfType(contextualType, member.escapedName);
                        // if (impliedProp) {
                        //     prop.flags |= impliedProp.flags & SymbolFlags.Optional;
                        // }

                        // else if (!compilerOptions.suppressExcessPropertyErrors && !getIndexInfoOfType(contextualType, stringType)) {
                        //     error(memberDecl.name, Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1,
                        //         symbolToString(member), typeToString(contextualType));
                        // }
                    }

                    let prop_sym = &mut self.symbols[prop];

                    // TODO: bad vec clone?
                    *self.symbols[prop].declarations_mut() =
                        self.symbols[member].declarations().clone();
                    *self.symbols[prop].parent_mut() = self.symbols[member].parent();
                    if self.symbols[member].valueDeclaration().is_some() {
                        *self.symbols[prop].valueDeclaration_mut() =
                            self.symbols[member].valueDeclaration().clone();
                    }

                    self.symbols[prop].as_transient_symbol_mut().symbol_links.ty = Some(ty);
                    self.symbols[prop]
                        .as_transient_symbol_mut()
                        .symbol_links
                        .target = Some(member);
                    member = prop;
                    if let Some(allPropertiesTable) = allPropertiesTable {
                        self.symbol_tables[allPropertiesTable]
                            .insert(self.symbols[prop].escapedName().clone(), prop);
                    }
                }
                ast::Prop::Spread(_) => {
                    todo!();
                    // if (languageVersion < ScriptTarget.ES2015) {
                    //     checkExternalEmitHelpers(memberDecl, ExternalEmitHelpers.Assign);
                    // }
                    // if (propertiesArray.length > 0) {
                    //     spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
                    //     propertiesArray = [];
                    //     propertiesTable = createSymbolTable();
                    //     hasComputedStringProperty = false;
                    //     hasComputedNumberProperty = false;
                    //     hasComputedSymbolProperty = false;
                    // }
                    // let ty = getReducedType(checkExpression(memberDecl.expression));
                    // if (isValidSpreadType(ty)) {
                    //     let mergedType = tryMergeUnionOfObjectTypeAndEmptyObject(ty, inConstContext);
                    //     if (allPropertiesTable) {
                    //         checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl);
                    //     }
                    //     offset = propertiesArray.length;
                    //     if (isErrorType(spread)) {
                    //         continue;
                    //     }
                    //     spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext);
                    // }
                    // else {
                    //     error(memberDecl, Diagnostics.Spread_types_may_only_be_created_from_object_types);
                    //     spread = errorType;
                    // }
                    // continue;
                }
                ast::Prop::Getter(_) | ast::Prop::Setter(_) => {
                    todo!();
                    // TypeScript 1.0 spec (April 2014)
                    // A get accessor declaration is processed in the same manner as
                    // an ordinary function declaration(section 6.1) with no parameters.
                    // A set accessor declaration is processed in the same manner
                    // as an ordinary function declaration with a single parameter and a Void return type.
                    // Debug.assert(memberDecl.kind == SyntaxKind.GetAccessor || memberDecl.kind == SyntaxKind.SetAccessor);
                    // checkNodeDeferred(memberDecl);
                }
                _ => unreachable!(),
            }

            if computedNameType.is_some()
                && !self.types[computedNameType.unwrap()]
                    .get_flags()
                    .intersects(TypeFlags::StringOrNumberLiteralOrUnique)
            {
                todo!();
                // if (isTypeAssignableTo(computedNameType, stringNumberSymbolType)) {
                //     if (isTypeAssignableTo(computedNameType, numberType)) {
                //         hasComputedNumberProperty = true;
                //     }
                //     else if (isTypeAssignableTo(computedNameType, esSymbolType)) {
                //         hasComputedSymbolProperty = true;
                //     }
                //     else {
                //         hasComputedStringProperty = true;
                //     }
                //     if (inDestructuringPattern) {
                //         patternWithComputedProperties = true;
                //     }
                // }
            } else {
                self.symbol_tables[propertiesTable]
                    .insert(self.symbols[member].escapedName().clone(), member);
            }
            propertiesArray.push(member);
        }

        // If object literal is contextually typed by the implied type of a binding pattern, augment the result
        // type with those properties for which the binding pattern specifies a default value.
        // If the object literal is spread into another object literal, skip this step and let the top-level object
        // literal handle it instead.
        if contextualTypeHasPattern && !matches!(&node.parent, Some(BoundNode::SpreadAssignment(_)))
        {
            todo!();
            // for (let prop of getPropertiesOfType(contextualType)) {
            //     if (!propertiesTable.get(prop.escapedName) && !getPropertyOfType(spread, prop.escapedName)) {
            //         if (!(prop.flags & SymbolFlags.Optional)) {
            //             error(prop.valueDeclaration || (prop as TransientSymbol).bindingElement,
            //                 Diagnostics.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
            //         }
            //         propertiesTable.set(prop.escapedName, prop);
            //         propertiesArray.push(prop);
            //     }
            // }
        }

        if self.isErrorType(spread) {
            return self.errorType;
        }

        if spread != self.emptyObjectType {
            todo!();
            // if (propertiesArray.length > 0) {
            //     spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
            //     propertiesArray = [];
            //     propertiesTable = createSymbolTable();
            //     hasComputedStringProperty = false;
            //     hasComputedNumberProperty = false;
            // }
            // // remap the raw emptyObjectType fed in at the top into a fresh empty object literal type, unique to this use site
            // return mapType(spread, t => t === emptyObjectType ? createObjectLiteralType() : t);
        }

        return createObjectLiteralType(
            self,
            propertiesTable,
            bound_node,
            objectFlags,
            hasComputedStringProperty,
            hasComputedNumberProperty,
            hasComputedSymbolProperty,
            isJSObjectLiteral,
            patternWithComputedProperties,
            inDestructuringPattern,
        );

        fn createObjectLiteralType(
            checker: &mut Checker,
            propertiesTable: SymbolTableId,
            bound_node: BoundNode,
            objectFlags: ObjectFlags,
            hasComputedStringProperty: bool,
            hasComputedNumberProperty: bool,
            hasComputedSymbolProperty: bool,
            isJSObjectLiteral: bool,
            patternWithComputedProperties: bool,
            inDestructuringPattern: bool,
        ) -> TypeId {
            let mut indexInfos = Vec::new();
            if hasComputedStringProperty {
                todo!();
                // indexInfos.push(self.getObjectLiteralIndexInfo(
                //     node,
                //     offset,
                //     propertiesArray,
                //     self.stringType,
                // ));
            }
            if hasComputedNumberProperty {
                todo!();
                // indexInfos.push(self.getObjectLiteralIndexInfo(
                //     node,
                //     offset,
                //     propertiesArray,
                //     self.numberType,
                // ));
            }
            if hasComputedSymbolProperty {
                todo!();
                // indexInfos.push(self.getObjectLiteralIndexInfo(
                //     node,
                //     offset,
                //     propertiesArray,
                //     self.esSymbolType,
                // ));
            }
            let symbol = checker.node_data(bound_node.clone()).symbol;
            let result = checker.createAnonymousType(
                symbol,
                propertiesTable,
                Rc::default(),
                Rc::default(),
                Rc::new(indexInfos),
            );
            *checker.types[result].get_object_flags_mut() |= objectFlags
                | ObjectFlags::ObjectLiteral
                | ObjectFlags::ContainsObjectOrArrayLiteral;
            if isJSObjectLiteral {
                *checker.types[result].get_object_flags_mut() |= ObjectFlags::JSLiteral;
            }
            if patternWithComputedProperties {
                *checker.types[result].get_object_flags_mut() |=
                    ObjectFlags::ObjectLiteralPatternWithComputedProperties;
            }
            if inDestructuringPattern {
                *checker.types[result].get_pattern_mut() = Some(bound_node);
            }
            result
        };
    }

    // TODO:
    // isValidSpreadType
    // TODO:
    // checkJsxSelfClosingElementDeferred
    // TODO:
    // checkJsxSelfClosingElement
    // TODO:
    // checkJsxElementDeferred
    // TODO:
    // checkJsxElement
    // TODO:
    // checkJsxFragment
    // TODO:
    // isHyphenatedJsxName
    // TODO:
    // isJsxIntrinsicIdentifier
    // TODO:
    // checkJsxAttribute
    // TODO:
    // createJsxAttributesTypeFromAttributesProperty
    // TODO:
    // checkJsxChildren
    // TODO:
    // checkSpreadPropOverrides
    // TODO:
    // checkJsxAttributes
    // TODO:
    // getJsxType
    // TODO:
    // getIntrinsicTagSymbol
    // TODO:
    // getJsxNamespaceContainerForImplicitImport
    // TODO:
    // getJsxNamespaceAt
    // TODO:
    // getNameFromJsxElementAttributesContainer
    // TODO:
    // getJsxLibraryManagedAttributes
    // TODO:
    // getJsxElementPropertiesName
    // TODO:
    // getJsxElementChildrenPropertyName
    // TODO:
    // getUninstantiatedJsxSignaturesOfType
    // TODO:
    // getIntrinsicAttributesTypeFromStringLiteralType
    // TODO:
    // checkJsxReturnAssignableToAppropriateBound
    // TODO:
    // getIntrinsicAttributesTypeFromJsxOpeningLikeElement
    // TODO:
    // getJsxElementClassTypeAt
    // TODO:
    // getJsxElementTypeAt
    // TODO:
    // getJsxStatelessElementTypeAt
    // TODO:
    // getJsxIntrinsicTagNamesAt
    // TODO:
    // checkJsxPreconditions
    // TODO:
    // checkJsxOpeningLikeElementOrOpeningFragment
    // TODO:
    // isKnownProperty
    // TODO:
    // isExcessPropertyCheckTarget
    // TODO:
    // checkJsxExpression

    fn getDeclarationNodeFlagsFromSymbol(&self, s: SymbolId) -> NodeFlags {
        self.symbols[s]
            .valueDeclaration()
            .as_ref()
            .map(|vd| getCombinedNodeFlags(vd))
            .unwrap_or_default()
    }

    /**
     * Return whether this symbol is a member of a prototype somewhere
     * Note that this is not tracked well within the compiler, so the answer may be incorrect.
     */
    fn isPrototypeProperty(&self, symbol: SymbolId) -> bool {
        if self.symbols[symbol].flags().intersects(SymbolFlags::Method)
            || getCheckFlags(&self.symbols[symbol]).intersects(CheckFlags::SyntheticMethod)
        {
            return true;
        }
        if isInJSFile(self.symbols[symbol].valueDeclaration().as_ref()) {
            let parent = self.symbols[symbol]
                .valueDeclaration()
                .as_ref()
                .unwrap()
                .parent();
            return matches!(parent, Some(BoundNode::AssignExpr(p)) if getAssignmentDeclarationKind(&ast::Expr::Assign(p.node.clone())) == AssignmentDeclarationKind::PrototypeProperty);
        }
        false
    }

    // TODO:
    // checkPropertyAccessibility
    // TODO:
    // checkPropertyAccessibilityAtLocation
    // TODO:
    // getThisParameterFromNodeContext
    // TODO:
    // symbolHasNonMethodDeclaration

    fn checkNonNullExpression(&mut self, node: BoundNode) -> TypeId {
        let ty = self.checkExpression(node.clone(), None, false);
        self.checkNonNullType(ty, node)
    }

    // TODO:
    // isNullableType
    // TODO:
    // getNonNullableTypeIfNeeded
    // TODO:
    // reportObjectPossiblyNullOrUndefinedError
    // TODO:
    // reportCannotInvokePossiblyNullOrUndefinedError

    fn checkNonNullTypeWithReporter(
        &mut self,
        ty: TypeId,
        node: BoundNode,
        // reportError: (node: Node, kind: TypeFlags) => void
    ) -> TypeId {
        let type_flags = self.types[ty].get_flags();
        if self.strictNullChecks && type_flags.intersects(TypeFlags::Unknown) {
            todo!();
            // error(node, Diagnostics.Object_is_of_type_unknown);
            // return errorType;
        }
        let kind = if self.strictNullChecks {
            self.getFalsyFlags(ty) & TypeFlags::Nullable
        } else {
            type_flags & TypeFlags::Nullable
        };
        if !kind.is_empty() {
            // TODO: error
            // reportError(node, kind);
            let t = self.getNonNullableType(ty);
            return if self.types[t]
                .get_flags()
                .intersects(TypeFlags::Nullable | TypeFlags::Never)
            {
                self.errorType
            } else {
                t
            };
        }
        ty
    }

    fn checkNonNullType(&mut self, ty: TypeId, node: BoundNode) -> TypeId {
        // TODO:
        // self.checkNonNullTypeWithReporter(ty, node, reportObjectPossiblyNullOrUndefinedError)
        self.checkNonNullTypeWithReporter(ty, node)
    }

    // TODO:
    // checkNonNullNonVoidType

    fn checkPropertyAccessExpression(
        &mut self,
        bound_node: BoundNode,
        node: Rc<MemberExpr>,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        // TODO: optional chain
        // if node.flags & NodeFlags::OptionalChain {
        // self.checkPropertyAccessChain(node as PropertyAccessChain, checkMode)
        // } else {
        let left_type = self.checkNonNullExpression(node.obj.bind(bound_node.clone()));
        self.checkPropertyAccessExpressionOrQualifiedName(
            bound_node.clone(),
            node.obj.bind(bound_node.clone()),
            left_type,
            node.prop.bind(bound_node),
            checkMode,
        )
        // }
    }

    // TODO:
    // checkPropertyAccessChain
    // TODO:
    // checkQualifiedName
    // TODO:
    // isMethodAccessForCall
    // TODO:
    // lookupSymbolForPrivateIdentifierDeclaration
    // TODO:
    // checkGrammarPrivateIdentifierExpression
    // TODO:
    // checkPrivateIdentifierExpression
    // TODO:
    // getSymbolForPrivateIdentifierExpression
    // TODO:
    // getPrivateIdentifierPropertyOfType
    // TODO:
    // checkPrivateIdentifierPropertyAccess

    fn isThisPropertyAccessInConstructor(&mut self, node: BoundNode, prop: SymbolId) -> bool {
        (self.isConstructorDeclaredProperty(prop)
            || isThisProperty(&node) && self.isAutoTypedProperty(prop))
            && Some(getThisContainer(node, true)) == self.getDeclaringConstructor(prop)
    }

    fn checkPropertyAccessExpressionOrQualifiedName(
        &mut self,
        node: BoundNode,
        left: BoundNode,
        leftType: TypeId,
        right: BoundNode,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        let parentSymbol = self.getNodeLinks(left.clone()).resolvedSymbol;
        let assignmentKind = getAssignmentTargetKind(node.clone());
        let apparentType =
            if assignmentKind != AssignmentKind::None || isMethodAccessForCall(node.clone()) {
                self.getWidenedType(leftType)
            } else {
                leftType
            };
        let apparentType = self.getApparentType(apparentType);
        let isAnyLike = self.isTypeAny(Some(apparentType)) || apparentType == self.silentNeverType;
        let prop = if let BoundNode::PrivateName(right) = right {
            todo!();
            // if (languageVersion < ScriptTarget.ESNext) {
            //     if (assignmentKind !== AssignmentKind.None) {
            //         checkExternalEmitHelpers(node, ExternalEmitHelpers.ClassPrivateFieldSet);
            //     }
            //     if (assignmentKind !== AssignmentKind.Definite) {
            //         checkExternalEmitHelpers(node, ExternalEmitHelpers.ClassPrivateFieldGet);
            //     }
            // }

            // const lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right);
            // if (assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration)) {
            //     grammarErrorOnNode(right, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, idText(right));
            // }

            // if (lexicallyScopedSymbol?.valueDeclaration && (getEmitScriptTarget(compilerOptions) === ScriptTarget.ESNext && !useDefineForClassFields)) {
            //     const lexicalClass = getContainingClass(lexicallyScopedSymbol.valueDeclaration);
            //     const parentStaticFieldInitializer = findAncestor(node, (n) => {
            //         if (n === lexicalClass) return "quit";
            //         if (isPropertyDeclaration(n.parent) && hasStaticModifier(n.parent) && n.parent.initializer === n && n.parent.parent === lexicalClass) {
            //             return true;
            //         }
            //         return false;
            //     });
            //     if (parentStaticFieldInitializer) {
            //         const parentStaticFieldInitializerSymbol = getSymbolOfNode(parentStaticFieldInitializer.parent);
            //         Debug.assert(parentStaticFieldInitializerSymbol, "Initializer without declaration symbol");
            //         const diagnostic = error(node,
            //             Diagnostics.Property_0_may_not_be_used_in_a_static_property_s_initializer_in_the_same_class_when_target_is_esnext_and_useDefineForClassFields_is_false,
            //             symbolName(lexicallyScopedSymbol));
            //         addRelatedInfo(diagnostic,
            //             createDiagnosticForNode(parentStaticFieldInitializer.parent,
            //                 Diagnostics.Initializer_for_property_0,
            //                 symbolName(parentStaticFieldInitializerSymbol))
            //         );
            //     }
            // }

            // if (isAnyLike) {
            //     if (lexicallyScopedSymbol) {
            //         return isErrorType(apparentType) ? errorType : apparentType;
            //     }
            //     if (!getContainingClass(right)) {
            //         grammarErrorOnNode(right, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
            //         return anyType;
            //     }
            // }
            // prop = lexicallyScopedSymbol ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol) : undefined;
            // // Check for private-identifier-specific shadowing and lexical-scoping errors.
            // if (!prop && checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol)) {
            //     return errorType;
            // }
            // else {
            //     const isSetonlyAccessor = prop && prop.flags & SymbolFlags::SetAccessor && !(prop.flags & SymbolFlags::GetAccessor);
            //     if (isSetonlyAccessor && assignmentKind !== AssignmentKind.Definite) {
            //         error(node, Diagnostics.Private_accessor_was_defined_without_a_getter);
            //     }
            // }
        } else if let BoundNode::Ident(right) = &right {
            if isAnyLike {
                if matches!(left, BoundNode::Ident(_)) {
                    if let Some(parentSymbol) = parentSymbol {
                        self.markAliasReferenced(parentSymbol, node);
                    }
                }
                return if self.isErrorType(apparentType) {
                    self.errorType
                } else {
                    apparentType
                };
            }
            self.getPropertyOfType(apparentType, &right.sym, false)
        } else {
            unreachable!();
        };
        // In `Foo.Bar.Baz`, 'Foo' is not referenced if 'Bar' is a const enum or a module containing only const enums.
        // The exceptions are:
        //   1. if 'isolatedModules' is enabled, because the const enum value will not be inlined, and
        //   2. if 'preserveConstEnums' is enabled and the expression is itself an export, e.g. `export = Foo.Bar.Baz`.
        if matches!(left, BoundNode::Ident(_)) {
            if let Some(parentSymbol) = parentSymbol {
                if self.compilerOptions.isolatedModules
                    || !(prop.is_some() && self.isConstEnumOrConstEnumOnlyModule(prop.unwrap()))
                // todo:
                // || shouldPreserveConstEnums(compilerOptions)
                //     && isExportOrExportExpression(node)
                {
                    self.markAliasReferenced(parentSymbol, node.clone());
                }
            }
        }

        let propType = if let Some(prop) = prop {
            // TODO:
            // if (prop.declarations && getDeclarationNodeFlagsFromSymbol(prop) & NodeFlags.Deprecated && isUncalledFunctionReference(node, prop)) {
            //     addDeprecatedSuggestion(right, prop.declarations, right.escapedText as string);
            // }
            // BIG TODOS: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            // self.checkPropertyNotUsedBeforeDeclaration(prop, node, right);
            // self.markPropertyAsReferenced(prop, node, self.isSelfTypeAccess(left, parentSymbol));
            self.getNodeLinks_mut(node.clone()).resolvedSymbol = Some(prop);
            let writing = isWriteAccess(&node);
            // BIG TODOS: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            // self.checkPropertyAccessibility(
            //     node,
            //     matches!(left, BoundNode::Super(_)),
            //     writing,
            //     apparentType,
            //     prop,
            // );
            // BIG TODOS: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            // if isAssignmentToReadonlyEntity(node as Expression, prop, assignmentKind) {
            //     todo!();
            //     // error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right));
            //     // return errorType;
            // }

            if self.isThisPropertyAccessInConstructor(node.clone(), prop) {
                self.autoType
            } else if writing {
                self.getSetAccessorTypeOfSymbol(prop)
            } else {
                self.getTypeOfSymbol(prop)
            }
        } else {
            let mut indexInfo = None;
            if let BoundNode::Ident(i) = &right {
                if (assignmentKind == AssignmentKind::None
                    || !self.isGenericObjectType(leftType)
                    || self.isThisTypeParameter(leftType))
                {
                    indexInfo = self.getApplicableIndexInfoForName(apparentType, &i.sym);
                }
            }
            if let Some(indexInfo) = indexInfo {
                if self.index_infos[indexInfo].isReadonly
                    && (isAssignmentTarget(node.clone()) || isDeleteTarget(node.clone()))
                {
                    todo!();
                    // error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType));
                }

                let propType = if self.compilerOptions.noUncheckedIndexedAccess
                    && !isAssignmentTarget(node.clone())
                {
                    todo!();
                    // getUnionType([indexInfo.ty, undefinedType])
                } else {
                    self.index_infos[indexInfo].ty
                };
                if self.compilerOptions.noPropertyAccessFromIndexSignature
                    && matches!(&node, BoundNode::MemberExpr(m)if!m.computed)
                {
                    todo!();
                    // error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.escapedText));
                }
                propType
            } else {
                // TODO:
                // let isUncheckedJS = isUncheckedJSSuggestion(node, leftType.symbol, /*excludeClasses*/ true);
                // if !isUncheckedJS && isJSLiteralType(leftType) {
                //     return anyType;
                // }
                if self.types[leftType].get_symbol() == &Some(self.globalThisSymbol) {
                    // TODO: errors
                    // if (globalThisSymbol.exports!.has(right.escapedText) && (globalThisSymbol.exports!.get(right.escapedText)!.flags & SymbolFlags::BlockScoped)) {
                    //     error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.escapedText), typeToString(leftType));
                    // }
                    // else if (noImplicitAny) {
                    //     error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType));
                    // }
                    return self.anyType;
                }
                // TODO:
                // if (right.escapedText && !checkAndReportErrorForExtendingInterface(node)) {
                //     reportNonexistentProperty(right, isThisTypeParameter(leftType) ? apparentType : leftType, isUncheckedJS);
                // }
                return self.errorType;
            }
        };

        self.getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode)
    }

    // TODO:
    // isUncheckedJSSuggestion

    fn getFlowTypeOfAccessExpression(
        &mut self,
        node: BoundNode,
        prop: Option<SymbolId>,
        mut propType: TypeId,
        errorNode: BoundNode,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        // Only compute control flow type if this is a property access expression that isn't an
        // assignment target, and the referenced property was declared as a variable, property,
        // accessor, or optional method.
        let assignmentKind = getAssignmentTargetKind(node.clone());
        if assignmentKind == AssignmentKind::Definite {
            let isOptional = prop.is_some()
                && self.symbols[prop.unwrap()]
                    .flags()
                    .intersects(SymbolFlags::Optional);
            return self.removeMissingType(propType, isOptional);
        }
        if let Some(prop) = prop {
            if !self.symbols[prop]
                .flags()
                .intersects(SymbolFlags::Variable | SymbolFlags::Property | SymbolFlags::Accessor)
                && !(self.symbols[prop].flags().intersects(SymbolFlags::Method)
                    && self.types[propType]
                        .get_flags()
                        .intersects(TypeFlags::Union))
                && !isDuplicatedCommonJSExport(self.symbols[prop].declarations())
            {
                return propType;
            }
        }
        if propType == self.autoType {
            todo!();
            // return getFlowTypeOfProperty(node, prop);
        }
        propType = self.getNarrowableTypeForReference(propType, node.clone(), checkMode);
        // If strict null checks and strict property initialization checks are enabled, if we have
        // a this.xxx property access, if the property is an instance property without an initializer,
        // and if we are in a constructor of the same class as the property declaration, assume that
        // the property is uninitialized at the top of the control flow.
        let mut assumeUninitialized = false;
        if self.strictNullChecks
            && self.strictPropertyInitialization
            && matches!(&node, BoundNode::MemberExpr(m) if matches!(m.obj, ast::ExprOrSuper::Expr(ast::Expr::This(_))))
        {
            todo!();
            // let declaration = prop && prop.valueDeclaration;
            // if (declaration && isPropertyWithoutInitializer(declaration)) {
            //     if (!isStatic(declaration)) {
            //         let flowContainer = getControlFlowContainer(node);
            //         if (flowContainer.kind == SyntaxKind.Constructor && flowContainer.parent == declaration.parent && !(declaration.flags & NodeFlags.Ambient)) {
            //             assumeUninitialized = true;
            //         }
            //     }
            // }
        } else if let Some(prop) = prop {
            if let Some(valueDeclaration) = self.symbols[prop].valueDeclaration() {
                if self.strictNullChecks
                    && matches!(valueDeclaration, BoundNode::MemberExpr(m) if !m.computed && getAssignmentDeclarationPropertyAccessKind(&m.node) != AssignmentDeclarationKind::None)
                    && getControlFlowContainer(&node) == getControlFlowContainer(&valueDeclaration)
                {
                    assumeUninitialized = true;
                }
            }
        }

        let flowType = self.getFlowTypeOfReference(
            &node,
            propType,
            if assumeUninitialized {
                todo!();
                // self.getOptionalType(propType)
            } else {
                propType
            },
            None,
        );
        if assumeUninitialized
            && !self
                .getFalsyFlags(propType)
                .intersects(TypeFlags::Undefined)
            && self
                .getFalsyFlags(flowType)
                .intersects(TypeFlags::Undefined)
        {
            todo!();
            // error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(prop!)); // TODO: GH#18217
            // // Return the declared type to reduce follow-on errors
            // return propType;
        }
        if assignmentKind == AssignmentKind::Compound {
            self.getBaseTypeOfLiteralType(flowType)
        } else {
            flowType
        }
    }

    // TODO:
    // checkPropertyNotUsedBeforeDeclaration
    // TODO:
    // isPropertyDeclaredInAncestorClass
    // TODO:
    // getSuperClass
    // TODO:
    // reportNonexistentProperty
    // TODO:
    // containerSeemsToBeEmptyDomElement
    // TODO:
    // typeHasStaticProperty
    // TODO:
    // getSuggestedLibForNonExistentName
    // TODO:
    // getSuggestedLibForNonExistentProperty
    // TODO:
    // getSuggestedSymbolForNonexistentClassMember
    // TODO:
    // getSuggestedSymbolForNonexistentProperty
    // TODO:
    // getSuggestedSymbolForNonexistentJSXAttribute
    // TODO:
    // getSuggestionForNonexistentProperty
    // TODO:
    // getSuggestedSymbolForNonexistentSymbol
    // TODO:
    // getSuggestionForNonexistentSymbol
    // TODO:
    // getSuggestedSymbolForNonexistentModule
    // TODO:
    // getSuggestionForNonexistentExport
    // TODO:
    // getSuggestionForNonexistentIndexSignature
    // TODO:
    // getSuggestedTypeForNonexistentStringLiteralType
    // TODO:
    // getSpellingSuggestionForName
    // TODO:
    // markPropertyAsReferenced
    // TODO:
    // isSelfTypeAccess
    // TODO:
    // isValidPropertyAccess
    // TODO:
    // isValidPropertyAccessForCompletions
    // TODO:
    // isValidPropertyAccessWithType
    // TODO:
    // isPropertyAccessible
    // TODO:
    // getForInVariableSymbol
    // TODO:
    // hasNumericPropertyNames

    /**
     * Return true if given node is an expression consisting of an identifier (possibly parenthesized)
     * that references a for-in variable for an object with numeric property names.
     */
    fn isForInVariableForNumericPropertyNames(&mut self, expr: BoundNode) -> bool {
        let e = skipParenthesesOfNode(expr);
        if matches!(e, BoundNode::Ident(_)) {
            // const symbol = getResolvedSymbol(e as Identifier);
            // if (symbol.flags & SymbolFlags.Variable) {
            //     let child: Node = expr;
            //     let node = expr.parent;
            //     while (node) {
            //         if (node.kind === SyntaxKind.ForInStatement &&
            //             child === (node as ForInStatement).statement &&
            //             getForInVariableSymbol(node as ForInStatement) === symbol &&
            //             hasNumericPropertyNames(getTypeOfExpression((node as ForInStatement).expression))) {
            //             return true;
            //         }
            //         child = node;
            //         node = node.parent;
            //     }
            // }
        }
        false
    }

    fn checkIndexedAccess(
        &mut self,
        node: &Rc<MemberExpr>,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        debug_assert!(node.computed);
        // TODO: optional chaining
        // if node.flags & NodeFlags.OptionalChain{
        //    self. checkElementAccessChain(node as ElementAccessChain, checkMode)
        // } else {
        let exprType = self.checkNonNullExpression(node.obj.bind(node.clone().into()));
        self.checkElementAccessExpression(node, exprType, checkMode)
        // }
    }

    // TODO:
    // checkElementAccessChain

    fn checkElementAccessExpression(
        &mut self,
        node: &Rc<MemberExpr>,
        exprType: TypeId,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        debug_assert!(node.computed);
        let bound_node = BoundNode::MemberExpr(node.clone());
        let objectType = if getAssignmentTargetKind(bound_node.clone()) != AssignmentKind::None
            || isMethodAccessForCall(bound_node.clone())
        {
            self.getWidenedType(exprType)
        } else {
            exprType
        };
        let indexExpression = &node.prop;
        let boundIndexExpression = node.prop.bind(bound_node.clone());
        let indexType = self.checkExpression(boundIndexExpression.clone(), None, false);

        if self.isErrorType(objectType) || objectType == self.silentNeverType {
            return objectType;
        }

        if self.isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression) {
            todo!();
            // error(indexExpression, Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal);
            // return errorType;
        }

        let effectiveIndexType =
            if self.isForInVariableForNumericPropertyNames(boundIndexExpression.clone()) {
                self.numberType
            } else {
                indexType
            };
        let accessFlags = if isAssignmentTarget(bound_node.clone()) {
            AccessFlags::Writing
                | (if self.isGenericObjectType(objectType) && !self.isThisTypeParameter(objectType)
                {
                    AccessFlags::NoIndexSignatures
                } else {
                    AccessFlags::empty()
                })
        } else {
            AccessFlags::ExpressionPosition
        };
        let indexedAccessType = self
            .getIndexedAccessTypeOrUndefined(
                objectType,
                effectiveIndexType,
                Some(accessFlags),
                Some(bound_node.clone()),
                None,
                None,
            )
            .unwrap_or(self.errorType);
        let propSym = self.getNodeLinks(bound_node.clone()).resolvedSymbol;
        let ty = self.getFlowTypeOfAccessExpression(
            bound_node.clone(),
            propSym,
            indexedAccessType,
            boundIndexExpression,
            checkMode,
        );
        return self.checkIndexedAccessIndexType(ty, &bound_node);
    }

    // TODO:
    // callLikeExpressionMayHaveTypeArguments

    fn resolveUntypedCall(&mut self, node: BoundNode) -> SignatureId {
        // TODO:
        // if (callLikeExpressionMayHaveTypeArguments(node)) {
        //     // Check type arguments even though we will give an error that untyped calls may not accept type arguments.
        //     // This gets us diagnostics for the type arguments and marks them as referenced.
        //     forEach(node.typeArguments, checkSourceElement);
        // }

        // if (node.kind === SyntaxKind.TaggedTemplateExpression) {
        //     checkExpression(node.template);
        // }
        // else if (isJsxOpeningLikeElement(node)) {
        //     checkExpression(node.attributes);
        // }
        // else if (node.kind !== SyntaxKind.Decorator) {
        //     forEach((node as CallExpression).arguments, argument => {
        //         checkExpression(argument);
        //     });
        // }
        self.anySignature
    }

    fn resolveErrorCall(&mut self, node: BoundNode) -> SignatureId {
        self.resolveUntypedCall(node);
        return self.unknownSignature;
    }

    // Re-order candidate signatures into the result array. Assumes the result array to be empty.
    // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
    // A nit here is that we reorder only signatures that belong to the same symbol,
    // so order how inherited signatures are processed is still preserved.
    // interface A { (x: string): void }
    // interface B extends A { (x: 'foo'): string }
    // const b: B;
    // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
    fn reorderCandidates(
        &mut self,
        signatures: Rc<Vec<SignatureId>>,
        result: &mut Vec<SignatureId>,
        callChainFlags: SignatureFlags,
    ) {
        let mut lastParent = None;
        let mut lastSymbol = None;
        let mut cutoffIndex = 0;
        let mut index = 0;
        let mut specializedIndex: isize = -1;
        debug_assert!(result.is_empty());
        for &signature in signatures.iter() {
            let symbol = self.signatures[signature]
                .declaration
                .clone()
                .map(|d| self.getSymbolOfNode(d));
            let parent = self.signatures[signature]
                .declaration
                .as_ref()
                .and_then(|d| d.parent());
            if lastSymbol.is_none() || symbol == lastSymbol {
                if lastParent.is_some() && parent == lastParent {
                    index += 1;
                } else {
                    lastParent = parent;
                    index = cutoffIndex;
                }
            } else {
                // current declaration belongs to a different symbol
                // set cutoffIndex so re-orderings in the future won't change result set from 0 to cutoffIndex
                index = result.len();
                cutoffIndex = result.len();
                lastParent = parent;
            }
            lastSymbol = symbol;

            // specialized signatures always need to be placed before non-specialized signatures regardless
            // of the cutoff position; see GH#1133
            let spliceIndex = if signatureHasLiteralTypes(&self.signatures[signature]) {
                // The cutoff index always needs to be greater than or equal to the specialized signature index
                // in order to prevent non-specialized signatures from being added before a specialized
                // signature.
                cutoffIndex += 1;

                specializedIndex += 1;
                specializedIndex as usize
            } else {
                index
            };

            result.insert(
                spliceIndex,
                if !callChainFlags.is_empty() {
                    self.getOptionalCallSignature(signature, callChainFlags)
                } else {
                    signature
                },
            );
        }
    }

    fn acceptsVoid(&self, t: TypeId) -> bool {
        self.types[t].get_flags().intersects(TypeFlags::Void)
    }

    fn acceptsVoidUndefinedUnknownOrAny(&self, t: TypeId) -> bool {
        self.types[t].get_flags().intersects(
            TypeFlags::Void | TypeFlags::Undefined | TypeFlags::Unknown | TypeFlags::Any,
        )
    }

    fn hasCorrectArity(
        &mut self,
        node: &BoundNode,
        args: &Vec<BoundNode>,
        signature: SignatureId,
        signatureHelpTrailingComma: bool,
    ) -> bool {
        let mut argCount;
        let mut callIsIncomplete = false; // In incomplete call we want to be lenient when we have too few arguments
        let mut effectiveParameterCount = self.getParameterCount(signature);
        let mut effectiveMinimumArguments = self.getMinArgumentCount(signature, None);

        if matches!(node, BoundNode::TaggedTpl(_)) {
            todo!();
            // argCount = args.length;
            // if (node.template.kind === SyntaxKind.TemplateExpression) {
            //     // If a tagged template expression lacks a tail literal, the call is incomplete.
            //     // Specifically, a template only can end in a TemplateTail or a Missing literal.
            //     const lastSpan = last(node.template.templateSpans); // we should always have at least one span.
            //     callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
            // }
            // else {
            //     // If the template didn't end in a backtick, or its beginning occurred right prior to EOF,
            //     // then this might actually turn out to be a TemplateHead in the future;
            //     // so we consider the call to be incomplete.
            //     const templateLiteral = node.template as LiteralExpression;
            //     Debug.assert(templateLiteral.kind === SyntaxKind.NoSubstitutionTemplateLiteral);
            //     callIsIncomplete = !!templateLiteral.isUnterminated;
            // }
        } else if matches!(node, BoundNode::Decorator(_)) {
            todo!();
            // argCount = getDecoratorArgumentCount(node, signature);
        }
        // TODO: jsx
        // else if isJsxOpeningLikeElement(node) {
        //     todo!();
        //     // callIsIncomplete = node.attributes.end === node.end;
        //     // if (callIsIncomplete) {
        //     //     return true;
        //     // }
        //     // argCount = effectiveMinimumArguments === 0 ? args.length : 1;
        //     // effectiveParameterCount = args.length === 0 ? effectiveParameterCount : 1; // class may have argumentless ctor functions - still resolve ctor and compare vs props member type
        //     // effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1); // sfc may specify context argument - handled by framework and not typechecked
        // }
        else if matches!(node, BoundNode::NewExpr(e) if e.args.is_none()) {
            // This only happens when we have something of the form: 'new C'
            return self.getMinArgumentCount(signature, None) == 0;
        } else {
            argCount = if signatureHelpTrailingComma {
                args.len() + 1
            } else {
                args.len()
            };

            // TODO:
            // If we are missing the close parenthesis, the call is incomplete.
            // callIsIncomplete = node.arguments.end == node.end;

            // If a spread argument is present, check that it corresponds to a rest parameter or at least that it's in the valid range.
            let spreadArgIndex = getSpreadArgumentIndex(args);
            if let Some(spreadArgIndex) = spreadArgIndex {
                return spreadArgIndex >= self.getMinArgumentCount(signature, None)
                    && (self.hasEffectiveRestParameter(signature)
                        || spreadArgIndex < self.getParameterCount(signature));
            }
        }

        // Too many arguments implies incorrect arity.
        if !self.hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount {
            return false;
        }

        // If the call is incomplete, we should skip the lower bound check.
        // JSX signatures can have extra parameters provided by the library which we don't check
        if callIsIncomplete || argCount >= effectiveMinimumArguments {
            return true;
        }
        let mut i = argCount;
        while i < effectiveMinimumArguments {
            let ty = self.getTypeAtPosition(signature, i);
            let filtered_ty = self.filterType(ty, |checker, ty| {
                if isBoundNodeInJSFile(node) && !checker.strictNullChecks {
                    checker.acceptsVoidUndefinedUnknownOrAny(ty)
                } else {
                    checker.acceptsVoid(ty)
                }
            });
            if self.types[filtered_ty]
                .get_flags()
                .intersects(TypeFlags::Never)
            {
                return false;
            }
            i += 1;
        }
        true
    }

    fn hasCorrectTypeArgumentArity(
        &self,
        signature: SignatureId,
        typeArguments: Option<&Rc<TsTypeParamInstantiation>>,
    ) -> bool {
        // If the user supplied type arguments, but the number of type arguments does not match
        // the declared number of type parameters, the call has an incorrect arity.
        let typeParameters = self.signatures[signature].typeParameters.clone();
        let numTypeParameters = typeParameters.length();
        let minTypeArgumentCount = self.getMinTypeArgumentCount(typeParameters);
        if let Some(typeArguments) = typeArguments {
            typeArguments.params.len() >= minTypeArgumentCount
                && typeArguments.params.len() <= numTypeParameters
        } else {
            true
        }
    }

    // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
    fn getSingleCallSignature(&mut self, ty: TypeId) -> Option<SignatureId> {
        self.getSingleSignature(ty, SignatureKind::Call, false)
    }

    fn getSingleCallOrConstructSignature(&mut self, ty: TypeId) -> Option<SignatureId> {
        self.getSingleSignature(ty, SignatureKind::Call, false)
            .or(self.getSingleSignature(ty, SignatureKind::Construct, false))
    }

    fn getSingleSignature(
        &mut self,
        ty: TypeId,
        kind: SignatureKind,
        allowMembers: bool,
    ) -> Option<SignatureId> {
        if self.types[ty].get_flags().intersects(TypeFlags::Object) {
            let resolved = self.resolveStructuredTypeMembers(ty);
            let resolved =
                &unwrap_as!(&self.types[resolved], Type::ResolvedType(t), t).object_type_base;
            if allowMembers || resolved.properties.len() == 0 && resolved.indexInfos.len() == 0 {
                if kind == SignatureKind::Call
                    && resolved.callSignatures.len() == 1
                    && resolved.constructSignatures.len() == 0
                {
                    return Some(resolved.callSignatures[0]);
                }
                if kind == SignatureKind::Construct
                    && resolved.constructSignatures.len() == 1
                    && resolved.callSignatures.len() == 0
                {
                    return Some(resolved.constructSignatures[0]);
                }
            }
        }
        None
    }

    // TODO:
    // instantiateSignatureInContextOf
    // TODO:
    // inferJsxTypeArguments
    // TODO:
    // getThisArgumentType

    fn inferTypeArguments(
        &mut self,
        node: &BoundNode,
        signature: SignatureId,
        args: &Vec<BoundNode>,
        checkMode: CheckMode,
        context: InferenceContextId,
    ) -> Vec<TypeId> {
        // TODO: jsx:
        // if isJsxOpeningLikeElement(node) {
        //     return inferJsxTypeArguments(node, signature, checkMode, context);
        // }

        // If a contextual type is available, infer from that type to the return type of the call expression. For
        // example, given a 'function wrap<T, U>(cb: (x: T) => U): (x: T) => U' and a call expression
        // 'let f: (x: string) => number = wrap(s => s.length)', we infer from the declared type of 'f' to the
        // return type of 'wrap'.
        if !matches!(node, BoundNode::Decorator(_)) {
            let contextFlags = if self.signatures[signature]
                .typeParameters
                .clone()
                .iter()
                .flat_map(|v| v.iter())
                .all(|&p| self.getDefaultFromTypeParameter(p).is_some())
            {
                ContextFlags::SkipBindingPatterns
            } else {
                ContextFlags::None
            };
            let contextualType = self.getContextualType(node.clone(), Some(contextFlags));
            if let Some(contextualType) = contextualType {
                // We clone the inference context to avoid disturbing a resolution in progress for an
                // outer call expression. Effectively we just want a snapshot of whatever has been
                // inferred for any outer call expression so far.
                let outerContext = self.getInferenceContext(node.clone());
                let outerMapper = {
                    let ctx =
                        self.cloneInferenceContext(outerContext, Some(InferenceFlags::NoDefault));
                    self.getMapperFromContext(ctx)
                };
                let instantiatedType = self.instantiateType(contextualType, outerMapper);
                // If the contextual type is a generic function type with a single call signature, we
                // instantiate the type with its own type parameters and type arguments. This ensures that
                // the type parameters are not erased to type any during type inference such that they can
                // be inferred as actual types from the contextual type. For example:
                //   declare function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[];
                //   const boxElements: <A>(a: A[]) => { value: A }[] = arrayMap(value => ({ value }));
                // Above, the type of the 'value' parameter is inferred to be 'A'.
                let contextualSignature = self.getSingleCallSignature(instantiatedType);
                let inferenceSourceType = if let Some(contextualSignature) = contextualSignature {
                    let sig = self.getSignatureInstantiationWithoutFillingInTypeArguments(
                        contextualSignature,
                        self.signatures[contextualSignature].typeParameters.clone(),
                    );
                    self.getOrCreateTypeFromSignature(sig)
                } else {
                    instantiatedType
                };
                let inferenceTargetType = self.getReturnTypeOfSignature(signature);
                // Inferences made from return types have lower priority than all other inferences.
                self.inferTypes(
                    context,
                    inferenceSourceType,
                    inferenceTargetType,
                    Some(InferencePriority::ReturnType),
                    false,
                );
                // Create a type mapper for instantiating generic contextual types using the inferences made
                // from the return type. We need a separate inference pass here because (a) instantiation of
                // the source type uses the outer context's return mapper (which excludes inferences made from
                // outer arguments), and (b) we don't want any further inferences going into this context.
                let returnContext = self.createInferenceContext(
                    self.signatures[signature].typeParameters.clone().unwrap(),
                    Some(signature),
                    self.inference_contexts[context].flags,
                    None,
                );
                let returnSourceType = self.instantiateType(
                    contextualType,
                    outerContext.and_then(|ctx| self.inference_contexts[ctx].returnMapper.clone()),
                );
                self.inferTypes(
                    returnContext,
                    returnSourceType,
                    inferenceTargetType,
                    None,
                    false,
                );
                self.inference_contexts[context].returnMapper = if self.inference_contexts
                    [returnContext]
                    .inferences
                    .iter()
                    .any(hasInferenceCandidates)
                {
                    let ctx = self.cloneInferredPartOfContext(returnContext);
                    self.getMapperFromContext(ctx)
                } else {
                    None
                };
            }
        }

        let restType = self.getNonArrayRestType(signature);
        let argCount = if restType.is_some() {
            cmp::min(self.getParameterCount(signature) - 1, args.len())
        } else {
            args.len()
        };
        if let Some(restType) = restType {
            if self.types[restType]
                .get_flags()
                .intersects(TypeFlags::TypeParameter)
            {
                todo!();
                // const info = find(context.inferences, info => info.typeParameter === restType);
                // if (info) {
                //     info.impliedArity = findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : undefined;
                // }
            }
        }

        let thisType = self.getThisTypeOfSignature(signature);
        if let Some(thisType) = thisType {
            todo!();
            // const thisArgumentNode = getThisArgumentOfCall(node);
            // inferTypes(context.inferences, getThisArgumentType(thisArgumentNode), thisType);
        }

        for i in 0..argCount {
            let arg = &args[i];
            // TODO:
            // if (arg.kind !== SyntaxKind.OmittedExpression) {
            let paramType = self.getTypeAtPosition(signature, i);
            let argType = self.checkExpressionWithContextualType(
                arg.clone(),
                paramType,
                Some(context),
                checkMode,
            );
            self.inferTypes(context, argType, paramType, None, false);
            // }
        }

        if let Some(restType) = restType {
            todo!();
            // const spreadType = getSpreadArgumentType(args, argCount, args.length, restType, context, checkMode);
            // inferTypes(context.inferences, spreadType, restType);
        }

        self.getInferredTypes(context)
    }

    // TODO:
    // getMutableArrayOrTupleType
    // TODO:
    // getSpreadArgumentType

    // TODO: errors
    fn checkTypeArguments(
        &mut self,
        signature: SignatureId,
        typeArgumentInstantiation: &Rc<TsTypeParamInstantiation>,
        reportErrors: bool, /*, headMessage?: DiagnosticMessage*/
    ) -> Option<Rc<Vec<TypeId>>> {
        let isJavascript = isInJSFile(self.signatures[signature].declaration.as_ref());
        let typeParameters = self.signatures[signature].typeParameters.clone().unwrap();
        let typeArgumentTypes = Rc::new(
            typeArgumentInstantiation
                .params
                .iter()
                .map(|t| self.getTypeFromTypeNode(t.bind(typeArgumentInstantiation.clone().into())))
                .collect::<Vec<_>>(),
        );
        let typeArgumentTypes = self
            .fillMissingTypeArguments(
                Some(typeArgumentTypes),
                Some(typeParameters.clone()),
                self.getMinTypeArgumentCount(Some(typeParameters.clone())),
                isJavascript,
            )
            .unwrap();
        let mut mapper = None;
        for (i, typeArgumentNode) in typeArgumentInstantiation.params.iter().enumerate() {
            debug_assert!(
                typeParameters.get(i).is_some(),
                "Should not call checkTypeArguments with too many type arguments"
            );
            if let Some(constraint) = self.getConstraintOfTypeParameter(typeParameters[i]) {
                // let errorInfo = reportErrors && headMessage ? (() => chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)) : undefined;
                // let typeArgumentHeadMessage = headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
                let mapper = match mapper {
                    Some(m) => m,
                    None => {
                        let m = self.createTypeMapper(typeParameters, Some(typeArgumentTypes));
                        mapper = Some(m.clone());
                        m
                    }
                };
                // let typeArgument = typeArgumentTypes[i];
                todo!();
                // if (!checkTypeAssignableTo(
                //     typeArgument,
                //     getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument),
                //     reportErrors ? typeArgumentNodes[i] : undefined,
                //     typeArgumentHeadMessage,
                //     errorInfo)) {
                //     return undefined;
                // }
            }
        }
        Some(typeArgumentTypes)
    }

    // TODO:
    // getJsxReferenceKind
    // TODO:
    // checkApplicableSignatureForJsxOpeningLikeElement
    // TODO:
    // getSignatureApplicabilityError
    // TODO:
    // getThisArgumentOfCall
    // TODO:
    // createSyntheticExpression

    /**
     * Returns the effective arguments for an expression that works like a function invocation.
     */
    fn getEffectiveCallArguments(&mut self, node: &BoundNode) -> Vec<BoundNode> {
        // TODO:JsxOpeningLikeElement
        debug_assert!(matches!(
            node,
            BoundNode::TaggedTpl(_)
                | BoundNode::Decorator(_)
                | BoundNode::CallExpr(_)
                | BoundNode::NewExpr(_)
        ));
        if matches!(node, BoundNode::TaggedTpl(_)) {
            // const template = node.template;
            // const args: Expression[] = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
            // if (template.kind === SyntaxKind.TemplateExpression) {
            //     forEach(template.templateSpans, span => {
            //         args.push(span.expression);
            //     });
            // }
            // return args;
        }
        if matches!(node, BoundNode::Decorator(_)) {
            todo!();
            // return getEffectiveDecoratorArguments(node);
        }
        // TODO:
        // if (isJsxOpeningLikeElement(node)) {
        //     return node.attributes.properties.length > 0 || (isJsxOpeningElement(node) && node.parent.children.length > 0) ? [node.attributes] : emptyArray;
        // }
        // let args = match node {
        //     BoundNode::CallExpr(n) => n.args.iter(),
        //     BoundNode::NewExpr(n) => n.args.iter().flatten(),
        //     _ => unreachable!(),
        // };
        // let spreadIndex = args.position(|a| a.spread.is_some());
        let args = match node {
            BoundNode::CallExpr(n) => Some(n.args.clone()),
            BoundNode::NewExpr(n) => n.args.clone(),
            _ => unreachable!(),
        };
        let args = args.iter().flatten();
        let spreadIndex = args
            .clone()
            .position(|a| matches!(a, ast::ExprOrSpread::Spread(_)));
        if spreadIndex.is_some() {
            todo!();
            // Create synthetic arguments from spreads of tuple types.
            // const effectiveArgs = args.slice(0, spreadIndex);
            // for (let i = spreadIndex; i < args.length; i++) {
            //     const arg = args[i];
            //     // We can call checkExpressionCached because spread expressions never have a contextual type.
            //     const spreadType = arg.kind === SyntaxKind.SpreadElement && (flowLoopCount ? checkExpression((arg as SpreadElement).expression) : checkExpressionCached((arg as SpreadElement).expression));
            //     if (spreadType && isTupleType(spreadType)) {
            //         forEach(getTypeArguments(spreadType), (t, i) => {
            //             const flags = spreadType.target.elementFlags[i];
            //             const syntheticArg = createSyntheticExpression(arg, flags & ElementFlags.Rest ? createArrayType(t) : t,
            //                 !!(flags & ElementFlags.Variable), spreadType.target.labeledElementDeclarations?.[i]);
            //             effectiveArgs.push(syntheticArg);
            //         });
            //     }
            //     else {
            //         effectiveArgs.push(arg);
            //     }
            // }
            // return effectiveArgs;
        }
        // TODO: bad collect:
        args.map(|a| a.bind(node.clone())).collect()
    }

    // TODO:
    // getEffectiveDecoratorArguments
    // TODO:
    // getDecoratorArgumentCount
    // TODO:
    // getDiagnosticSpanForCallNode
    // TODO:
    // getDiagnosticForCallNode
    // TODO:
    // isPromiseResolveArityError
    // TODO:
    // getArgumentArityError
    // TODO:
    // getTypeArgumentArityError

    fn resolveCall(
        &mut self,
        node: BoundNode,
        signatures: Rc<Vec<SignatureId>>,
        candidatesOutArray: Option<&mut Vec<SignatureId>>,
        checkMode: CheckMode,
        callChainFlags: SignatureFlags,
        // fallbackError: DiagnosticMessage,
    ) -> SignatureId {
        let isDecorator = matches!(node, BoundNode::Decorator(_));
        let reportErrors = candidatesOutArray.is_none() && self.produceDiagnostics;

        let typeArguments = match &node {
            BoundNode::CallExpr(n) => {
                // We already perform checking on the type arguments on the class declaration itself.
                if !matches!(n.callee, ast::ExprOrSuper::Super(_)) {
                    if let Some(type_params) = &n.type_args {
                        for p in &type_params.params {
                            self.checkSourceElement(Some(p.bind(type_params.bind(node.clone()))));
                        }
                    }
                }
                n.type_args
                    .as_ref()
                    .map(|i| TsTypeParamInstantiation::new(i.clone(), Some(node.clone())))
            }
            BoundNode::NewExpr(n) => {
                if let Some(type_params) = &n.type_args {
                    for p in &type_params.params {
                        self.checkSourceElement(Some(p.bind(type_params.bind(node.clone()))));
                    }
                }
                n.type_args
                    .as_ref()
                    .map(|i| TsTypeParamInstantiation::new(i.clone(), Some(node.clone())))
            }
            BoundNode::TaggedTpl(n) => {
                if let Some(type_params) = &n.type_params {
                    for p in &type_params.params {
                        self.checkSourceElement(Some(p.bind(type_params.bind(node.clone()))));
                    }
                }
                n.type_params
                    .as_ref()
                    .map(|i| TsTypeParamInstantiation::new(i.clone(), Some(node.clone())))
            }
            // TODO: jsx
            // JsxOpeningLikeElement => {
            //     forEach(typeArguments, checkSourceElement);
            //     n.type_params
            // }
            _ => None,
        };

        let mut temp = Vec::new();
        let candidates = candidatesOutArray.unwrap_or(&mut temp);
        // reorderCandidates fills up the candidates array directly
        self.reorderCandidates(signatures, candidates, callChainFlags);
        if candidates.is_empty() {
            todo!();
            // if (reportErrors) {
            //     diagnostics.add(getDiagnosticForCallNode(
            //         node,
            //         Diagnostics.Call_target_does_not_contain_any_signatures,
            //     ));
            // }
            // return resolveErrorCall(node);
        }

        let args = self.getEffectiveCallArguments(&node);

        // The excludeArgument array contains true for each context sensitive argument (an argument
        // is context sensitive it is susceptible to a one-time permanent contextual typing).
        //
        // The idea is that we will perform type argument inference & assignability checking once
        // without using the susceptible parameters that are functions, and once more for those
        // parameters, contextually typing each as we go along.
        //
        // For a tagged template, then the first argument be 'undefined' if necessary because it
        // represents a TemplateStringsArray.
        //
        // For a decorator, no arguments are susceptible to contextual typing due to the fact
        // decorators are applied to a declaration by the emitter, and not to an expression.
        let isSingleNonGenericCandidate =
            candidates.len() == 1 && self.signatures[candidates[0]].typeParameters.is_none();
        let mut argCheckMode = if !isDecorator
            && !isSingleNonGenericCandidate
            && args.iter().any(|a| isContextSensitive(&a.clone().into()))
        {
            CheckMode::SkipContextSensitive
        } else {
            CheckMode::Normal
        };

        // The following variables are captured and modified by calls to chooseOverload.
        // If overload resolution or type argument inference fails, we want to report the
        // best error possible. The best error is one which says that an argument was not
        // assignable to a parameter. This implies that everything else about the overload
        // was fine. So if there is any overload that is only incorrect because of an
        // argument, we will report an error on that one.
        //
        //     function foo(s: string): void;
        //     function foo(n: number): void; // Report argument error on this overload
        //     function foo(): void;
        //     foo(true);
        //
        // If none of the overloads even made it that far, there are two possibilities.
        // There was a problem with type arguments for some overload, in which case
        // report an error on that. Or none of the overloads even had correct arity,
        // in which case give an arity error.
        //
        //     function foo<T extends string>(x: T): void; // Report type argument error
        //     function foo(): void;
        //     foo<number>(0);
        //
        // let candidatesForArgumentError = None;
        let mut candidateForArgumentArityError = None;
        // let candidateForTypeArgumentError = None;
        let mut result = None;

        // If we are in signature help, a trailing comma indicates that we intend to provide another argument,
        // so we will only accept overloads with arity at least 1 higher than the current number of provided arguments.
        // let signatureHelpTrailingComma = checkMode.intersects(CheckMode::IsForSignatureHelp)
        //     && node.kind == SyntaxKind.CallExpression
        //     && node.arguments.hasTrailingComma;
        // TODO:
        let signatureHelpTrailingComma = if checkMode.intersects(CheckMode::IsForSignatureHelp) {
            todo!()
        } else {
            false
        };

        // Section 4.12.1:
        // if the candidate list contains one or more signatures for which the type of each argument
        // expression is a subtype of each corresponding parameter type, the return type of the first
        // of those signatures becomes the return type of the function call.
        // Otherwise, the return type of the first signature in the candidate list becomes the return
        // type of the function call.
        //
        // Whether the call is an error is determined by assignability of the arguments. The subtype pass
        // is just important for choosing the best signature. So in the case where there is only one
        // signature, the subtype pass is useless. So skipping it is an optimization.
        if candidates.len() > 1 {
            result = chooseOverload(
                self,
                candidates,
                self.subtypeRelation,
                isSingleNonGenericCandidate,
                signatureHelpTrailingComma,
                &mut argCheckMode,
                &typeArguments,
                &node,
                &args,
                &mut candidateForArgumentArityError,
            );
        }
        if result.is_none() {
            result = chooseOverload(
                self,
                candidates,
                self.assignableRelation,
                isSingleNonGenericCandidate,
                signatureHelpTrailingComma,
                &mut argCheckMode,
                &typeArguments,
                &node,
                &args,
                &mut candidateForArgumentArityError,
            );
        }
        if let Some(result) = result {
            return result;
        }
        todo!();

        // No signatures were applicable. Now report errors based on the last applicable signature with
        // no arguments excluded from assignability checks.
        // If candidate is undefined, it means that no candidates had a suitable arity. In that case,
        // skip the checkApplicableSignature check.
        // if (reportErrors) {
        //     if (candidatesForArgumentError) {
        //         if (candidatesForArgumentError.length === 1 || candidatesForArgumentError.length > 3) {
        //             const last = candidatesForArgumentError[candidatesForArgumentError.length - 1];
        //             let chain: DiagnosticMessageChain | undefined;
        //             if (candidatesForArgumentError.length > 3) {
        //                 chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error);
        //                 chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call);
        //             }
        //             const diags = getSignatureApplicabilityError(node, args, last, assignableRelation, CheckMode.Normal, /*reportErrors*/ true, () => chain);
        //             if (diags) {
        //                 for (const d of diags) {
        //                     if (last.declaration && candidatesForArgumentError.length > 3) {
        //                         addRelatedInfo(d, createDiagnosticForNode(last.declaration, Diagnostics.The_last_overload_is_declared_here));
        //                     }
        //                     addImplementationSuccessElaboration(last, d);
        //                     diagnostics.add(d);
        //                 }
        //             }
        //             else {
        //                 Debug.fail("No error for last overload signature");
        //             }
        //         }
        //         else {
        //             const allDiagnostics: (readonly DiagnosticRelatedInformation[])[] = [];
        //             let max = 0;
        //             let min = Number.MAX_VALUE;
        //             let minIndex = 0;
        //             let i = 0;
        //             for (const c of candidatesForArgumentError) {
        //                 const chain = () => chainDiagnosticMessages(/*details*/ undefined, Diagnostics.Overload_0_of_1_2_gave_the_following_error, i + 1, candidates.length, signatureToString(c));
        //                 const diags = getSignatureApplicabilityError(node, args, c, assignableRelation, CheckMode.Normal, /*reportErrors*/ true, chain);
        //                 if (diags) {
        //                     if (diags.length <= min) {
        //                         min = diags.length;
        //                         minIndex = i;
        //                     }
        //                     max = Math.max(max, diags.length);
        //                     allDiagnostics.push(diags);
        //                 }
        //                 else {
        //                     Debug.fail("No error for 3 or fewer overload signatures");
        //                 }
        //                 i++;
        //             }

        //             const diags = max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics);
        //             Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures");
        //             const chain = chainDiagnosticMessages(
        //                 map(diags, d => typeof d.messageText === "string" ? (d as DiagnosticMessageChain) : d.messageText),
        //                 Diagnostics.No_overload_matches_this_call);
        //             // The below is a spread to guarantee we get a new (mutable) array - our `flatMap` helper tries to do "smart" optimizations where it reuses input
        //             // arrays and the emptyArray singleton where possible, which is decidedly not what we want while we're still constructing this diagnostic
        //             const related = [...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[]];
        //             let diag: Diagnostic;
        //             if (every(diags, d => d.start === diags[0].start && d.length === diags[0].length && d.file === diags[0].file)) {
        //                 const { file, start, length } = diags[0];
        //                 diag = { file, start, length, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related };
        //             }
        //             else {
        //                 diag = createDiagnosticForNodeFromMessageChain(node, chain, related);
        //             }
        //             addImplementationSuccessElaboration(candidatesForArgumentError[0], diag);
        //             diagnostics.add(diag);
        //         }
        //     }
        //     else if (candidateForArgumentArityError) {
        //         diagnostics.add(getArgumentArityError(node, [candidateForArgumentArityError], args));
        //     }
        //     else if (candidateForTypeArgumentError) {
        //         checkTypeArguments(candidateForTypeArgumentError, (node as CallExpression | TaggedTemplateExpression | JsxOpeningLikeElement).typeArguments!, /*reportErrors*/ true, fallbackError);
        //     }
        //     else {
        //         const signaturesWithCorrectTypeArgumentArity = filter(signatures, s => hasCorrectTypeArgumentArity(s, typeArguments));
        //         if (signaturesWithCorrectTypeArgumentArity.length === 0) {
        //             diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments!));
        //         }
        //         else if (!isDecorator) {
        //             diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args));
        //         }
        //         else if (fallbackError) {
        //             diagnostics.add(getDiagnosticForCallNode(node, fallbackError));
        //         }
        //     }
        // }

        // return getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray);

        // function addImplementationSuccessElaboration(failed: Signature, diagnostic: Diagnostic) {
        //     const oldCandidatesForArgumentError = candidatesForArgumentError;
        //     const oldCandidateForArgumentArityError = candidateForArgumentArityError;
        //     const oldCandidateForTypeArgumentError = candidateForTypeArgumentError;

        //     const failedSignatureDeclarations = failed.declaration?.symbol?.declarations || emptyArray;
        //     const isOverload = failedSignatureDeclarations.length > 1;
        //     const implDecl = isOverload ? find(failedSignatureDeclarations, d => isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)) : undefined;
        //     if (implDecl) {
        //         const candidate = getSignatureFromDeclaration(implDecl as FunctionLikeDeclaration);
        //         const isSingleNonGenericCandidate = !candidate.typeParameters;
        //         if (chooseOverload([candidate], assignableRelation, isSingleNonGenericCandidate)) {
        //             addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible));
        //         }
        //     }

        //     candidatesForArgumentError = oldCandidatesForArgumentError;
        //     candidateForArgumentArityError = oldCandidateForArgumentArityError;
        //     candidateForTypeArgumentError = oldCandidateForTypeArgumentError;
        // }

        fn chooseOverload(
            checker: &mut Checker,

            candidates: &mut Vec<SignatureId>,
            relation: TypeRelationTableId,
            isSingleNonGenericCandidate: bool,
            signatureHelpTrailingComma: bool,

            argCheckMode: &mut CheckMode,
            typeArguments: &Option<Rc<TsTypeParamInstantiation>>,
            node: &BoundNode,
            args: &Vec<BoundNode>,
            candidateForArgumentArityError: &mut Option<SignatureId>,
        ) -> Option<SignatureId> {
            // candidatesForArgumentError = undefined;
            *candidateForArgumentArityError = None;
            // candidateForTypeArgumentError = undefined;

            if isSingleNonGenericCandidate {
                let candidate = candidates[0];
                if let Some(typeArguments) = typeArguments {
                    if !typeArguments.params.is_empty() {
                        return None;
                    }
                }
                if !checker.hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
                    return None;
                }
                // TODO: error:
                // if getSignatureApplicabilityError(node, args, candidate, relation, CheckMode.Normal, /*reportErrors*/ false, /*containingMessageChain*/ undefined) {
                //     candidatesForArgumentError = [candidate];
                //     return None;
                // }
                return Some(candidate);
            }

            for (candidateIndex, &candidate) in candidates.iter().enumerate() {
                if !checker.hasCorrectTypeArgumentArity(candidate, typeArguments.as_ref())
                    || !checker.hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)
                {
                    continue;
                }

                let mut checkCandidate;
                let mut inferenceContext = None;

                if let Some(typeParameters) = checker.signatures[candidate].typeParameters.as_ref()
                {
                    let mut typeArgumentTypes = None;
                    if let Some(typeArguments) = typeArguments.as_ref() {
                        typeArgumentTypes =
                            checker.checkTypeArguments(candidate, typeArguments, false);
                        if typeArgumentTypes.is_none() {
                            // TODO:
                            // candidateForTypeArgumentError = candidate;
                            continue;
                        }
                    } else {
                        let ctx = checker.createInferenceContext(
                            typeParameters.clone(),
                            Some(candidate),
                            if isBoundNodeInJSFile(node) {
                                InferenceFlags::AnyDefault
                            } else {
                                InferenceFlags::None
                            },
                            None,
                        );
                        typeArgumentTypes = Some(Rc::new(checker.inferTypeArguments(
                            node,
                            candidate,
                            args,
                            *argCheckMode | CheckMode::SkipGenericFunctions,
                            ctx,
                        )));
                        *argCheckMode |= if checker.inference_contexts[ctx]
                            .flags
                            .intersects(InferenceFlags::SkippedGenericFunction)
                        {
                            CheckMode::SkipGenericFunctions
                        } else {
                            CheckMode::Normal
                        };
                        inferenceContext = Some(ctx);
                    }
                    checkCandidate = checker.getSignatureInstantiation(
                        candidate,
                        typeArgumentTypes,
                        isInJSFile(checker.signatures[candidate].declaration.as_ref()),
                        inferenceContext.and_then(|ctx| {
                            checker.inference_contexts[ctx]
                                .inferredTypeParameters
                                .clone()
                        }),
                    );
                    // If the original signature has a generic rest type, instantiation may produce a
                    // signature with different arity and we need to perform another arity check.
                    if checker.getNonArrayRestType(candidate).is_some()
                        && !checker.hasCorrectArity(
                            node,
                            args,
                            checkCandidate,
                            signatureHelpTrailingComma,
                        )
                    {
                        // TODO:
                        // candidateForArgumentArityError = checkCandidate;
                        continue;
                    }
                } else {
                    checkCandidate = candidate;
                }
                // todo: error:
                // if getSignatureApplicabilityError(
                //     node,
                //     args,
                //     checkCandidate,
                //     relation,
                //     argCheckMode,
                //     /*reportErrors*/ false,
                //     /*containingMessageChain*/ None,
                // ) {
                //     todo!();
                //     // Give preference to error candidates that have no rest parameters (as they are more specific)
                //     // (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                //     // continue;
                // }
                if *argCheckMode != CheckMode::Normal {
                    // If one or more context sensitive arguments were excluded, we start including
                    // them now (and keeping do so for any subsequent candidates) and perform a second
                    // round of type inference and applicability checking for this particular candidate.
                    *argCheckMode = CheckMode::Normal;
                    if let Some(inferenceContext) = inferenceContext {
                        let typeArgumentTypes = checker.inferTypeArguments(
                            node,
                            candidate,
                            args,
                            *argCheckMode,
                            inferenceContext,
                        );
                        checkCandidate = checker.getSignatureInstantiation(
                            candidate,
                            Some(Rc::new(typeArgumentTypes)),
                            isInJSFile(checker.signatures[candidate].declaration.as_ref()),
                            checker.inference_contexts[inferenceContext]
                                .inferredTypeParameters
                                .clone(),
                        );
                        // If the original signature has a generic rest type, instantiation may produce a
                        // signature with different arity and we need to perform another arity check.
                        if checker.getNonArrayRestType(candidate).is_some()
                            && !checker.hasCorrectArity(
                                node,
                                args,
                                checkCandidate,
                                signatureHelpTrailingComma,
                            )
                        {
                            *candidateForArgumentArityError = Some(checkCandidate);
                            continue;
                        }
                    }
                    // TODO: error
                    // if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors*/ false, /*containingMessageChain*/ undefined)) {
                    //     // Give preference to error candidates that have no rest parameters (as they are more specific)
                    //     (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                    //     continue;
                    // }
                }
                candidates[candidateIndex] = checkCandidate;
                return Some(checkCandidate);
            }

            None
        }
    }

    // TODO:
    // getCandidateForOverloadFailure
    // TODO:
    // createUnionOfSignaturesForOverloadFailure
    // TODO:
    // getNumNonRestParameters
    // TODO:
    // createCombinedSymbolFromTypes
    // TODO:
    // createCombinedSymbolForOverloadFailure
    // TODO:
    // pickLongestCandidateSignature
    // TODO:
    // getTypeArgumentsFromNodes
    // TODO:
    // inferSignatureInstantiationForOverloadFailure
    // TODO:
    // getLongestCandidateIndex

    fn resolveCallExpression(
        &mut self,
        node: &Rc<CallExpr>,
        candidatesOutArray: Option<&mut Vec<SignatureId>>,
        checkMode: CheckMode,
    ) -> SignatureId {
        let bound_node = BoundNode::CallExpr(node.clone());
        let callee = match &node.callee {
            ast::ExprOrSuper::Super(n) => {
                let superType =
                    self.checkSuperExpression(&Super::new(n.clone(), Some(bound_node.clone())));
                if self.isTypeAny(Some(superType)) {
                    for arg in &node.args {
                        self.checkExpression(arg.bind(bound_node.clone()), None, false);
                        // Still visit arguments so they get marked for visibility, etc
                    }
                    return self.anySignature;
                }
                if !self.isErrorType(superType) {
                    // In super call, the candidate signatures are the matching arity signatures of the base constructor function instantiated
                    // with the type arguments specified in the extends clause.
                    if let Some(baseTypeNode) =
                        getContainingClass(bound_node.clone()).and_then(getEffectiveBaseTypeNode)
                    {
                        let baseConstructors = self.getInstantiatedConstructorsForTypeArguments(
                            superType,
                            baseTypeNode.type_args,
                            baseTypeNode.expr,
                        );
                        return self.resolveCall(
                            bound_node.clone(),
                            baseConstructors,
                            candidatesOutArray,
                            checkMode,
                            SignatureFlags::None,
                        );
                    }
                }
                return self.resolveUntypedCall(bound_node);
            }
            ast::ExprOrSuper::Expr(e) => e.bind(bound_node.clone()),
        };

        let mut callChainFlags;
        let mut funcType = self.checkExpression(callee.clone(), None, false);
        // TODO:
        // if isCallChain(&node.clone().into()) {
        //     let nonOptionalType = self.getOptionalExpressionType(funcType, &callee);
        //     callChainFlags = if nonOptionalType == funcType {
        //         SignatureFlags::None
        //     } else if isOutermostOptionalChain(node) {
        //         SignatureFlags::IsOuterCallChain
        //     } else {
        //         SignatureFlags::IsInnerCallChain
        //     };
        //     funcType = nonOptionalType;
        // } else {
        callChainFlags = SignatureFlags::None;
        // }

        funcType = self.checkNonNullTypeWithReporter(
            funcType, callee, /*,reportCannotInvokePossiblyNullOrUndefinedError*/
        );

        if (funcType == self.silentNeverType) {
            return self.silentNeverSignature;
        }

        let apparentType = self.getApparentType(funcType);
        if self.isErrorType(apparentType) {
            // Another error has already been reported
            return self.resolveErrorCall(node.clone().into());
        }

        // Technically, this signatures list may be incomplete. We are taking the apparent type,
        // but we are not including call signatures that may have been added to the Object or
        // Function interface, since they have none by default. This is a bit of a leap of faith
        // that the user will not add any.
        let callSignatures = self.getSignaturesOfType(apparentType, SignatureKind::Call);
        let numConstructSignatures = self
            .getSignaturesOfType(apparentType, SignatureKind::Construct)
            .len();

        // TS 1.0 Spec: 4.12
        // In an untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
        // types are provided for the argument expressions, and the result is always of type Any.
        if self.isUntypedFunctionCall(
            funcType,
            apparentType,
            callSignatures.len(),
            numConstructSignatures,
        ) {
            // The unknownType indicates that an error already occurred (and was reported). No
            // need to report another error in this case.
            if !self.isErrorType(funcType) && node.type_args.is_some() {
                todo!();
                // error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            }
            return self.resolveUntypedCall(node.clone().into());
        }
        // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
        // TypeScript employs overload resolution in typed function calls in order to support functions
        // with multiple call signatures.
        if callSignatures.is_empty() {
            todo!();
            // if (numConstructSignatures) {
            //     error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
            // }
            // else {
            //     let relatedInformation: DiagnosticRelatedInformation | undefined;
            //     if (node.arguments.length == 1) {
            //         const text = getSourceFileOfNode(node).text;
            //         if (isLineBreak(text.charCodeAt(skipTrivia(text, callee.end, /* stopAfterLineBreak */ true) - 1))) {
            //             relatedInformation = createDiagnosticForNode(callee, Diagnostics.Are_you_missing_a_semicolon);
            //         }
            //     }
            //     invocationError(callee, apparentType, SignatureKind::Call, relatedInformation);
            // }
            // return resolveErrorCall(node);
        }
        // When a call to a generic function is an argument to an outer call to a generic function for which
        // inference is in process, we have a choice to make. If the inner call relies on inferences made from
        // its contextual type to its return type, deferring the inner call processing allows the best possible
        // contextual type to accumulate. But if the outer call relies on inferences made from the return type of
        // the inner call, the inner call should be processed early. There's no sure way to know which choice is
        // right (only a full unification algorithm can determine that), so we resort to the following heuristic:
        // If no type arguments are specified in the inner call and at least one call signature is generic and
        // returns a function type, we choose to defer processing. This narrowly permits function composition
        // operators to flow inferences through return types, but otherwise processes calls right away. We
        // use the resolvingSignature singleton to indicate that we deferred processing. This result will be
        // propagated out and eventually turned into nonInferrableType (a type that is assignable to anything and
        // from which we never make inferences).
        if checkMode.intersects(CheckMode::SkipGenericFunctions)
            && node.type_args.is_none()
            && callSignatures
                .iter()
                .any(|s| self.isGenericFunctionReturningFunction(*s))
        {
            todo!();
            // skippedGenericFunction(node, checkMode);
            // return resolvingSignature;
        }
        // If the function is explicitly marked with `@class`, then it must be constructed.
        if callSignatures
            .iter()
            .any(|&sig| isInJSFile(self.signatures[sig].declaration.as_ref())/* && !!getJSDocClassTag(sig.declaration.unwrap())*/)
        {
            todo!();
            // error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
            // return resolveErrorCall(node);
        }

        self.resolveCall(
            bound_node,
            callSignatures,
            candidatesOutArray,
            checkMode,
            callChainFlags,
        )
    }

    fn isGenericFunctionReturningFunction(&mut self, signature: SignatureId) -> bool {
        if self.signatures[signature].typeParameters.is_some() {
            let return_ty = self.getReturnTypeOfSignature(signature);
            self.isFunctionType(return_ty)
        } else {
            false
        }
    }

    /**
     * TS 1.0 spec: 4.12
     * If FuncExpr is of type Any, or of an object type that has no call or construct signatures
     * but is a subtype of the Function interface, the call is an untyped function call.
     */
    fn isUntypedFunctionCall(
        &mut self,
        funcType: TypeId,
        apparentFuncType: TypeId,
        numCallSignatures: usize,
        numConstructSignatures: usize,
    ) -> bool {
        // We exclude union types because we may have a union of function types that happen to have no common signatures.
        self.isTypeAny(Some(funcType))
            || self.isTypeAny(Some(apparentFuncType))
                && self.types[funcType]
                    .get_flags()
                    .intersects(TypeFlags::TypeParameter)
            || numCallSignatures == 0
                && numConstructSignatures == 0
                && !self.types[apparentFuncType]
                    .get_flags()
                    .intersects(TypeFlags::Union)
                && {
                    let reduced = self.getReducedType(apparentFuncType);
                    !self.types[reduced].get_flags().intersects(TypeFlags::Never)
                }
                && self.isTypeAssignableTo(funcType, self.globalFunctionType())
    }

    fn resolveNewExpression(
        &mut self,
        node: &Rc<NewExpr>,
        candidatesOutArray: Option<&mut Vec<SignatureId>>,
        checkMode: CheckMode,
    ) -> SignatureId {
        // TODO: es3
        // if node.arguments && languageVersion < ScriptTarget.ES5 {
        //     let spreadIndex = getSpreadArgumentIndex(node.arguments);
        //     if (spreadIndex >= 0) {
        //         error(node.arguments[spreadIndex], Diagnostics.Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher);
        //     }
        // }
        let bound_node = BoundNode::NewExpr(node.clone());

        let mut expressionType = self.checkNonNullExpression(node.callee.bind(bound_node.clone()));
        if expressionType == self.silentNeverType {
            return self.silentNeverSignature;
        }

        // If expressionType's apparent type(section 3.8.1) is an object type with one or
        // more construct signatures, the expression is processed in the same manner as a
        // function call, but using the construct signatures as the initial set of candidate
        // signatures for overload resolution. The result type of the function call becomes
        // the result type of the operation.
        expressionType = self.getApparentType(expressionType);
        if self.isErrorType(expressionType) {
            todo!();
            // Another error has already been reported
            // return resolveErrorCall(node);
        }

        // TS 1.0 spec: 4.11
        // If expressionType is of type Any, Args can be any argument
        // list and the result of the operation is of type Any.
        if self.isTypeAny(Some(expressionType)) {
            todo!();
            // if node.type_args.is_some() {
            //     todo!();
            //     // error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            // }
            // return self.resolveUntypedCall(node);
        }

        // Technically, this signatures list may be incomplete. We are taking the apparent type,
        // but we are not including construct signatures that may have been added to the Object or
        // Function interface, since they have none by default. This is a bit of a leap of faith
        // that the user will not add any.
        let constructSignatures =
            self.getSignaturesOfType(expressionType, SignatureKind::Construct);
        if !constructSignatures.is_empty() {
            if !self.isConstructorAccessible(node, constructSignatures[0]) {
                todo!();
                // return resolveErrorCall(node);
            }
            // If the expression is a class of abstract type, or an abstract construct signature,
            // then it cannot be instantiated.
            // In the case of a merged class-module or class-interface declaration,
            // only the class declaration node will have the Abstract flag set.
            if constructSignatures.iter().any(|&signature| {
                self.signatures[signature]
                    .flags
                    .intersects(SignatureFlags::Abstract)
            }) {
                todo!();
                // error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
                // return resolveErrorCall(node);
            }
            let valueDecl = self.types[expressionType]
                .get_symbol()
                .as_ref()
                .and_then(|&s| getClassLikeDeclarationOfSymbol(&self.symbols[s]));
            if valueDecl.is_some()
                && hasSyntacticModifier(&valueDecl.unwrap(), ModifierFlags::Abstract)
            {
                todo!();
                // error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
                // return resolveErrorCall(node);
            }

            return self.resolveCall(
                bound_node,
                constructSignatures,
                candidatesOutArray,
                checkMode,
                SignatureFlags::None,
            );
        }

        // If expressionType's apparent type is an object type with no construct signatures but
        // one or more call signatures, the expression is processed as a function call. A compile-time
        // error occurs if the result of the function call is not Void. The type of the result of the
        // operation is Any. It is an error to have a Void this type.
        let callSignatures = self.getSignaturesOfType(expressionType, SignatureKind::Call);
        if !callSignatures.is_empty() {
            let signature = self.resolveCall(
                bound_node,
                callSignatures,
                candidatesOutArray,
                checkMode,
                SignatureFlags::None,
            );
            if !self.noImplicitAny {
                todo!();
                // if (signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) !== voidType) {
                //     error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
                // }
                // if (getThisTypeOfSignature(signature) == voidType) {
                //     error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void);
                // }
            }
            return signature;
        }

        todo!();
        // invocationError(node.expression, expressionType, SignatureKind.Construct);
        // self.resolveErrorCall(node)
    }

    // TODO:
    // typeHasProtectedAccessibleBase

    fn isConstructorAccessible(&mut self, node: &Rc<NewExpr>, signature: SignatureId) -> bool {
        let declaration = match self.signatures[signature].declaration.as_ref() {
            Some(d) => d,
            None => return true,
        };
        let modifiers = getSelectedEffectiveModifierFlags(
            declaration,
            ModifierFlags::NonPublicAccessibilityModifier,
        );

        // (1) Public constructors and (2) constructor functions are always accessible.
        if modifiers.is_empty() || !matches!(declaration, BoundNode::Constructor(_)) {
            return true;
        }

        todo!();

        // let declaringClassDeclaration =
        //     getClassLikeDeclarationOfSymbol(declaration.parent().unwrap().symbol).unwrap();
        // let declaringClass = self.getDeclaredTypeOfSymbol(declaration.parent.symbol);

        // // A private or protected constructor can only be instantiated within its own class (or a subclass, for protected)
        // if !isNodeWithinClass(node, declaringClassDeclaration) {
        //     todo!();
        //     // let containingClass = getContainingClass(node);
        //     // if containingClass && modifiers.intersects(ModifierFlags::Protected) {
        //     //     todo!();
        //     //     // let containingType = getTypeOfNode(containingClass);
        //     //     // if typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType as InterfaceType) {
        //     //     //     return true;
        //     //     // }
        //     // }
        //     // if modifiers.intersects(ModifierFlags::Private) {
        //     //     todo!();
        //     //     // error(node, Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
        //     // }
        //     // if modifiers.intersects(ModifierFlags::Protected) {
        //     //     todo!();
        //     //     // error(node, Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
        //     // }
        //     // return false;
        // }

        // true
    }

    // TODO:
    // invocationErrorDetails
    // TODO:
    // invocationError
    // TODO:
    // invocationErrorRecovery
    // TODO:
    // resolveTaggedTemplateExpression
    // TODO:
    // getDiagnosticHeadMessageForDecoratorResolution
    // TODO:
    // resolveDecorator
    // TODO:
    // createSignatureForJSXIntrinsic
    // TODO:
    // resolveJsxOpeningLikeElement
    // TODO:
    // isPotentiallyUncalledDecorator

    fn resolveSignature(
        &mut self,
        node: &BoundNode,
        candidatesOutArray: Option<&mut Vec<SignatureId>>,
        checkMode: CheckMode,
    ) -> SignatureId {
        match node {
            BoundNode::CallExpr(n) => self.resolveCallExpression(n, candidatesOutArray, checkMode),
            BoundNode::NewExpr(n) => self.resolveNewExpression(n, candidatesOutArray, checkMode),
            BoundNode::TaggedTpl(_) => {
                todo!();
                // self.resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode)
            }
            BoundNode::Decorator(_) => {
                todo!();
                // self.resolveDecorator(node, candidatesOutArray, checkMode)
            }
            // TODO: jsx:
            // BoundNode::JsxOpeningElement(_)|
            // BoundNode::JsxSelfClosingElement(_)=> {
            //     self.resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode)
            // }
            _ => unreachable!(),
        }
    }

    /**
     * Resolve a signature of a given call-like expression.
     * @param node a call-like expression to try resolve a signature for
     * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
     *                           the function will fill it up with appropriate candidate signatures
     * @return a signature of the call-like expression or undefined if one can't be found
     */
    fn getResolvedSignature(
        &mut self,
        node: BoundNode,
        candidatesOutArray: Option<&mut Vec<SignatureId>>,
        checkMode: Option<CheckMode>,
    ) -> SignatureId {
        let resolvingSignature = self.resolvingSignature;
        let links = self.getNodeLinks_mut(node.clone());
        // If getResolvedSignature has already been called, we will have cached the resolvedSignature.
        // However, it is possible that either candidatesOutArray was not passed in the first time,
        // or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
        // to correctly fill the candidatesOutArray.
        let cached = links.resolvedSignature;
        if let Some(cached) = cached {
            if cached != resolvingSignature && candidatesOutArray.is_none() {
                return cached;
            }
        }
        links.resolvedSignature = Some(resolvingSignature);
        let result = self.resolveSignature(
            &node,
            candidatesOutArray,
            checkMode.unwrap_or(CheckMode::Normal),
        );
        // When CheckMode::SkipGenericFunctions is set we use resolvingSignature to indicate that call
        // resolution should be deferred.
        if result != resolvingSignature {
            // If signature resolution originated in control flow type analysis (for example to compute the
            // assigned type in a flow assignment) we don't cache the result as it may be based on temporary
            // types from the control flow analysis.
            self.getNodeLinks_mut(node).resolvedSignature =
                if self.flowLoopStart == self.flowLoopCount {
                    Some(result)
                } else {
                    cached
                };
        }
        result
    }

    /**
     * Indicates whether a declaration can be treated as a constructor in a JavaScript
     * file.
     */
    fn isJSConstructor(&mut self, node: Option<BoundNode>) -> bool {
        if let Some(node) = node {
            if !isBoundNodeInJSFile(&node) {
                return false;
            }
            let func = match &node {
                BoundNode::FnDecl(_) | BoundNode::FnExpr(_) => Some(node),
                BoundNode::VarDeclarator(v) => {
                    if let Some(ast::Expr::Fn(f)) = &v.init {
                        Some(f.bind(node.clone()))
                    } else {
                        None
                    }
                }
                _ => None,
            };
            if let Some(func) = func {
                // TODO: jsdoc
                // If the node has a @class tag, treat it like a constructor.
                // if getJSDocClassTag(node) {
                //     return true;
                // }

                // If the symbol of the node has members, treat it like a constructor.
                let symbol = self.getSymbolOfNode(func);
                return symbol
                    .and_then(|s| self.symbols[s].members().as_ref())
                    .map(|s| !self.symbol_tables[*s].is_empty())
                    .unwrap_or_default();
            }
        }
        false
    }

    fn mergeJSSymbols(&mut self, target: SymbolId, source: Option<SymbolId>) -> Option<SymbolId> {
        if let Some(source) = source {
            todo!();
            // let links = self.getSymbolLinks(source);
            // if !links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target)) {
            //     const inferred = isTransientSymbol(target) ? target : cloneSymbol(target) as TransientSymbol;
            //     inferred.exports = inferred.exports || createSymbolTable();
            //     inferred.members = inferred.members || createSymbolTable();
            //     inferred.flags |= source.flags & SymbolFlags::Class;
            //     if (source.exports?.size) {
            //         mergeSymbolTable(inferred.exports, source.exports);
            //     }
            //     if (source.members?.size) {
            //         mergeSymbolTable(inferred.members, source.members);
            //     }
            //     (links.inferredClassSymbol || (links.inferredClassSymbol = new Map())).set(getSymbolId(inferred), inferred);
            //     return inferred;
            // }
            // return links.inferredClassSymbol.get(getSymbolId(target));
        }

        None
    }

    fn getAssignedClassSymbol(&mut self, decl: BoundNode) -> Option<SymbolId> {
        let assignmentSymbol = self.getSymbolOfExpando(decl, /*allowDeclaration*/ true);
        let prototype = assignmentSymbol
            .and_then(|s| self.symbols[s].exports().as_ref())
            .and_then(|s| self.symbol_tables[*s].get(&JsWord::from("prototype")));
        let init = prototype
            .and_then(|p| self.symbols[*p].valueDeclaration().clone())
            .and_then(|v| self.getAssignedJSPrototype(v));
        if let Some(init) = init {
            self.getSymbolOfNode(init)
        } else {
            None
        }
    }

    fn getSymbolOfExpando(&mut self, node: BoundNode, allowDeclaration: bool) -> Option<SymbolId> {
        let parent = node.parent()?;
        let mut name = None;
        let mut decl = None;
        match &parent {
            BoundNode::VarDeclarator(d)
                if d.init.as_ref().map(|n| n.bind(parent.clone())) == Some(node.clone()) =>
            {
                if !isBoundNodeInJSFile(&node) {
                    let var_decl = unwrap_as!(parent.parent(), Some(BoundNode::VarDecl(v)), v);
                    if !(var_decl.kind == ast::VarDeclKind::Const
                        && isFunctionLikeDeclaration(&node))
                    {
                        return None;
                    }
                }
                name = Some(d.name.bind(parent.clone()));
                decl = Some(parent.clone());
            }
            BoundNode::AssignExpr(e) => {
                if allowDeclaration || e.right.bind(parent.clone()) == node {
                    name = Some(e.left.bind(parent.clone()));
                    decl = name.clone();
                }
            }
            BoundNode::BinExpr(e) => match e.op {
                ast::BinaryOp::LogicalOr | ast::BinaryOp::NullishCoalescing => {
                    todo!();
                    // if isVariableDeclaration(parent.parent) && parent.parent.initializer == parent {
                    //     name = parent.parent.name;
                    //     decl = parent.parent;
                    // } else if isBinaryExpression(parent.parent)
                    //     && parent.parent.operatorToken.kind == SyntaxKind.EqualsToken
                    //     && (allowDeclaration || parent.parent.right == parent)
                    // {
                    //     name = parent.parent.left;
                    //     decl = name;
                    // }

                    // if !name
                    //     || !isBindableStaticNameExpression(name)
                    //     || !isSameEntityName(name, parent.left)
                    // {
                    //     return None;
                    // }
                }
                _ => {}
            },
            _ if allowDeclaration => {
                if let BoundNode::FnDecl(f) = &node {
                    name = Some(f.ident.bind(node.clone()));
                    decl = Some(node.clone());
                }
            }
            _ => {}
        }

        let decl = decl?;
        let name = name?;

        if !allowDeclaration
            && getExpandoInitializer(node.into(), isPrototypeAccess(&name.into())).is_none()
        {
            return None;
        }
        self.getSymbolOfNode(decl)
    }

    fn getAssignedJSPrototype(&mut self, node: BoundNode) -> Option<BoundNode> {
        todo!();
        // if (!node.parent) {
        //     return false;
        // }
        // let parent: Node = node.parent;
        // while (parent && parent.kind === SyntaxKind.PropertyAccessExpression) {
        //     parent = parent.parent;
        // }
        // if (parent && isBinaryExpression(parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind === SyntaxKind.EqualsToken) {
        //     const right = getInitializerOfBinaryExpression(parent);
        //     return isObjectLiteralExpression(right) && right;
        // }
    }

    /**
     * Syntactically and semantically checks a call or new expression.
     * @param node The call/new expression to be checked.
     * @returns On success, the expression's signature's return type. On failure, anyType.
     */
    fn checkCallExpression(&mut self, node: &BoundNode, checkMode: Option<CheckMode>) -> TypeId {
        debug_assert!(matches!(
            node,
            BoundNode::CallExpr(_) | BoundNode::NewExpr(_)
        ));
        // if (!checkGrammarTypeArguments(node, node.typeArguments)) {
        //     checkGrammarArguments(node.arguments);
        // }

        let signature = self.getResolvedSignature(node.clone(), None, checkMode);
        if signature == self.resolvingSignature {
            // CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
            // returns a function type. We defer checking and return nonInferrableType.
            return self.nonInferrableType;
        }

        // TODO:
        // self.checkDeprecatedSignature(signature, node);

        if matches!(&node, BoundNode::CallExpr(c) if matches!(c.callee, ast::ExprOrSuper::Super(_)))
        {
            return self.voidType;
        }

        if matches!(node, BoundNode::NewExpr(_)) {
            let declaration = self.signatures[signature].declaration.as_ref();

            if let Some(declaration) = declaration {
                if !matches!(
                    declaration,
                    BoundNode::Constructor(_)
                        | BoundNode::TsConstructSignatureDecl(_)
                        | BoundNode::TsConstructorType(_)
                ) && !isJSDocConstructSignature(declaration)
                    && !self.isJSConstructor(Some(declaration.clone()))
                {
                    // When resolved signature is a call signature (and not a construct signature) the result type is any
                    if self.noImplicitAny {
                        todo!();
                        // error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                    }
                    return self.anyType;
                }
            }
        }

        // In JavaScript files, calls to any identifier 'require' are treated as external module imports
        // if isBoundNodeInJSFile(node) && isCommonJsRequire(node) {
        //     return resolveExternalModuleTypeByLiteral(node.arguments![0] as StringLiteral);
        // }
        if isBoundNodeInJSFile(node) {
            todo!("see above");
        }

        let returnType = self.getReturnTypeOfSignature(signature);
        // Treat any call to the global 'Symbol' function that is part of a const variable or readonly property
        // as a fresh unique symbol literal type.
        if self.types[returnType]
            .get_flags()
            .intersects(TypeFlags::ESSymbolLike)
            && self.isSymbolOrSymbolForCall(node)
        {
            todo!();
            // return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent));
        }
        if matches!(node, BoundNode::CallExpr(_))
            && matches!(node.parent(), Some(BoundNode::ExprStmt(_)))
            && self.types[returnType]
                .get_flags()
                .intersects(TypeFlags::Void)
            && self.getTypePredicateOfSignature(signature).is_some()
        {
            todo!();
            // if (!isDottedName(node.expression)) {
            //     error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name);
            // }
            // else if (!getEffectsSignature(node)) {
            //     const diagnostic = error(node.expression, Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation);
            //     getTypeOfDottedName(node.expression, diagnostic);
            // }
        }

        if isBoundNodeInJSFile(node) {
            todo!();
            // const jsSymbol = getSymbolOfExpando(node, /*allowDeclaration*/ false);
            // if (jsSymbol?.exports?.size) {
            //     const jsAssignmentType = createAnonymousType(jsSymbol, jsSymbol.exports, emptyArray, emptyArray, emptyArray);
            //     jsAssignmentType.objectFlags |= ObjectFlags.JSLiteral;
            //     return getIntersectionType([returnType, jsAssignmentType]);
            // }
        }

        returnType
    }

    // TODO:
    // checkDeprecatedSignature
    // TODO:
    // getDeprecatedSuggestionNode

    fn isSymbolOrSymbolForCall(&mut self, node: &BoundNode) -> bool {
        if let BoundNode::CallExpr(call) = node {
            let mut left = call.callee.bind(call.clone().into());
            if let BoundNode::MemberExpr(e) = &left {
                if !e.computed && unwrap_as!(&e.prop, ast::Expr::Ident(i), i).sym == js_word!("for")
                {
                    left = e.obj.bind(left.clone());
                }
            }
            if !matches!(left, BoundNode::Ident(i) if i.sym ==js_word!("Symbol") ) {
                return false;
            }

            todo!();

            // make sure `Symbol` is the global symbol
            // let globalESSymbol = self.getGlobalESSymbolConstructorSymbol(/*reportErrors*/ false);
            // if (!globalESSymbol) {
            //     return false;
            // }

            // globalESSymbol
            //     == self.resolveName(
            //         Some(left),
            //         js_word!("Symbol"),
            //         SymbolFlags::Value,
            //         // /*nameNotFoundMessage*/ undefined,
            //         None,
            //         false,
            //         false,
            //     )
        } else {
            false
        }
    }

    // TODO:
    // checkImportCallExpression
    // TODO:
    // getTypeWithSyntheticDefaultImportType

    fn isCommonJsRequire(&mut self, node: BoundNode) -> bool {
        if !isRequireCall(&node.into(), true) {
            return false;
        }
        todo!();

        // // Make sure require is not a local function
        // if (!isIdentifier(node.expression)) return Debug.fail();
        // const resolvedRequire = resolveName(node.expression, node.expression.escapedText, SymbolFlags::Value, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ true)!; // TODO: GH#18217
        // if (resolvedRequire === requireSymbol) {
        //     return true;
        // }
        // // project includes symbol named 'require' - make sure that it is ambient and local non-alias
        // if (resolvedRequire.flags & SymbolFlags::Alias) {
        //     return false;
        // }

        // const targetDeclarationKind = resolvedRequire.flags & SymbolFlags::Function
        //     ? SyntaxKind.FunctionDeclaration
        //     : resolvedRequire.flags & SymbolFlags::Variable
        //         ? SyntaxKind.VariableDeclaration
        //         : SyntaxKind.Unknown;
        // if (targetDeclarationKind !== SyntaxKind.Unknown) {
        //     const decl = getDeclarationOfKind(resolvedRequire, targetDeclarationKind)!;
        //     // function/variable declaration should be ambient
        //     return !!decl && !!(decl.flags & NodeFlags.Ambient);
        // }
        // return false;
    }

    // TODO:
    // checkTaggedTemplateExpression

    fn checkAssertion(&mut self, node: &BoundNode) -> TypeId {
        let (ty, expr) = match node {
            BoundNode::TsTypeAssertion(n) => {
                // TODO:
                // let file = getSourceFileOfNode(node);
                // if (file && fileExtensionIsOneOf(file.fileName, [Extension.Cts, Extension.Mts])) {
                //     grammarErrorOnNode(node, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead);
                // }
                (&n.type_ann, &n.expr)
            }
            BoundNode::TsAsExpr(n) => (&n.type_ann, &n.expr),
            _ => unreachable!(),
        };
        self.checkAssertionWorker(node, ty.bind(node.clone()), expr.bind(node.clone()), None)
    }

    // TODO:
    // isValidConstAssertionArgument

    fn checkAssertionWorker(
        &mut self,
        errNode: &BoundNode,
        ty: BoundNode,
        expression: BoundNode,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        let exprType = self.checkExpression(expression, checkMode, false);
        if isConstTypeReference(&ty.clone().into()) {
            todo!();
            // if !isValidConstAssertionArgument(expression) {
            //     todo!();
            //     // error(expression, Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals);
            // }
            // return self.getRegularTypeOfLiteralType(exprType);
        }
        self.checkSourceElement(Some(ty.clone()));
        let exprType = self.getBaseTypeOfLiteralType(exprType);
        let exprType = self.getRegularTypeOfObjectLiteral(exprType);
        let targetType = self.getTypeFromTypeNode(ty);
        if self.produceDiagnostics && !self.isErrorType(targetType) {
            todo!();
            // let widenedType = self.getWidenedType(exprType);
            // if !self.isTypeComparableTo(targetType, widenedType) {
            //     self.checkTypeComparableTo(exprType, targetType, errNode,
            //         Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first);
            // }
        }
        targetType
    }

    // TODO:
    // checkNonNullChain
    // TODO:
    // checkNonNullAssertion
    // TODO:
    // checkMetaProperty
    // TODO:
    // checkMetaPropertyKeyword
    // TODO:
    // checkNewTargetMetaProperty
    // TODO:
    // checkImportMetaProperty

    fn getTypeOfParameter(&mut self, symbol: SymbolId) -> TypeId {
        let ty = self.getTypeOfSymbol(symbol);
        if self.strictNullChecks {
            if let Some(declaration) = self.symbols[symbol].valueDeclaration() {
                todo!();
                // if hasInitializer(declaration) {
                //     return getOptionalType(ty);
                // }
            }
        }
        ty
    }

    // TODO:
    // getTupleElementLabel

    fn getParameterNameAtPosition(
        &mut self,
        signature: SignatureId,
        pos: usize,
        overrideRestType: Option<TypeId>,
    ) -> JsWord {
        let sig = &self.signatures[signature];
        let mut paramCount = sig.parameters.len();
        if signatureHasRestParameter(sig) {
            paramCount -= 1;
        }
        if pos < paramCount {
            return self.symbols[sig.parameters[pos]].escapedName().clone();
        }
        let restParameter = sig
            .parameters
            .get(paramCount)
            .cloned()
            .unwrap_or(self.unknownSymbol);
        let restType = overrideRestType.unwrap_or_else(|| self.getTypeOfSymbol(restParameter));
        if self.isTupleType(restType) {
            todo!();
            // let associatedNames = ((restType as TypeReference).target as TupleType).labeledElementDeclarations;
            // let index = pos - paramCount;
            // return associatedNames && getTupleElementLabel(associatedNames[index]) || restParameter.escapedName + "_" + index as __String;
        }
        self.symbols[restParameter].escapedName().clone()
    }

    // TODO:
    // getParameterIdentifierNameAtPosition
    // TODO:
    // isParameterDeclarationWithIdentifierName
    // TODO:
    // isValidDeclarationForTupleLabel

    fn getNameableDeclarationAtPosition(
        &mut self,
        signature: SignatureId,
        pos: usize,
    ) -> Option<BoundNode> {
        let paramCount = self.signatures[signature].parameters.len()
            - (if signatureHasRestParameter(&self.signatures[signature]) {
                1
            } else {
                0
            });
        if (pos < paramCount) {
            todo!();
            // let decl = self.signatures[signature].parameters[pos].valueDeclaration;
            // return if decl && isValidDeclarationForTupleLabel(decl) {
            //     decl
            // } else {
            //     None
            // };
        }
        let restParameter = self.signatures[signature]
            .parameters
            .get(paramCount)
            .copied()
            .unwrap_or(self.unknownSymbol);
        let restType = self.getTypeOfSymbol(restParameter);
        if self.isTupleType(restType) {
            todo!();
            // let associatedNames =
            //     ((restType as TypeReference).target as TupleType).labeledElementDeclarations;
            // let index = pos - paramCount;
            // return associatedNames.and_then(|names| names.get(index));
        }
        if let Some(vd) = self.symbols[restParameter].valueDeclaration() {
            todo!();
            // if isValidDeclarationForTupleLabel(vd) {
            //     return vd;
            // }
        }
        None
    }

    fn getTypeAtPosition(&mut self, signature: SignatureId, pos: usize) -> TypeId {
        self.tryGetTypeAtPosition(signature, pos)
            .unwrap_or(self.anyType)
    }

    fn tryGetTypeAtPosition(&mut self, signature: SignatureId, pos: usize) -> Option<TypeId> {
        let paramCount = self.signatures[signature].parameters.len()
            - (if signatureHasRestParameter(&self.signatures[signature]) {
                1
            } else {
                0
            });
        if pos < paramCount {
            return Some(self.getTypeOfParameter(self.signatures[signature].parameters[pos]));
        }
        if signatureHasRestParameter(&self.signatures[signature]) {
            todo!();
            // We want to return the value undefined for an out of bounds parameter position,
            // so we need to check bounds here before calling getIndexedAccessType (which
            // otherwise would return the type 'undefined').
            // let restType = self.getTypeOfSymbol(signature.parameters[paramCount]);
            // let index = pos - paramCount;
            // if (!isTupleType(restType) || restType.target.hasRestElement || index < restType.target.fixedLength) {
            //     return self.getIndexedAccessType(restType, self.getNumberLiteralType(index));
            // }
        }
        None
    }

    fn getRestTypeAtPosition(&mut self, source: SignatureId, pos: usize) -> TypeId {
        let parameterCount = self.getParameterCount(source);
        let minArgumentCount = self.getMinArgumentCount(source, None);
        let restType = self.getEffectiveRestType(source);
        if let Some(restType) = restType {
            if pos >= parameterCount - 1 {
                return if pos == parameterCount - 1 {
                    restType
                } else {
                    todo!();
                    // self.createArrayType(
                    //     self.getIndexedAccessType(restType, self.numberType),
                    //     false,
                    // )
                };
            }
        }
        let capacity = parameterCount - pos;
        let mut types = Vec::with_capacity(capacity);
        let mut flags = Vec::with_capacity(capacity);
        let mut names = Vec::with_capacity(capacity);
        for i in pos..parameterCount {
            if restType.is_none() || i < parameterCount - 1 {
                types.push(self.getTypeAtPosition(source, i));
                flags.push(if i < minArgumentCount {
                    ElementFlags::Required
                } else {
                    ElementFlags::Optional
                });
            } else {
                types.push(restType.unwrap());
                flags.push(ElementFlags::Variadic);
            }
            let name = self.getNameableDeclarationAtPosition(source, i);
            if let Some(name) = name {
                names.push(name);
            }
        }
        let namedMemberDeclarations = if names.len() == types.len() {
            Some(names)
        } else {
            None
        };
        self.createTupleType(Rc::new(types), Some(flags), false, namedMemberDeclarations)
    }

    // Return the number of parameters in a signature. The rest parameter, if present, counts as one
    // parameter. For example, the parameter count of (x: number, y: number, ...z: string[]) is 3 and
    // the parameter count of (x: number, ...args: [number, ...string[], boolean])) is also 3. In the
    // latter example, the effective rest type is [...string[], boolean].
    fn getParameterCount(&mut self, signature: SignatureId) -> usize {
        let length = self.signatures[signature].parameters.len();
        if signatureHasRestParameter(&self.signatures[signature]) {
            todo!();
            // let restType = getTypeOfSymbol(signature.parameters[length - 1]);
            // if isTupleType(restType) {
            //     return length + restType.target.fixedLength - (restType.target.hasRestElement ? 0 : 1);
            // }
        }
        length
    }

    fn getMinArgumentCount(
        &mut self,
        signature: SignatureId,
        flags: Option<MinArgumentCountFlags>,
    ) -> usize {
        let flags = flags.unwrap_or_default();
        let strongArityForUntypedJS =
            flags.intersects(MinArgumentCountFlags::StrongArityForUntypedJS);
        let voidIsNonOptional = flags.intersects(MinArgumentCountFlags::VoidIsNonOptional);
        if voidIsNonOptional || self.signatures[signature].resolvedMinArgumentCount == None {
            let mut minArgumentCount = None;
            if signatureHasRestParameter(&self.signatures[signature]) {
                todo!();
                // let restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                // if (isTupleType(restType)) {
                //     const firstOptionalIndex = findIndex(restType.target.elementFlags, f => !(f & ElementFlags.Required));
                //     const requiredCount = firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex;
                //     if (requiredCount > 0) {
                //         minArgumentCount = signature.parameters.length - 1 + requiredCount;
                //     }
                // }
            }
            let mut minArgumentCount = match minArgumentCount {
                Some(c) => c,
                None => {
                    if !strongArityForUntypedJS
                        && self.signatures[signature]
                            .flags
                            .intersects(SignatureFlags::IsUntypedSignatureInJSFile)
                    {
                        return 0;
                    }
                    self.signatures[signature].minArgumentCount
                }
            };
            if voidIsNonOptional {
                return minArgumentCount;
            }
            let mut i = isize::try_from(minArgumentCount).unwrap() - 1;
            while i >= 0 {
                let ty = self.getTypeAtPosition(signature, i as usize);
                let filtered = self.filterType(ty, |checker, ty| checker.acceptsVoid(ty));
                if self.types[filtered]
                    .get_flags()
                    .intersects(TypeFlags::Never)
                {
                    break;
                }
                minArgumentCount = i as usize;
                i -= 1;
            }
            self.signatures[signature].resolvedMinArgumentCount = Some(minArgumentCount);
        }
        self.signatures[signature].resolvedMinArgumentCount.unwrap()
    }

    fn hasEffectiveRestParameter(&mut self, signature: SignatureId) -> bool {
        if signatureHasRestParameter(&self.signatures[signature]) {
            todo!();
            // let restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            // return !isTupleType(restType) || restType.target.hasRestElement;
        }
        false
    }

    fn getEffectiveRestType(&mut self, signature: SignatureId) -> Option<TypeId> {
        if signatureHasRestParameter(&self.signatures[signature]) {
            todo!();
            // let restType = self.getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            // if (!isTupleType(restType)) {
            //     return restType;
            // }
            // if (restType.target.hasRestElement) {
            //     return sliceTupleType(restType, restType.target.fixedLength);
            // }
        }
        None
    }

    fn getNonArrayRestType(&mut self, signature: SignatureId) -> Option<TypeId> {
        let restType = self.getEffectiveRestType(signature);
        if let Some(restType) = restType {
            if !self.isArrayType(restType) && !self.isTypeAny(Some(restType)) {
                let reduced = self.getReducedType(restType);
                if !self.types[reduced].get_flags().intersects(TypeFlags::Never) {
                    return Some(restType);
                }
            }
        }
        None
    }

    // TODO:
    // getTypeOfFirstParameterOfSignature
    // TODO:
    // getTypeOfFirstParameterOfSignatureWithFallback

    fn inferFromAnnotatedParameters(
        &mut self,
        signature: SignatureId,
        context: SignatureId,
        inferenceContext: InferenceContextId,
    ) {
        let len = self.signatures[signature].parameters.len()
            - (if signatureHasRestParameter(&self.signatures[signature]) {
                1
            } else {
                0
            });
        for i in 0..len {
            let declaration = self.symbols[self.signatures[signature].parameters[i]]
                .valueDeclaration()
                .clone()
                .unwrap();
            let pat = match &declaration {
                BoundNode::Param(n) => n.pat.clone(),
                BoundNode::ParamWithoutDecorators(n) => n.pat.clone(),
                BoundNode::TsAmbientParam(n) => n.pat.clone().into(),
                BoundNode::TsParamProp(n) => n.param.clone().into(),
                _ => unreachable!(),
            };
            let has_type_ann = match pat {
                ast::Pat::Ident(n) => n.type_ann.is_some(),
                ast::Pat::Array(n) => n.type_ann.is_some(),
                ast::Pat::Rest(n) => n.type_ann.is_some(),
                ast::Pat::Object(n) => n.type_ann.is_some(),
                ast::Pat::Assign(n) => n.type_ann.is_some(),
                _ => unreachable!(),
            };
            if has_type_ann {
                let typeNode = getBoundEffectiveTypeAnnotationNode(&declaration);
                if let Some(typeNode) = typeNode {
                    let originalSource = self.getTypeFromTypeNode(typeNode);
                    let originalTarget = self.getTypeAtPosition(context, i);
                    self.inferTypes(
                        inferenceContext,
                        originalSource,
                        originalTarget,
                        None,
                        false,
                    );
                }
            }
        }
        let restType = self.getEffectiveRestType(context);
        if let Some(restType) = restType {
            if self.types[restType]
                .get_flags()
                .intersects(TypeFlags::TypeParameter)
            {
                // The contextual signature has a generic rest parameter. We first instantiate the contextual
                // signature (without fixing type parameters) and assign types to contextually typed parameters.
                let instantiatedContext = self.instantiateSignature(
                    context,
                    self.inference_contexts[inferenceContext]
                        .nonFixingMapper
                        .clone(),
                    false,
                );
                self.assignContextualParameterTypes(signature, instantiatedContext);
                // We then infer from a tuple type representing the parameters that correspond to the contextual
                // rest parameter.
                let restPos = self.getParameterCount(context) - 1;
                let originalSource = self.getRestTypeAtPosition(signature, restPos);
                self.inferTypes(inferenceContext, originalSource, restType, None, false);
            }
        }
    }

    fn assignContextualParameterTypes(&mut self, signature: SignatureId, context: SignatureId) {
        if self.signatures[context].typeParameters.is_some() {
            if self.signatures[signature].typeParameters.is_none() {
                self.signatures[signature].typeParameters =
                    self.signatures[context].typeParameters.clone();
            } else {
                return; // This signature has already has a contextual inference performed and cached on it!
            }
        }
        if let Some(context_this_param) = self.signatures[context].thisParameter {
            todo!();
            // let parameter = self.signatures[signature].thisParameter;
            // if parameter.is_none() || parameter.valueDeclaration && !(parameter.valueDeclaration as ParameterDeclaration).ty {
            //     if parameter.is_none() {
            //         self.signatures[signature].thisParameter = self.createSymbolWithType(context_this_param, None);
            //     }
            //     assignParameterType(self.signatures[signature].thisParameter.unwrap(), self.getTypeOfSymbol(context_this_param));
            // }
        }
        let len = self.signatures[signature].parameters.len()
            - (if signatureHasRestParameter(&self.signatures[signature]) {
                1
            } else {
                0
            });
        for i in 0..len {
            let parameter = self.signatures[signature].parameters[i];
            if getEffectiveTypeAnnotationNode(
                &self.symbols[parameter]
                    .valueDeclaration()
                    .clone()
                    .unwrap()
                    .into(),
            )
            .is_none()
            {
                let contextualParameterType = self.tryGetTypeAtPosition(context, i);
                self.assignParameterType(parameter, contextualParameterType);
            }
        }
        if signatureHasRestParameter(&self.signatures[signature]) {
            todo!();
            // parameter might be a transient symbol generated by use of `arguments` in the function body.
            // let parameter = last(signature.parameters);
            // if (isTransientSymbol(parameter) || !getEffectiveTypeAnnotationNode(parameter.valueDeclaration as ParameterDeclaration)) {
            //     let contextualParameterType = getRestTypeAtPosition(context, len);
            //     assignParameterType(parameter, contextualParameterType);
            // }
        }
    }

    fn assignNonContextualParameterTypes(&mut self, signature: SignatureId) {
        if let Some(thisParameter) = self.signatures[signature].thisParameter {
            self.assignParameterType(thisParameter, None);
        }
        for parameter in self.signatures[signature].parameters.clone().iter() {
            self.assignParameterType(*parameter, None);
        }
    }

    fn assignParameterType(&mut self, parameter: SymbolId, ty: Option<TypeId>) {
        if self.getSymbolLinks(parameter).ty.is_none() {
            let decl = self.symbols[parameter].valueDeclaration().clone().unwrap();
            self.getSymbolLinksMut(parameter).ty = ty.or_else(|| {
                Some(self.getWidenedTypeForVariableLikeDeclaration(
                    decl.clone(),
                    /*includeOptionality*/ true,
                ))
            });
            let mut name = match &decl {
                BoundNode::Param(n) => n.pat.bind(decl.clone()),
                BoundNode::ParamWithoutDecorators(n) => n.pat.bind(decl.clone()),
                BoundNode::TsAmbientParam(n) => n.pat.bind(decl.clone()),
                BoundNode::TsParamProp(n) => n.param.bind(decl.clone()),
                _ => todo!("unreachable?"),
            };
            match &name {
                BoundNode::RestPat(n) => name = n.arg.bind(name.clone()),
                BoundNode::AssignPat(n) => name = n.left.bind(name.clone()),
                _ => {}
            }
            if !matches!(name, BoundNode::BindingIdent(_)) {
                // if inference didn't come up with anything but unknown, fall back to the binding pattern if present.
                // if links.ty == self.unknownType {
                //     links.ty = self.getTypeFromBindingPattern(declaration.name);
                // }
                // self.assignBindingElementTypes(declaration.name);
                todo!();
            }
        }
    }

    // TODO:
    // assignBindingElementTypes
    // TODO:
    // createPromiseType
    // TODO:
    // createPromiseLikeType
    // TODO:
    // createPromiseReturnType
    // TODO:
    // createNewTargetExpressionType

    fn getReturnTypeFromBody(&mut self, func: &BoundNode, checkMode: Option<CheckMode>) -> TypeId {
        let has_body = match func {
            BoundNode::Constructor(n) => n.body.is_some(),
            BoundNode::GetterProp(n) => n.body.is_some(),
            BoundNode::SetterProp(n) => n.body.is_some(),
            BoundNode::FnDecl(n) => n.function.body.is_some(),
            BoundNode::FnExpr(n) => n.function.body.is_some(),
            BoundNode::PrivateMethod(n) => n.function.body.is_some(),
            BoundNode::ClassMethod(n) => n.function.body.is_some(),
            BoundNode::MethodProp(n) => n.function.body.is_some(),
            BoundNode::ArrowExpr(_) => true,
            _ => unreachable!(),
        };
        if !has_body {
            return self.errorType;
        }

        let functionFlags = getFunctionFlags(Some(func));
        let isAsync = functionFlags.intersects(FunctionFlags::Async);
        let isGenerator = functionFlags.intersects(FunctionFlags::Generator);

        let mut returnType = None;
        let mut yieldType = None;
        let mut nextType = None;
        let mut fallbackReturnType = self.voidType;
        match func {
            BoundNode::ArrowExpr(e) if matches!(e.body, ast::BlockStmtOrExpr::Expr(_)) => {
                // Async or normal arrow function
                todo!();
                // returnType = checkExpressionCached(func.body, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);
                // if (isAsync) {
                //     // From within an async function you can return either a non-promise value or a promise. Any
                //     // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                //     // return type of the body should be unwrapped to its awaited type, which we will wrap in
                //     // the native Promise<T> type later in this function.
                //     returnType = unwrapAwaitedType(checkAwaitedType(returnType, /*withAlias*/ false, /*errorNode*/ func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));
                // }
            }
            _ if isGenerator => {
                // Generator or AsyncGenerator function
                todo!();
                // const returnTypes = checkAndAggregateReturnExpressionTypes(func, checkMode);
                // if (!returnTypes) {
                //     fallbackReturnType = neverType;
                // }
                // else if (returnTypes.length > 0) {
                //     returnType = getUnionType(returnTypes, UnionReduction.Subtype);
                // }
                // const { yieldTypes, nextTypes } = checkAndAggregateYieldOperandTypes(func, checkMode);
                // yieldType = some(yieldTypes) ? getUnionType(yieldTypes, UnionReduction.Subtype) : undefined;
                // nextType = some(nextTypes) ? getIntersectionType(nextTypes) : undefined;
            }
            _ => {
                // Async or normal function
                let types = self.checkAndAggregateReturnExpressionTypes(func, checkMode);
                if let Some(types) = types {
                    if types.is_empty() {
                        // For an async function, the return type will not be void, but rather a Promise for void.
                        return if functionFlags.intersects(FunctionFlags::Async) {
                            // Async function
                            // createPromiseReturnType(func, self.voidType)
                            todo!();
                        } else {
                            // Normal function
                            self.voidType
                        };
                    }

                    // Return a union of the return expression types.
                    returnType = Some(self.getUnionType(
                        &types,
                        Some(UnionReduction::Subtype),
                        None,
                        None,
                        None,
                    ));
                } else {
                    // For an async function, the return type will not be never, but rather a Promise for never.
                    return if functionFlags.intersects(FunctionFlags::Async) {
                        // Async function
                        // createPromiseReturnType(func, self.neverType)
                        todo!();
                    } else {
                        // Normal function
                        self.neverType
                    };
                }
            }
        }

        if returnType.is_some() || yieldType.is_some() || nextType.is_some() {
            if let Some(yieldType) = yieldType {
                self.reportErrorsFromWidening(
                    func.clone(),
                    yieldType,
                    Some(WideningKind::GeneratorYield),
                );
            }
            if let Some(returnType) = returnType {
                self.reportErrorsFromWidening(
                    func.clone(),
                    returnType,
                    Some(WideningKind::FunctionReturn),
                );
            }
            if let Some(nextType) = nextType {
                self.reportErrorsFromWidening(
                    func.clone(),
                    nextType,
                    Some(WideningKind::GeneratorNext),
                );
            }
            if returnType.is_some() && self.isUnitType(returnType.unwrap())
                || yieldType.is_some() && self.isUnitType(yieldType.unwrap())
                || nextType.is_some() && self.isUnitType(nextType.unwrap())
            {
                let contextualSignature =
                    self.getContextualSignatureForFunctionLikeDeclaration(func);
                let contextualType = if let Some(contextualSignature) = contextualSignature {
                    if contextualSignature == self.getSignatureFromDeclaration(func.clone()) {
                        if isGenerator {
                            None
                        } else {
                            returnType
                        }
                    } else {
                        let contextualType = self.getReturnTypeOfSignature(contextualSignature);
                        self.instantiateContextualType(Some(contextualType), func.clone(), None)
                    }
                } else {
                    None
                };
                if isGenerator {
                    todo!();
                    // yieldType = self.getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(
                    //     yieldType,
                    //     contextualType,
                    //     IterationTypeKind::Yield,
                    //     isAsync,
                    // );
                    // returnType = self.getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(
                    //     returnType,
                    //     contextualType,
                    //     IterationTypeKind::Return,
                    //     isAsync,
                    // );
                    // nextType = self.getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(
                    //     nextType,
                    //     contextualType,
                    //     IterationTypeKind::Next,
                    //     isAsync,
                    // );
                } else {
                    returnType = self.getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(
                        returnType,
                        contextualType,
                        isAsync,
                    );
                }
            }

            if let Some(ty) = yieldType {
                yieldType = Some(self.getWidenedType(ty));
            }
            if let Some(ty) = returnType {
                returnType = Some(self.getWidenedType(ty));
            }
            if let Some(ty) = nextType {
                nextType = Some(self.getWidenedType(ty));
            }
        }

        if isGenerator {
            todo!();
            // return createGeneratorReturnType(
            //     yieldType || neverType,
            //     returnType || fallbackReturnType,
            //     nextType || getContextualIterationType(IterationTypeKind.Next, func) || unknownType,
            //     isAsync);
        } else {
            // From within an async function you can return either a non-promise value or a promise. Any
            // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
            // return type of the body is awaited type of the body, wrapped in a native Promise<T> type.
            if isAsync {
                todo!();
                // createPromiseType(returnType || fallbackReturnType)
            } else {
                returnType.unwrap_or(fallbackReturnType)
            }
        }
    }

    // TODO:
    // createGeneratorReturnType
    // TODO:
    // checkAndAggregateYieldOperandTypes
    // TODO:
    // getYieldedTypeOfYieldExpression
    // TODO:
    // getFactsFromTypeofSwitch

    fn isExhaustiveSwitchStatement(&mut self, node: &Rc<SwitchStmt>) -> bool {
        let links = self.getNodeLinks(node.clone().into());
        if let Some(isExhaustive) = links.isExhaustive {
            isExhaustive
        } else {
            todo!();
            // let isExhaustive = computeExhaustiveSwitchStatement(node);
            //     self.getNodeLinks_mut(node).isExhaustive = Some(isExhaustive);
            //     isExhaustive
        }
    }

    // TODO:
    // computeExhaustiveSwitchStatement

    fn functionHasImplicitReturn(&mut self, func: BoundNode) -> bool {
        self.node_data(func)
            .endFlowNode
            .map(|f| {
                todo!();
                // self.isReachableFlowNode(f)
            })
            .unwrap_or_default()
    }

    /// NOTE: Return value of `Some([])` means a different thing than `None`. `Some([])` means func returns `void`, `None` means it returns `never`.
    fn checkAndAggregateReturnExpressionTypes(
        &mut self,
        func: &BoundNode,
        checkMode: Option<CheckMode>,
    ) -> Option<Vec<TypeId>> {
        let functionFlags = getFunctionFlags(Some(func));
        let mut aggregatedTypes = Vec::new();
        let mut hasReturnWithNoExpression = self.functionHasImplicitReturn(func.clone());
        let mut hasReturnOfTypeNever = false;
        let body = match &func {
            BoundNode::FnDecl(n) => n
                .function
                .body
                .as_ref()
                .map(|b| b.bind(n.function.bind(func.clone()))),
            BoundNode::PrivateMethod(n) => n
                .function
                .body
                .as_ref()
                .map(|b| b.bind(n.function.bind(func.clone()))),
            BoundNode::ClassMethod(n) => n
                .function
                .body
                .as_ref()
                .map(|b| b.bind(n.function.bind(func.clone()))),
            BoundNode::MethodProp(n) => n
                .function
                .body
                .as_ref()
                .map(|b| b.bind(n.function.bind(func.clone()))),
            BoundNode::GetterProp(n) => n.body.as_ref().map(|b| b.bind(func.clone())),
            BoundNode::SetterProp(n) => n.body.as_ref().map(|b| b.bind(func.clone())),
            BoundNode::Constructor(n) => n.body.as_ref().map(|b| b.bind(func.clone())),
            BoundNode::FnExpr(n) => n
                .function
                .body
                .as_ref()
                .map(|b| b.bind(n.function.bind(func.clone()))),
            _ => unreachable!(),
        };
        if let Some(body) = body {
            forEachReturnStatement(&body, |returnStatement| {
                if let Some(expr) = &returnStatement.arg {
                    let ty = self.checkExpressionCached(
                        expr.bind(returnStatement.clone().into()),
                        checkMode.map(|m| m & !CheckMode::SkipGenericFunctions),
                    );
                    if functionFlags.intersects(FunctionFlags::Async) {
                        // From within an async function you can return either a non-promise value or a promise. Any
                        // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                        // return type of the body should be unwrapped to its awaited type, which should be wrapped in
                        // the native Promise<T> type by the caller.
                        // ty = unwrapAwaitedType(checkAwaitedType(type, /*withAlias*/ false, func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));
                        todo!();
                    }
                    if self.types[ty].get_flags().intersects(TypeFlags::Never) {
                        hasReturnOfTypeNever = true;
                    }
                    aggregatedTypes.push_if_unique(ty);
                } else {
                    hasReturnWithNoExpression = true;
                }
            });
        }
        if aggregatedTypes.is_empty()
            && !hasReturnWithNoExpression
            && (hasReturnOfTypeNever || mayReturnNever(func))
        {
            return None;
        }
        if self.strictNullChecks
            && !aggregatedTypes.is_empty()
            && hasReturnWithNoExpression
            && !(self.isJSConstructor(Some(func.clone()))
                && aggregatedTypes.iter().any(|&t| {
                    self.types[t].get_symbol().clone() == self.node_data(func.clone()).symbol
                }))
        {
            // Javascript "callable constructors", containing eg `if (!(this instanceof A)) return new A()` should not add undefined
            aggregatedTypes.push_if_unique(self.undefinedType);
        }
        Some(aggregatedTypes)
    }

    // TODO:
    // checkAllCodePathsInNonVoidFunctionReturnOrThrow

    fn checkFunctionExpressionOrObjectLiteralMethod(
        &mut self,
        node: BoundNode,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        debug_assert!(matches!(
            node,
            BoundNode::FnExpr(_) | BoundNode::ArrowExpr(_) | BoundNode::MethodProp(_)
        ));
        self.checkNodeDeferred(node.clone());

        if let BoundNode::FnExpr(f) = &node {
            self.checkCollisionsForDeclarationName(&node, f.ident.clone());
        }

        // The identityMapper object is used to indicate that function expressions are wildcards
        if let Some(checkMode) = checkMode {
            if checkMode.intersects(CheckMode::SkipContextSensitive)
                && isContextSensitive(&node.clone().into())
            {
                // Skip parameters, return signature with return type that retains noncontextual parts so inferences can still be drawn in an early stage
                if getEffectiveReturnTypeNode(&node.clone().into()).is_none()
                    && !hasContextSensitiveParameters(&node.clone().into())
                {
                    // Return plain anyFunctionType if there is no possibility we'll make inferences from the return type
                    todo!();
                    // const contextualSignature = getContextualSignature(node);
                    // if (contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature))) {
                    //     const links = getNodeLinks(node);
                    //     if (links.contextFreeType) {
                    //         return links.contextFreeType;
                    //     }
                    //     const returnType = getReturnTypeFromBody(node, checkMode);
                    //     const returnOnlySignature = createSignature(undefined, undefined, undefined, emptyArray, returnType, /*resolvedTypePredicate*/ undefined, 0, SignatureFlags.None);
                    //     const returnOnlyType = createAnonymousType(node.symbol, emptySymbols, [returnOnlySignature], emptyArray, emptyArray);
                    //     returnOnlyType.objectFlags |= ObjectFlags.NonInferrableType;
                    //     return links.contextFreeType = returnOnlyType;
                    // }
                }
                return self.anyFunctionType;
            }
        }

        // Grammar checking
        let hasGrammarError = self.checkGrammarFunctionLikeDeclaration(&node);
        if !hasGrammarError && matches!(node, BoundNode::FnExpr(_)) {
            todo!();
            // self.checkGrammarForGenerator(node);
        }

        self.contextuallyCheckFunctionExpressionOrObjectLiteralMethod(&node, checkMode);

        let sym = self.getSymbolOfNode(node).unwrap();
        self.getTypeOfSymbol(sym)
    }

    fn contextuallyCheckFunctionExpressionOrObjectLiteralMethod(
        &mut self,
        node: &BoundNode,
        checkMode: Option<CheckMode>,
    ) {
        let links = self.getNodeLinks(node.clone());
        // Check if function expression is contextually typed and assign parameter types if so.
        if !links.flags.intersects(NodeCheckFlags::ContextChecked) {
            let contextualSignature = self.getContextualSignature(node);
            // If a type check is started at a function expression that is an argument of a function call, obtaining the
            // contextual type may recursively get back to here during overload resolution of the call. If so, we will have
            // already assigned contextual types.
            let flags = &mut self.getNodeLinks_mut(node.clone()).flags;
            if !flags.intersects(NodeCheckFlags::ContextChecked) {
                *flags |= NodeCheckFlags::ContextChecked;
                let symbol = self.getSymbolOfNode(node.clone()).unwrap();
                let ty = self.getTypeOfSymbol(symbol);
                let signature = self
                    .getSignaturesOfType(ty, SignatureKind::Call)
                    .first()
                    .cloned();
                let signature = match signature {
                    Some(s) => s,
                    None => return,
                };
                if isContextSensitive(&node.clone().into()) {
                    if let Some(contextualSignature) = contextualSignature {
                        let inferenceContext = self.getInferenceContext(node.clone());
                        if checkMode
                            .unwrap_or_default()
                            .intersects(CheckMode::Inferential)
                        {
                            self.inferFromAnnotatedParameters(
                                signature,
                                contextualSignature,
                                inferenceContext.unwrap(),
                            );
                        }
                        let instantiatedContextualSignature =
                            if let Some(inferenceContext) = inferenceContext {
                                self.instantiateSignature(
                                    contextualSignature,
                                    self.inference_contexts[inferenceContext].mapper.clone(),
                                    false,
                                )
                            } else {
                                contextualSignature
                            };
                        self.assignContextualParameterTypes(
                            signature,
                            instantiatedContextualSignature,
                        );
                    } else {
                        // Force resolution of all parameter types such that the absence of a contextual type is consistently reflected.
                        self.assignNonContextualParameterTypes(signature);
                    }
                }
                if contextualSignature.is_some()
                    && self.getReturnTypeFromAnnotation(node).is_none()
                    && self.signatures[signature].resolvedReturnType.is_none()
                {
                    let returnType = self.getReturnTypeFromBody(node, checkMode);
                    let resolvedReturnType = &mut self.signatures[signature].resolvedReturnType;
                    if resolvedReturnType.is_none() {
                        *resolvedReturnType = Some(returnType);
                    }
                }
                // TODO:
                // self.checkSignatureDeclaration(node);
            }
        }
    }

    // TODO:
    // checkFunctionExpressionOrObjectLiteralMethodDeferred
    // TODO:
    // checkArithmeticOperandType

    fn isReadonlyAssignmentDeclaration(&mut self, d: &BoundNode) -> bool {
        if !matches!(d, BoundNode::CallExpr(_)) {
            return false;
        }
        todo!();
        // if (!isBindableObjectDefinePropertyCall(d)) {
        //     return false;
        // }
        // const objectLitType = checkExpressionCached(d.arguments[2]);
        // const valueType = getTypeOfPropertyOfType(objectLitType, "value" as __String);
        // if (valueType) {
        //     const writableProp = getPropertyOfType(objectLitType, "writable" as __String);
        //     const writableType = writableProp && getTypeOfSymbol(writableProp);
        //     if (!writableType || writableType === falseType || writableType === regularFalseType) {
        //         return true;
        //     }
        //     // We include this definition whereupon we walk back and check the type at the declaration because
        //     // The usual definition of `Object.defineProperty` will _not_ cause literal types to be preserved in the
        //     // argument types, should the type be contextualized by the call itself.
        //     if (writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration)) {
        //         const initializer = writableProp.valueDeclaration.initializer;
        //         const rawOriginalType = checkExpression(initializer);
        //         if (rawOriginalType === falseType || rawOriginalType === regularFalseType) {
        //             return true;
        //         }
        //     }
        //     return false;
        // }
        // const setProp = getPropertyOfType(objectLitType, "set" as __String);
        // return !setProp;
    }

    fn isReadonlySymbol(&mut self, symbol: SymbolId) -> bool {
        // The following symbols are considered read-only:
        // Properties with a 'readonly' modifier
        // Variables declared with 'const'
        // Get accessors without matching set accessors
        // Enum members
        // Object.defineProperty assignments with writable false or no setter
        // Unions and intersections of the above (unions and intersections eagerly set isReadonly on creation)
        let symbol_flags = self.symbols[symbol].flags();
        getCheckFlags(&self.symbols[symbol]).intersects(CheckFlags::Readonly)
            || symbol_flags.intersects(SymbolFlags::Property)
                && self
                    .getDeclarationModifierFlagsFromSymbol(symbol, false)
                    .intersects(ModifierFlags::Readonly)
            || symbol_flags.intersects(SymbolFlags::Variable)
                && self
                    .getDeclarationNodeFlagsFromSymbol(symbol)
                    .intersects(NodeFlags::Const)
            || symbol_flags.intersects(SymbolFlags::Accessor)
                && !symbol_flags.intersects(SymbolFlags::SetAccessor)
            || symbol_flags.intersects(SymbolFlags::EnumMember)
            // TODO: bad collect:
            || self.symbols[symbol]
                .declarations().clone()
                .iter()
                .any(|d| self.isReadonlyAssignmentDeclaration(d))
    }

    // TODO:
    // isAssignmentToReadonlyEntity
    // TODO:
    // checkReferenceExpression
    // TODO:
    // checkDeleteExpression
    // TODO:
    // checkDeleteExpressionMustBeOptional
    // TODO:
    // checkTypeOfExpression
    // TODO:
    // checkVoidExpression
    // TODO:
    // checkAwaitExpression
    // TODO:
    // checkPrefixUnaryExpression
    // TODO:
    // checkPostfixUnaryExpression
    // TODO:
    // getUnaryResultType

    // Return true if type might be of the given kind. A union or intersection type might be of a given
    // kind if at least one constituent type is of the given kind.
    fn maybeTypeOfKind(&self, ty: TypeId, kind: TypeFlags) -> bool {
        let flags = self.types[ty].get_flags();
        if flags.intersects(kind) {
            return true;
        }
        if flags.intersects(TypeFlags::UnionOrIntersection) {
            todo!();
            // const types = (ty as UnionOrIntersectionType).types;
            // for (const t of types) {
            //     if (maybeTypeOfKind(t, kind)) {
            //         return true;
            //     }
            // }
        }
        false
    }

    fn isTypeAssignableToKind(&mut self, source: TypeId, kind: TypeFlags, strict: bool) -> bool {
        if self.types[source].get_flags().intersects(kind) {
            return true;
        }
        if strict
            && self.types[source].get_flags().intersects(
                TypeFlags::AnyOrUnknown | TypeFlags::Void | TypeFlags::Undefined | TypeFlags::Null,
            )
        {
            return false;
        }

        macro_rules! test {
            ($test_flags:ident, $target_ty:expr) => {
                kind.intersects(TypeFlags::$test_flags)
                    && self.isTypeAssignableTo(source, $target_ty)
            };
        }

        test!(NumberLike, self.numberType)
            || test!(BigIntLike, self.bigintType)
            || test!(StringLike, self.stringType)
            || test!(BooleanLike, self.booleanType())
            || test!(Void, self.voidType)
            || test!(Never, self.neverType)
            || test!(Null, self.nullType)
            || test!(Undefined, self.undefinedType)
            || test!(ESSymbol, self.esSymbolType)
            || test!(NonPrimitive, self.nonPrimitiveType)
    }

    // TODO:
    // allTypesAssignableToKind

    fn isConstEnumObjectType(&self, ty: TypeId) -> bool {
        self.types[ty]
            .get_object_flags()
            .intersects(ObjectFlags::Anonymous)
            && self.types[ty].get_symbol().is_some()
            && self.isConstEnumSymbol(self.types[ty].get_symbol().unwrap())
    }

    fn isConstEnumSymbol(&self, symbol: SymbolId) -> bool {
        self.symbols[symbol]
            .flags()
            .intersects(SymbolFlags::ConstEnum)
    }

    // TODO:
    // checkInstanceOfExpression
    // TODO:
    // checkInExpression
    // TODO:
    // checkObjectLiteralAssignment
    // TODO:
    // checkObjectLiteralDestructuringPropertyAssignment
    // TODO:
    // checkArrayLiteralAssignment
    // TODO:
    // checkArrayLiteralDestructuringElementAssignment
    // TODO:
    // checkDestructuringAssignment
    // TODO:
    // checkReferenceAssignment
    // TODO:
    // isSideEffectFree
    // TODO:
    // isTypeEqualityComparableTo
    // TODO:
    // createCheckBinaryExpression
    // TODO:
    // checkGrammarNullishCoalesceWithLogicalExpression
    // TODO:
    // checkBinaryLikeExpression
    // TODO:
    // checkBinaryLikeExpressionWorker
    // TODO:
    // getBaseTypesIfUnrelated
    // TODO:
    // checkYieldExpression
    // TODO:
    // checkConditionalExpression
    // TODO:
    // isTemplateLiteralContext
    // TODO:
    // checkTemplateExpression
    // TODO:
    // isTemplateLiteralContextualType

    fn checkExpressionWithContextualType(
        &mut self,
        node: BoundNode,
        contextualType: TypeId,
        inferenceContext: Option<InferenceContextId>,
        checkMode: CheckMode,
    ) -> TypeId {
        let context = getContextNode(node.clone());
        // let saveContextualType = context.contextualType;
        // let saveInferenceContext = context.inferenceContext;
        // try {
        self.node_data_mut(context.clone()).contextualType = Some(contextualType);
        self.node_data_mut(context).inferenceContext = inferenceContext;
        let mut checkMode = checkMode | CheckMode::Contextual;
        if inferenceContext.is_some() {
            checkMode |= CheckMode::Inferential;
        }
        let ty = self.checkExpression(node.clone(), Some(checkMode), false);
        // We strip literal freshness when an appropriate contextual type is present such that contextually typed
        // literals always preserve their literal types (otherwise they might widen during type inference). An alternative
        // here would be to not mark contextually typed literals as fresh in the first place.
        let result = if self.maybeTypeOfKind(ty, TypeFlags::Literal) && {
            let contextualType = self.instantiateContextualType(Some(contextualType), node, None);
            self.isLiteralOfContextualType(ty, contextualType)
        } {
            self.getRegularTypeOfLiteralType(ty)
        } else {
            ty
        };
        result
        // }
        // finally {
        //     // In the event our operation is canceled or some other exception occurs, reset the contextual type
        //     // so that we do not accidentally hold onto an instance of the checker, as a Type created in the services layer
        //     // may hold onto the checker that created it.
        //     context.contextualType = saveContextualType;
        //     context.inferenceContext = saveInferenceContext;
        // }
    }

    fn checkExpressionCached(&mut self, node: BoundNode, checkMode: Option<CheckMode>) -> TypeId {
        match self.getNodeLinks(node.clone()).resolvedType {
            Some(t) => t,
            None => {
                if checkMode.is_some() && checkMode.unwrap() != CheckMode::Normal {
                    return self.checkExpression(node, checkMode, false);
                }
                // When computing a type that we're going to cache, we need to ignore any ongoing control flow
                // analysis because variables may have transient types in indeterminable states. Moving flowLoopStart
                // to the top of the stack ensures all transient types are computed from a known point.
                let saveFlowLoopStart = mem::replace(&mut self.flowLoopStart, self.flowLoopCount);
                let saveFlowTypeCache = mem::take(&mut self.flowTypeCache);
                let resolvedType = self.checkExpression(node.clone(), checkMode, false);
                self.getNodeLinks_mut(node).resolvedType = Some(resolvedType);
                self.flowTypeCache = saveFlowTypeCache;
                self.flowLoopStart = saveFlowLoopStart;
                resolvedType
            }
        }
    }

    // TODO:
    // isTypeAssertion

    fn checkDeclarationInitializer(
        &mut self,
        declaration: &BoundNode,
        contextualType: Option<TypeId>,
    ) -> TypeId {
        let initializer = getEffectiveInitializer(declaration).unwrap();
        let ty = self
            .getQuickTypeOfExpression(initializer.clone())
            .unwrap_or_else(|| {
                if let Some(contextualType) = contextualType {
                    self.checkExpressionWithContextualType(
                        initializer,
                        contextualType,
                        None,
                        CheckMode::Normal,
                    )
                } else {
                    self.checkExpressionCached(initializer, None)
                }
            });

        if let Ok(param) = Parameter::try_from(declaration.clone()) {
            if let ast::Pat::Array(p) = param.pat() {
                todo!();
                //     if self.isTupleType(ty)
                //     && !ty.target.hasRestElement
                //     && self.getTypeReferenceArity(ty) < p.elems.len()
                // {
                //     return self.padTupleType(ty, param.pat());
                // }
            }
        }
        ty
    }

    // TODO:
    // padTupleType

    fn widenTypeInferredFromInitializer(&mut self, declaration: &BoundNode, ty: TypeId) -> TypeId {
        let widened = if getCombinedNodeFlags(declaration).intersects(NodeFlags::Const)
            || isDeclarationReadonly(declaration)
        {
            ty
        } else {
            self.getWidenedLiteralType(ty)
        };
        if isBoundNodeInJSFile(declaration) {
            todo!();
            // if (isEmptyLiteralType(widened)) {
            //     reportImplicitAny(declaration, anyType);
            //     return anyType;
            // }
            // else if (isEmptyArrayLiteralType(widened)) {
            //     reportImplicitAny(declaration, anyArrayType);
            //     return anyArrayType;
            // }
        }
        widened
    }

    fn isLiteralOfContextualType(
        &mut self,
        candidateType: TypeId,
        contextualType: Option<TypeId>,
    ) -> bool {
        if let Some(contextualType) = contextualType {
            let flags = self.types[contextualType].get_flags();
            if flags.intersects(TypeFlags::UnionOrIntersection) {
                // const types = (contextualType as UnionType).types;
                // return some(types, t => isLiteralOfContextualType(candidateType, t));
                todo!();
            }
            if flags.intersects(TypeFlags::InstantiableNonPrimitive) {
                // If the contextual type is a type variable constrained to a primitive type, consider
                // this a literal context for literals of that primitive type. For example, given a
                // type parameter 'T extends string', infer string literal types for T.
                // const constraint = getBaseConstraintOfType(contextualType) || unknownType;
                // return maybeTypeOfKind(constraint, TypeFlags::String) && maybeTypeOfKind(candidateType, TypeFlags::StringLiteral) ||
                //     maybeTypeOfKind(constraint, TypeFlags::Number) && maybeTypeOfKind(candidateType, TypeFlags::NumberLiteral) ||
                //     maybeTypeOfKind(constraint, TypeFlags::BigInt) && maybeTypeOfKind(candidateType, TypeFlags::BigIntLiteral) ||
                //     maybeTypeOfKind(constraint, TypeFlags::ESSymbol) && maybeTypeOfKind(candidateType, TypeFlags::UniqueESSymbol) ||
                //     isLiteralOfContextualType(candidateType, constraint);
                todo!();
            }
            // If the contextual type is a literal of a particular primitive type, we consider this a
            // literal context for all literals of that primitive type.
            return flags.intersects(
                TypeFlags::StringLiteral
                    | TypeFlags::Index
                    | TypeFlags::TemplateLiteral
                    | TypeFlags::StringMapping,
            ) && self.maybeTypeOfKind(candidateType, TypeFlags::StringLiteral)
                || flags.intersects(TypeFlags::NumberLiteral)
                    && self.maybeTypeOfKind(candidateType, TypeFlags::NumberLiteral)
                || flags.intersects(TypeFlags::BigIntLiteral)
                    && self.maybeTypeOfKind(candidateType, TypeFlags::BigIntLiteral)
                || flags.intersects(TypeFlags::BooleanLiteral)
                    && self.maybeTypeOfKind(candidateType, TypeFlags::BooleanLiteral)
                || flags.intersects(TypeFlags::UniqueESSymbol)
                    && self.maybeTypeOfKind(candidateType, TypeFlags::UniqueESSymbol);
        }
        false
    }

    fn checkExpressionForMutableLocation(
        &mut self,
        node: BoundNode,
        checkMode: Option<CheckMode>,
        contextualType: Option<TypeId>,
        forceTuple: bool,
    ) -> TypeId {
        let ty = self.checkExpression(node.clone(), checkMode, forceTuple);
        if isConstContext(&node) {
            self.getRegularTypeOfLiteralType(ty)
        } else if isTypeAssertion(node.clone()) {
            ty
        } else {
            let contextualType = if contextualType.is_none() {
                self.getContextualType(node.clone(), None)
            } else {
                contextualType
            };
            let contextualType = self.instantiateContextualType(contextualType, node, None);
            self.getWidenedLiteralLikeTypeForContextualType(ty, contextualType)
        }
    }

    fn checkPropertyAssignment(
        &mut self,
        node: &Rc<KeyValueProp>,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        if let ast::PropName::Computed(n) = &node.key {
            todo!();
            // self.checkComputedPropertyName(node.name);
        }

        self.checkExpressionForMutableLocation(
            node.value.bind(node.clone().into()),
            checkMode,
            None,
            false,
        )
    }

    // TODO:
    // checkObjectLiteralMethod

    fn instantiateTypeWithSingleGenericCallSignature(
        &mut self,
        node: BoundNode,
        ty: TypeId,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        if let Some(checkMode) = checkMode {
            if checkMode.intersects(CheckMode::Inferential | CheckMode::SkipGenericFunctions) {
                let callSignature = self.getSingleSignature(ty, SignatureKind::Call, true);
                let constructSignature =
                    self.getSingleSignature(ty, SignatureKind::Construct, true);
                let signature = callSignature.or(constructSignature);
                if let Some(signature) = signature {
                    if self.signatures[signature].typeParameters.is_some() {
                        todo!();
                        // let contextualType = getApparentTypeOfContextualType(node as Expression, ContextFlags.NoConstraints);
                        // if (contextualType) {
                        //     let contextualSignature = getSingleSignature(getNonNullableType(contextualType), callSignature ? SignatureKind::Call : SignatureKind::Construct, /*allowMembers*/ false);
                        //     if (contextualSignature && !contextualSignature.typeParameters) {
                        //         if (checkMode & CheckMode.SkipGenericFunctions) {
                        //             skippedGenericFunction(node, checkMode);
                        //             return anyFunctionType;
                        //         }
                        //         let context = getInferenceContext(node)!;
                        //         // We have an expression that is an argument of a generic function for which we are performing
                        //         // type argument inference. The expression is of a function type with a single generic call
                        //         // signature and a contextual function type with a single non-generic call signature. Now check
                        //         // if the outer function returns a function type with a single non-generic call signature and
                        //         // if some of the outer function type parameters have no inferences so far. If so, we can
                        //         // potentially add inferred type parameters to the outer function return type.
                        //         let returnType = context.signature && getReturnTypeOfSignature(context.signature);
                        //         let returnSignature = returnType && getSingleCallOrConstructSignature(returnType);
                        //         if (returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates)) {
                        //             // Instantiate the signature with its own type parameters as type arguments, possibly
                        //             // renaming the type parameters to ensure they have unique names.
                        //             let uniqueTypeParameters = getUniqueTypeParameters(context, signature.typeParameters);
                        //             let instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters);
                        //             // Infer from the parameters of the instantiated signature to the parameters of the
                        //             // contextual signature starting with an empty set of inference candidates.
                        //             let inferences = map(context.inferences, info => createInferenceInfo(info.typeParameter));
                        //             applyToParameterTypes(instantiatedSignature, contextualSignature, (source, target) => {
                        //                 inferTypes(inferences, source, target, /*priority*/ 0, /*contravariant*/ true);
                        //             });
                        //             if (some(inferences, hasInferenceCandidates)) {
                        //                 // We have inference candidates, indicating that one or more type parameters are referenced
                        //                 // in the parameter types of the contextual signature. Now also infer from the return type.
                        //                 applyToReturnTypes(instantiatedSignature, contextualSignature, (source, target) => {
                        //                     inferTypes(inferences, source, target);
                        //                 });
                        //                 // If the type parameters for which we produced candidates do not have any inferences yet,
                        //                 // we adopt the new inference candidates and add the type parameters of the expression type
                        //                 // to the set of inferred type parameters for the outer function return type.
                        //                 if (!hasOverlappingInferences(context.inferences, inferences)) {
                        //                     mergeInferences(context.inferences, inferences);
                        //                     context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters);
                        //                     return getOrCreateTypeFromSignature(instantiatedSignature);
                        //                 }
                        //             }
                        //         }
                        //         return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context));
                        //     }
                        // }
                    }
                }
            }
        }
        ty
    }

    // TODO:
    // skippedGenericFunction

    // TODO:
    // hasOverlappingInferences
    // TODO:
    // mergeInferences
    // TODO:
    // getUniqueTypeParameters
    // TODO:
    // hasTypeParameterByName
    // TODO:
    // getUniqueTypeParameterName

    fn getReturnTypeOfSingleNonGenericCallSignature(&mut self, funcType: TypeId) -> Option<TypeId> {
        let signature = self.getSingleCallSignature(funcType);
        if let Some(sig) = signature {
            if !self.signatures[sig].typeParameters.is_some() {
                return Some(self.getReturnTypeOfSignature(sig));
            }
        }
        None
    }

    // TODO:
    // getReturnTypeOfSingleNonGenericSignatureOfCallChain

    /**
     * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
     * with computing the type and may not fully check all contained sub-expressions for errors.
     */
    fn getTypeOfExpression(&mut self, node: BoundNode) -> TypeId {
        // Don't bother caching types that require no flow analysis and are quick to compute.
        let quickType = self.getQuickTypeOfExpression(node.clone());
        if let Some(quickType) = quickType {
            return quickType;
        }
        // If a type has been cached for the node, return it.
        if self
            .node_data(node.clone())
            .flags
            .intersects(NodeFlags::TypeCached)
        {
            let cachedType = self.flowTypeCache.get(&node);
            if let Some(cachedType) = cachedType {
                return *cachedType;
            }
        }
        let startInvocationCount = self.flowInvocationCount;
        let ty = self.checkExpression(node.clone(), None, false);
        // If control flow analysis was required to determine the type, it is worth caching.
        if self.flowInvocationCount != startInvocationCount {
            self.flowTypeCache.insert(node.clone(), ty);
            self.node_data_mut(node.clone()).flags |= NodeFlags::TypeCached;
        }
        return ty;
    }

    fn getQuickTypeOfExpression(&mut self, node: BoundNode) -> Option<TypeId> {
        // TODO: jsdoc:
        // let mut expr = skipParenthesesOfNode(node, /*excludeJSDocTypeAssertions*/ true);
        // if (isJSDocTypeAssertion(expr)) {
        //     let ty = getJSDocTypeAssertionType(expr);
        //     if (!isConstTypeReference(ty)) {
        //         return getTypeFromTypeNode(ty);
        //     }
        // }
        // expr = skipParenthesesOfNode(node);
        let expr = skipParenthesesOfNode(node.clone());
        // Optimize for the common case of a call to a function with a single non-generic call
        // signature where we can just fetch the return type without checking the arguments.
        if matches!(&expr, BoundNode::CallExpr(c) if !matches!(c.callee, ast::ExprOrSuper::Super(_)))
            && !isRequireCall(&expr.clone().into(), true)
            && !self.isSymbolOrSymbolForCall(&expr)
        {
            // let ty = if isCallChain(expr) {
            //     self.getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr)
            // } else {
            //     self.getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(
            //         expr.expression,
            //     ))
            // };
            // TOOD: call chains
            let callee = &unwrap_as!(&expr, BoundNode::CallExpr(e), e).callee;
            let ty = self.checkNonNullExpression(callee.bind(expr.clone()));
            let ty = self.getReturnTypeOfSingleNonGenericCallSignature(ty);
            if ty.is_some() {
                return ty;
            }
        } else if matches!(&expr, BoundNode::TsTypeAssertion(e) if !isConstTypeReference(&e.type_ann.clone().into()))
            || matches!(&expr, BoundNode::TsAsExpr(e) if !isConstTypeReference(&e.type_ann.clone().into()))
        {
            let ty_node = match &expr {
                BoundNode::TsTypeAssertion(n) => &n.type_ann,
                BoundNode::TsAsExpr(n) => &n.type_ann,
                _ => unreachable!(),
            };
            return Some(self.getTypeFromTypeNode(ty_node.bind(expr.clone())));
        } else if matches!(
            node,
            BoundNode::Number(_) | BoundNode::Str(_) | BoundNode::Bool(_)
        ) {
            return Some(self.checkExpression(node, None, false));
        }
        None
    }

    // TODO:
    // getContextFreeTypeOfExpression

    fn checkExpression(
        &mut self,
        node: BoundNode,
        checkMode: Option<CheckMode>,
        forceTuple: bool,
    ) -> TypeId {
        // tracing?.push(tracing.Phase.Check, "checkExpression", { kind: node.kind, pos: node.pos, end: node.end });
        let saveCurrentNode = mem::replace(&mut self.currentNode, Some(node.clone()));
        self.instantiationCount = 0;
        let uninstantiatedType = self.checkExpressionWorker(&node, checkMode, forceTuple);
        let ty =
            self.instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
        if self.isConstEnumObjectType(ty) {
            todo!();
            // self.checkConstEnumAccess(node, ty);
        }
        self.currentNode = saveCurrentNode;
        // tracing?.pop();
        ty
    }

    // TODO:
    // checkConstEnumAccess

    fn checkParenthesizedExpression(
        &mut self,
        node: &Rc<ParenExpr>,
        checkMode: Option<CheckMode>,
    ) -> TypeId {
        // TODO: jsdoc
        // if (hasJSDocNodes(node) && isJSDocTypeAssertion(node)) {
        //     const type = getJSDocTypeAssertionType(node);
        //     return checkAssertionWorker(type, type, node.expression, checkMode);
        // }
        self.checkExpression(node.expr.bind(node.clone().into()), checkMode, false)
    }

    fn checkExpressionWorker(
        &mut self,
        node: &BoundNode,
        checkMode: Option<CheckMode>,
        forceTuple: bool,
    ) -> TypeId {
        // if (cancellationToken) {
        //     // Only bother checking on a few construct kinds.  We don't want to be excessively
        //     // hitting the cancellation token on every node we check.
        //     switch (kind) {
        //         case SyntaxKind.ClassExpression:
        //         case SyntaxKind.FunctionExpression:
        //         case SyntaxKind.ArrowFunction:
        //             cancellationToken.throwIfCancellationRequested();
        //     }
        // }
        match node {
            BoundNode::Ident(i) => self.checkIdentifier(i, checkMode),
            BoundNode::PrivateName(_) => {
                todo!();
                // self.checkPrivateIdentifierExpression(node as PrivateIdentifier)
            }
            BoundNode::ThisExpr(_) => self.checkThisExpression(node.clone()),
            BoundNode::Super(n) => self.checkSuperExpression(n),
            BoundNode::Null(_) => self.nullWideningType,
            // TODO:
            // BoundNode::NoSubstitutionTemplateLiteral(_) => {
            //     todo!();
            //     // self.getFreshTypeOfLiteralType(getStringLiteralType((node as StringLiteralLike).text))
            // }
            BoundNode::Str(n) => {
                let ty = self.getStringLiteralType(&n.value);
                self.getFreshTypeOfLiteralType(ty)
            }
            BoundNode::Number(n) => {
                // TODO:
                // checkGrammarNumericLiteral(node as NumericLiteral);
                let ty = self.getNumberLiteralType(n.value);
                self.getFreshTypeOfLiteralType(ty)
            }
            BoundNode::BigInt(_) => {
                todo!();
                // checkGrammarBigIntLiteral(node as BigIntLiteral);
                // return getFreshTypeOfLiteralType(getBigIntLiteralType({
                //     negative: false,
                //     base10Value: parsePseudoBigInt((node as BigIntLiteral).text)
                // }));
            }
            BoundNode::Bool(b) => {
                if b.value {
                    self.trueType
                } else {
                    self.falseType
                }
            }
            // TODO:
            // BoundNode::TemplateExpression(_) => {
            //     todo!();
            //     // self.checkTemplateExpression(node as TemplateExpression)
            // }
            BoundNode::Regex(_) => self.globalRegExpType(),
            BoundNode::ArrayLit(_) => {
                todo!();
                // self.checkArrayLiteral(node as ArrayLiteralExpression, checkMode, forceTuple)
            }
            BoundNode::ObjectLit(n) => self.checkObjectLiteral(n, checkMode),
            BoundNode::TsQualifiedName(_) => {
                todo!();
                // self.checkQualifiedName(node as QualifiedName, checkMode)
            }
            BoundNode::MemberExpr(m) => {
                if m.computed {
                    self.checkIndexedAccess(m, checkMode)
                } else {
                    self.checkPropertyAccessExpression(node.clone(), m.clone(), checkMode)
                }
            }
            BoundNode::CallExpr(c) => {
                if matches!(&c.callee, ast::ExprOrSuper::Expr(ast::Expr::Ident(i)) if i.sym == js_word!("import"))
                {
                    todo!();
                    // return self.checkImportCallExpression(node as ImportCall);
                }
                self.checkCallExpression(node, checkMode)
            }
            BoundNode::NewExpr(_) => self.checkCallExpression(node, checkMode),
            // TODO:
            // BoundNode::TaggedTemplateExpression(_) => {
            //     todo!();
            //     // self.checkTaggedTemplateExpression(node as TaggedTemplateExpression)
            // }
            BoundNode::ParenExpr(n) => self.checkParenthesizedExpression(n, checkMode),
            BoundNode::ClassExpr(_) => {
                todo!();
                // self.checkClassExpression(node as ClassExpression)
            }
            BoundNode::FnExpr(_) | BoundNode::ArrowExpr(_) => {
                self.checkFunctionExpressionOrObjectLiteralMethod(node.clone(), checkMode)
            }
            // TODO:
            // BoundNode::TypeOfExpression(_) => {
            //     todo!();
            //     // self.checkTypeOfExpression(node as TypeOfExpression)
            // }
            BoundNode::TsTypeAssertion(_) | BoundNode::TsAsExpr(_) => self.checkAssertion(node),
            BoundNode::TsNonNullExpr(_) => {
                todo!();
                // self.checkNonNullAssertion(node as NonNullExpression)
            }
            BoundNode::MetaPropExpr(_) => {
                todo!();
                // self.checkMetaProperty(node as MetaProperty)
            }
            // TODO:
            // BoundNode::DeleteExpression(_) => {
            //     todo!();
            //     // self.checkDeleteExpression(node as DeleteExpression)
            // }
            // TODO:
            // BoundNode::VoidExpression(_) => {
            //     todo!();
            //     // self.checkVoidExpression(node as VoidExpression)
            // }
            BoundNode::AwaitExpr(_) => {
                todo!();
                // self.checkAwaitExpression(node as AwaitExpression)
            }
            // TODO:
            // BoundNode::PrefixUnaryExpression(_) => {
            //     todo!();
            //     // self.checkPrefixUnaryExpression(node as PrefixUnaryExpression)
            // }
            // TODO:
            // BoundNode::PostfixUnaryExpression(_) => {
            //     todo!();
            //     // self.checkPostfixUnaryExpression(node as PostfixUnaryExpression)
            // }
            // TODO:
            // BoundNode::BinaryExpression(_) => {
            //     todo!();
            //     // self.checkBinaryExpression(node as BinaryExpression, checkMode)
            // }
            BoundNode::CondExpr(_) => {
                todo!();
                // self.checkConditionalExpression(node as ConditionalExpression, checkMode)
            }
            BoundNode::SpreadElement(n) => self.checkSpreadExpression(n, checkMode),
            // TODO:
            // BoundNode::OmittedExpression(_) => {
            //     self.undefinedWideningType
            // }
            BoundNode::YieldExpr(_) => {
                todo!();
                // self.checkYieldExpression(node as YieldExpression)
            }
            // TODO:
            // BoundNode::SyntheticExpression(_) => {
            //     // self.checkSyntheticExpression(node as SyntheticExpression)
            // }
            // BoundNode::JsxExpression(_) => {
            //     // self.checkJsxExpression(node as JsxExpression, checkMode)
            // }
            // BoundNode::JsxElement(_) => {
            //     // self.checkJsxElement(node as JsxElement, checkMode)
            // }
            // BoundNode::JsxSelfClosingElement(_) => {
            //     // self.checkJsxSelfClosingElement(node as JsxSelfClosingElement, checkMode)
            // }
            // BoundNode::JsxFragment(_) => {
            //     // self.checkJsxFragment(node as JsxFragment)
            // }
            // BoundNode::JsxAttributes(_) => {
            //     // self.checkJsxAttributes(node as JsxAttributes, checkMode)
            // }
            // BoundNode::JsxOpeningElement(_) => {
            //     unreachable!("Shouldn't ever directly check a JsxOpeningElement")
            // }
            _ => {
                dbg!(node);
                unreachable!("todo");
                // self.errorType
            }
        }
    }

    // TODO:
    // checkTypeParameter
    // TODO:
    // checkParameter
    // TODO:
    // checkTypePredicate
    // TODO:
    // getTypePredicateParent
    // TODO:
    // checkIfTypePredicateVariableIsDeclaredInBindingPattern
    // TODO:
    // checkSignatureDeclaration
    // TODO:
    // checkClassForDuplicateDeclarations
    // TODO:
    // checkClassForStaticPropertyNameConflicts
    // TODO:
    // checkObjectTypeForDuplicateDeclarations
    // TODO:
    // checkTypeForDuplicateIndexSignatures
    // TODO:
    // checkPropertyDeclaration
    // TODO:
    // checkPropertySignature
    // TODO:
    // checkMethodDeclaration
    // TODO:
    // setNodeLinksForPrivateIdentifierScope
    // TODO:
    // checkClassStaticBlockDeclaration
    // TODO:
    // checkConstructorDeclaration
    // TODO:
    // checkAccessorDeclaration
    // TODO:
    // checkMissingDeclaration
    // TODO:
    // getEffectiveTypeArguments
    // TODO:
    // checkTypeArgumentConstraints
    // TODO:
    // getTypeParametersForTypeReference
    // TODO:
    // checkTypeReferenceNode
    // TODO:
    // getTypeArgumentConstraint
    // TODO:
    // checkTypeQuery
    // TODO:
    // checkTypeLiteral
    // TODO:
    // checkArrayType
    // TODO:
    // checkTupleType
    // TODO:
    // checkUnionOrIntersectionType

    fn checkIndexedAccessIndexType(&mut self, ty: TypeId, accessNode: &BoundNode) -> TypeId {
        debug_assert!(
            matches!(accessNode, BoundNode::TsIndexedAccessType(_))
                || matches!(&accessNode, BoundNode::MemberExpr(m) if m.computed)
        );
        if !self.types[ty]
            .get_flags()
            .intersects(TypeFlags::IndexedAccess)
        {
            return ty;
        }
        // Check if the index type is assignable to 'keyof T' for the object type.
        let objectType = unwrap_as!(&self.types[ty], Type::IndexedAccessType(t), t).objectType;
        let indexType = unwrap_as!(&self.types[ty], Type::IndexedAccessType(t), t).indexType;
        {
            let target = self.getIndexType(objectType, Some(false), false);
            if self.isTypeAssignableTo(indexType, target) {
                todo!();
                // if (accessNode.kind == SyntaxKind.ElementAccessExpression && isAssignmentTarget(accessNode) &&
                //     self.types[objectType].get_object_flags().intersects(ObjectFlags::Mapped) && self.getMappedTypeModifiers(objectType as MappedType) & MappedTypeModifiers::IncludeReadonly) {
                //         todo!();
                //     // error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
                // }
                // return ty;
            }
        }
        // Check if we're indexing with a numeric type and if either object or index types
        // is a generic type with a constraint that has a numeric index signature.
        let apparentObjectType = self.getApparentType(objectType);
        if self
            .getIndexInfoOfType(apparentObjectType, self.numberType)
            .is_some()
            && self.isTypeAssignableToKind(indexType, TypeFlags::NumberLike, false)
        {
            return ty;
        }
        if self.isGenericObjectType(objectType) {
            todo!();
            // let propertyName = getPropertyNameFromIndex(indexType, accessNode);
            // if (propertyName) {
            //     let propertySymbol = forEachType(apparentObjectType, t => getPropertyOfType(t, propertyName));
            //     if (propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol) & ModifierFlags.NonPublicAccessibilityModifier) {
            //         error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName));
            //         return errorType;
            //     }
            // }
        }
        todo!();
        // error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
        // return errorType;
    }

    // TODO:
    // checkIndexedAccessType
    // TODO:
    // checkMappedType
    // TODO:
    // checkThisType
    // TODO:
    // checkTypeOperator
    // TODO:
    // checkConditionalType
    // TODO:
    // checkInferType
    // TODO:
    // checkTemplateLiteralType
    // TODO:
    // checkImportType
    // TODO:
    // checkNamedTupleMember
    // TODO:
    // isPrivateWithinAmbient
    // TODO:
    // getEffectiveDeclarationFlags
    // TODO:
    // checkFunctionOrConstructorSymbol
    // TODO:
    // checkExportsOnMergedDeclarations
    // TODO:
    // getAwaitedTypeOfPromise
    // TODO:
    // getPromisedTypeOfPromise
    // TODO:
    // checkAwaitedType
    // TODO:
    // isThenableType
    // TODO:
    // isAwaitedTypeInstantiation
    // TODO:
    // unwrapAwaitedType
    // TODO:
    // createAwaitedTypeIfNeeded
    // TODO:
    // getAwaitedType
    // TODO:
    // getAwaitedTypeNoAlias
    // TODO:
    // checkAsyncFunctionReturnType
    // TODO:
    // checkDecorator
    // TODO:
    // markTypeNodeAsReferenced
    // TODO:
    // markEntityNameOrEntityExpressionAsReference
    // TODO:
    // markDecoratorMedataDataTypeNodeAsReferenced
    // TODO:
    // getEntityNameForDecoratorMetadata
    // TODO:
    // getEntityNameForDecoratorMetadataFromTypeList
    // TODO:
    // getParameterTypeNodeForDecoratorCheck
    // TODO:
    // checkDecorators
    // TODO:
    // checkFunctionDeclaration
    // TODO:
    // checkJSDocTypeAliasTag
    // TODO:
    // checkJSDocTemplateTag
    // TODO:
    // checkJSDocTypeTag
    // TODO:
    // checkJSDocParameterTag
    // TODO:
    // checkJSDocPropertyTag
    // TODO:
    // checkJSDocFunctionType
    // TODO:
    // checkJSDocImplementsTag
    // TODO:
    // checkJSDocAugmentsTag
    // TODO:
    // checkJSDocAccessibilityModifiers
    // TODO:
    // getIdentifierFromEntityNameExpression
    // TODO:
    // getIdentifierFromEntityNameExpression
    // TODO:
    // getIdentifierFromEntityNameExpression
    // TODO:
    // checkFunctionOrMethodDeclaration
    // TODO:
    // registerForUnusedIdentifiersCheck
    // TODO:
    // checkUnusedIdentifiers
    // TODO:
    // errorUnusedLocal
    // TODO:
    // isIdentifierThatStartsWithUnderscore
    // TODO:
    // checkUnusedClassMembers
    // TODO:
    // checkUnusedInferTypeParameter
    // TODO:
    // checkUnusedTypeParameters
    // TODO:
    // isTypeParameterUnused
    // TODO:
    // addToGroup
    // TODO:
    // tryGetRootParameterDeclaration
    // TODO:
    // isValidUnusedLocalDeclaration
    // TODO:
    // checkUnusedLocalsAndParameters
    // TODO:
    // bindingNameText
    // TODO:
    // isImportedDeclaration
    // TODO:
    // importClauseFromImported
    // TODO:
    // checkBlock
    // TODO:
    // checkCollisionWithArgumentsInGeneratedCode
    // TODO:
    // needCollisionCheckForIdentifier
    // TODO:
    // checkIfThisIsCapturedInEnclosingScope
    // TODO:
    // checkIfNewTargetIsCapturedInEnclosingScope
    // TODO:
    // checkCollisionWithRequireExportsInGeneratedCode
    // TODO:
    // checkCollisionWithGlobalPromiseInGeneratedCode
    // TODO:
    // recordPotentialCollisionWithWeakMapSetInGeneratedCode
    // TODO:
    // checkWeakMapSetCollision
    // TODO:
    // recordPotentialCollisionWithReflectInGeneratedCode
    // TODO:
    // checkReflectCollision

    fn checkCollisionsForDeclarationName(
        &mut self,
        node: &BoundNode,
        name: Option<Rc<ast::Ident>>,
    ) {
        if name.is_none() {
            return;
        }
        todo!();
        // checkCollisionWithRequireExportsInGeneratedCode(node, name);
        // checkCollisionWithGlobalPromiseInGeneratedCode(node, name);
        // recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name);
        // recordPotentialCollisionWithReflectInGeneratedCode(node, name);
        // if (isClassLike(node)) {
        //     checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0);
        //     if (!(node.flags & NodeFlags.Ambient)) {
        //         checkClassNameCollisionWithObject(name);
        //     }
        // }
        // else if (isEnumDeclaration(node)) {
        //     checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0);
        // }
    }

    // TODO:
    // checkVarDeclaredNamesNotShadowed
    // TODO:
    // convertAutoToAny
    // TODO:
    // checkVariableLikeDeclaration
    // TODO:
    // errorNextVariableOrPropertyDeclarationMustHaveSameType
    // TODO:
    // areDeclarationFlagsIdentical
    // TODO:
    // checkVariableDeclaration
    // TODO:
    // checkBindingElement
    // TODO:
    // checkVariableStatement
    // TODO:
    // checkExpressionStatement
    // TODO:
    // checkIfStatement
    // TODO:
    // checkTestingKnownTruthyCallableOrAwaitableType
    // TODO:
    // isSymbolUsedInConditionBody
    // TODO:
    // isSymbolUsedInBinaryExpressionChain
    // TODO:
    // checkDoStatement
    // TODO:
    // checkWhileStatement
    // TODO:
    // checkTruthinessOfType
    // TODO:
    // checkTruthinessExpression
    // TODO:
    // checkForStatement
    // TODO:
    // checkForOfStatement
    // TODO:
    // checkForInStatement
    // TODO:
    // checkForInOrForOfVariableDeclaration
    // TODO:
    // checkRightHandSideOfForOf

    fn checkIteratedTypeOrElementType(
        &mut self,
        usage: IterationUse,
        inputType: TypeId,
        sentType: TypeId,
        errorNode: Option<BoundNode>,
    ) -> TypeId {
        if self.isTypeAny(Some(inputType)) {
            return inputType;
        }
        self.getIteratedTypeOrElementType(usage, inputType, sentType, errorNode, true)
            .unwrap_or(self.anyType)
    }

    /**
     * When consuming an iterable type in a for..of, spread, or iterator destructuring assignment
     * we want to get the iterated type of an iterable for ES2015 or later, or the iterated type
     * of a iterable (if defined globally) or element type of an array like for ES2015 or earlier.
     */
    fn getIteratedTypeOrElementType(
        &mut self,
        usage: IterationUse,
        inputType: TypeId,
        sentType: TypeId,
        errorNode: Option<BoundNode>,
        checkAssignability: bool,
    ) -> Option<TypeId> {
        let allowAsyncIterables = usage.intersects(IterationUse::AllowsAsyncIterablesFlag);
        if inputType == self.neverType {
            todo!();
            // reportTypeNotIterableError(errorNode!, inputType, allowAsyncIterables); // TODO: GH#18217
            // return undefined;
        }

        let uplevelIteration = self.languageVersion >= ScriptTarget::ES2015;
        let downlevelIteration = !uplevelIteration && self.compilerOptions.downlevelIteration;
        let possibleOutOfBounds = self.compilerOptions.noUncheckedIndexedAccess
            && usage.intersects(IterationUse::PossiblyOutOfBounds);

        // Get the iterated type of an `Iterable<T>` or `IterableIterator<T>` only in ES2015
        // or higher, when inside of an async generator or for-await-if, or when
        // downlevelIteration is requested.
        if uplevelIteration || downlevelIteration || allowAsyncIterables {
            // We only report errors for an invalid iterable type in ES2015 or higher.
            todo!();
            // const iterationTypes = getIterationTypesOfIterable(inputType, usage, uplevelIteration ? errorNode : undefined);
            // if (checkAssignability) {
            //     if (iterationTypes) {
            //         const diagnostic =
            //             usage & IterationUse.ForOfFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 :
            //             usage & IterationUse.SpreadFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 :
            //             usage & IterationUse.DestructuringFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 :
            //             usage & IterationUse.YieldStarFlag ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 :
            //             undefined;
            //         if (diagnostic) {
            //             checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic);
            //         }
            //     }
            // }
            // if (iterationTypes || uplevelIteration) {
            //     return possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : (iterationTypes && iterationTypes.yieldType);
            // }
        }

        let mut arrayType = inputType;
        let mut reportedError = false;
        let mut hasStringConstituent = false;

        // If strings are permitted, remove any string-like constituents from the array type.
        // This allows us to find other non-string element types from an array unioned with
        // a string.
        if usage.intersects(IterationUse::AllowsStringInputFlag) {
            todo!();
            // if (arrayType.flags & TypeFlags::Union) {
            //     // After we remove all types that are StringLike, we will know if there was a string constituent
            //     // based on whether the result of filter is a new array.
            //     const arrayTypes = (inputType as UnionType).types;
            //     const filteredTypes = filter(arrayTypes, t => !(t.flags & TypeFlags::StringLike));
            //     if (filteredTypes !== arrayTypes) {
            //         arrayType = getUnionType(filteredTypes, UnionReduction.Subtype);
            //     }
            // }
            // else if (arrayType.flags & TypeFlags::StringLike) {
            //     arrayType = neverType;
            // }

            // hasStringConstituent = arrayType !== inputType;
            // if (hasStringConstituent) {
            //     if (languageVersion < ScriptTarget.ES5) {
            //         if (errorNode) {
            //             error(errorNode, Diagnostics.Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher);
            //             reportedError = true;
            //         }
            //     }

            //     // Now that we've removed all the StringLike types, if no constituents remain, then the entire
            //     // arrayOrStringType was a string.
            //     if (arrayType.flags & TypeFlags::Never) {
            //         return possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType;
            //     }
            // }
        }

        if !self.isArrayLikeType(arrayType) {
            todo!();
            // if (errorNode && !reportedError) {
            //     // Which error we report depends on whether we allow strings or if there was a
            //     // string constituent. For example, if the input type is number | string, we
            //     // want to say that number is not an array type. But if the input was just
            //     // number and string input is allowed, we want to say that number is not an
            //     // array type or a string type.
            //     const allowsStrings = !!(usage & IterationUse.AllowsStringInputFlag) && !hasStringConstituent;
            //     const [defaultDiagnostic, maybeMissingAwait] = getIterationDiagnosticDetails(allowsStrings, downlevelIteration);
            //     errorAndMaybeSuggestAwait(
            //         errorNode,
            //         maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType),
            //         defaultDiagnostic,
            //         typeToString(arrayType));
            // }
            // return hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : undefined;
        }

        let arrayElementType = self.getIndexTypeOfType(arrayType, self.numberType);
        if hasStringConstituent {
            if let Some(arrayElementType) = arrayElementType {
                // This is just an optimization for the case where arrayOrStringType is string | string[]
                // if (arrayElementType.flags & TypeFlags::StringLike && !compilerOptions.noUncheckedIndexedAccess) {
                //     return stringType;
                // }

                // return getUnionType(possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType], UnionReduction.Subtype);
                todo!();
            }
        }

        return if usage.intersects(IterationUse::PossiblyOutOfBounds) {
            self.includeUndefinedInIndexSignature(arrayElementType)
        } else {
            arrayElementType
        };

        // fn getIterationDiagnosticDetails(allowsStrings: boolean, downlevelIteration: boolean | undefined): [DiagnosticMessage, boolean] {
        //     if (downlevelIteration) {
        //         return allowsStrings
        //             ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]
        //             : [Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true];
        //     }

        //     const yieldType = getIterationTypeOfIterable(usage, IterationTypeKind.Yield, inputType, /*errorNode*/ undefined);

        //     if (yieldType) {
        //         return [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_Use_compiler_option_downlevelIteration_to_allow_iterating_of_iterators, false];
        //     }

        //     if (isES2015OrLaterIterable(inputType.symbol?.escapedName)) {
        //         return [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true];
        //     }

        //     return allowsStrings
        //         ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true]
        //         : [Diagnostics.Type_0_is_not_an_array_type, true];
        // }
    }

    // TODO:
    // isES2015OrLaterIterable
    // TODO:
    // getIterationTypeOfIterable
    // TODO:
    // createIterationTypes
    // TODO:
    // combineIterationTypes
    // TODO:
    // getCachedIterationTypes
    // TODO:
    // setCachedIterationTypes
    // TODO:
    // getIterationTypesOfIterable
    // TODO:
    // getAsyncFromSyncIterationTypes
    // TODO:
    // getIterationTypesOfIterableWorker
    // TODO:
    // getIterationTypesOfIterableCached
    // TODO:
    // getIterationTypesOfGlobalIterableType
    // TODO:
    // getIterationTypesOfIterableFast
    // TODO:
    // getPropertyNameForKnownSymbolName
    // TODO:
    // getIterationTypesOfIterableSlow
    // TODO:
    // reportTypeNotIterableError
    // TODO:
    // getIterationTypesOfIterator
    // TODO:
    // getIterationTypesOfIteratorCached
    // TODO:
    // getIterationTypesOfIteratorFast
    // TODO:
    // isIteratorResult
    // TODO:
    // isYieldIteratorResult
    // TODO:
    // isReturnIteratorResult
    // TODO:
    // getIterationTypesOfIteratorResult
    // TODO:
    // getIterationTypesOfMethod
    // TODO:
    // getIterationTypesOfIteratorSlow
    // TODO:
    // getIterationTypeOfGeneratorFunctionReturnType
    // TODO:
    // getIterationTypesOfGeneratorFunctionReturnType
    // TODO:
    // checkBreakOrContinueStatement
    // TODO:
    // unwrapReturnType
    // TODO:
    // isUnwrappedReturnTypeVoidOrAny
    // TODO:
    // checkReturnStatement
    // TODO:
    // checkWithStatement
    // TODO:
    // checkSwitchStatement
    // TODO:
    // checkLabeledStatement
    // TODO:
    // checkThrowStatement
    // TODO:
    // checkTryStatement
    // TODO:
    // checkIndexConstraints
    // TODO:
    // checkIndexConstraintForProperty
    // TODO:
    // checkIndexConstraintForIndexSignature
    // TODO:
    // checkTypeNameIsReserved
    // TODO:
    // checkClassNameCollisionWithObject
    // TODO:
    // checkTypeParameters
    // TODO:
    // checkTypeParametersNotReferenced
    // TODO:
    // checkTypeParameterListsIdentical
    // TODO:
    // areTypeParametersIdentical
    // TODO:
    // checkClassExpression
    // TODO:
    // checkClassExpressionDeferred
    // TODO:
    // checkClassDeclaration
    // TODO:
    // checkClassLikeDeclaration
    // TODO:
    // checkMembersForMissingOverrideModifier
    // TODO:
    // issueMemberSpecificError
    // TODO:
    // checkBaseTypeAccessibility

    fn getTargetSymbol(&self, s: SymbolId) -> Option<SymbolId> {
        // if symbol is instantiated its flags are not copied from the 'target'
        // so we'll need to get back original 'target' symbol to work with correct set of flags
        if getCheckFlags(&self.symbols[s]).intersects(CheckFlags::Instantiated) {
            self.symbols[s].as_transient_symbol().symbol_links.target
        } else {
            Some(s)
        }
    }

    // TODO:
    // getClassOrInterfaceDeclarationsOfSymbol
    // TODO:
    // checkKindsOfPropertyMemberOverrides
    // TODO:
    // getNonInterhitedProperties
    // TODO:
    // checkInheritedPropertiesAreIdentical
    // TODO:
    // checkPropertyInitialization
    // TODO:
    // isPropertyWithoutInitializer
    // TODO:
    // isPropertyInitializedInStaticBlocks
    // TODO:
    // isPropertyInitializedInConstructor
    // TODO:
    // checkInterfaceDeclaration
    // TODO:
    // checkTypeAliasDeclaration
    // TODO:
    // computeEnumMemberValues
    // TODO:
    // computeMemberValue
    // TODO:
    // computeConstantValue
    // TODO:
    // isConstantMemberAccess
    // TODO:
    // checkEnumDeclaration
    // TODO:
    // checkEnumMember
    // TODO:
    // getFirstNonAmbientClassOrFunctionDeclaration
    // TODO:
    // inSameLexicalScope
    // TODO:
    // checkModuleDeclaration
    // TODO:
    // checkModuleAugmentationElement
    // TODO:
    // getFirstNonModuleExportsIdentifier
    // TODO:
    // checkExternalImportOrExportDeclaration
    // TODO:
    // checkAliasSymbol
    // TODO:
    // checkImportBinding
    // TODO:
    // checkAssertClause
    // TODO:
    // checkImportDeclaration
    // TODO:
    // checkImportEqualsDeclaration
    // TODO:
    // checkExportDeclaration
    // TODO:
    // checkGrammarExportDeclaration
    // TODO:
    // checkGrammarModuleElementContext
    // TODO:
    // importClauseContainsReferencedImport
    // TODO:
    // importClauseContainsConstEnumUsedAsValue
    // TODO:
    // canConvertImportDeclarationToTypeOnly
    // TODO:
    // canConvertImportEqualsDeclarationToTypeOnly
    // TODO:
    // checkImportsForTypeOnlyConversion
    // TODO:
    // checkExportSpecifier
    // TODO:
    // checkExportAssignment
    // TODO:
    // hasExportedMembers
    // TODO:
    // checkExternalModuleExports
    // TODO:
    // isDuplicatedCommonJSExport

    fn checkSourceElement(&mut self, node: Option<BoundNode>) {
        // TODO: checking:
        // if let Some(node) = node {
        //     dbg!(node);
        //     todo!();
        //     // let  saveCurrentNode = mem::replace(&mut self.currentNode, Some(node));
        //     // self.instantiationCount = 0;
        //     // self.checkSourceElementWorker(node);
        //     // self.currentNode = saveCurrentNode;
        // }
    }

    // TODO:
    // checkSourceElementWorker
    // TODO:
    // checkJSDocTypeIsInJsFile
    // TODO:
    // checkJSDocVariadicType
    // TODO:
    // getTypeFromJSDocVariadicType

    // Function and class expression bodies are checked after all statements in the enclosing body. This is
    // to ensure constructs like the following are permitted:
    //     const foo = function () {
    //        const s = foo();
    //        return "hello";
    //     }
    // Here, performing a full type check of the body of the function expression whilst in the process of
    // determining the type of foo would cause foo to be given type any because of the recursive reference.
    // Delaying the type check of the body ensures foo has been assigned a type.
    fn checkNodeDeferred(&mut self, node: BoundNode) {
        let enclosingFile = getSourceFileOfNode(node.clone());
        let links = self.getNodeLinks_mut(enclosingFile);
        if !links.flags.intersects(NodeCheckFlags::TypeChecked) {
            links.deferredNodes.insert(node);
        }
    }

    // TODO:
    // checkDeferredNodes
    // TODO:
    // checkDeferredNode
    // TODO:
    // checkSourceFile
    // TODO:
    // unusedIsError
    // TODO:
    // getPotentiallyUnusedIdentifiers
    // TODO:
    // checkSourceFileWorker
    // TODO:
    // getDiagnostics
    // TODO:
    // getDiagnosticsWorker
    // TODO:
    // getGlobalDiagnostics
    // TODO:
    // throwIfNonDiagnosticsProducing
    // TODO:
    // getSymbolsInScope
    // TODO:
    // isTypeDeclarationName
    // TODO:
    // isTypeDeclaration
    // TODO:
    // isTypeReferenceIdentifier
    // TODO:
    // isHeritageClauseElementIdentifier
    // TODO:
    // forEachEnclosingClass
    // TODO:
    // isNodeUsedDuringClassInitialization
    // TODO:
    // isNodeWithinClass
    // TODO:
    // getLeftSideOfImportEqualsOrExportAssignment
    // TODO:
    // isInRightSideOfImportOrExportAssignment
    // TODO:
    // getSpecialPropertyAssignmentSymbolFromEntityName
    // TODO:
    // isImportTypeQualifierPart

    fn getSymbolOfNameOrPropertyAccessExpression(
        &mut self,
        mut name: BoundNode,
    ) -> Option<SymbolId> {
        // TODO: jsdoc: add JSDocMemberName to check:
        debug_assert!(match &name {
            BoundNode::Ident(_) | BoundNode::TsQualifiedName(_) | BoundNode::PrivateName(_) => true,
            BoundNode::MemberExpr(m) => !m.computed,
            _ => false,
        });
        if isDeclarationName(name.clone()) {
            return self.getSymbolOfNode(name.parent().unwrap());
        }

        // TODO:
        // if (isBoundNodeInJSFile(name)
        //     && name.parent.kind == SyntaxKind.PropertyAccessExpression
        //     && name.parent == (name.parent.parent as BinaryExpression).left)
        // {
        //     // Check if this is a special property assignment
        //     if (!isPrivateIdentifier(name) && !isJSDocMemberName(name)) {
        //         let specialPropertyAssignmentSymbol =
        //             getSpecialPropertyAssignmentSymbolFromEntityName(name);
        //         if (specialPropertyAssignmentSymbol) {
        //             return specialPropertyAssignmentSymbol;
        //         }
        //     }
        // }

        // TODO:
        // if (name.parent.kind == SyntaxKind.ExportAssignment && isEntityNameExpression(name)) {
        //     // Even an entity name expression that doesn't resolve as an entityname may still typecheck as a property access expression
        //     let success = self.resolveEntityName(
        //         name,
        //         /*all meanings*/
        //         SymbolFlags::Value
        //             | SymbolFlags::Type
        //             | SymbolFlags::Namespace
        //             | SymbolFlags::Alias,
        //         /*ignoreErrors*/ true,
        //     );
        //     if (success && success != unknownSymbol) {
        //         return success;
        //     }
        // } else if (isEntityName(name) && isInRightSideOfImportOrExportAssignment(name)) {
        //     // Since we already checked for ExportAssignment, this really could only be an Import
        //     let importEqualsDeclaration = getAncestor(name, SyntaxKind.ImportEqualsDeclaration);
        //     Debug.assert(importEqualsDeclaration != None);
        //     return getSymbolOfPartOfRightHandSideOfImportEquals(
        //         name, /*dontResolveAlias*/ true,
        //     );
        // }

        // TODO:
        // if isEntityName(name) {
        //     let possibleImportNode = isImportTypeQualifierPart(name);
        //     if possibleImportNode {
        //         getTypeFromTypeNode(possibleImportNode);
        //         let sym = getNodeLinks(name).resolvedSymbol;
        //         return if sym == unknownSymbol { None } else { sym };
        //     }
        // }

        while isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(&name) {
            name = name.parent().unwrap();
        }

        // TODO:
        // if (isHeritageClauseElementIdentifier(name)) {
        //     let meaning = SymbolFlags::None;
        //     // In an interface or class, we're definitely interested in a type.
        //     if (name.parent.kind == SyntaxKind.ExpressionWithTypeArguments) {
        //         meaning = SymbolFlags::Type;

        //         // In a class 'extends' clause we are also looking for a value.
        //         if (isExpressionWithTypeArgumentsInClassExtendsClause(name.parent)) {
        //             meaning |= SymbolFlags::Value;
        //         }
        //     } else {
        //         meaning = SymbolFlags::Namespace;
        //     }

        //     meaning |= SymbolFlags::Alias;
        //     let entityNameSymbol = if isEntityNameExpression(name) {
        //         resolveEntityName(name, meaning)
        //     } else {
        //         None
        //     };
        //     if (entityNameSymbol) {
        //         return entityNameSymbol;
        //     }
        // }

        // TODO:
        // if (name.parent.kind == SyntaxKind.JSDocParameterTag) {
        //     return getParameterSymbolFromJSDoc(name.parent as JSDocParameterTag);
        // }

        // TODO:
        // if (name.parent.kind == SyntaxKind.TypeParameter
        //     && name.parent.parent.kind == SyntaxKind.JSDocTemplateTag)
        // {
        //     Debug.assert(!isBoundNodeInJSFile(name)); // Otherwise `isDeclarationName` would have been true.
        //     let typeParameter = getTypeParameterFromJsDoc(
        //         name.parent, /*as TypeParameterDeclaration & { parent: JSDocTemplateTag },*/
        //     );
        //     return typeParameter && typeParameter.symbol;
        // }

        if isExpressionNode(&name) {
            // TODO:
            // if nodeIsMissing(name) {
            //     // Missing entity name.
            //     return None;
            // }

            // TODO: jsdoc
            // let isJSDoc = findAncestor(
            //     name,
            //     or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName),
            // );
            let isJSDoc = false;
            let meaning = if isJSDoc {
                SymbolFlags::Type | SymbolFlags::Namespace | SymbolFlags::Value
            } else {
                SymbolFlags::Value
            };
            if matches!(name, BoundNode::Ident(_)) {
                // TODO:
                // if isJSXTagName(name) && isJsxIntrinsicIdentifier(name) {
                //     let symbol = getIntrinsicTagSymbol(name.parent as JsxOpeningLikeElement);
                //     return if symbol == unknownSymbol {
                //         None
                //     } else {
                //         symbol
                //     };
                // }
                let result = self.resolveEntityName(
                    name, meaning, false, !isJSDoc,
                    // TODO:
                    // self.getHostSignatureFromJSDoc(name),
                    None,
                );
                // TODO: jsodc
                // if result.is_none() && isJSDoc {
                //     let container = findAncestor(name, or(isClassLike, isInterfaceDeclaration));
                //     if container {
                //         return resolveJSDocMemberName(name, getSymbolOfNode(container));
                //     }
                // }
                return result;
            } else if matches!(name, BoundNode::PrivateName(_)) {
                todo!();
                // return getSymbolForPrivateIdentifierExpression(name);
            } else if matches!(&name, BoundNode::MemberExpr(m) if !m.computed)
                || matches!(name, BoundNode::TsQualifiedName(_))
            {
                if self.getNodeLinks(name.clone()).resolvedSymbol.is_some() {
                    return self.getNodeLinks(name).resolvedSymbol;
                }

                if let BoundNode::MemberExpr(m) = name.clone() {
                    self.checkPropertyAccessExpression(name.clone(), m, Some(CheckMode::Normal));
                } else {
                    todo!();
                    // self.checkQualifiedName(name, CheckMode::Normal);
                }
                // TODO: jsdoc
                // if !links.resolvedSymbol && isJSDoc && isQualifiedName(name) {
                //     return resolveJSDocMemberName(name);
                // }
                return self.getNodeLinks(name).resolvedSymbol;
            }
            // TODO: jsdoc
            // else if isJSDocMemberName(name) {
            //     return resolveJSDocMemberName(name);
            // }
        } else if isTypeReferenceIdentifier(name.clone()) {
            let meaning = if matches!(name.parent(), Some(BoundNode::TsTypeRef(_))) {
                SymbolFlags::Type
            } else {
                SymbolFlags::Namespace
            };
            let symbol = self.resolveEntityName(name.clone(), meaning, false, true, None);
            return if symbol.is_some() && symbol != Some(self.unknownSymbol) {
                symbol
            } else {
                Some(self.getUnresolvedSymbolForEntityName(name))
            };
        }
        if matches!(name.parent(), Some(BoundNode::TsTypePredicate(_))) {
            return self.resolveEntityName(
                name,
                SymbolFlags::FunctionScopedVariable,
                false,
                false,
                None,
            );
        }

        None
    }

    // TODO:
    // resolveJSDocMemberName

    fn getSymbolAtLocation(&mut self, node: BoundNode, ignoreErrors: bool) -> Option<SymbolId> {
        if matches!(node, BoundNode::Module(_) | BoundNode::Script(_)) {
            return None;
        }
        // TODO:
        // if node.kind == SyntaxKind.SourceFile {
        //     return if isExternalModule(node as SourceFile) {
        //         self.getMergedSymbol(node.symbol)
        //     } else {
        //         None
        //     };
        // }
        // Safe to unwrap as all nodes except Scripts and Modules have a parent
        // and those are handled above.
        let parent = node.parent().unwrap();
        let grandparent = parent.parent();

        // TODO:
        // if node.flags & NodeFlags.InWithStatement {
        //     // We cannot answer semantic questions within a with block, do not proceed any further
        //     return None;
        // }

        if isDeclarationNameOrImportPropertyName(node.clone()) {
            // This is a declaration, call getSymbolOfNode

            let parentSymbol = self.getSymbolOfNode(parent).unwrap();
            return Some(parentSymbol);
            // TODO: import/export
            // return if isImportOrExportSpecifier(parent) && parent.propertyName == node {
            //     self.getImmediateAliasedSymbol(parentSymbol)
            // } else {
            //     Some(parentSymbol)
            // };
        } else if isLiteralComputedPropertyDeclarationName(node.clone()) {
            return self.getSymbolOfNode(grandparent.unwrap());
        }

        // TODO:
        // if let BoundNode::Ident(ident) = node {
        //     if isInRightSideOfImportOrExportAssignment(ident) {
        //         return self.getSymbolOfNameOrPropertyAccessExpression(ident);
        //     } else if parent.kind == SyntaxKind.BindingElement
        //         && grandParent.kind == SyntaxKind.ObjectBindingPattern
        //         && node == (parent as BindingElement).propertyName
        //     {
        //         let typeOfPattern = self.getTypeOfNode(grandParent);
        //         let propertyDeclaration = self.getPropertyOfType(typeOfPattern, ident.sym);

        //         if propertyDeclaration {
        //             return propertyDeclaration;
        //         }
        //     } else if let BoundNode::MetaPropExpr(parent_inner) = parent {
        //         let parentType = self.getTypeOfNode(parent);
        //         if let Some(propertyDeclaration) = self.getPropertyOfType(parentType, ident.sym) {
        //             return propertyDeclaration;
        //         }
        //         if parent_inner.keywordToken == SyntaxKind.NewKeyword {
        //             return self.checkNewTargetMetaProperty(parent).symbol;
        //         }
        //     }
        // }

        match &node {
            BoundNode::Ident(_) | BoundNode::PrivateName(_) | BoundNode::TsQualifiedName(_) => {
                self.getSymbolOfNameOrPropertyAccessExpression(node.clone())
            }
            BoundNode::MemberExpr(m) if !m.computed => {
                self.getSymbolOfNameOrPropertyAccessExpression(node.clone())
            }

            BoundNode::ThisExpr(expr) => {
                let container = getThisContainer(node.clone(), false);
                if isFunctionLike(Some(&container)) {
                    let sig = self.getSignatureFromDeclaration(container);
                    let sig = &self.signatures[sig];
                    if sig.thisParameter.is_some() {
                        return sig.thisParameter;
                    }
                }
                if isInExpressionContext(
                    node.clone().parent().unwrap(),
                    ast::Expr::This(expr.node.clone()),
                ) {
                    let ty = self.checkExpression(node, None, false);
                    return *self.types[ty].get_symbol();
                }
                let ty = self.getTypeFromThisTypeNode(node);
                *self.types[ty].get_symbol()
            }

            BoundNode::TsThisType(_) => {
                let type_id = self.getTypeFromThisTypeNode(node);
                *self.types[type_id].get_symbol()
            }
            BoundNode::Super(_) => {
                let ty = self.checkExpression(node, None, false);
                *self.types[ty].get_symbol()
            }
            // TODO:
            // BoundNode::ConstructorKeyword(_) => {
            //     // constructor keyword for an overload, should take us to the definition if it exist
            //     let constructorDeclaration = parent;
            //     if constructorDeclaration && constructorDeclaration.kind == SyntaxKind.Constructor {
            //         return (constructorDeclaration.parent as ClassDeclaration).symbol;
            //     }
            //     None
            // }
            BoundNode::Tpl(_) => todo!("see below"),
            //     BoundNode::StringLiteral(_) | BoundNode::NoSubstitutionTemplateLiteral(_) => {
            BoundNode::Str(_) => {
                // TODO:
                // 1). import x = require("./mo/*gotToDefinitionHere*/d")
                // 2). External module name in an import declaration
                // 3). Dynamic import call or require in javascript
                // 4). type A = import("./f/*gotToDefinitionHere*/oo")
                // if (isExternalModuleImportEqualsDeclaration(grandparent)
                //     && getExternalModuleImportEqualsDeclarationExpression(grandparent) == node)
                //     || ((parent.kind == SyntaxKind.ImportDeclaration
                //         || parent.kind == SyntaxKind.ExportDeclaration)
                //         && (parent as ImportDeclaration).moduleSpecifier == node)
                //     || ((isBoundNodeInJSFile(node)
                //         && isRequireCall(parent, /*checkArgumentIsStringLiteralLike*/ false))
                //         || isImportCall(parent))
                //     || (isLiteralTypeNode(parent)
                //         && isLiteralImportTypeNode(grandparent)
                //         && grandparent.argument == parent)
                // {
                //     return resolveExternalModuleName(
                //         node,
                //         node as LiteralExpression,
                //         ignoreErrors,
                //     );
                // }
                if let BoundNode::CallExpr(p) = &parent {
                    if isBindableObjectDefinePropertyCall(&p.node)
                        && p.args[1].bind(parent.clone()) == node
                    {
                        return self.getSymbolOfNode(parent);
                    }
                }

                // index access
                let objectType = match &parent {
                    BoundNode::MemberExpr(m) if m.computed => {
                        if Node::from(m.prop.clone()) == Node::from(node) {
                            Some(self.getTypeOfExpression(m.obj.bind(parent.clone())))
                        } else {
                            None
                        }
                    }
                    BoundNode::TsLitType(_) => {
                        todo!();
                        // if isIndexedAccessTypeNode(grandParent) {
                        //     Some(self.getTypeFromTypeNode(grandParent.objectType))
                        // } else {
                        //     None
                        // }
                    }
                    _ => None,
                };
                if let Some(objectType) = objectType {
                    todo!();
                // self.getPropertyOfType(
                //     objectType,
                //     escapeLeadingUnderscores((node as StringLiteral | NumericLiteral).text),false
                // )
                } else {
                    None
                }
            }
            BoundNode::Number(n) => {
                // index access
                let objectType = match &parent {
                    BoundNode::MemberExpr(m) if m.computed => {
                        if Node::from(m.prop.clone()) == Node::from(node) {
                            Some(self.getTypeOfExpression(m.obj.bind(parent.clone())))
                        } else {
                            None
                        }
                    }
                    BoundNode::TsLitType(_) => {
                        todo!();
                        // if isIndexedAccessTypeNode(grandParent) {
                        //     Some(self.getTypeFromTypeNode(grandParent.objectType))
                        // } else {
                        //     None
                        // }
                    }
                    _ => None,
                };
                if let Some(objectType) = objectType {
                    todo!();
                // self.getPropertyOfType(
                //     objectType,
                //     escapeLeadingUnderscores((node as StringLiteral | NumericLiteral).text),false
                // )
                } else {
                    None
                }
            }
            // TODO:
            //     BoundNode::DefaultKeyword(_)
            //     | BoundNode::FunctionKeyword(_)
            //     | BoundNode::EqualsGreaterThanToken(_)
            //     | BoundNode::ClassKeyword(_) => self.getSymbolOfNode(parent),
            //     BoundNode::ImportType(_) => {
            //         if isLiteralImportTypeNode(node) {
            //             self.getSymbolAtLocation(node.argument.literal, ignoreErrors)
            //         } else {
            //             None
            //         }
            //     }
            // TODO:
            //     BoundNode::ExportKeyword(_) => {
            //         if isExportAssignment(parent) {
            //             Debug.checkDefined(parent.symbol)
            //         } else {
            //             None
            //         }
            //     }
            // TODO:
            //     BoundNode::ImportKeyword(_) | BoundNode::NewKeyword(_) => {
            //         if isMetaProperty(parent) {
            //             self.checkMetaPropertyKeyword(parent).symbol
            //         } else {
            //             None
            //         }
            //     }
            BoundNode::MetaPropExpr(_) => {
                let ty = self.checkExpression(node, None, false);
                *self.types[ty].get_symbol()
            }

            _ => None,
        }
    }

    // TODO:
    // getIndexInfosAtLocation
    // TODO:
    // getShorthandAssignmentValueSymbol
    // TODO:
    // getExportSpecifierLocalTargetSymbol

    fn getTypeOfNode(&mut self, mut node: BoundNode) -> TypeId {
        // 'flatten' binding idents to simplify logic:
        if let Some(p @ BoundNode::BindingIdent(_)) = node.parent() {
            node = p;
        }

        // TODO:
        // if (isSourceFile(node) && !isExternalModule(node)) {
        //     return errorType;
        // }
        if matches!(node, BoundNode::Script(_) | BoundNode::Module(_)) {
            todo!("see above");
        }

        // TODO:
        // if (node.flags & NodeFlags.InWithStatement) {
        //     // We cannot answer semantic questions within a with block, do not proceed any further
        //     return errorType;
        // }

        let classDecl = tryGetClassImplementingOrExtendingExpressionWithTypeArguments(&node);
        let classType = classDecl.as_ref().map(|c| {
            let sym = self.getSymbolOfNode(c.class.clone()).unwrap();
            self.getDeclaredTypeOfClassOrInterface(sym)
        });
        if isPartOfTypeNode(&node) {
            let typeFromTypeNode = self.getTypeFromTypeNode(node);
            return if let Some(classType) = classType {
                let thisType = self.types[classType].unwrap_as_interface_type().thisType;
                self.getTypeWithThisArgument(typeFromTypeNode, thisType, false)
            } else {
                typeFromTypeNode
            };
        }

        if isExpressionNode(&node) {
            return self.getRegularTypeOfExpression(node);
        }

        if let Some(classType) = classType {
            if !classDecl.unwrap().isImplements {
                // A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the
                // extends clause of a class. We handle that case here.
                return if let Some(baseType) = self.getBaseTypes(classType).first() {
                    let thisType = self.types[classType].unwrap_as_interface_type().thisType;
                    self.getTypeWithThisArgument(*baseType, thisType, false)
                } else {
                    self.errorType
                };
            }
        }

        if isTypeDeclaration(&node) {
            // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
            let symbol = self.getSymbolOfNode(node).unwrap();
            return self.getDeclaredTypeOfSymbol(symbol);
        }

        if isTypeDeclarationName(&node) {
            let symbol = self.getSymbolAtLocation(node, false);
            return if let Some(symbol) = symbol {
                self.getDeclaredTypeOfSymbol(symbol)
            } else {
                todo!();
                self.errorType
            };
        }

        if isDeclaration(&node) {
            // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
            let symbol = self.getSymbolOfNode(node).unwrap();
            return self.getTypeOfSymbol(symbol);
        }

        if isDeclarationNameOrImportPropertyName(node.clone()) {
            let symbol = self.getSymbolAtLocation(node, false);
            if let Some(symbol) = symbol {
                return self.getTypeOfSymbol(symbol);
            }
            return self.errorType;
        }

        if isBindingPattern(&node) {
            todo!();
            // return getTypeForVariableLikeDeclaration(node.parent, /*includeOptionality*/ true) || errorType;
        }

        // TODO:
        // if isInRightSideOfImportOrExportAssignment(node as Identifier) {
        //     let symbol = getSymbolAtLocation(node);
        //     if symbol {
        //         let declaredType = getDeclaredTypeOfSymbol(symbol);
        //         return if !isErrorType(declaredType) {declaredType}else{getTypeOfSymbol(symbol)};
        //     }
        // }

        if let BoundNode::MetaPropExpr(p) = node {
            todo!();
            // return checkMetaPropertyKeyword(node.parent);
        }

        // dbg!(&node, node.parent());
        // todo!();

        self.errorType
    }

    // TODO:
    // getTypeOfAssignmentPattern
    // TODO:
    // getPropertySymbolOfDestructuringAssignment

    fn getRegularTypeOfExpression(&mut self, mut expr: BoundNode) -> TypeId {
        if isRightSideOfQualifiedNameOrPropertyAccess(&expr) {
            expr = expr.parent().unwrap();
        }
        let ty = self.getTypeOfExpression(expr);
        self.getRegularTypeOfLiteralType(ty)
    }

    // TODO:
    // getParentTypeOfClassElement
    // TODO:
    // getClassElementPropertyKeyType
    // TODO:
    // getAugmentedPropertiesOfType

    fn typeHasCallOrConstructSignatures(&mut self, ty: TypeId) -> bool {
        !self.getSignaturesOfType(ty, SignatureKind::Call).is_empty()
            || !self
                .getSignaturesOfType(ty, SignatureKind::Construct)
                .is_empty()
    }

    // TODO:
    // getRootSymbols
    // TODO:
    // getImmediateRootSymbols
    // TODO:
    // tryGetAliasTarget
    // TODO:
    // isArgumentsLocalBinding
    // TODO:
    // moduleExportsSomeValue
    // TODO:
    // isNameOfModuleOrEnumDeclaration
    // TODO:
    // getReferencedExportContainer
    // TODO:
    // getReferencedImportDeclaration
    // TODO:
    // isSymbolOfDestructuredElementOfCatchBinding
    // TODO:
    // isSymbolOfDeclarationWithCollidingName
    // TODO:
    // getReferencedDeclarationWithCollidingName
    // TODO:
    // isDeclarationWithCollidingName
    // TODO:
    // isValueAliasDeclaration
    // TODO:
    // isTopLevelValueImportEqualsWithEntityName
    // TODO:
    // isAliasResolvedToValue

    fn isConstEnumOrConstEnumOnlyModule(&self, s: SymbolId) -> bool {
        self.isConstEnumSymbol(s) || self.symbols[s].constEnumOnlyModule()
    }

    // TODO:
    // isReferencedAliasDeclaration
    // TODO:
    // isImplementationOfOverload
    // TODO:
    // isRequiredInitializedParameter
    // TODO:
    // isOptionalUninitializedParameterProperty
    // TODO:
    // isOptionalUninitializedParameter
    // TODO:
    // isExpandoFunctionDeclaration
    // TODO:
    // getPropertiesOfContainerFunction
    // TODO:
    // getNodeCheckFlags
    // TODO:
    // getEnumMemberValue
    // TODO:
    // canHaveConstantValue
    // TODO:
    // getConstantValue

    fn isFunctionType(&mut self, ty: TypeId) -> bool {
        self.types[ty].get_flags().intersects(TypeFlags::Object)
            && !self.getSignaturesOfType(ty, SignatureKind::Call).is_empty()
    }

    // TODO:
    // getTypeReferenceSerializationKind
    // TODO:
    // createTypeOfDeclaration
    // TODO:
    // createReturnTypeOfSignatureDeclaration
    // TODO:
    // createTypeOfExpression
    // TODO:
    // hasGlobalName
    // TODO:
    // getReferencedValueSymbol
    // TODO:
    // getReferencedValueDeclaration
    // TODO:
    // isLiteralConstDeclaration
    // TODO:
    // literalTypeToNode
    // TODO:
    // createLiteralConstValue
    // TODO:
    // getJsxFactoryEntity
    // TODO:
    // getJsxFragmentFactoryEntity
    // TODO:
    // createResolver
    // TODO:
    // getExternalModuleFileFromDeclaration

    fn initializeTypeChecker(&mut self) {
        // // Bind all source files and propagate errors
        // for (const file of host.getSourceFiles()) {
        //     bindSourceFile(file, compilerOptions);
        // }

        // amalgamatedDuplicates = new Map();

        let files = mem::take(&mut self.host.files);

        // Initialize global symbol table
        // let augmentations: (readonly (StringLiteral | Identifier)[])[] | undefined;
        for f in &files {
            // if (file.redirectInfo) {
            //     continue;
            // }

            let program = f.program.bind_to_opt_parent(None);

            if !f.isExternalOrCommonJsModule() {
                // It is an error for a non-external-module (i.e. script) to declare its own `globalThis`.
                // We can't use `builtinGlobals` for this due to synthetic expando-namespace generation in JS files.
                let file_locals = self.node_data(program.clone()).locals.unwrap();
                let fileGlobalThisSymbol = self.symbol_tables[file_locals]
                    .get(&"globalThis".into())
                    .copied();

                if let Some(sym_id) = fileGlobalThisSymbol {
                    let symbol = &self.symbols[sym_id];
                    if !symbol.declarations().is_empty() {
                        todo!();
                        // for declaration in fileGlobalThisSymbol.declarations {
                        //     diagnostics.add(createDiagnosticForNode(
                        //         declaration,
                        //         Diagnostics
                        //             .Declaration_name_conflicts_with_built_in_global_identifier_0,
                        //         "globalThis",
                        //     ));
                        // }
                    }
                }
                self.mergeSymbolTable(self.globals, file_locals, false);
            }
            if !f.jsGlobalAugmentations.is_empty() {
                // Copied from `mergeSymbolTable`:
                for (id, &sourceSymbol) in &f.jsGlobalAugmentations {
                    let new = match self.symbol_tables[self.globals].get(id) {
                        Some(existing) => self.mergeSymbol(*existing, sourceSymbol, false),
                        None => sourceSymbol,
                    };
                    self.symbol_tables[self.globals].insert(id.clone(), new);
                }
            }
            // if (f.patternAmbientModules && f.patternAmbientModules.length) {
            //     patternAmbientModules = concatenate(patternAmbientModules, f.patternAmbientModules);
            // }
            // if (f.moduleAugmentations.length) {
            //     // (augmentations || (augmentations = [])).push(f.moduleAugmentations);
            // }
            // if (f.symbol && f.symbol.globalExports) {
            //     // Merge in UMD exports with first-in-wins semantics (see #9771)
            //     let source = f.symbol.globalExports;
            //     // source.forEach((sourceSymbol, id) => {
            //     //     if (!globals.has(id)) {
            //     //         globals.set(id, sourceSymbol);
            //     //     }
            //     // });
            // }
        }

        self.host.files = files;

        // // We do global augmentations separately from module augmentations (and before creating global types) because they
        // //  1. Affect global types. We won't have the correct global types until global augmentations are merged. Also,
        // //  2. Module augmentation instantiation requires creating the type of a module, which, in turn, can require
        // //       checking for an export or property on the module (if export=) which, in turn, can fall back to the
        // //       apparent type of the module - either globalObjectType or globalFunctionType - which wouldn't exist if we
        // //       did module augmentations prior to finalizing the global types.
        // if (augmentations) {
        //     // merge _global_ module augmentations.
        //     // this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
        //     for (const list of augmentations) {
        //         for (const augmentation of list) {
        //             if (!isGlobalScopeAugmentation(augmentation.parent as ModuleDeclaration)) continue;
        //             mergeModuleAugmentation(augmentation);
        //         }
        //     }
        // }

        self.booleanType = Some(self.getUnionType(
            &[self.regularFalseType, self.regularTrueType],
            None,
            None,
            None,
            None,
        ));
        self.stringNumberSymbolType = Some(self.getUnionType(
            &[self.stringType, self.numberType, self.esSymbolType],
            None,
            None,
            None,
            None,
        ));
        self.keyofConstraintType = if self.keyofStringsOnly {
            Some(self.stringType)
        } else {
            self.stringNumberSymbolType
        };

        // Setup global builtins
        {
            let (globals, builtinGlobals) = self
                .symbol_tables
                .pick2_mut(self.globals, self.builtinGlobals);
            addToSymbolTable(
                globals,
                &*builtinGlobals,
                /*Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0,*/
            );
        }

        self.symbols[self.undefinedSymbol]
            .as_transient_symbol_mut()
            .symbol_links
            .ty = Some(self.undefinedWideningType);
        self.symbols[self.argumentsSymbol]
            .as_transient_symbol_mut()
            .symbol_links
            .ty = self.getGlobalType("IArguments".into(), 0, true);
        self.symbols[self.unknownSymbol]
            .as_transient_symbol_mut()
            .symbol_links
            .ty = Some(self.errorType);
        // TODO: te following may be better than the below:
        // self.types.push(Type::AnonymousType(AnonymousType {
        //     anonymous_type: Default::default(),
        //     object_type_base: ObjectTypeBase::new(ObjectFlags::Anonymous),
        //     type_base: TypeBase::new(TypeFlags::Object, Some(symbol)),
        // }))
        self.symbols[self.globalThisSymbol]
            .as_transient_symbol_mut()
            .symbol_links
            .ty = Some(self.createObjectType(ObjectFlags::Anonymous, Some(self.globalThisSymbol)));

        // Initialize special types
        self.globalArrayType = Some(self.getGlobalType("Array".into(), 1, true).unwrap());
        self.globalObjectType = Some(self.getGlobalType("Object".into(), 0, true).unwrap());
        self.globalFunctionType = Some(self.getGlobalType("Function".into(), 0, true).unwrap());
        // let globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction" .into(),  0,  true) || globalFunctionType;
        // let globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction" .into(),  0,  true) || globalFunctionType;
        self.globalStringType = Some(self.getGlobalType("String".into(), 0, true).unwrap());
        self.globalNumberType = Some(self.getGlobalType("Number".into(), 0, true).unwrap());
        self.globalBooleanType = Some(self.getGlobalType("Boolean".into(), 0, true).unwrap());
        self.globalRegExpType = Some(self.getGlobalType("RegExp".into(), 0, true).unwrap());
        self.anyArrayType = Some(self.createArrayType(self.anyType, false));

        self.autoArrayType = Some(self.createArrayType(self.autoType, false));
        if self.autoArrayType == Some(self.emptyObjectType) {
            // autoArrayType is used as a marker, so even if global Array type is not defined, it needs to be a unique type
            self.autoArrayType = Some(self.createAnonymousType(
                None,
                self.emptySymbols,
                Default::default(),
                Default::default(),
                Default::default(),
            ));
        }

        self.globalReadonlyArrayType =
            (self.getGlobalTypeOrUndefined("ReadonlyArray".into(), 1)/*as GenericType*/)
                .or(self.globalArrayType);
        self.anyReadonlyArrayType = Some(
            if let Some(globalReadonlyArrayType) = self.globalReadonlyArrayType {
                self.createTypeFromGenericGlobalType(globalReadonlyArrayType, &[self.anyType])
            } else {
                unreachable!("I think this is unreachable");
                // anyArrayType
            },
        );
        self.globalThisType = self.getGlobalTypeOrUndefined("ThisType".into(),  1) /*as GenericType*/;

        // if (augmentations) {
        //     // merge _nonglobal_ module augmentations.
        //     // this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
        //     for (const list of augmentations) {
        //         for (const augmentation of list) {
        //             if (isGlobalScopeAugmentation(augmentation.parent as ModuleDeclaration)) continue;
        //             mergeModuleAugmentation(augmentation);
        //         }
        //     }
        // }

        // amalgamatedDuplicates.forEach(({ firstFile, secondFile, conflictingSymbols }) => {
        //     // If not many things conflict, issue individual errors
        //     if (conflictingSymbols.size < 8) {
        //         conflictingSymbols.forEach(({ isBlockScoped, firstFileLocations, secondFileLocations }, symbolName) => {
        //             const message = isBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0;
        //             for (const node of firstFileLocations) {
        //                 addDuplicateDeclarationError(node, message, symbolName, secondFileLocations);
        //             }
        //             for (const node of secondFileLocations) {
        //                 addDuplicateDeclarationError(node, message, symbolName, firstFileLocations);
        //             }
        //         });
        //     }
        //     else {
        //         // Otherwise issue top-level error since the files appear very identical in terms of what they contain
        //         const list = arrayFrom(conflictingSymbols.keys()).join(", ");
        //         diagnostics.add(addRelatedInfo(
        //             createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),
        //             createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file)
        //         ));
        //         diagnostics.add(addRelatedInfo(
        //             createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),
        //             createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file)
        //         ));
        //     }
        // });
        // amalgamatedDuplicates = undefined;
    }

    // TODO:
    // checkExternalEmitHelpers
    // TODO:
    // getHelperName
    // TODO:
    // resolveHelpersModule
    // TODO:
    // checkGrammarDecoratorsAndModifiers
    // TODO:
    // checkGrammarDecorators
    // TODO:
    // checkGrammarModifiers
    // TODO:
    // reportObviousModifierErrors
    // TODO:
    // shouldReportBadModifier
    // TODO:
    // nodeHasAnyModifiersExcept
    // TODO:
    // checkGrammarAsyncModifier
    // TODO:
    // checkGrammarForDisallowedTrailingComma
    // TODO:
    // checkGrammarTypeParameterList
    // TODO:
    // checkGrammarParameterList
    // TODO:
    // getNonSimpleParameters
    // TODO:
    // checkGrammarForUseStrictSimpleParameterList

    fn checkGrammarFunctionLikeDeclaration(&mut self, node: &BoundNode) -> bool {
        // Prevent cascading error by short-circuit
        // let file = getSourceFileOfNode(node);
        // self.checkGrammarDecoratorsAndModifiers(node) ||
        //     self.checkGrammarTypeParameterList(node.typeParameters, file) ||
        //     self.checkGrammarParameterList(node.parameters) ||
        //     self.checkGrammarArrowFunction(node, file) ||
        //     (isFunctionLikeDeclaration(node) && self.checkGrammarForUseStrictSimpleParameterList(node))

        // todo:
        true
    }

    // TODO:
    // checkGrammarClassLikeDeclaration
    // TODO:
    // checkGrammarArrowFunction
    // TODO:
    // checkGrammarIndexSignatureParameters
    // TODO:
    // checkGrammarIndexSignature
    // TODO:
    // checkGrammarForAtLeastOneTypeArgument
    // TODO:
    // checkGrammarTypeArguments
    // TODO:
    // checkGrammarTaggedTemplateChain
    // TODO:
    // checkGrammarForOmittedArgument
    // TODO:
    // checkGrammarArguments
    // TODO:
    // checkGrammarHeritageClause
    // TODO:
    // checkGrammarExpressionWithTypeArguments
    // TODO:
    // checkGrammarClassDeclarationHeritageClauses
    // TODO:
    // checkGrammarInterfaceDeclaration
    // TODO:
    // checkGrammarComputedPropertyName
    // TODO:
    // checkGrammarForGenerator
    // TODO:
    // checkGrammarForInvalidQuestionMark
    // TODO:
    // checkGrammarForInvalidExclamationToken
    // TODO:
    // checkGrammarObjectLiteralExpression
    // TODO:
    // checkGrammarJsxElement
    // TODO:
    // checkGrammarJsxName
    // TODO:
    // checkGrammarJsxExpression
    // TODO:
    // checkGrammarForInOrForOfStatement
    // TODO:
    // checkGrammarAccessor
    // TODO:
    // doesAccessorHaveCorrectParameterCount
    // TODO:
    // getAccessorThisParameter
    // TODO:
    // checkGrammarTypeOperatorNode
    // TODO:
    // checkGrammarForInvalidDynamicName
    // TODO:
    // checkGrammarMethod
    // TODO:
    // checkGrammarBreakOrContinueStatement
    // TODO:
    // checkGrammarBindingElement
    // TODO:
    // isStringOrNumberLiteralExpression
    // TODO:
    // isBigIntLiteralExpression
    // TODO:
    // isSimpleLiteralEnumReference
    // TODO:
    // checkAmbientInitializer
    // TODO:
    // checkGrammarVariableDeclaration
    // TODO:
    // checkESModuleMarker
    // TODO:
    // checkGrammarNameInLetOrConstDeclarations
    // TODO:
    // checkGrammarVariableDeclarationList
    // TODO:
    // allowLetAndConstDeclarations
    // TODO:
    // checkGrammarForDisallowedLetOrConstStatement
    // TODO:
    // checkGrammarMetaProperty
    // TODO:
    // hasParseDiagnostics
    // TODO:
    // grammarErrorOnFirstToken
    // TODO:
    // grammarErrorAtPos
    // TODO:
    // grammarErrorOnNodeSkippedOn
    // TODO:
    // grammarErrorOnNode
    // TODO:
    // checkGrammarConstructorTypeParameters
    // TODO:
    // checkGrammarConstructorTypeAnnotation
    // TODO:
    // checkGrammarProperty
    // TODO:
    // checkGrammarTopLevelElementForRequiredDeclareModifier
    // TODO:
    // checkGrammarTopLevelElementsForRequiredDeclareModifier
    // TODO:
    // checkGrammarSourceFile
    // TODO:
    // checkGrammarStatementInAmbientContext
    // TODO:
    // checkGrammarNumericLiteral
    // TODO:
    // checkNumericLiteralValueSize
    // TODO:
    // checkGrammarBigIntLiteral
    // TODO:
    // grammarErrorAfterFirstToken
    // TODO:
    // getAmbientModules
    // TODO:
    // checkGrammarImportClause
    // TODO:
    // checkGrammarNamedImportsOrExports
    // TODO:
    // checkGrammarImportCallExpression
    // TODO:
    // findMatchingTypeReferenceOrTypeAliasReference
    // TODO:
    // findBestTypeForObjectLiteral
    // TODO:
    // findBestTypeForInvokable
    // TODO:
    // findMostOverlappyType
    // TODO:
    // filterPrimitivesIfContainsNonPrimitive
    // TODO:
    // findMatchingDiscriminantType

    pub fn getDeclarationModifierFlagsFromSymbol(
        &mut self,
        s: SymbolId,
        isWrite: bool,
    ) -> ModifierFlags {
        if let Some(valueDeclaration) = self.symbols[s].valueDeclaration() {
            let declaration = if isWrite {
                self.symbols[s]
                    .declarations()
                    .iter()
                    .find(|d| match d {
                        BoundNode::ClassMethod(m) => m.kind == ast::MethodKind::Setter,
                        BoundNode::PrivateMethod(m) => m.kind == ast::MethodKind::Setter,
                        BoundNode::SetterProp(_) | BoundNode::TsSetterSignature(_) => true,
                        _ => false,
                    })
                    .unwrap_or(valueDeclaration)
            } else {
                valueDeclaration
            };
            let flags = getCombinedModifierFlags(declaration);
            let parent_sym = self.symbols[s].parent();
            return if parent_sym.is_some()
                && self.symbols[parent_sym.unwrap()]
                    .flags()
                    .intersects(SymbolFlags::Class)
            {
                flags
            } else {
                flags & !ModifierFlags::AccessibilityModifier
            };
        }
        if getCheckFlags(&self.symbols[s]).intersects(CheckFlags::Synthetic) {
            let checkFlags = getCheckFlags(&self.symbols[s]);
            let accessModifier = if checkFlags.intersects(CheckFlags::ContainsPrivate) {
                ModifierFlags::Private
            } else if checkFlags.intersects(CheckFlags::ContainsPublic) {
                ModifierFlags::Public
            } else {
                ModifierFlags::Protected
            };
            let staticModifier = if checkFlags.intersects(CheckFlags::ContainsStatic) {
                ModifierFlags::Static
            } else {
                ModifierFlags::empty()
            };
            return accessModifier | staticModifier;
        }
        if self.symbols[s].flags().intersects(SymbolFlags::Prototype) {
            return ModifierFlags::Public | ModifierFlags::Static;
        }
        ModifierFlags::empty()
    }
}

bitflags! {
    struct IterationUse: u8 {
        const AllowsSyncIterablesFlag = 1 << 0;
        const AllowsAsyncIterablesFlag = 1 << 1;
        const AllowsStringInputFlag = 1 << 2;
        const ForOfFlag = 1 << 3;
        const YieldStarFlag = 1 << 4;
        const SpreadFlag = 1 << 5;
        const DestructuringFlag = 1 << 6;
        const PossiblyOutOfBounds = 1 << 7;

        // Spread, Destructuring, Array element assignment
        const Element = Self::AllowsSyncIterablesFlag.bits;
        const Spread = Self::AllowsSyncIterablesFlag.bits | Self::SpreadFlag.bits;
        const Destructuring = Self::AllowsSyncIterablesFlag.bits | Self::DestructuringFlag.bits;

        const ForOf = Self::AllowsSyncIterablesFlag.bits | Self::AllowsStringInputFlag.bits | Self::ForOfFlag.bits;
        const ForAwaitOf = Self::AllowsSyncIterablesFlag.bits | Self::AllowsAsyncIterablesFlag.bits | Self::AllowsStringInputFlag.bits | Self::ForOfFlag.bits;

        const YieldStar = Self::AllowsSyncIterablesFlag.bits | Self::YieldStarFlag.bits;
        const AsyncYieldStar = Self::AllowsSyncIterablesFlag.bits | Self::AllowsAsyncIterablesFlag.bits | Self::YieldStarFlag.bits;

        const GeneratorReturnType = Self::AllowsSyncIterablesFlag.bits;
        const AsyncGeneratorReturnType = Self::AllowsAsyncIterablesFlag.bits;
    }
}

enum IterationTypeKind {
    Yield,
    Return,
    Next,
}

enum WideningKind {
    Normal,
    FunctionReturn,
    GeneratorNext,
    GeneratorYield,
}

bitflags! {
    struct TypeFacts: u32 {
        const None = 0;
        const TypeofEQString = 1 << 0;      // typeof x === "string"
        const TypeofEQNumber = 1 << 1;      // typeof x === "number"
        const TypeofEQBigInt = 1 << 2;      // typeof x === "bigint"
        const TypeofEQBoolean = 1 << 3;     // typeof x === "boolean"
        const TypeofEQSymbol = 1 << 4;      // typeof x === "symbol"
        const TypeofEQObject = 1 << 5;      // typeof x === "object"
        const TypeofEQFunction = 1 << 6;    // typeof x === "function"
        const TypeofEQHostObject = 1 << 7;  // typeof x === "xxx"
        const TypeofNEString = 1 << 8;      // typeof x !== "string"
        const TypeofNENumber = 1 << 9;      // typeof x !== "number"
        const TypeofNEBigInt = 1 << 10;     // typeof x !== "bigint"
        const TypeofNEBoolean = 1 << 11;     // typeof x !== "boolean"
        const TypeofNESymbol = 1 << 12;     // typeof x !== "symbol"
        const TypeofNEObject = 1 << 13;     // typeof x !== "object"
        const TypeofNEFunction = 1 << 14;   // typeof x !== "function"
        const TypeofNEHostObject = 1 << 15; // typeof x !== "xxx"
        const EQUndefined = 1 << 16;        // x === undefined
        const EQNull = 1 << 17;             // x === null
        const EQUndefinedOrNull = 1 << 18;  // x === undefined / x === null
        const NEUndefined = 1 << 19;        // x !== undefined
        const NENull = 1 << 20;             // x !== null
        const NEUndefinedOrNull = 1 << 21;  // x != undefined / x != null
        const Truthy = 1 << 22;             // x
        const Falsy = 1 << 23;              // !x
        const All = (1 << 24) - 1;
        // The following members encode facts about particular kinds of types for use in the getTypeFacts function.
        // The presence of a particular fact means that the given test is true for some (and possibly all) values
        // of that kind of type.
        const BaseStringStrictFacts = Self::TypeofEQString.bits | Self::TypeofNENumber.bits | Self::TypeofNEBigInt.bits | Self::TypeofNEBoolean.bits | Self::TypeofNESymbol.bits | Self::TypeofNEObject.bits | Self::TypeofNEFunction.bits | Self::TypeofNEHostObject.bits | Self::NEUndefined.bits | Self::NENull.bits | Self::NEUndefinedOrNull.bits;
        const BaseStringFacts = Self::BaseStringStrictFacts.bits | Self::EQUndefined.bits | Self::EQNull.bits | Self::EQUndefinedOrNull.bits | Self::Falsy.bits;
        const StringStrictFacts = Self::BaseStringStrictFacts.bits | Self::Truthy.bits | Self::Falsy.bits;
        const StringFacts = Self::BaseStringFacts.bits | Self::Truthy.bits;
        const EmptyStringStrictFacts = Self::BaseStringStrictFacts.bits | Self::Falsy.bits;
        const EmptyStringFacts = Self::BaseStringFacts.bits;
        const NonEmptyStringStrictFacts = Self::BaseStringStrictFacts.bits | Self::Truthy.bits;
        const NonEmptyStringFacts = Self::BaseStringFacts.bits | Self::Truthy.bits;
        const BaseNumberStrictFacts = Self::TypeofEQNumber.bits | Self::TypeofNEString.bits | Self::TypeofNEBigInt.bits | Self::TypeofNEBoolean.bits | Self::TypeofNESymbol.bits | Self::TypeofNEObject.bits | Self::TypeofNEFunction.bits | Self::TypeofNEHostObject.bits | Self::NEUndefined.bits | Self::NENull.bits | Self::NEUndefinedOrNull.bits;
        const BaseNumberFacts = Self::BaseNumberStrictFacts.bits | Self::EQUndefined.bits | Self::EQNull.bits | Self::EQUndefinedOrNull.bits | Self::Falsy.bits;
        const NumberStrictFacts = Self::BaseNumberStrictFacts.bits | Self::Truthy.bits | Self::Falsy.bits;
        const NumberFacts = Self::BaseNumberFacts.bits | Self::Truthy.bits;
        const ZeroNumberStrictFacts = Self::BaseNumberStrictFacts.bits | Self::Falsy.bits;
        const ZeroNumberFacts = Self::BaseNumberFacts.bits;
        const NonZeroNumberStrictFacts = Self::BaseNumberStrictFacts.bits | Self::Truthy.bits;
        const NonZeroNumberFacts = Self::BaseNumberFacts.bits | Self::Truthy.bits;
        const BaseBigIntStrictFacts = Self::TypeofEQBigInt.bits | Self::TypeofNEString.bits | Self::TypeofNENumber.bits | Self::TypeofNEBoolean.bits | Self::TypeofNESymbol.bits | Self::TypeofNEObject.bits | Self::TypeofNEFunction.bits | Self::TypeofNEHostObject.bits | Self::NEUndefined.bits | Self::NENull.bits | Self::NEUndefinedOrNull.bits;
        const BaseBigIntFacts = Self::BaseBigIntStrictFacts.bits | Self::EQUndefined.bits | Self::EQNull.bits | Self::EQUndefinedOrNull.bits | Self::Falsy.bits;
        const BigIntStrictFacts = Self::BaseBigIntStrictFacts.bits | Self::Truthy.bits | Self::Falsy.bits;
        const BigIntFacts = Self::BaseBigIntFacts.bits | Self::Truthy.bits;
        const ZeroBigIntStrictFacts = Self::BaseBigIntStrictFacts.bits | Self::Falsy.bits;
        const ZeroBigIntFacts = Self::BaseBigIntFacts.bits;
        const NonZeroBigIntStrictFacts = Self::BaseBigIntStrictFacts.bits | Self::Truthy.bits;
        const NonZeroBigIntFacts = Self::BaseBigIntFacts.bits | Self::Truthy.bits;
        const BaseBooleanStrictFacts = Self::TypeofEQBoolean.bits | Self::TypeofNEString.bits | Self::TypeofNENumber.bits | Self::TypeofNEBigInt.bits | Self::TypeofNESymbol.bits | Self::TypeofNEObject.bits | Self::TypeofNEFunction.bits | Self::TypeofNEHostObject.bits | Self::NEUndefined.bits | Self::NENull.bits | Self::NEUndefinedOrNull.bits;
        const BaseBooleanFacts = Self::BaseBooleanStrictFacts.bits | Self::EQUndefined.bits | Self::EQNull.bits | Self::EQUndefinedOrNull.bits | Self::Falsy.bits;
        const BooleanStrictFacts = Self::BaseBooleanStrictFacts.bits | Self::Truthy.bits | Self::Falsy.bits;
        const BooleanFacts = Self::BaseBooleanFacts.bits | Self::Truthy.bits;
        const FalseStrictFacts = Self::BaseBooleanStrictFacts.bits | Self::Falsy.bits;
        const FalseFacts = Self::BaseBooleanFacts.bits;
        const TrueStrictFacts = Self::BaseBooleanStrictFacts.bits | Self::Truthy.bits;
        const TrueFacts = Self::BaseBooleanFacts.bits | Self::Truthy.bits;
        const SymbolStrictFacts = Self::TypeofEQSymbol.bits | Self::TypeofNEString.bits | Self::TypeofNENumber.bits | Self::TypeofNEBigInt.bits | Self::TypeofNEBoolean.bits | Self::TypeofNEObject.bits | Self::TypeofNEFunction.bits | Self::TypeofNEHostObject.bits | Self::NEUndefined.bits | Self::NENull.bits | Self::NEUndefinedOrNull.bits | Self::Truthy.bits;
        const SymbolFacts = Self::SymbolStrictFacts.bits | Self::EQUndefined.bits | Self::EQNull.bits | Self::EQUndefinedOrNull.bits | Self::Falsy.bits;
        const ObjectStrictFacts = Self::TypeofEQObject.bits | Self::TypeofEQHostObject.bits | Self::TypeofNEString.bits | Self::TypeofNENumber.bits | Self::TypeofNEBigInt.bits | Self::TypeofNEBoolean.bits | Self::TypeofNESymbol.bits | Self::TypeofNEFunction.bits | Self::NEUndefined.bits | Self::NENull.bits | Self::NEUndefinedOrNull.bits | Self::Truthy.bits;
        const ObjectFacts = Self::ObjectStrictFacts.bits | Self::EQUndefined.bits | Self::EQNull.bits | Self::EQUndefinedOrNull.bits | Self::Falsy.bits;
        const FunctionStrictFacts = Self::TypeofEQFunction.bits | Self::TypeofEQHostObject.bits | Self::TypeofNEString.bits | Self::TypeofNENumber.bits | Self::TypeofNEBigInt.bits | Self::TypeofNEBoolean.bits | Self::TypeofNESymbol.bits | Self::TypeofNEObject.bits | Self::NEUndefined.bits | Self::NENull.bits | Self::NEUndefinedOrNull.bits | Self::Truthy.bits;
        const FunctionFacts = Self::FunctionStrictFacts.bits | Self::EQUndefined.bits | Self::EQNull.bits | Self::EQUndefinedOrNull.bits | Self::Falsy.bits;
        const UndefinedFacts = Self::TypeofNEString.bits | Self::TypeofNENumber.bits | Self::TypeofNEBigInt.bits | Self::TypeofNEBoolean.bits | Self::TypeofNESymbol.bits | Self::TypeofNEObject.bits | Self::TypeofNEFunction.bits | Self::TypeofNEHostObject.bits | Self::EQUndefined.bits | Self::EQUndefinedOrNull.bits | Self::NENull.bits | Self::Falsy.bits;
        const NullFacts = Self::TypeofEQObject.bits | Self::TypeofNEString.bits | Self::TypeofNENumber.bits | Self::TypeofNEBigInt.bits | Self::TypeofNEBoolean.bits | Self::TypeofNESymbol.bits | Self::TypeofNEFunction.bits | Self::TypeofNEHostObject.bits | Self::EQNull.bits | Self::EQUndefinedOrNull.bits | Self::NEUndefined.bits | Self::Falsy.bits;
        const EmptyObjectStrictFacts = Self::All.bits & !(Self::EQUndefined.bits | Self::EQNull.bits | Self::EQUndefinedOrNull.bits);
        const AllTypeofNE = Self::TypeofNEString.bits | Self::TypeofNENumber.bits | Self::TypeofNEBigInt.bits | Self::TypeofNEBoolean.bits | Self::TypeofNESymbol.bits | Self::TypeofNEObject.bits | Self::TypeofNEFunction.bits | Self::NEUndefined.bits;
        const EmptyObjectFacts = Self::All.bits;
    }
}

// const typeofEQFacts: ReadonlyESMap<string, TypeFacts> = new Map(getEntries({
//     string: TypeFacts.TypeofEQString,
//     number: TypeFacts.TypeofEQNumber,
//     bigint: TypeFacts.TypeofEQBigInt,
//     boolean: TypeFacts.TypeofEQBoolean,
//     symbol: TypeFacts.TypeofEQSymbol,
//     undefined: TypeFacts.EQUndefined,
//     object: TypeFacts.TypeofEQObject,
//     function: TypeFacts.TypeofEQFunction
// }));

// const typeofNEFacts: ReadonlyESMap<string, TypeFacts> = new Map(getEntries({
//     string: TypeFacts.TypeofNEString,
//     number: TypeFacts.TypeofNENumber,
//     bigint: TypeFacts.TypeofNEBigInt,
//     boolean: TypeFacts.TypeofNEBoolean,
//     symbol: TypeFacts.TypeofNESymbol,
//     undefined: TypeFacts.NEUndefined,
//     object: TypeFacts.TypeofNEObject,
//     function: TypeFacts.TypeofNEFunction
// }));

#[derive(PartialEq, Eq, Clone)]
enum TypeSystemEntity {
    Node(BoundNode),
    Symbol(SymbolId),
    Type(TypeId),
    Signature(SignatureId),
}

#[derive(PartialEq, Eq, Copy, Clone)]
enum TypeSystemPropertyName {
    Type,
    ResolvedBaseConstructorType,
    DeclaredType,
    ResolvedReturnType,
    ImmediateBaseConstraint,
    EnumTagType,
    ResolvedTypeArguments,
    ResolvedBaseTypes,
}

bitflags! {
    #[derive(Default)]
    pub struct CheckMode: u8 {
        const Normal = 0;                     // Normal type checking
        const Contextual = 1 << 0;            // Explicitly assigned contextual type, therefore not cacheable
        const Inferential = 1 << 1;           // Inferential typing
        const SkipContextSensitive = 1 << 2;  // Skip context sensitive function expressions
        const SkipGenericFunctions = 1 << 3;  // Skip single signature generic functions
        const IsForSignatureHelp = 1 << 4;    // Call resolution for purposes of signature help
    }
}

// const enum SignatureCheckMode {
//     BivariantCallback = 1 << 0,
//     StrictCallback    = 1 << 1,
//     IgnoreReturnTypes = 1 << 2,
//     StrictArity       = 1 << 3,
//     Callback          = BivariantCallback | StrictCallback,
// }

// const enum IntersectionState {
//     None = 0,
//     Source = 1 << 0,
//     Target = 1 << 1,
//     PropertyCheck = 1 << 2,
//     UnionIntersectionCheck = 1 << 3,
//     InPropertyCheck = 1 << 4,
// }

// const enum RecursionFlags {
//     None = 0,
//     Source = 1 << 0,
//     Target = 1 << 1,
//     Both = Source | Target,
// }

// const enum MappedTypeModifiers {
//     IncludeReadonly = 1 << 0,
//     ExcludeReadonly = 1 << 1,
//     IncludeOptional = 1 << 2,
//     ExcludeOptional = 1 << 3,
// }

bitflags! {
    struct ExpandingFlags: u8 {
        const None = 0;
        const Source = 1;
        const Target = 1 << 1;
        const Both = Self::Source.bits | Self::Target.bits;
    }
}

#[derive(PartialEq, Eq)]
enum MembersOrExportsResolutionKind {
    ResolvedExports,
    ResolvedMembers,
}

bitflags! {
    #[derive(Default)]
    pub struct MinArgumentCountFlags: u8 {
        const None = 0;
        const StrongArityForUntypedJS = 1 << 0;
        const VoidIsNonOptional = 1 << 1;
    }
}

fn addToSymbolTable(
    target: &mut SymbolTable,
    source: &SymbolTable,
    // message: DiagnosticMessage,
) {
    for (id, sourceSymbol) in source.iter() {
        match target.entry(id.clone()) {
            Entry::Occupied(existing) => {
                // Error on redeclarations
                todo!("Error on redeclarations");
                // forEach(
                //     targetSymbol.declarations,
                //     addDeclarationDiagnostic(unescapeLeadingUnderscores(id), message),
                // );
            }
            Entry::Vacant(slot) => {
                slot.insert(*sourceSymbol);
            }
        }
    }

    // fn addDeclarationDiagnostic(id: string, message: DiagnosticMessage) {
    //     return (declaration: Declaration) => diagnostics.add(createDiagnosticForNode(declaration, message, id));
    // }
}

fn getExcludedSymbolFlags(flags: SymbolFlags) -> SymbolFlags {
    let mut result = SymbolFlags::empty();
    if flags.intersects(SymbolFlags::BlockScopedVariable) {
        result |= SymbolFlags::BlockScopedVariableExcludes
    }
    if flags.intersects(SymbolFlags::FunctionScopedVariable) {
        result |= SymbolFlags::FunctionScopedVariableExcludes
    }
    if flags.intersects(SymbolFlags::Property) {
        result |= SymbolFlags::PropertyExcludes
    }
    if flags.intersects(SymbolFlags::EnumMember) {
        result |= SymbolFlags::EnumMemberExcludes
    }
    if flags.intersects(SymbolFlags::Function) {
        result |= SymbolFlags::FunctionExcludes
    }
    if flags.intersects(SymbolFlags::Class) {
        result |= SymbolFlags::ClassExcludes
    }
    if flags.intersects(SymbolFlags::Interface) {
        result |= SymbolFlags::InterfaceExcludes
    }
    if flags.intersects(SymbolFlags::RegularEnum) {
        result |= SymbolFlags::RegularEnumExcludes
    }
    if flags.intersects(SymbolFlags::ConstEnum) {
        result |= SymbolFlags::ConstEnumExcludes
    }
    if flags.intersects(SymbolFlags::ValueModule) {
        result |= SymbolFlags::ValueModuleExcludes
    }
    if flags.intersects(SymbolFlags::Method) {
        result |= SymbolFlags::MethodExcludes
    }
    if flags.intersects(SymbolFlags::GetAccessor) {
        result |= SymbolFlags::GetAccessorExcludes
    }
    if flags.intersects(SymbolFlags::SetAccessor) {
        result |= SymbolFlags::SetAccessorExcludes
    }
    if flags.intersects(SymbolFlags::TypeParameter) {
        result |= SymbolFlags::TypeParameterExcludes
    }
    if flags.intersects(SymbolFlags::TypeAlias) {
        result |= SymbolFlags::TypeAliasExcludes
    }
    if flags.intersects(SymbolFlags::Alias) {
        result |= SymbolFlags::AliasExcludes
    }
    result
}

fn getIsDeferredContext(location: &BoundNode, lastLocation: &Option<BoundNode>) -> bool {
    match location {
        BoundNode::ArrowExpr(location_node) => {
            // async functions are not inlined in control flow when immediately invoked
            if location_node.is_async {
                return true;
            }
            getImmediatelyInvokedFunctionExpression(location.clone()).is_none()
        }
        BoundNode::FnExpr(location_node) => {
            if lastLocation.is_some() {
                let fn_name = location_node
                    .ident
                    .as_ref()
                    .map(|i| i.bind(location.clone()));
                if lastLocation == &fn_name {
                    return false;
                }
            }
            // generator functions and async functions are not inlined in control flow when immediately invoked
            if location_node.function.is_generator || location_node.function.is_async {
                return true;
            }
            getImmediatelyInvokedFunctionExpression(location.clone()).is_none()
        }
        BoundNode::TsTypeQuery(_) => true,
        _ => {
            // initializers in instance property declaration of class like entities are executed in constructor and thus deferred
            let name = match location {
                BoundNode::FnDecl(n) => n.ident.bind(location.clone()),
                BoundNode::PrivateMethod(n) => n.key.bind(location.clone()),
                BoundNode::ClassMethod(n) => n.key.bind(location.clone()),
                BoundNode::MethodProp(n) => n.key.bind(location.clone()),
                BoundNode::GetterProp(n) => n.key.bind(location.clone()),
                BoundNode::SetterProp(n) => n.key.bind(location.clone()),
                BoundNode::ClassProp(n) if !n.is_static => n.key.bind(location.clone()),
                BoundNode::PrivateProp(n) if !n.is_static => n.key.bind(location.clone()),
                _ => return false,
            };
            // A name is evaluated within the enclosing scope - so it shouldn't count as deferred
            if let Some(last_location) = lastLocation {
                last_location != &name
            } else {
                true
            }
        }
    }
}

fn isSelfReferenceLocation(node: BoundNode) -> bool {
    matches!(
        node,
        BoundNode::FnDecl(_)
            | BoundNode::ClassDecl(_)
            | BoundNode::TsInterfaceDecl(_)
            | BoundNode::TsEnumDecl(_)
            | BoundNode::TsTypeAliasDecl(_)
            | BoundNode::TsModuleDecl(_) // For `namespace N { N; }`
    )
}

fn findConstructorDeclaration(node: &BoundNode) -> Option<BoundNode> {
    let members = match &node {
        BoundNode::Class(c) => &c.body,
        _ => unreachable!(),
    };

    for member in members {
        if let ast::ClassMember::Constructor(constructor) = member {
            if constructor.body.is_some() {
                return Some(constructor.bind(node.clone()));
            }
        }
    }

    None
}

// TODO: comment:
/// Like 'isDeclarationName', but returns true for LHS of `import { x as y }` or `export { x as y }`.
fn isDeclarationNameOrImportPropertyName(name: BoundNode) -> bool {
    match name.parent() {
        // TODO: import/export
        // Some(BoundNode::ImportSpecifier(_) | BoundNode::ExportSpecifier(_)) => {
        //     matches!(name, BoundNode::Ident(_))
        // }
        _ => isDeclarationName(name),
    }
}

fn isInParameterInitializerBeforeContainingFunction(mut node: BoundNode) -> bool {
    let mut inBindingInitializer = false;
    while let Some(parent) = node.parent() {
        if isFunctionLike(Some(&parent)) {
            break;
        }

        if matches!(
            parent,
            BoundNode::Param(_)
                | BoundNode::ParamWithoutDecorators(_)
                | BoundNode::TsAmbientParam(_)
                | BoundNode::TsParamProp(_)
        ) {
            if inBindingInitializer {
                return true;
            }
            match &parent {
                BoundNode::Param(n) => {
                    if let ast::Pat::Assign(p) = &n.pat {
                        if p.right.bind(p.bind(parent.clone())) == node {
                            return true;
                        }
                    }
                }
                BoundNode::ParamWithoutDecorators(n) => {
                    if let ast::Pat::Assign(p) = &n.pat {
                        if p.right.bind(p.bind(parent.clone())) == node {
                            return true;
                        }
                    }
                }
                BoundNode::TsParamProp(n) => {
                    if let ast::TsParamPropParam::Assign(p) = &n.param {
                        if p.right.bind(p.bind(parent.clone())) == node {
                            return true;
                        }
                    }
                }
                _ => {}
            }
        }
        if let BoundNode::AssignPat(p) = &parent {
            if p.right.bind(parent.clone()) == node {
                inBindingInitializer = true;
            }
        } else if let BoundNode::AssignPatProp(p) = &parent {
            if p.value.as_ref().map(|v| v.bind(parent.clone())) == Some(node) {
                inBindingInitializer = true;
            }
        }

        node = parent;
    }
    false
}

// Returns true if the given expression contains (at any level of nesting) a function or arrow expression
// that is subject to contextual typing.
fn isContextSensitive(node: &Node) -> bool {
    // TODO:
    // Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || isObjectLiteralMethod(node));
    match node {
        Node::FnExpr(_)
        | Node::ArrowExpr(_)
        | Node::PrivateMethod(_)
        | Node::ClassMethod(_)
        | Node::MethodProp(_)
        | Node::FnDecl(_) => {
            // Function declarations can have context when annotated with a jsdoc @type
            isContextSensitiveFunctionLikeDeclaration(node)
        }
        Node::ObjectLit(n) => n
            .props
            .iter()
            .any(|p| isContextSensitive(&p.clone().into())),
        Node::ArrayLit(n) => n
            .elems
            .iter()
            .filter_map(|e| e.as_ref())
            .any(|e| isContextSensitive(&e.clone().into())),
        Node::CondExpr(n) => {
            isContextSensitive(&n.cons.clone().into()) || isContextSensitive(&n.alt.clone().into())
        }
        Node::BinExpr(n) => {
            (n.op == ast::BinaryOp::LogicalOr || n.op == ast::BinaryOp::NullishCoalescing)
                && (isContextSensitive(&n.left.clone().into())
                    || isContextSensitive(&n.right.clone().into()))
        }
        Node::KeyValueProp(n) => isContextSensitive(&n.value.clone().into()),
        Node::ParenExpr(n) => isContextSensitive(&n.expr.clone().into()),
        // TODO: Jsx
        // Node::JsxAttributes(_) => {
        //     // some((node as JsxAttributes).properties, isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, isContextSensitive)
        // }
        // Node::JsxAttribute(_) => {
        //     // // If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.
        //     // const { initializer } = node as JsxAttribute;
        //     // !!initializer && isContextSensitive(initializer)
        // }
        // Node::JsxExpression(_) => {
        //     // // It is possible to that node.expression is undefined (e.g <div x={} />)
        //     // const { expression } = node as JsxExpression;
        //     // !!expression && isContextSensitive(expression)
        // }
        _ => false,
    }
}

fn isContextSensitiveFunctionLikeDeclaration(node: &Node) -> bool {
    // TODO: jsdoc:
    // (!matches!(node, BoundNode::FnDecl(_))
    //     || isBoundNodeInJSFile(&node) && !!getTypeForDeclarationFromJSDocComment(node))
    //     && (self.hasContextSensitiveParameters(node)
    //         || self.hasContextSensitiveReturnExpression(node))
    !matches!(node, Node::FnDecl(_))
        && (hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node))
}

fn hasContextSensitiveReturnExpression(node: &Node) -> bool {
    let n = match node {
        Node::ArrowExpr(n) => n,
        _ => return false,
    };
    // TODO(anhans): A block should be context-sensitive if it has a context-sensitive return value.
    n.type_params.is_none()
        && getEffectiveReturnTypeNode(&node.clone()).is_none()
        && matches!(n.body, ast::BlockStmtOrExpr::Expr(_))
        && isContextSensitive(&n.body.clone().into())
}

fn isContextSensitiveFunctionOrObjectLiteralMethod(func: &Node) -> bool {
    (isNodeInJSFile(&func) && matches!(func, Node::FnDecl(_))
        || matches!(
            func,
            Node::FnExpr(_) | Node::ArrowExpr(_) | Node::MethodProp(_)
        ))
        && isContextSensitiveFunctionLikeDeclaration(func)
}

pub struct NodeBuilderContext {
    enclosingDeclaration: Option<BoundNode>,
    flags: NodeBuilderFlags,
    // tracker: SymbolTracker;

    // // State
    // encounteredError: boolean;
    // reportedDiagnostic: boolean;
    // visitedTypes: Set<number> | undefined;
    // symbolDepth: ESMap<string, number> | undefined;
    // inferTypeParameters: TypeParameter[] | undefined;
    // approximateLength: number;
    // truncating?: boolean;
    // typeParameterSymbolList?: Set<number>;
    // typeParameterNames?: ESMap<TypeId, Identifier>;
    // typeParameterNamesByText?: Set<string>;
    // typeParameterNamesByTextNextNameCount?: ESMap<string, number>;
    // usedSymbolNames?: Set<string>;
    // remappedSymbolNames?: ESMap<SymbolId, string>;
    // reverseMappedStack?: ReverseMappedSymbol[];
}

fn isDefaultBindingContext(location: &BoundNode) -> bool {
    matches!(location, BoundNode::Script(_) | BoundNode::Module(_)) || isAmbientModule(&location)
}

fn isGlobalSourceFile(node: &BoundNode) -> bool {
    matches!(node, BoundNode::Script(_) | BoundNode::Module(_)) && !isExternalOrCommonJsModule(node)
}

fn getQualifiedLeftMeaning(rightMeaning: SymbolFlags) -> SymbolFlags {
    // If we are looking in value space, the parent meaning is value, other wise it is namespace
    if rightMeaning == SymbolFlags::Value {
        SymbolFlags::Value
    } else {
        SymbolFlags::Namespace
    }
}

fn hasNonGlobalAugmentationExternalModuleSymbol(declaration: &BoundNode) -> bool {
    if isModuleWithStringLiteralName(declaration) {
        true
    } else if matches!(declaration, BoundNode::Script(_) | BoundNode::Module(_)) {
        isExternalOrCommonJsModule(declaration)
    } else {
        false
    }
}

// True if the given identifier is part of a type reference
fn isTypeReferenceIdentifier(mut node: BoundNode) -> bool {
    while let Some(p @ BoundNode::TsQualifiedName(_)) = node.parent() {
        node = p;
    }

    matches!(node.parent(), Some(BoundNode::TsTypeRef(_)))
}

fn getReferenceRoot(node: BoundNode) -> BoundNode {
    if let Some(parent) = node.parent() {
        match &parent {
            BoundNode::ParenExpr(_) => return getReferenceRoot(parent),
            BoundNode::AssignExpr(a) if a.left.bind(parent.clone()) == node => {
                return getReferenceRoot(parent)
            }
            BoundNode::SeqExpr(s)
                if s.exprs.last().map(|e| e.bind(parent.clone())).as_ref() == Some(&node) =>
            {
                return getReferenceRoot(parent)
            }
            _ => {}
        }
    }
    node
}

fn isMethodAccessForCall(mut node: BoundNode) -> bool {
    while let Some(parent @ BoundNode::ParenExpr(_)) = node.parent() {
        node = parent;
    }
    match &node.parent() {
        Some(parent @ BoundNode::CallExpr(c)) => c.callee.bind(parent.clone()) == node,
        Some(parent @ BoundNode::NewExpr(n)) => n.callee.bind(parent.clone()) == node,
        _ => false,
    }
}

/**
 * A type is free of this references if it's the any, string, number, boolean, symbol, or void keyword, a string
 * literal type, an array with an element type that is free of this references, or a type reference that is
 * free of this references.
 */
fn isThislessType(node: &Node) -> bool {
    match node {
        Node::TsKeywordType(k) => match k.kind {
            ast::TsKeywordTypeKind::TsAnyKeyword
            | ast::TsKeywordTypeKind::TsUnknownKeyword
            | ast::TsKeywordTypeKind::TsStringKeyword
            | ast::TsKeywordTypeKind::TsNumberKeyword
            | ast::TsKeywordTypeKind::TsBigIntKeyword
            | ast::TsKeywordTypeKind::TsBooleanKeyword
            | ast::TsKeywordTypeKind::TsSymbolKeyword
            | ast::TsKeywordTypeKind::TsObjectKeyword
            | ast::TsKeywordTypeKind::TsVoidKeyword
            | ast::TsKeywordTypeKind::TsUndefinedKeyword
            | ast::TsKeywordTypeKind::TsNeverKeyword => true,
            _ => false,
        },
        Node::TsLitType(_) => true,
        Node::TsArrayType(t) => isThislessType(&t.elem_type.clone().into()),
        Node::TsTypeRef(t) => t
            .type_params
            .as_ref()
            .map(|p| p.params.iter().all(|t| isThislessType(&t.clone().into())))
            .unwrap_or(true),
        _ => false,
    }
}

/** A type parameter is thisless if its constraint is thisless, or if it has no constraint. */
fn isThislessTypeParameter(node: &ast::TsTypeParamDecl) -> bool {
    let constraint = getEffectiveConstraintOfTypeParameter(node);
    constraint
        .map(|c| isThislessType(&c.clone().into()))
        .unwrap_or_default()
}

/**
 * A variable-like declaration is free of this references if it has a type annotation
 * that is thisless, or if it has no type annotation and no initializer (and is thus of type any).
 */
fn isThislessVariableLikeDeclaration(node: &Node) -> bool {
    let typeNode = getEffectiveTypeAnnotationNode(node);
    if let Some(typeNode) = typeNode {
        isThislessType(&typeNode.into())
    } else {
        !hasInitializer(node)
    }
}

/**
 * A function-like declaration is considered free of `this` references if it has a return type
 * annotation that is free of this references and if each parameter is thisless and if
 * each type parameter (if present) is thisless.
 */
fn isThislessFunctionLikeDeclaration(node: &Node) -> bool {
    let returnType = getEffectiveReturnTypeNode(node);
    if matches!(node, Node::Constructor(_))
        || (returnType.is_some() && isThislessType(&returnType.unwrap().into()))
    {
        let params_are_thisless = match node {
            Node::PrivateMethod(n) => n
                .function
                .params
                .iter()
                .all(|p| isThislessVariableLikeDeclaration(&p.clone().into())),
            Node::ClassMethod(n) => n
                .function
                .params
                .iter()
                .all(|p| isThislessVariableLikeDeclaration(&p.clone().into())),
            Node::MethodProp(n) => n
                .function
                .params
                .iter()
                .all(|p| isThislessVariableLikeDeclaration(&p.clone().into())),
            Node::TsMethodSignature(n) => n
                .params
                .iter()
                .all(|p| isThislessVariableLikeDeclaration(&p.clone().into())),
            Node::Constructor(n) => n
                .params
                .iter()
                .all(|p| isThislessVariableLikeDeclaration(&p.clone().into())),
            Node::SetterProp(n) => isThislessVariableLikeDeclaration(&n.param.clone().into()),
            Node::TsSetterSignature(n) => {
                isThislessVariableLikeDeclaration(&n.param.clone().into())
            }
            _ => true,
        };
        let mut typeParameters = getEffectiveTypeParameterDeclarations(node)
            .into_iter()
            .flatten();
        return params_are_thisless && typeParameters.all(|p| isThislessTypeParameter(&p));
    }
    false
}

fn isReadonlyTypeOperator(node: &BoundNode) -> bool {
    if let BoundNode::TsTypeOperator(t) = node {
        t.op == ast::TsTypeOperatorOp::ReadOnly
    } else {
        false
    }
}

fn getControlFlowContainer(node: &BoundNode) -> BoundNode {
    findAncestor(node.parent(), |node| {
        Some(
            isFunctionLike(Some(node))
                && getImmediatelyInvokedFunctionExpression(node.clone()).is_none()
                || matches!(
                    node,
                    BoundNode::TsModuleBlock(_)
                        | BoundNode::Script(_)
                        | BoundNode::Module(_)
                        | BoundNode::ClassProp(_)
                        | BoundNode::PrivateProp(_)
                ),
        )
    })
    .unwrap()
}

fn isDuplicatedCommonJSExport(declarations: &Vec<BoundNode>) -> bool {
    // TODO: commonjs
    false
    // declarations.iter().all(|d|isBoundNodeInJSFile(&d) && isAccessExpression(d) && (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression)))
}

fn isLateBoundName(name: &JsWord) -> bool {
    name.starts_with("__@")
}

fn getTupleElementFlags(node: &Rc<ast::TsTupleElement>, parent: &BoundNode) -> ElementFlags {
    match &node.ty {
        ast::TsType::TsOptionalType(t) => ElementFlags::Optional,
        ast::TsType::TsRestType(t) => {
            if getArrayElementTypeNode(&t.type_ann.bind(node.ty.bind(node.bind(parent.clone()))))
                .is_some()
            {
                ElementFlags::Rest
            } else {
                ElementFlags::Variadic
            }
        }
        _ => ElementFlags::Required,
    }
}

// Return true when the given node is transitively contained in type constructs that eagerly
// resolve their constituent types. We include SyntaxKind.TypeReference because type arguments
// of type aliases are eagerly resolved.
fn isResolvedByTypeAlias(node: &BoundNode) -> bool {
    let parent = node.parent();
    if let Some(parent) = parent {
        return match parent {
            BoundNode::TsParenthesizedType(_)
            | BoundNode::TsTypeRef(_)
            | BoundNode::TsUnionType(_)
            | BoundNode::TsIntersectionType(_)
            | BoundNode::TsIndexedAccessType(_)
            | BoundNode::TsConditionalType(_)
            | BoundNode::TsTypeOperator(_)
            | BoundNode::TsArrayType(_)
            | BoundNode::TsTupleType(_) => isResolvedByTypeAlias(&parent),
            BoundNode::TsTypeAliasDecl(_) => true,
            _ => false,
        };
    }
    false
}

fn getArrayElementTypeNode(node: &BoundNode) -> Option<BoundNode> {
    match node {
        BoundNode::TsParenthesizedType(n) => {
            return getArrayElementTypeNode(&n.type_ann.bind(node.clone()));
        }
        BoundNode::TsTupleType(n) => {
            if n.elem_types.len() == 1 {
                let elem = &n.elem_types[0];
                if let ast::TsType::TsRestType(rest) = &elem.ty {
                    return getArrayElementTypeNode(&rest.type_ann.bind(rest.bind(node.clone())));
                }
            }
        }
        BoundNode::TsArrayType(n) => {
            return Some(n.elem_type.bind(node.clone()));
        }
        _ => {}
    }
    None
}

fn getTypeReferenceName(node: &BoundNode) -> Option<BoundNode> {
    match node {
        BoundNode::TsTypeRef(t) => {
            return Some(t.type_name.bind(node.clone()));
        }
        BoundNode::TsExprWithTypeArgs(e) => {
            // We only support expressions that are simple qualified names.
            // TODO: this should never fail, as our definition of TsExprWithTypeArgs
            // can only contain an EntityNameExpression for its `expr`.
            debug_assert!(isEntityNameExpression(&e.expr.clone().into()));
            return Some(e.expr.bind(node.clone()));
        }
        _ => {}
    }

    None
}

fn maybeTypeParameterReference(node: &BoundNode) -> bool {
    !(matches!(&node.parent(), Some(p@BoundNode::TsTypeRef(r)) if r.type_params.is_some() && node == &r.type_name.bind(p.clone()))
        || matches!(&node.parent(), Some(p@BoundNode::TsImportType(t)) if t.type_args.is_some() && Some(node) == t.qualifier.as_ref().map(|q|q.bind(p.clone())).as_ref()))
}

fn isSpreadArgument(arg: &BoundNode) -> bool {
    // return !!arg && (arg.kind === SyntaxKind.SpreadElement || arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).isSpread);
    matches!(arg, BoundNode::SpreadElement(e))
}

fn getSpreadArgumentIndex(args: &Vec<BoundNode>) -> Option<usize> {
    args.iter().position(isSpreadArgument)
}

fn hasInferenceCandidates(info: &InferenceInfo) -> bool {
    info.candidates.is_some() || info.contraCandidates.is_some()
}

trait AsInferenceInfos<'a, 'b>
where
    'a: 'b,
{
    fn as_slice_of_inference_infos(self, checker: &'a mut Checker) -> &'b mut [InferenceInfo];
}

impl<'a, 'b> AsInferenceInfos<'a, 'b> for InferenceContextId
where
    'a: 'b,
{
    fn as_slice_of_inference_infos(self, checker: &'a mut Checker) -> &'a mut [InferenceInfo] {
        &mut checker.inference_contexts[self].inferences
    }
}

impl<'a, 'b> AsInferenceInfos<'a, 'b> for &'b mut [InferenceInfo]
where
    'a: 'b,
{
    fn as_slice_of_inference_infos(self, _checker: &'a mut Checker) -> &'b mut [InferenceInfo] {
        self
    }
}

enum InferenceContextOrId<'a> {
    InferenceContext(&'a mut InferenceContext),
    InferenceContextId(InferenceContextId),
}

fn getContextNode(node: BoundNode) -> BoundNode {
    // TODO: jsdoc:
    // if (node.kind == SyntaxKind.JsxAttributes && !isJsxSelfClosingElement(node.parent)) {
    //     return node.parent.parent; // Needs to be the root JsxElement, so it encompasses the attributes _and_ the children (which are essentially part of the attributes)
    // }
    node
}

#[derive(PartialEq, Eq, Hash, Clone, Copy)]
struct RecursionIdentity(u64);

#[derive(PartialEq, Eq, Hash, Clone, Copy)]
struct TupleTypeKey(u64);

#[derive(PartialEq, Eq, Hash, Clone, Copy)]
struct IntersectionTypeKey(u64);

#[derive(PartialEq, Eq, Hash, Clone, Copy)]
struct SubstitutionTypeKey(u64);

impl SubstitutionTypeKey {
    pub fn new(base_type: TypeId, substitute: TypeId) -> Self {
        // TODO: it may not be necessary to hash '>':
        Self(hash![base_type, '>', substitute])
    }
}

#[derive(PartialEq, Eq, Hash, Clone, Copy)]
struct UnionTypeKey(u64);

fn typePredicateKindsMatch(a: &TypePredicate, b: &TypePredicate) -> bool {
    mem::discriminant(a) == mem::discriminant(b) && a.parameterIndex() == b.parameterIndex()
}

fn mayReturnNever(func: &BoundNode) -> bool {
    matches!(
        func,
        BoundNode::MethodProp(_) | BoundNode::FnExpr(_) | BoundNode::ArrowExpr(_)
    )
}

fn isDestructuringAssignmentTarget(parent: &BoundNode) -> bool {
    matches!(&parent.parent(), Some(grand_parent@BoundNode::AssignExpr(a)) if &a.left.bind(grand_parent.clone()) ==parent)
        || matches!(&parent.parent(), Some(grand_parent@BoundNode::ForOfStmt(s)) if &s.left.bind(grand_parent.clone()) ==parent)
}

/// `types` should be sorted
fn containsType(types: &[TypeId], ty: TypeId) -> bool {
    types.binary_search(&ty).is_ok()
}

enum IntrinsicTypeKind {
    Uppercase,
    Lowercase,
    Capitalize,
    Uncapitalize,
}

fn get_intrinsic_type_kind(name: &JsWord) -> Option<IntrinsicTypeKind> {
    if name == "Uppercase" {
        Some(IntrinsicTypeKind::Uppercase)
    } else if name == "Lowercase" {
        Some(IntrinsicTypeKind::Lowercase)
    } else if name == "Capitalize" {
        Some(IntrinsicTypeKind::Capitalize)
    } else if name == "Uncapitalize" {
        Some(IntrinsicTypeKind::Uncapitalize)
    } else {
        None
    }
}

/// `types` should be sorted
/// Returns `true` if the type was inserted.
fn insertType(types: &mut Vec<TypeId>, ty: TypeId) -> bool {
    match types.binary_search(&ty) {
        Ok(_) => false,
        Err(index) => {
            types.insert(index, ty);
            true
        }
    }
}

fn clearCachedInferences(inferences: &mut Vec<InferenceInfo>) {
    for inference in inferences {
        if !inference.isFixed {
            inference.inferredType = None;
        }
    }
}

fn createOriginType(flags: TypeFlags) -> TypeBase {
    TypeBase::new(flags, None)
}

fn isConstContext(node: &BoundNode) -> bool {
    if let Some(parent) = node.parent() {
        match parent {
            // TODO: jsdoc:
            // isJSDocTypeAssertion(parent) => isConstTypeReference(getJSDocTypeAssertionType(parent))
            BoundNode::TsTypeAssertion(n) => isConstTypeReference(&Node::from(n.type_ann.clone())),
            BoundNode::TsAsExpr(n) => isConstTypeReference(&Node::from(n.type_ann.clone())),
            BoundNode::ParenExpr(_) | BoundNode::ArrayLit(_) | BoundNode::SpreadElement(_) => {
                isConstContext(&parent)
            }
            BoundNode::Ident(i) if matches!(i.parent, Some(BoundNode::ObjectLit(_))) => {
                unreachable!("shorthand props are removed by normalization")
            }
            BoundNode::KeyValueProp(n) => isConstContext(n.parent.as_ref().unwrap()),
            BoundNode::TplElement(n) => isConstContext(n.parent.as_ref().unwrap()),
            _ => false,
        }
    } else {
        false
    }
}

fn isTypeAssertion(mut node: BoundNode) -> bool {
    // TODO: jsdoc
    // node = skipParenthesesOfNode(node, /*excludeJSDocTypeAssertions*/ true);
    // return node.kind === SyntaxKind.TypeAssertionExpression ||
    //     node.kind === SyntaxKind.AsExpression ||
    //     isJSDocTypeAssertion(node);
    node = skipParenthesesOfNode(node);
    matches!(node, BoundNode::TsTypeAssertion(_) | BoundNode::TsAsExpr(_))
}

fn isInConstructorArgumentInitializer(node: BoundNode, constructorDecl: &BoundNode) -> bool {
    findAncestor(Some(node), |n| {
        if isFunctionLikeDeclaration(n) {
            None
        } else {
            Some(
                matches!(
                    n,
                    BoundNode::Param(_)
                        | BoundNode::ParamWithoutDecorators(_)
                        | BoundNode::TsAmbientParam(_)
                        | BoundNode::TsParamProp(_)
                ) && n.parent().as_ref() == Some(constructorDecl),
            )
        }
    })
    .is_some()
}

fn isDeclarationWithExplicitTypeAnnotation(node: &Node) -> bool {
    matches!(
        node,
        Node::VarDeclarator(_)
            | Node::KeyValueProp(_)
            | Node::TsPropertySignature(_)
            | Node::Param(_)
            | Node::ParamWithoutDecorators(_)
            | Node::TsAmbientParam(_)
            | Node::TsParamProp(_)
    ) && (getEffectiveTypeAnnotationNode(node).is_some()
        || isNodeInJSFile(node)
            && if let Some(init) = getInitializer(node) {
                todo!();
                // isFunctionExpressionOrArrowFunction(init)
                //     && getEffectiveReturnTypeNode(&init).is_some()
            } else {
                false
            })
}

fn isInPropertyInitializerOrClassStaticBlock(node: Option<BoundNode>) -> bool {
    findAncestor(node, |node| {
        match node {
            BoundNode::ClassProp(_) | BoundNode::PrivateProp(_) => Some(true),
            // TODO: jsx
            // BoundNode::TemplateSpan(_)|
            // BoundNode::JsxExpression(_)|
            // BoundNode::JsxAttribute(_)|
            // BoundNode::JsxAttributes(_)|
            // BoundNode::JsxSpreadAttribute(_)|
            // BoundNode::JsxOpeningElement(_)|
            BoundNode::KeyValueProp(_)
            | BoundNode::PrivateMethod(_)
            | BoundNode::ClassMethod(_)
            | BoundNode::MethodProp(_)
            | BoundNode::GetterProp(_)
            | BoundNode::TsGetterSignature(_)
            | BoundNode::SetterProp(_)
            | BoundNode::TsSetterSignature(_)
            | BoundNode::SpreadAssignment(_)
            | BoundNode::ComputedPropName(_)
            | BoundNode::TsExprWithTypeArgs(_)
            | BoundNode::ExtendsClause(_) => Some(false),
            BoundNode::ArrowExpr(_) | BoundNode::ExprStmt(_) => {
                // if matches!(node.parent(), Some(BoundNode::BlockStmt(_))) {
                //     todo!("see below");
                // } else {
                //     None
                // }
                // TODO: class static blocks
                // if isBlock(node.parent) && isClassStaticBlockDeclaration(node.parent.parent) {Some(true)}else{None}
                None
            }
            _ => {
                if isExpressionNode(node) {
                    Some(false)
                } else {
                    None
                }
            }
        }
    })
    .is_some()
}

////////////////////////////////////////////////////////////////////////////////////////////////////
fn signatureHasRestParameter(s: &Signature) -> bool {
    s.flags.intersects(SignatureFlags::HasRestParameter)
}

fn signatureHasLiteralTypes(s: &Signature) -> bool {
    s.flags.intersects(SignatureFlags::HasLiteralTypes)
}
