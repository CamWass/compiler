use crate::{jsx::JSXText, CloneNode, GetNodeId, NodeId};
use ast_node::ast_node;
use atoms::JsWord;
use global_common::{integer_decode::integer_decode, EqIgnoreSpan, Span};
use num_bigint::BigInt as BigIntValue;
use std::{
    fmt::{self, Display, Formatter},
    hash::{Hash, Hasher},
};

#[ast_node]
#[derive(Eq, Hash, EqIgnoreSpan)]
pub enum Lit {
    Str(Str),

    Bool(Bool),

    Null(Null),

    Num(Number),

    BigInt(BigInt),

    Regex(Regex),

    JSXText(JSXText),
}

#[ast_node]
#[derive(Eq, Hash, EqIgnoreSpan)]
pub struct BigInt {
    pub node_id: NodeId,

    pub span: Span,
    pub value: BigIntValue,
}

#[cfg(feature = "arbitrary")]
impl arbitrary::Arbitrary for BigInt {
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        let span = u.arbitrary()?;
        let value = u.arbitrary::<usize>()?.into();

        Ok(Self { span, value })
    }
}

#[ast_node]
#[derive(Eq, Hash, EqIgnoreSpan)]
pub struct Str {
    pub node_id: NodeId,

    pub span: Span,

    pub value: JsWord,

    /// This includes line escape.
    pub has_escape: bool,

    pub kind: StrKind,
}

/// THis enum determines how string literal should be printed.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum StrKind {
    /// Span of string points to original source code, and codegen should use
    /// it.
    //
    /// **Note**: Giving wrong value to this field will result in invalid
    /// codegen.
    Normal {
        /// Does span of this string literal contains quote?
        ///
        /// True for string literals generated by parser, false for string
        /// literals generated by various passes.
        contains_quote: bool,
    },
    /// If the span of string does not point a string literal, mainly because
    /// this string is synthesized, this variant should be used.
    Synthesized,
}

impl CloneNode for StrKind {
    fn clone_node(&self, _: &mut crate::NodeIdGen) -> Self {
        *self
    }
}

/// Always returns true as this is not a data of a string literal.
impl EqIgnoreSpan for StrKind {
    fn eq_ignore_span(&self, _: &Self) -> bool {
        true
    }
}

impl Default for StrKind {
    fn default() -> Self {
        Self::Synthesized
    }
}

#[cfg(feature = "arbitrary")]
impl arbitrary::Arbitrary for Str {
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        let span = u.arbitrary()?;
        let value = u.arbitrary::<String>()?.into();

        Ok(Self {
            span,
            value,
            has_escape: false,
            kind: Default::default(),
        })
    }
}

impl Str {
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.value.is_empty()
    }
}

#[ast_node]
#[derive(Eq, Hash, EqIgnoreSpan)]
pub struct Bool {
    pub node_id: NodeId,

    pub span: Span,
    pub value: bool,
}

#[ast_node]
#[derive(Eq, Hash, EqIgnoreSpan)]
pub struct Null {
    pub node_id: NodeId,

    pub span: Span,
}

#[ast_node]
#[derive(Eq, Hash, EqIgnoreSpan)]
pub struct Regex {
    pub node_id: NodeId,

    pub span: Span,

    pub exp: JsWord,

    pub flags: JsWord,
}

#[cfg(feature = "arbitrary")]
impl arbitrary::Arbitrary for Regex {
    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
        let span = u.arbitrary()?;
        let exp = u.arbitrary::<String>()?.into();
        let flags = "".into(); // TODO

        Ok(Self { span, exp, flags })
    }
}

#[ast_node]
#[derive(EqIgnoreSpan)]
pub struct Number {
    pub node_id: NodeId,

    pub span: Span,
    /// **Note**: This should not be `NaN`. Use [crate::Ident] to represent NaN.
    ///
    /// If you store `NaN` in this field, a hash map will behave strangely.
    #[use_eq]
    pub value: f64,

    /// The exact, original representaion of this number, as it was in the input.
    /// `None` if this node was created synthetically (by a compiler pass).
    pub raw: Option<JsWord>,
}

impl Eq for Number {}

#[allow(clippy::derive_hash_xor_eq)]
impl Hash for Number {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.span.hash(state);
        integer_decode(self.value).hash(state);
    }
}

impl Display for Number {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        if self.value.is_infinite() {
            if self.value.is_sign_positive() {
                Display::fmt("Infinity", f)
            } else {
                Display::fmt("-Infinity", f)
            }
        } else {
            Display::fmt(&self.value, f)
        }
    }
}
