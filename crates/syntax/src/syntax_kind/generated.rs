//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    OpenBraceToken,
    CloseBraceToken,
    OpenParenToken,
    CloseParenToken,
    OpenBracketToken,
    CloseBracketToken,
    DotToken,
    DotDotDotToken,
    SemicolonToken,
    CommaToken,
    LessThanToken,
    GreaterThanToken,
    LessThanEqualsToken,
    GreaterThanEqualsToken,
    EqualsEqualsToken,
    ExclamationEqualsToken,
    EqualsEqualsEqualsToken,
    ExclamationEqualsEqualsToken,
    EqualsGreaterThanToken,
    PlusToken,
    MinusToken,
    AsteriskAsteriskToken,
    AsteriskToken,
    SlashToken,
    PercentToken,
    PlusPlusToken,
    MinusMinusToken,
    LessThanLessThanToken,
    LessThanSlashToken,
    GreaterThanGreaterThanToken,
    GreaterThanGreaterThanGreaterThanToken,
    AmpersandToken,
    BarToken,
    CaretToken,
    ExclamationToken,
    TildeToken,
    AmpersandAmpersandToken,
    BarBarToken,
    QuestionToken,
    QuestionQuestionToken,
    QuestionDotToken,
    ColonToken,
    EqualsToken,
    PlusEqualsToken,
    MinusEqualsToken,
    AsteriskEqualsToken,
    AsteriskAsteriskEqualsToken,
    SlashEqualsToken,
    PercentEqualsToken,
    LessThanLessThanEqualsToken,
    GreaterThanGreaterThanEqualsToken,
    GreaterThanGreaterThanGreaterThanEqualsToken,
    AmpersandEqualsToken,
    BarEqualsToken,
    CaretEqualsToken,
    BarBarEqualsToken,
    AmpersandAmpersandEqualsToken,
    QuestionQuestionEqualsToken,
    AtToken,
    HashToken,
    BacktickToken,
    AbstractKeyword,
    AnyKeyword,
    AsKeyword,
    AssertsKeyword,
    AssertKeyword,
    BigIntKeyword,
    BooleanKeyword,
    BreakKeyword,
    CaseKeyword,
    CatchKeyword,
    ClassKeyword,
    ContinueKeyword,
    ConstKeyword,
    ConstructorKeyword,
    DebuggerKeyword,
    DeclareKeyword,
    DefaultKeyword,
    DeleteKeyword,
    DoKeyword,
    ElseKeyword,
    EnumKeyword,
    ExportKeyword,
    ExtendsKeyword,
    FalseKeyword,
    FinallyKeyword,
    ForKeyword,
    FromKeyword,
    FunctionKeyword,
    GetKeyword,
    IfKeyword,
    ImplementsKeyword,
    ImportKeyword,
    InKeyword,
    InferKeyword,
    InstanceOfKeyword,
    InterfaceKeyword,
    IntrinsicKeyword,
    IsKeyword,
    KeyOfKeyword,
    LetKeyword,
    ModuleKeyword,
    NamespaceKeyword,
    NeverKeyword,
    NewKeyword,
    NullKeyword,
    NumberKeyword,
    ObjectKeyword,
    PackageKeyword,
    PrivateKeyword,
    ProtectedKeyword,
    PublicKeyword,
    OverrideKeyword,
    ReadonlyKeyword,
    RequireKeyword,
    GlobalKeyword,
    ReturnKeyword,
    SetKeyword,
    StaticKeyword,
    StringKeyword,
    SuperKeyword,
    SwitchKeyword,
    SymbolKeyword,
    ThisKeyword,
    ThrowKeyword,
    TrueKeyword,
    TryKeyword,
    TypeKeyword,
    TypeOfKeyword,
    UndefinedKeyword,
    UniqueKeyword,
    UnknownKeyword,
    VarKeyword,
    VoidKeyword,
    WhileKeyword,
    WithKeyword,
    YieldKeyword,
    AsyncKeyword,
    AwaitKeyword,
    OfKeyword,
    NumericLiteral,
    BigIntLiteral,
    StringLiteral,
    JsxText,
    JsxTextAllWhiteSpaces,
    RegularExpressionLiteral,
    NoSubstitutionTemplateLiteral,
    TemplateHead,
    TemplateMiddle,
    TemplateTail,
    Unknown,
    EndOfFileToken,
    SingleLineCommentTrivia,
    MultiLineCommentTrivia,
    NewLineTrivia,
    WhitespaceTrivia,
    ShebangTrivia,
    ConflictMarkerTrivia,
    Identifier,
    PrivateIdentifier,
    QualifiedName,
    ComputedPropertyName,
    TypeParameter,
    Parameter,
    Decorator,
    PropertySignature,
    PropertyDeclaration,
    MethodSignature,
    MethodDeclaration,
    ClassStaticBlockDeclaration,
    Constructor,
    GetAccessor,
    SetAccessor,
    CallSignature,
    ConstructSignature,
    IndexSignature,
    TypePredicate,
    TypeReference,
    FunctionType,
    ConstructorType,
    TypeQuery,
    TypeLiteral,
    ArrayType,
    TupleType,
    OptionalType,
    RestType,
    UnionType,
    IntersectionType,
    ConditionalType,
    InferType,
    ParenthesizedType,
    ThisType,
    TypeOperator,
    IndexedAccessType,
    MappedType,
    LiteralType,
    NamedTupleMember,
    TemplateLiteralType,
    TemplateLiteralTypeSpan,
    ImportType,
    ObjectBindingPattern,
    ArrayBindingPattern,
    BindingElement,
    ArrayLiteralExpression,
    ObjectLiteralExpression,
    PropertyAccessExpression,
    ElementAccessExpression,
    CallExpression,
    NewExpression,
    TaggedTemplateExpression,
    TypeAssertionExpression,
    ParenthesizedExpression,
    FunctionExpression,
    ArrowFunction,
    DeleteExpression,
    TypeOfExpression,
    VoidExpression,
    AwaitExpression,
    PrefixUnaryExpression,
    PostfixUnaryExpression,
    BinaryExpression,
    ConditionalExpression,
    TemplateExpression,
    YieldExpression,
    SpreadElement,
    ClassExpression,
    OmittedExpression,
    ExpressionWithTypeArguments,
    AsExpression,
    NonNullExpression,
    MetaProperty,
    SyntheticExpression,
    TemplateSpan,
    SemicolonClassElement,
    Block,
    EmptyStatement,
    VariableStatement,
    ExpressionStatement,
    IfStatement,
    DoStatement,
    WhileStatement,
    ForStatement,
    ForInStatement,
    ForOfStatement,
    ContinueStatement,
    BreakStatement,
    ReturnStatement,
    WithStatement,
    SwitchStatement,
    LabeledStatement,
    ThrowStatement,
    TryStatement,
    DebuggerStatement,
    VariableDeclaration,
    VariableDeclarationList,
    FunctionDeclaration,
    ClassDeclaration,
    InterfaceDeclaration,
    TypeAliasDeclaration,
    EnumDeclaration,
    ModuleDeclaration,
    ModuleBlock,
    CaseBlock,
    NamespaceExportDeclaration,
    ImportEqualsDeclaration,
    ImportDeclaration,
    ImportClause,
    NamespaceImport,
    NamedImports,
    ImportSpecifier,
    ExportAssignment,
    ExportDeclaration,
    NamedExports,
    NamespaceExport,
    ExportSpecifier,
    MissingDeclaration,
    ExternalModuleReference,
    JsxElement,
    JsxSelfClosingElement,
    JsxOpeningElement,
    JsxClosingElement,
    JsxFragment,
    JsxOpeningFragment,
    JsxClosingFragment,
    JsxAttribute,
    JsxAttributes,
    JsxSpreadAttribute,
    JsxExpression,
    CaseClause,
    DefaultClause,
    HeritageClause,
    CatchClause,
    AssertClause,
    AssertEntry,
    PropertyAssignment,
    ShorthandPropertyAssignment,
    SpreadAssignment,
    EnumMember,
    UnparsedPrologue,
    UnparsedPrepend,
    UnparsedText,
    UnparsedInternalText,
    UnparsedSyntheticReference,
    SourceFile,
    Bundle,
    UnparsedSource,
    InputFiles,
    JSDocTypeExpression,
    JSDocNameReference,
    JSDocMemberName,
    JSDocAllType,
    JSDocUnknownType,
    JSDocNullableType,
    JSDocNonNullableType,
    JSDocOptionalType,
    JSDocFunctionType,
    JSDocVariadicType,
    JSDocNamepathType,
    JSDocComment,
    JSDocText,
    JSDocTypeLiteral,
    JSDocSignature,
    JSDocLink,
    JSDocLinkCode,
    JSDocLinkPlain,
    JSDocTag,
    JSDocAugmentsTag,
    JSDocImplementsTag,
    JSDocAuthorTag,
    JSDocDeprecatedTag,
    JSDocClassTag,
    JSDocPublicTag,
    JSDocPrivateTag,
    JSDocProtectedTag,
    JSDocReadonlyTag,
    JSDocOverrideTag,
    JSDocCallbackTag,
    JSDocEnumTag,
    JSDocParameterTag,
    JSDocReturnTag,
    JSDocThisTag,
    JSDocTypeTag,
    JSDocTemplateTag,
    JSDocTypedefTag,
    JSDocSeeTag,
    JSDocPropertyTag,
    SyntaxList,
    NotEmittedStatement,
    PartiallyEmittedExpression,
    CommaListExpression,
    MergeDeclarationMarker,
    EndOfDeclarationMarker,
    SyntheticReferenceExpression,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            AbstractKeyword
                | AnyKeyword
                | AsKeyword
                | AssertsKeyword
                | AssertKeyword
                | BigIntKeyword
                | BooleanKeyword
                | BreakKeyword
                | CaseKeyword
                | CatchKeyword
                | ClassKeyword
                | ContinueKeyword
                | ConstKeyword
                | ConstructorKeyword
                | DebuggerKeyword
                | DeclareKeyword
                | DefaultKeyword
                | DeleteKeyword
                | DoKeyword
                | ElseKeyword
                | EnumKeyword
                | ExportKeyword
                | ExtendsKeyword
                | FalseKeyword
                | FinallyKeyword
                | ForKeyword
                | FromKeyword
                | FunctionKeyword
                | GetKeyword
                | IfKeyword
                | ImplementsKeyword
                | ImportKeyword
                | InKeyword
                | InferKeyword
                | InstanceOfKeyword
                | InterfaceKeyword
                | IntrinsicKeyword
                | IsKeyword
                | KeyOfKeyword
                | LetKeyword
                | ModuleKeyword
                | NamespaceKeyword
                | NeverKeyword
                | NewKeyword
                | NullKeyword
                | NumberKeyword
                | ObjectKeyword
                | PackageKeyword
                | PrivateKeyword
                | ProtectedKeyword
                | PublicKeyword
                | OverrideKeyword
                | ReadonlyKeyword
                | RequireKeyword
                | GlobalKeyword
                | ReturnKeyword
                | SetKeyword
                | StaticKeyword
                | StringKeyword
                | SuperKeyword
                | SwitchKeyword
                | SymbolKeyword
                | ThisKeyword
                | ThrowKeyword
                | TrueKeyword
                | TryKeyword
                | TypeKeyword
                | TypeOfKeyword
                | UndefinedKeyword
                | UniqueKeyword
                | UnknownKeyword
                | VarKeyword
                | VoidKeyword
                | WhileKeyword
                | WithKeyword
                | YieldKeyword
                | AsyncKeyword
                | AwaitKeyword
                | OfKeyword
        )
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            OpenBraceToken
                | CloseBraceToken
                | OpenParenToken
                | CloseParenToken
                | OpenBracketToken
                | CloseBracketToken
                | DotToken
                | DotDotDotToken
                | SemicolonToken
                | CommaToken
                | LessThanToken
                | GreaterThanToken
                | LessThanEqualsToken
                | GreaterThanEqualsToken
                | EqualsEqualsToken
                | ExclamationEqualsToken
                | EqualsEqualsEqualsToken
                | ExclamationEqualsEqualsToken
                | EqualsGreaterThanToken
                | PlusToken
                | MinusToken
                | AsteriskAsteriskToken
                | AsteriskToken
                | SlashToken
                | PercentToken
                | PlusPlusToken
                | MinusMinusToken
                | LessThanLessThanToken
                | LessThanSlashToken
                | GreaterThanGreaterThanToken
                | GreaterThanGreaterThanGreaterThanToken
                | AmpersandToken
                | BarToken
                | CaretToken
                | ExclamationToken
                | TildeToken
                | AmpersandAmpersandToken
                | BarBarToken
                | QuestionToken
                | QuestionQuestionToken
                | QuestionDotToken
                | ColonToken
                | EqualsToken
                | PlusEqualsToken
                | MinusEqualsToken
                | AsteriskEqualsToken
                | AsteriskAsteriskEqualsToken
                | SlashEqualsToken
                | PercentEqualsToken
                | LessThanLessThanEqualsToken
                | GreaterThanGreaterThanEqualsToken
                | GreaterThanGreaterThanGreaterThanEqualsToken
                | AmpersandEqualsToken
                | BarEqualsToken
                | CaretEqualsToken
                | BarBarEqualsToken
                | AmpersandAmpersandEqualsToken
                | QuestionQuestionEqualsToken
                | AtToken
                | HashToken
                | BacktickToken
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(
            self,
            NumericLiteral
                | BigIntLiteral
                | StringLiteral
                | JsxText
                | JsxTextAllWhiteSpaces
                | RegularExpressionLiteral
                | NoSubstitutionTemplateLiteral
                | TemplateHead
                | TemplateMiddle
                | TemplateTail
        )
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "abstract" => AbstractKeyword,
            "any" => AnyKeyword,
            "as" => AsKeyword,
            "asserts" => AssertsKeyword,
            "assert" => AssertKeyword,
            "bigint" => BigIntKeyword,
            "boolean" => BooleanKeyword,
            "break" => BreakKeyword,
            "case" => CaseKeyword,
            "catch" => CatchKeyword,
            "class" => ClassKeyword,
            "continue" => ContinueKeyword,
            "const" => ConstKeyword,
            "constructor" => ConstructorKeyword,
            "debugger" => DebuggerKeyword,
            "declare" => DeclareKeyword,
            "default" => DefaultKeyword,
            "delete" => DeleteKeyword,
            "do" => DoKeyword,
            "else" => ElseKeyword,
            "enum" => EnumKeyword,
            "export" => ExportKeyword,
            "extends" => ExtendsKeyword,
            "false" => FalseKeyword,
            "finally" => FinallyKeyword,
            "for" => ForKeyword,
            "from" => FromKeyword,
            "function" => FunctionKeyword,
            "get" => GetKeyword,
            "if" => IfKeyword,
            "implements" => ImplementsKeyword,
            "import" => ImportKeyword,
            "in" => InKeyword,
            "infer" => InferKeyword,
            "instanceof" => InstanceOfKeyword,
            "interface" => InterfaceKeyword,
            "intrinsic" => IntrinsicKeyword,
            "is" => IsKeyword,
            "keyof" => KeyOfKeyword,
            "let" => LetKeyword,
            "module" => ModuleKeyword,
            "namespace" => NamespaceKeyword,
            "never" => NeverKeyword,
            "new" => NewKeyword,
            "null" => NullKeyword,
            "number" => NumberKeyword,
            "object" => ObjectKeyword,
            "package" => PackageKeyword,
            "private" => PrivateKeyword,
            "protected" => ProtectedKeyword,
            "public" => PublicKeyword,
            "override" => OverrideKeyword,
            "readonly" => ReadonlyKeyword,
            "require" => RequireKeyword,
            "global" => GlobalKeyword,
            "return" => ReturnKeyword,
            "set" => SetKeyword,
            "static" => StaticKeyword,
            "string" => StringKeyword,
            "super" => SuperKeyword,
            "switch" => SwitchKeyword,
            "symbol" => SymbolKeyword,
            "this" => ThisKeyword,
            "throw" => ThrowKeyword,
            "true" => TrueKeyword,
            "try" => TryKeyword,
            "type" => TypeKeyword,
            "typeof" => TypeOfKeyword,
            "undefined" => UndefinedKeyword,
            "unique" => UniqueKeyword,
            "unknown" => UnknownKeyword,
            "var" => VarKeyword,
            "void" => VoidKeyword,
            "while" => WhileKeyword,
            "with" => WithKeyword,
            "yield" => YieldKeyword,
            "async" => AsyncKeyword,
            "await" => AwaitKeyword,
            "of" => OfKeyword,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '{' => OpenBraceToken,
            '}' => CloseBraceToken,
            '(' => OpenParenToken,
            ')' => CloseParenToken,
            '[' => OpenBracketToken,
            ']' => CloseBracketToken,
            '.' => DotToken,
            ';' => SemicolonToken,
            ',' => CommaToken,
            '<' => LessThanToken,
            '>' => GreaterThanToken,
            '+' => PlusToken,
            '-' => MinusToken,
            '*' => AsteriskToken,
            '/' => SlashToken,
            '%' => PercentToken,
            '&' => AmpersandToken,
            '|' => BarToken,
            '^' => CaretToken,
            '!' => ExclamationToken,
            '~' => TildeToken,
            '?' => QuestionToken,
            ':' => ColonToken,
            '=' => EqualsToken,
            '@' => AtToken,
            '#' => HashToken,
            '`' => BacktickToken,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { ['{'] => { $ crate :: SyntaxKind :: OpenBraceToken } ; ['}'] => { $ crate :: SyntaxKind :: CloseBraceToken } ; ['('] => { $ crate :: SyntaxKind :: OpenParenToken } ; [')'] => { $ crate :: SyntaxKind :: CloseParenToken } ; ['['] => { $ crate :: SyntaxKind :: OpenBracketToken } ; [']'] => { $ crate :: SyntaxKind :: CloseBracketToken } ; [.] => { $ crate :: SyntaxKind :: DotToken } ; [...] => { $ crate :: SyntaxKind :: DotDotDotToken } ; [;] => { $ crate :: SyntaxKind :: SemicolonToken } ; [,] => { $ crate :: SyntaxKind :: CommaToken } ; [<] => { $ crate :: SyntaxKind :: LessThanToken } ; [>] => { $ crate :: SyntaxKind :: GreaterThanToken } ; [<=] => { $ crate :: SyntaxKind :: LessThanEqualsToken } ; [>=] => { $ crate :: SyntaxKind :: GreaterThanEqualsToken } ; [==] => { $ crate :: SyntaxKind :: EqualsEqualsToken } ; [!=] => { $ crate :: SyntaxKind :: ExclamationEqualsToken } ; [===] => { $ crate :: SyntaxKind :: EqualsEqualsEqualsToken } ; [!==] => { $ crate :: SyntaxKind :: ExclamationEqualsEqualsToken } ; [=>] => { $ crate :: SyntaxKind :: EqualsGreaterThanToken } ; [+] => { $ crate :: SyntaxKind :: PlusToken } ; [-] => { $ crate :: SyntaxKind :: MinusToken } ; [**] => { $ crate :: SyntaxKind :: AsteriskAsteriskToken } ; [*] => { $ crate :: SyntaxKind :: AsteriskToken } ; [/] => { $ crate :: SyntaxKind :: SlashToken } ; [%] => { $ crate :: SyntaxKind :: PercentToken } ; [++] => { $ crate :: SyntaxKind :: PlusPlusToken } ; [--] => { $ crate :: SyntaxKind :: MinusMinusToken } ; [<<] => { $ crate :: SyntaxKind :: LessThanLessThanToken } ; [</] => { $ crate :: SyntaxKind :: LessThanSlashToken } ; [>>] => { $ crate :: SyntaxKind :: GreaterThanGreaterThanToken } ; [>>>] => { $ crate :: SyntaxKind :: GreaterThanGreaterThanGreaterThanToken } ; [&] => { $ crate :: SyntaxKind :: AmpersandToken } ; [|] => { $ crate :: SyntaxKind :: BarToken } ; [^] => { $ crate :: SyntaxKind :: CaretToken } ; [!] => { $ crate :: SyntaxKind :: ExclamationToken } ; [~] => { $ crate :: SyntaxKind :: TildeToken } ; [&&] => { $ crate :: SyntaxKind :: AmpersandAmpersandToken } ; [||] => { $ crate :: SyntaxKind :: BarBarToken } ; [?] => { $ crate :: SyntaxKind :: QuestionToken } ; [??] => { $ crate :: SyntaxKind :: QuestionQuestionToken } ; [?.] => { $ crate :: SyntaxKind :: QuestionDotToken } ; [:] => { $ crate :: SyntaxKind :: ColonToken } ; [=] => { $ crate :: SyntaxKind :: EqualsToken } ; [+=] => { $ crate :: SyntaxKind :: PlusEqualsToken } ; [-=] => { $ crate :: SyntaxKind :: MinusEqualsToken } ; [*=] => { $ crate :: SyntaxKind :: AsteriskEqualsToken } ; [**=] => { $ crate :: SyntaxKind :: AsteriskAsteriskEqualsToken } ; [/=] => { $ crate :: SyntaxKind :: SlashEqualsToken } ; [%=] => { $ crate :: SyntaxKind :: PercentEqualsToken } ; [<<=] => { $ crate :: SyntaxKind :: LessThanLessThanEqualsToken } ; [>>=] => { $ crate :: SyntaxKind :: GreaterThanGreaterThanEqualsToken } ; [>>>=] => { $ crate :: SyntaxKind :: GreaterThanGreaterThanGreaterThanEqualsToken } ; [&=] => { $ crate :: SyntaxKind :: AmpersandEqualsToken } ; [|=] => { $ crate :: SyntaxKind :: BarEqualsToken } ; [^=] => { $ crate :: SyntaxKind :: CaretEqualsToken } ; [||=] => { $ crate :: SyntaxKind :: BarBarEqualsToken } ; [&&=] => { $ crate :: SyntaxKind :: AmpersandAmpersandEqualsToken } ; [??=] => { $ crate :: SyntaxKind :: QuestionQuestionEqualsToken } ; [@] => { $ crate :: SyntaxKind :: AtToken } ; [#] => { $ crate :: SyntaxKind :: HashToken } ; ['`'] => { $ crate :: SyntaxKind :: BacktickToken } ; [AbstractKeyword] => { $ crate :: SyntaxKind :: AbstractKeyword } ; [AnyKeyword] => { $ crate :: SyntaxKind :: AnyKeyword } ; [AsKeyword] => { $ crate :: SyntaxKind :: AsKeyword } ; [AssertsKeyword] => { $ crate :: SyntaxKind :: AssertsKeyword } ; [AssertKeyword] => { $ crate :: SyntaxKind :: AssertKeyword } ; [BigIntKeyword] => { $ crate :: SyntaxKind :: BigIntKeyword } ; [BooleanKeyword] => { $ crate :: SyntaxKind :: BooleanKeyword } ; [BreakKeyword] => { $ crate :: SyntaxKind :: BreakKeyword } ; [CaseKeyword] => { $ crate :: SyntaxKind :: CaseKeyword } ; [CatchKeyword] => { $ crate :: SyntaxKind :: CatchKeyword } ; [ClassKeyword] => { $ crate :: SyntaxKind :: ClassKeyword } ; [ContinueKeyword] => { $ crate :: SyntaxKind :: ContinueKeyword } ; [ConstKeyword] => { $ crate :: SyntaxKind :: ConstKeyword } ; [ConstructorKeyword] => { $ crate :: SyntaxKind :: ConstructorKeyword } ; [DebuggerKeyword] => { $ crate :: SyntaxKind :: DebuggerKeyword } ; [DeclareKeyword] => { $ crate :: SyntaxKind :: DeclareKeyword } ; [DefaultKeyword] => { $ crate :: SyntaxKind :: DefaultKeyword } ; [DeleteKeyword] => { $ crate :: SyntaxKind :: DeleteKeyword } ; [DoKeyword] => { $ crate :: SyntaxKind :: DoKeyword } ; [ElseKeyword] => { $ crate :: SyntaxKind :: ElseKeyword } ; [EnumKeyword] => { $ crate :: SyntaxKind :: EnumKeyword } ; [ExportKeyword] => { $ crate :: SyntaxKind :: ExportKeyword } ; [ExtendsKeyword] => { $ crate :: SyntaxKind :: ExtendsKeyword } ; [FalseKeyword] => { $ crate :: SyntaxKind :: FalseKeyword } ; [FinallyKeyword] => { $ crate :: SyntaxKind :: FinallyKeyword } ; [ForKeyword] => { $ crate :: SyntaxKind :: ForKeyword } ; [FromKeyword] => { $ crate :: SyntaxKind :: FromKeyword } ; [FunctionKeyword] => { $ crate :: SyntaxKind :: FunctionKeyword } ; [GetKeyword] => { $ crate :: SyntaxKind :: GetKeyword } ; [IfKeyword] => { $ crate :: SyntaxKind :: IfKeyword } ; [ImplementsKeyword] => { $ crate :: SyntaxKind :: ImplementsKeyword } ; [ImportKeyword] => { $ crate :: SyntaxKind :: ImportKeyword } ; [InKeyword] => { $ crate :: SyntaxKind :: InKeyword } ; [InferKeyword] => { $ crate :: SyntaxKind :: InferKeyword } ; [InstanceOfKeyword] => { $ crate :: SyntaxKind :: InstanceOfKeyword } ; [InterfaceKeyword] => { $ crate :: SyntaxKind :: InterfaceKeyword } ; [IntrinsicKeyword] => { $ crate :: SyntaxKind :: IntrinsicKeyword } ; [IsKeyword] => { $ crate :: SyntaxKind :: IsKeyword } ; [KeyOfKeyword] => { $ crate :: SyntaxKind :: KeyOfKeyword } ; [LetKeyword] => { $ crate :: SyntaxKind :: LetKeyword } ; [ModuleKeyword] => { $ crate :: SyntaxKind :: ModuleKeyword } ; [NamespaceKeyword] => { $ crate :: SyntaxKind :: NamespaceKeyword } ; [NeverKeyword] => { $ crate :: SyntaxKind :: NeverKeyword } ; [NewKeyword] => { $ crate :: SyntaxKind :: NewKeyword } ; [NullKeyword] => { $ crate :: SyntaxKind :: NullKeyword } ; [NumberKeyword] => { $ crate :: SyntaxKind :: NumberKeyword } ; [ObjectKeyword] => { $ crate :: SyntaxKind :: ObjectKeyword } ; [PackageKeyword] => { $ crate :: SyntaxKind :: PackageKeyword } ; [PrivateKeyword] => { $ crate :: SyntaxKind :: PrivateKeyword } ; [ProtectedKeyword] => { $ crate :: SyntaxKind :: ProtectedKeyword } ; [PublicKeyword] => { $ crate :: SyntaxKind :: PublicKeyword } ; [OverrideKeyword] => { $ crate :: SyntaxKind :: OverrideKeyword } ; [ReadonlyKeyword] => { $ crate :: SyntaxKind :: ReadonlyKeyword } ; [RequireKeyword] => { $ crate :: SyntaxKind :: RequireKeyword } ; [GlobalKeyword] => { $ crate :: SyntaxKind :: GlobalKeyword } ; [ReturnKeyword] => { $ crate :: SyntaxKind :: ReturnKeyword } ; [SetKeyword] => { $ crate :: SyntaxKind :: SetKeyword } ; [StaticKeyword] => { $ crate :: SyntaxKind :: StaticKeyword } ; [StringKeyword] => { $ crate :: SyntaxKind :: StringKeyword } ; [SuperKeyword] => { $ crate :: SyntaxKind :: SuperKeyword } ; [SwitchKeyword] => { $ crate :: SyntaxKind :: SwitchKeyword } ; [SymbolKeyword] => { $ crate :: SyntaxKind :: SymbolKeyword } ; [ThisKeyword] => { $ crate :: SyntaxKind :: ThisKeyword } ; [ThrowKeyword] => { $ crate :: SyntaxKind :: ThrowKeyword } ; [TrueKeyword] => { $ crate :: SyntaxKind :: TrueKeyword } ; [TryKeyword] => { $ crate :: SyntaxKind :: TryKeyword } ; [TypeKeyword] => { $ crate :: SyntaxKind :: TypeKeyword } ; [TypeOfKeyword] => { $ crate :: SyntaxKind :: TypeOfKeyword } ; [UndefinedKeyword] => { $ crate :: SyntaxKind :: UndefinedKeyword } ; [UniqueKeyword] => { $ crate :: SyntaxKind :: UniqueKeyword } ; [UnknownKeyword] => { $ crate :: SyntaxKind :: UnknownKeyword } ; [VarKeyword] => { $ crate :: SyntaxKind :: VarKeyword } ; [VoidKeyword] => { $ crate :: SyntaxKind :: VoidKeyword } ; [WhileKeyword] => { $ crate :: SyntaxKind :: WhileKeyword } ; [WithKeyword] => { $ crate :: SyntaxKind :: WithKeyword } ; [YieldKeyword] => { $ crate :: SyntaxKind :: YieldKeyword } ; [AsyncKeyword] => { $ crate :: SyntaxKind :: AsyncKeyword } ; [AwaitKeyword] => { $ crate :: SyntaxKind :: AwaitKeyword } ; [OfKeyword] => { $ crate :: SyntaxKind :: OfKeyword } ; }
pub use T;
