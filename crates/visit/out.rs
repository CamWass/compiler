#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
#[doc(hidden)]
pub extern crate ast;
use ast::*;
use global_common::{pass::CompilerPass, Span, DUMMY_SP};
use global_visit::{define, AndThen, Repeat, Repeated};
use num_bigint::BigInt as BigIntValue;
use std::{any::Any, borrow::Cow, fmt::Debug};
use swc_atoms::JsWord;
pub trait VisitAstNodeWith<'ast, V>
where
    V: Visit<'ast>,
{
    fn visit_with<'a>(&'a self, v: &mut V);
    fn visit_children_with(&'ast self, visitor: &mut V);
}
impl<'ast, V: Visit<'ast>> VisitAstNodeWith<'ast, V> for AstNode<'ast> {
    fn visit_with(&self, v: &mut V) {
        match self {
            AstNode::Class(a) => a.visit_with(v),
            AstNode::ClassProp(a) => a.visit_with(v),
            AstNode::PrivateProp(a) => a.visit_with(v),
            AstNode::ClassMethod(a) => a.visit_with(v),
            AstNode::PrivateMethod(a) => a.visit_with(v),
            AstNode::Constructor(a) => a.visit_with(v),
            AstNode::Decorator(a) => a.visit_with(v),
            AstNode::FnDecl(a) => a.visit_with(v),
            AstNode::ClassDecl(a) => a.visit_with(v),
            AstNode::VarDecl(a) => a.visit_with(v),
            AstNode::VarDeclarator(a) => a.visit_with(v),
            AstNode::ThisExpr(a) => a.visit_with(v),
            AstNode::ArrayLit(a) => a.visit_with(v),
            AstNode::ObjectLit(a) => a.visit_with(v),
            AstNode::SpreadElement(a) => a.visit_with(v),
            AstNode::UnaryExpr(a) => a.visit_with(v),
            AstNode::UpdateExpr(a) => a.visit_with(v),
            AstNode::BinExpr(a) => a.visit_with(v),
            AstNode::FnExpr(a) => a.visit_with(v),
            AstNode::ClassExpr(a) => a.visit_with(v),
            AstNode::AssignExpr(a) => a.visit_with(v),
            AstNode::MemberExpr(a) => a.visit_with(v),
            AstNode::CondExpr(a) => a.visit_with(v),
            AstNode::CallExpr(a) => a.visit_with(v),
            AstNode::NewExpr(a) => a.visit_with(v),
            AstNode::SeqExpr(a) => a.visit_with(v),
            AstNode::ArrowExpr(a) => a.visit_with(v),
            AstNode::YieldExpr(a) => a.visit_with(v),
            AstNode::MetaPropExpr(a) => a.visit_with(v),
            AstNode::AwaitExpr(a) => a.visit_with(v),
            AstNode::Tpl(a) => a.visit_with(v),
            AstNode::TaggedTpl(a) => a.visit_with(v),
            AstNode::TplElement(a) => a.visit_with(v),
            AstNode::ParenExpr(a) => a.visit_with(v),
            AstNode::Super(a) => a.visit_with(v),
            AstNode::ExprOrSpread(a) => a.visit_with(v),
            AstNode::OptChainExpr(a) => a.visit_with(v),
            AstNode::Function(a) => a.visit_with(v),
            AstNode::Param(a) => a.visit_with(v),
            AstNode::BindingIdent(a) => a.visit_with(v),
            AstNode::Ident(a) => a.visit_with(v),
            AstNode::PrivateName(a) => a.visit_with(v),
            AstNode::JSXMemberExpr(a) => a.visit_with(v),
            AstNode::JSXNamespacedName(a) => a.visit_with(v),
            AstNode::JSXEmptyExpr(a) => a.visit_with(v),
            AstNode::JSXExprContainer(a) => a.visit_with(v),
            AstNode::JSXSpreadChild(a) => a.visit_with(v),
            AstNode::JSXOpeningElement(a) => a.visit_with(v),
            AstNode::JSXClosingElement(a) => a.visit_with(v),
            AstNode::JSXAttr(a) => a.visit_with(v),
            AstNode::JSXText(a) => a.visit_with(v),
            AstNode::JSXElement(a) => a.visit_with(v),
            AstNode::JSXFragment(a) => a.visit_with(v),
            AstNode::JSXOpeningFragment(a) => a.visit_with(v),
            AstNode::JSXClosingFragment(a) => a.visit_with(v),
            AstNode::Invalid(a) => a.visit_with(v),
            AstNode::Str(a) => a.visit_with(v),
            AstNode::Bool(a) => a.visit_with(v),
            AstNode::Null(a) => a.visit_with(v),
            AstNode::Number(a) => a.visit_with(v),
            AstNode::BigInt(a) => a.visit_with(v),
            AstNode::Regex(a) => a.visit_with(v),
            AstNode::ExportDefaultExpr(a) => a.visit_with(v),
            AstNode::ExportDecl(a) => a.visit_with(v),
            AstNode::ImportDecl(a) => a.visit_with(v),
            AstNode::ExportAll(a) => a.visit_with(v),
            AstNode::NamedExport(a) => a.visit_with(v),
            AstNode::ExportDefaultDecl(a) => a.visit_with(v),
            AstNode::ImportDefaultSpecifier(a) => a.visit_with(v),
            AstNode::ImportStarAsSpecifier(a) => a.visit_with(v),
            AstNode::ImportNamedSpecifier(a) => a.visit_with(v),
            AstNode::ExportNamespaceSpecifier(a) => a.visit_with(v),
            AstNode::ExportDefaultSpecifier(a) => a.visit_with(v),
            AstNode::ExportNamedSpecifier(a) => a.visit_with(v),
            AstNode::Script(a) => a.visit_with(v),
            AstNode::Module(a) => a.visit_with(v),
            AstNode::ArrayPat(a) => a.visit_with(v),
            AstNode::ObjectPat(a) => a.visit_with(v),
            AstNode::AssignPat(a) => a.visit_with(v),
            AstNode::RestPat(a) => a.visit_with(v),
            AstNode::KeyValuePatProp(a) => a.visit_with(v),
            AstNode::AssignPatProp(a) => a.visit_with(v),
            AstNode::KeyValueProp(a) => a.visit_with(v),
            AstNode::AssignProp(a) => a.visit_with(v),
            AstNode::GetterProp(a) => a.visit_with(v),
            AstNode::SetterProp(a) => a.visit_with(v),
            AstNode::MethodProp(a) => a.visit_with(v),
            AstNode::ComputedPropName(a) => a.visit_with(v),
            AstNode::BlockStmt(a) => a.visit_with(v),
            AstNode::ExprStmt(a) => a.visit_with(v),
            AstNode::EmptyStmt(a) => a.visit_with(v),
            AstNode::DebuggerStmt(a) => a.visit_with(v),
            AstNode::WithStmt(a) => a.visit_with(v),
            AstNode::ReturnStmt(a) => a.visit_with(v),
            AstNode::LabeledStmt(a) => a.visit_with(v),
            AstNode::BreakStmt(a) => a.visit_with(v),
            AstNode::ContinueStmt(a) => a.visit_with(v),
            AstNode::IfStmt(a) => a.visit_with(v),
            AstNode::SwitchStmt(a) => a.visit_with(v),
            AstNode::ThrowStmt(a) => a.visit_with(v),
            AstNode::TryStmt(a) => a.visit_with(v),
            AstNode::WhileStmt(a) => a.visit_with(v),
            AstNode::DoWhileStmt(a) => a.visit_with(v),
            AstNode::ForStmt(a) => a.visit_with(v),
            AstNode::ForInStmt(a) => a.visit_with(v),
            AstNode::ForOfStmt(a) => a.visit_with(v),
            AstNode::SwitchCase(a) => a.visit_with(v),
            AstNode::CatchClause(a) => a.visit_with(v),
            AstNode::TsTypeAnn(a) => a.visit_with(v),
            AstNode::TsTypeParamDecl(a) => a.visit_with(v),
            AstNode::TsTypeParam(a) => a.visit_with(v),
            AstNode::TsTypeParamInstantiation(a) => a.visit_with(v),
            AstNode::TsParamProp(a) => a.visit_with(v),
            AstNode::TsQualifiedName(a) => a.visit_with(v),
            AstNode::TsCallSignatureDecl(a) => a.visit_with(v),
            AstNode::TsConstructSignatureDecl(a) => a.visit_with(v),
            AstNode::TsPropertySignature(a) => a.visit_with(v),
            AstNode::TsGetterSignature(a) => a.visit_with(v),
            AstNode::TsSetterSignature(a) => a.visit_with(v),
            AstNode::TsMethodSignature(a) => a.visit_with(v),
            AstNode::TsIndexSignature(a) => a.visit_with(v),
            AstNode::TsKeywordType(a) => a.visit_with(v),
            AstNode::TsThisType(a) => a.visit_with(v),
            AstNode::TsFnType(a) => a.visit_with(v),
            AstNode::TsConstructorType(a) => a.visit_with(v),
            AstNode::TsTypeRef(a) => a.visit_with(v),
            AstNode::TsTypePredicate(a) => a.visit_with(v),
            AstNode::TsTypeQuery(a) => a.visit_with(v),
            AstNode::TsImportType(a) => a.visit_with(v),
            AstNode::TsTypeLit(a) => a.visit_with(v),
            AstNode::TsArrayType(a) => a.visit_with(v),
            AstNode::TsTupleType(a) => a.visit_with(v),
            AstNode::TsTupleElement(a) => a.visit_with(v),
            AstNode::TsOptionalType(a) => a.visit_with(v),
            AstNode::TsRestType(a) => a.visit_with(v),
            AstNode::TsUnionType(a) => a.visit_with(v),
            AstNode::TsIntersectionType(a) => a.visit_with(v),
            AstNode::TsConditionalType(a) => a.visit_with(v),
            AstNode::TsInferType(a) => a.visit_with(v),
            AstNode::TsParenthesizedType(a) => a.visit_with(v),
            AstNode::TsTypeOperator(a) => a.visit_with(v),
            AstNode::TsIndexedAccessType(a) => a.visit_with(v),
            AstNode::TsMappedType(a) => a.visit_with(v),
            AstNode::TsLitType(a) => a.visit_with(v),
            AstNode::TsTplLitType(a) => a.visit_with(v),
            AstNode::TsInterfaceDecl(a) => a.visit_with(v),
            AstNode::TsInterfaceBody(a) => a.visit_with(v),
            AstNode::TsExprWithTypeArgs(a) => a.visit_with(v),
            AstNode::TsTypeAliasDecl(a) => a.visit_with(v),
            AstNode::TsEnumDecl(a) => a.visit_with(v),
            AstNode::TsEnumMember(a) => a.visit_with(v),
            AstNode::TsModuleDecl(a) => a.visit_with(v),
            AstNode::TsModuleBlock(a) => a.visit_with(v),
            AstNode::TsNamespaceDecl(a) => a.visit_with(v),
            AstNode::TsImportEqualsDecl(a) => a.visit_with(v),
            AstNode::TsExternalModuleRef(a) => a.visit_with(v),
            AstNode::TsExportAssignment(a) => a.visit_with(v),
            AstNode::TsNamespaceExportDecl(a) => a.visit_with(v),
            AstNode::TsAsExpr(a) => a.visit_with(v),
            AstNode::TsTypeAssertion(a) => a.visit_with(v),
            AstNode::TsNonNullExpr(a) => a.visit_with(v),
            AstNode::TsConstAssertion(a) => a.visit_with(v),
        }
    }
    fn visit_children_with(&self, visitor: &mut V) {
        self.visit_with(visitor)
    }
}
impl<A, B> Fold for AndThen<A, B>
where
    A: Fold,
    B: Fold,
{
    #[inline(always)]
    fn fold_module(&mut self, n: Module) -> Module {
        let n = self.first.fold_module(n);
        self.second.fold_module(n)
    }
    #[inline(always)]
    fn fold_script(&mut self, n: Script) -> Script {
        let n = self.first.fold_script(n);
        self.second.fold_script(n)
    }
}
impl<'ast, A, B> Visit<'ast> for AndThen<A, B>
where
    A: Visit<'ast>,
    B: Visit<'ast>,
{
    fn visit_module(&mut self, n: &'ast Module) {
        self.first.visit_module(n);
        self.second.visit_module(n);
    }
    fn visit_script(&mut self, n: &'ast Script) {
        self.first.visit_script(n);
        self.second.visit_script(n);
    }
}
impl<V> Fold for Repeat<V>
where
    V: Fold + Repeated,
{
    fn fold_module(&mut self, mut node: Module) -> Module {
        loop {
            self.pass.reset();
            node = node.fold_with(&mut self.pass);
            if !self.pass.changed() {
                break;
            }
        }
        node
    }
    fn fold_script(&mut self, mut node: Script) -> Script {
        loop {
            self.pass.reset();
            node = node.fold_with(&mut self.pass);
            if !self.pass.changed() {
                break;
            }
        }
        node
    }
}
/// Not a public api.
struct SpanRemover;
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for SpanRemover {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            SpanRemover => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "SpanRemover");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for SpanRemover {
    #[inline]
    fn clone(&self) -> SpanRemover {
        {
            *self
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::marker::Copy for SpanRemover {}
impl ::core::marker::StructuralPartialEq for SpanRemover {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for SpanRemover {
    #[inline]
    fn eq(&self, other: &SpanRemover) -> bool {
        match *other {
            SpanRemover => match *self {
                SpanRemover => true,
            },
        }
    }
}
impl ::core::marker::StructuralEq for SpanRemover {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for SpanRemover {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        {}
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::default::Default for SpanRemover {
    #[inline]
    fn default() -> SpanRemover {
        SpanRemover {}
    }
}
/// Returns a `Fold` which changes all span into `DUMMY_SP`.
pub fn span_remover() -> impl Debug + Fold + Copy + Eq + Default + 'static {
    SpanRemover
}
impl Fold for SpanRemover {
    fn fold_span(&mut self, _: Span) -> Span {
        DUMMY_SP
    }
}
#[allow(unused_variables)]
pub fn fold_accessibility<V: ?Sized + Fold>(_visitor: &mut V, n: Accessibility) -> Accessibility {
    {
        match n {
            Accessibility::Public {} => {
                return Accessibility::Public {};
            }
            Accessibility::Protected {} => {
                return Accessibility::Protected {};
            }
            Accessibility::Private {} => {
                return Accessibility::Private {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_array_lit<V: ?Sized + Fold>(_visitor: &mut V, n: ArrayLit) -> ArrayLit {
    {
        match n {
            ArrayLit { span, elems } => {
                let span = _visitor.fold_span(span);
                let elems = _visitor.fold_opt_vec_expr_or_spreads(elems);
                return ArrayLit { span, elems };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_array_pat<V: ?Sized + Fold>(_visitor: &mut V, n: ArrayPat) -> ArrayPat {
    {
        match n {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let elems = _visitor.fold_opt_vec_pats(elems);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                return ArrayPat {
                    span,
                    elems,
                    optional,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_arrow_expr<V: ?Sized + Fold>(_visitor: &mut V, n: ArrowExpr) -> ArrowExpr {
    {
        match n {
            ArrowExpr {
                span,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                let span = _visitor.fold_span(span);
                let params = _visitor.fold_pats(params);
                let body = _visitor.fold_block_stmt_or_expr(body);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                let return_type = _visitor.fold_opt_ts_type_ann(return_type);
                return ArrowExpr {
                    span,
                    params,
                    body,
                    is_async,
                    is_generator,
                    type_params,
                    return_type,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_assign_expr<V: ?Sized + Fold>(_visitor: &mut V, n: AssignExpr) -> AssignExpr {
    {
        match n {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                let span = _visitor.fold_span(span);
                let op = _visitor.fold_assign_op(op);
                let left = _visitor.fold_pat_or_expr(left);
                let right = Box::new(_visitor.fold_expr(*right));
                return AssignExpr {
                    span,
                    op,
                    left,
                    right,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_assign_op<V: ?Sized + Fold>(_visitor: &mut V, n: AssignOp) -> AssignOp {
    {
        match n {
            AssignOp::Assign {} => {
                return AssignOp::Assign {};
            }
            AssignOp::AddAssign {} => {
                return AssignOp::AddAssign {};
            }
            AssignOp::SubAssign {} => {
                return AssignOp::SubAssign {};
            }
            AssignOp::MulAssign {} => {
                return AssignOp::MulAssign {};
            }
            AssignOp::DivAssign {} => {
                return AssignOp::DivAssign {};
            }
            AssignOp::ModAssign {} => {
                return AssignOp::ModAssign {};
            }
            AssignOp::LShiftAssign {} => {
                return AssignOp::LShiftAssign {};
            }
            AssignOp::RShiftAssign {} => {
                return AssignOp::RShiftAssign {};
            }
            AssignOp::ZeroFillRShiftAssign {} => {
                return AssignOp::ZeroFillRShiftAssign {};
            }
            AssignOp::BitOrAssign {} => {
                return AssignOp::BitOrAssign {};
            }
            AssignOp::BitXorAssign {} => {
                return AssignOp::BitXorAssign {};
            }
            AssignOp::BitAndAssign {} => {
                return AssignOp::BitAndAssign {};
            }
            AssignOp::ExpAssign {} => {
                return AssignOp::ExpAssign {};
            }
            AssignOp::AndAssign {} => {
                return AssignOp::AndAssign {};
            }
            AssignOp::OrAssign {} => {
                return AssignOp::OrAssign {};
            }
            AssignOp::NullishAssign {} => {
                return AssignOp::NullishAssign {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_assign_pat<V: ?Sized + Fold>(_visitor: &mut V, n: AssignPat) -> AssignPat {
    {
        match n {
            AssignPat {
                span,
                left,
                right,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let left = Box::new(_visitor.fold_pat(*left));
                let right = Box::new(_visitor.fold_expr(*right));
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                return AssignPat {
                    span,
                    left,
                    right,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_assign_pat_prop<V: ?Sized + Fold>(_visitor: &mut V, n: AssignPatProp) -> AssignPatProp {
    {
        match n {
            AssignPatProp { span, key, value } => {
                let span = _visitor.fold_span(span);
                let key = _visitor.fold_ident(key);
                let value = _visitor.fold_opt_expr(value);
                return AssignPatProp { span, key, value };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_assign_prop<V: ?Sized + Fold>(_visitor: &mut V, n: AssignProp) -> AssignProp {
    {
        match n {
            AssignProp { key, value } => {
                let key = _visitor.fold_ident(key);
                let value = Box::new(_visitor.fold_expr(*value));
                return AssignProp { key, value };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_await_expr<V: ?Sized + Fold>(_visitor: &mut V, n: AwaitExpr) -> AwaitExpr {
    {
        match n {
            AwaitExpr { span, arg } => {
                let span = _visitor.fold_span(span);
                let arg = Box::new(_visitor.fold_expr(*arg));
                return AwaitExpr { span, arg };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_big_int<V: ?Sized + Fold>(_visitor: &mut V, n: BigInt) -> BigInt {
    {
        match n {
            BigInt { span, value } => {
                let span = _visitor.fold_span(span);
                let value = _visitor.fold_big_int_value(value);
                return BigInt { span, value };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_big_int_value<V: ?Sized + Fold>(_visitor: &mut V, n: BigIntValue) -> BigIntValue {
    {
        return n;
    }
}
#[allow(unused_variables)]
pub fn fold_bin_expr<V: ?Sized + Fold>(_visitor: &mut V, n: BinExpr) -> BinExpr {
    {
        match n {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                let span = _visitor.fold_span(span);
                let op = _visitor.fold_binary_op(op);
                let left = Box::new(_visitor.fold_expr(*left));
                let right = Box::new(_visitor.fold_expr(*right));
                return BinExpr {
                    span,
                    op,
                    left,
                    right,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_binary_op<V: ?Sized + Fold>(_visitor: &mut V, n: BinaryOp) -> BinaryOp {
    {
        match n {
            BinaryOp::EqEq {} => {
                return BinaryOp::EqEq {};
            }
            BinaryOp::NotEq {} => {
                return BinaryOp::NotEq {};
            }
            BinaryOp::EqEqEq {} => {
                return BinaryOp::EqEqEq {};
            }
            BinaryOp::NotEqEq {} => {
                return BinaryOp::NotEqEq {};
            }
            BinaryOp::Lt {} => {
                return BinaryOp::Lt {};
            }
            BinaryOp::LtEq {} => {
                return BinaryOp::LtEq {};
            }
            BinaryOp::Gt {} => {
                return BinaryOp::Gt {};
            }
            BinaryOp::GtEq {} => {
                return BinaryOp::GtEq {};
            }
            BinaryOp::LShift {} => {
                return BinaryOp::LShift {};
            }
            BinaryOp::RShift {} => {
                return BinaryOp::RShift {};
            }
            BinaryOp::ZeroFillRShift {} => {
                return BinaryOp::ZeroFillRShift {};
            }
            BinaryOp::Add {} => {
                return BinaryOp::Add {};
            }
            BinaryOp::Sub {} => {
                return BinaryOp::Sub {};
            }
            BinaryOp::Mul {} => {
                return BinaryOp::Mul {};
            }
            BinaryOp::Div {} => {
                return BinaryOp::Div {};
            }
            BinaryOp::Mod {} => {
                return BinaryOp::Mod {};
            }
            BinaryOp::BitOr {} => {
                return BinaryOp::BitOr {};
            }
            BinaryOp::BitXor {} => {
                return BinaryOp::BitXor {};
            }
            BinaryOp::BitAnd {} => {
                return BinaryOp::BitAnd {};
            }
            BinaryOp::LogicalOr {} => {
                return BinaryOp::LogicalOr {};
            }
            BinaryOp::LogicalAnd {} => {
                return BinaryOp::LogicalAnd {};
            }
            BinaryOp::In {} => {
                return BinaryOp::In {};
            }
            BinaryOp::InstanceOf {} => {
                return BinaryOp::InstanceOf {};
            }
            BinaryOp::Exp {} => {
                return BinaryOp::Exp {};
            }
            BinaryOp::NullishCoalescing {} => {
                return BinaryOp::NullishCoalescing {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_binding_ident<V: ?Sized + Fold>(_visitor: &mut V, n: BindingIdent) -> BindingIdent {
    {
        match n {
            BindingIdent { id, type_ann } => {
                let id = _visitor.fold_ident(id);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                return BindingIdent { id, type_ann };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_block_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: BlockStmt) -> BlockStmt {
    {
        match n {
            BlockStmt { span, stmts } => {
                let span = _visitor.fold_span(span);
                let stmts = _visitor.fold_stmts(stmts);
                return BlockStmt { span, stmts };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_block_stmt_or_expr<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: BlockStmtOrExpr,
) -> BlockStmtOrExpr {
    {
        match n {
            BlockStmtOrExpr::BlockStmt { 0: _0 } => {
                let _0 = _visitor.fold_block_stmt(_0);
                return BlockStmtOrExpr::BlockStmt { 0: _0 };
            }
            BlockStmtOrExpr::Expr { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_expr(*_0));
                return BlockStmtOrExpr::Expr { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_bool<V: ?Sized + Fold>(_visitor: &mut V, n: Bool) -> Bool {
    {
        match n {
            Bool { span, value } => {
                let span = _visitor.fold_span(span);
                return Bool { span, value };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_break_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: BreakStmt) -> BreakStmt {
    {
        match n {
            BreakStmt { span, label } => {
                let span = _visitor.fold_span(span);
                let label = _visitor.fold_opt_ident(label);
                return BreakStmt { span, label };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_call_expr<V: ?Sized + Fold>(_visitor: &mut V, n: CallExpr) -> CallExpr {
    {
        match n {
            CallExpr {
                span,
                callee,
                args,
                type_args,
            } => {
                let span = _visitor.fold_span(span);
                let callee = _visitor.fold_expr_or_super(callee);
                let args = _visitor.fold_expr_or_spreads(args);
                let type_args = _visitor.fold_opt_ts_type_param_instantiation(type_args);
                return CallExpr {
                    span,
                    callee,
                    args,
                    type_args,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_catch_clause<V: ?Sized + Fold>(_visitor: &mut V, n: CatchClause) -> CatchClause {
    {
        match n {
            CatchClause { span, param, body } => {
                let span = _visitor.fold_span(span);
                let param = _visitor.fold_opt_pat(param);
                let body = _visitor.fold_block_stmt(body);
                return CatchClause { span, param, body };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_class<V: ?Sized + Fold>(_visitor: &mut V, n: Class) -> Class {
    {
        match n {
            Class {
                span,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                let span = _visitor.fold_span(span);
                let decorators = _visitor.fold_decorators(decorators);
                let body = _visitor.fold_class_members(body);
                let super_class = _visitor.fold_opt_expr(super_class);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                let super_type_params =
                    _visitor.fold_opt_ts_type_param_instantiation(super_type_params);
                let implements = _visitor.fold_ts_expr_with_type_args_vec(implements);
                return Class {
                    span,
                    decorators,
                    body,
                    super_class,
                    is_abstract,
                    type_params,
                    super_type_params,
                    implements,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_class_decl<V: ?Sized + Fold>(_visitor: &mut V, n: ClassDecl) -> ClassDecl {
    {
        match n {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                let ident = _visitor.fold_ident(ident);
                let class = _visitor.fold_class(class);
                return ClassDecl {
                    ident,
                    declare,
                    class,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_class_expr<V: ?Sized + Fold>(_visitor: &mut V, n: ClassExpr) -> ClassExpr {
    {
        match n {
            ClassExpr { ident, class } => {
                let ident = _visitor.fold_opt_ident(ident);
                let class = _visitor.fold_class(class);
                return ClassExpr { ident, class };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_class_member<V: ?Sized + Fold>(_visitor: &mut V, n: ClassMember) -> ClassMember {
    {
        match n {
            ClassMember::Constructor { 0: _0 } => {
                let _0 = _visitor.fold_constructor(_0);
                return ClassMember::Constructor { 0: _0 };
            }
            ClassMember::Method { 0: _0 } => {
                let _0 = _visitor.fold_class_method(_0);
                return ClassMember::Method { 0: _0 };
            }
            ClassMember::PrivateMethod { 0: _0 } => {
                let _0 = _visitor.fold_private_method(_0);
                return ClassMember::PrivateMethod { 0: _0 };
            }
            ClassMember::ClassProp { 0: _0 } => {
                let _0 = _visitor.fold_class_prop(_0);
                return ClassMember::ClassProp { 0: _0 };
            }
            ClassMember::PrivateProp { 0: _0 } => {
                let _0 = _visitor.fold_private_prop(_0);
                return ClassMember::PrivateProp { 0: _0 };
            }
            ClassMember::TsIndexSignature { 0: _0 } => {
                let _0 = _visitor.fold_ts_index_signature(_0);
                return ClassMember::TsIndexSignature { 0: _0 };
            }
            ClassMember::Empty { 0: _0 } => {
                let _0 = _visitor.fold_empty_stmt(_0);
                return ClassMember::Empty { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_class_members<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<ClassMember>,
) -> Vec<ClassMember> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_class_member(v))
    }
}
#[allow(unused_variables)]
pub fn fold_class_method<V: ?Sized + Fold>(_visitor: &mut V, n: ClassMethod) -> ClassMethod {
    {
        match n {
            ClassMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                let span = _visitor.fold_span(span);
                let key = _visitor.fold_prop_name(key);
                let function = _visitor.fold_function(function);
                let kind = _visitor.fold_method_kind(kind);
                let accessibility = _visitor.fold_opt_accessibility(accessibility);
                return ClassMethod {
                    span,
                    key,
                    function,
                    kind,
                    is_static,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_class_prop<V: ?Sized + Fold>(_visitor: &mut V, n: ClassProp) -> ClassProp {
    {
        match n {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                computed,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                let span = _visitor.fold_span(span);
                let key = Box::new(_visitor.fold_expr(*key));
                let value = _visitor.fold_opt_expr(value);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                let decorators = _visitor.fold_decorators(decorators);
                let accessibility = _visitor.fold_opt_accessibility(accessibility);
                return ClassProp {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    computed,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                    readonly,
                    declare,
                    definite,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_computed_prop_name<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ComputedPropName,
) -> ComputedPropName {
    {
        match n {
            ComputedPropName { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return ComputedPropName { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_cond_expr<V: ?Sized + Fold>(_visitor: &mut V, n: CondExpr) -> CondExpr {
    {
        match n {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                let span = _visitor.fold_span(span);
                let test = Box::new(_visitor.fold_expr(*test));
                let cons = Box::new(_visitor.fold_expr(*cons));
                let alt = Box::new(_visitor.fold_expr(*alt));
                return CondExpr {
                    span,
                    test,
                    cons,
                    alt,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_constructor<V: ?Sized + Fold>(_visitor: &mut V, n: Constructor) -> Constructor {
    {
        match n {
            Constructor {
                span,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                let span = _visitor.fold_span(span);
                let key = _visitor.fold_prop_name(key);
                let params = _visitor.fold_param_or_ts_param_props(params);
                let body = _visitor.fold_opt_block_stmt(body);
                let accessibility = _visitor.fold_opt_accessibility(accessibility);
                return Constructor {
                    span,
                    key,
                    params,
                    body,
                    accessibility,
                    is_optional,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_continue_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: ContinueStmt) -> ContinueStmt {
    {
        match n {
            ContinueStmt { span, label } => {
                let span = _visitor.fold_span(span);
                let label = _visitor.fold_opt_ident(label);
                return ContinueStmt { span, label };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_debugger_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: DebuggerStmt) -> DebuggerStmt {
    {
        match n {
            DebuggerStmt { span } => {
                let span = _visitor.fold_span(span);
                return DebuggerStmt { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_decl<V: ?Sized + Fold>(_visitor: &mut V, n: Decl) -> Decl {
    {
        match n {
            Decl::Class { 0: _0 } => {
                let _0 = _visitor.fold_class_decl(_0);
                return Decl::Class { 0: _0 };
            }
            Decl::Fn { 0: _0 } => {
                let _0 = _visitor.fold_fn_decl(_0);
                return Decl::Fn { 0: _0 };
            }
            Decl::Var { 0: _0 } => {
                let _0 = _visitor.fold_var_decl(_0);
                return Decl::Var { 0: _0 };
            }
            Decl::TsInterface { 0: _0 } => {
                let _0 = _visitor.fold_ts_interface_decl(_0);
                return Decl::TsInterface { 0: _0 };
            }
            Decl::TsTypeAlias { 0: _0 } => {
                let _0 = _visitor.fold_ts_type_alias_decl(_0);
                return Decl::TsTypeAlias { 0: _0 };
            }
            Decl::TsEnum { 0: _0 } => {
                let _0 = _visitor.fold_ts_enum_decl(_0);
                return Decl::TsEnum { 0: _0 };
            }
            Decl::TsModule { 0: _0 } => {
                let _0 = _visitor.fold_ts_module_decl(_0);
                return Decl::TsModule { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_decorator<V: ?Sized + Fold>(_visitor: &mut V, n: Decorator) -> Decorator {
    {
        match n {
            Decorator { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return Decorator { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_decorators<V: ?Sized + Fold>(_visitor: &mut V, n: Vec<Decorator>) -> Vec<Decorator> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_decorator(v))
    }
}
#[allow(unused_variables)]
pub fn fold_default_decl<V: ?Sized + Fold>(_visitor: &mut V, n: DefaultDecl) -> DefaultDecl {
    {
        match n {
            DefaultDecl::Class { 0: _0 } => {
                let _0 = _visitor.fold_class_expr(_0);
                return DefaultDecl::Class { 0: _0 };
            }
            DefaultDecl::Fn { 0: _0 } => {
                let _0 = _visitor.fold_fn_expr(_0);
                return DefaultDecl::Fn { 0: _0 };
            }
            DefaultDecl::TsInterfaceDecl { 0: _0 } => {
                let _0 = _visitor.fold_ts_interface_decl(_0);
                return DefaultDecl::TsInterfaceDecl { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_do_while_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: DoWhileStmt) -> DoWhileStmt {
    {
        match n {
            DoWhileStmt { span, test, body } => {
                let span = _visitor.fold_span(span);
                let test = Box::new(_visitor.fold_expr(*test));
                let body = Box::new(_visitor.fold_stmt(*body));
                return DoWhileStmt { span, test, body };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_empty_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: EmptyStmt) -> EmptyStmt {
    {
        match n {
            EmptyStmt { span } => {
                let span = _visitor.fold_span(span);
                return EmptyStmt { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_export_all<V: ?Sized + Fold>(_visitor: &mut V, n: ExportAll) -> ExportAll {
    {
        match n {
            ExportAll { span, src, asserts } => {
                let span = _visitor.fold_span(span);
                let src = _visitor.fold_str(src);
                let asserts = _visitor.fold_opt_object_lit(asserts);
                return ExportAll { span, src, asserts };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_export_decl<V: ?Sized + Fold>(_visitor: &mut V, n: ExportDecl) -> ExportDecl {
    {
        match n {
            ExportDecl { span, decl } => {
                let span = _visitor.fold_span(span);
                let decl = _visitor.fold_decl(decl);
                return ExportDecl { span, decl };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_export_default_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ExportDefaultDecl,
) -> ExportDefaultDecl {
    {
        match n {
            ExportDefaultDecl { span, decl } => {
                let span = _visitor.fold_span(span);
                let decl = _visitor.fold_default_decl(decl);
                return ExportDefaultDecl { span, decl };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_export_default_expr<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ExportDefaultExpr,
) -> ExportDefaultExpr {
    {
        match n {
            ExportDefaultExpr { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return ExportDefaultExpr { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_export_default_specifier<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ExportDefaultSpecifier,
) -> ExportDefaultSpecifier {
    {
        match n {
            ExportDefaultSpecifier { exported } => {
                let exported = _visitor.fold_ident(exported);
                return ExportDefaultSpecifier { exported };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_export_named_specifier<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ExportNamedSpecifier,
) -> ExportNamedSpecifier {
    {
        match n {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
            } => {
                let span = _visitor.fold_span(span);
                let orig = _visitor.fold_ident(orig);
                let exported = _visitor.fold_opt_ident(exported);
                return ExportNamedSpecifier {
                    span,
                    orig,
                    exported,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_export_namespace_specifier<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ExportNamespaceSpecifier,
) -> ExportNamespaceSpecifier {
    {
        match n {
            ExportNamespaceSpecifier { span, name } => {
                let span = _visitor.fold_span(span);
                let name = _visitor.fold_ident(name);
                return ExportNamespaceSpecifier { span, name };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_export_specifier<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ExportSpecifier,
) -> ExportSpecifier {
    {
        match n {
            ExportSpecifier::Namespace { 0: _0 } => {
                let _0 = _visitor.fold_export_namespace_specifier(_0);
                return ExportSpecifier::Namespace { 0: _0 };
            }
            ExportSpecifier::Default { 0: _0 } => {
                let _0 = _visitor.fold_export_default_specifier(_0);
                return ExportSpecifier::Default { 0: _0 };
            }
            ExportSpecifier::Named { 0: _0 } => {
                let _0 = _visitor.fold_export_named_specifier(_0);
                return ExportSpecifier::Named { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_export_specifiers<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<ExportSpecifier>,
) -> Vec<ExportSpecifier> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_export_specifier(v))
    }
}
#[allow(unused_variables)]
pub fn fold_expr<V: ?Sized + Fold>(_visitor: &mut V, n: Expr) -> Expr {
    {
        match n {
            Expr::This { 0: _0 } => {
                let _0 = _visitor.fold_this_expr(_0);
                return Expr::This { 0: _0 };
            }
            Expr::Array { 0: _0 } => {
                let _0 = _visitor.fold_array_lit(_0);
                return Expr::Array { 0: _0 };
            }
            Expr::Object { 0: _0 } => {
                let _0 = _visitor.fold_object_lit(_0);
                return Expr::Object { 0: _0 };
            }
            Expr::Fn { 0: _0 } => {
                let _0 = _visitor.fold_fn_expr(_0);
                return Expr::Fn { 0: _0 };
            }
            Expr::Unary { 0: _0 } => {
                let _0 = _visitor.fold_unary_expr(_0);
                return Expr::Unary { 0: _0 };
            }
            Expr::Update { 0: _0 } => {
                let _0 = _visitor.fold_update_expr(_0);
                return Expr::Update { 0: _0 };
            }
            Expr::Bin { 0: _0 } => {
                let _0 = _visitor.fold_bin_expr(_0);
                return Expr::Bin { 0: _0 };
            }
            Expr::Assign { 0: _0 } => {
                let _0 = _visitor.fold_assign_expr(_0);
                return Expr::Assign { 0: _0 };
            }
            Expr::Member { 0: _0 } => {
                let _0 = _visitor.fold_member_expr(_0);
                return Expr::Member { 0: _0 };
            }
            Expr::Cond { 0: _0 } => {
                let _0 = _visitor.fold_cond_expr(_0);
                return Expr::Cond { 0: _0 };
            }
            Expr::Call { 0: _0 } => {
                let _0 = _visitor.fold_call_expr(_0);
                return Expr::Call { 0: _0 };
            }
            Expr::New { 0: _0 } => {
                let _0 = _visitor.fold_new_expr(_0);
                return Expr::New { 0: _0 };
            }
            Expr::Seq { 0: _0 } => {
                let _0 = _visitor.fold_seq_expr(_0);
                return Expr::Seq { 0: _0 };
            }
            Expr::Ident { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return Expr::Ident { 0: _0 };
            }
            Expr::Lit { 0: _0 } => {
                let _0 = _visitor.fold_lit(_0);
                return Expr::Lit { 0: _0 };
            }
            Expr::Tpl { 0: _0 } => {
                let _0 = _visitor.fold_tpl(_0);
                return Expr::Tpl { 0: _0 };
            }
            Expr::TaggedTpl { 0: _0 } => {
                let _0 = _visitor.fold_tagged_tpl(_0);
                return Expr::TaggedTpl { 0: _0 };
            }
            Expr::Arrow { 0: _0 } => {
                let _0 = _visitor.fold_arrow_expr(_0);
                return Expr::Arrow { 0: _0 };
            }
            Expr::Class { 0: _0 } => {
                let _0 = _visitor.fold_class_expr(_0);
                return Expr::Class { 0: _0 };
            }
            Expr::Yield { 0: _0 } => {
                let _0 = _visitor.fold_yield_expr(_0);
                return Expr::Yield { 0: _0 };
            }
            Expr::MetaProp { 0: _0 } => {
                let _0 = _visitor.fold_meta_prop_expr(_0);
                return Expr::MetaProp { 0: _0 };
            }
            Expr::Await { 0: _0 } => {
                let _0 = _visitor.fold_await_expr(_0);
                return Expr::Await { 0: _0 };
            }
            Expr::Paren { 0: _0 } => {
                let _0 = _visitor.fold_paren_expr(_0);
                return Expr::Paren { 0: _0 };
            }
            Expr::JSXMember { 0: _0 } => {
                let _0 = _visitor.fold_jsx_member_expr(_0);
                return Expr::JSXMember { 0: _0 };
            }
            Expr::JSXNamespacedName { 0: _0 } => {
                let _0 = _visitor.fold_jsx_namespaced_name(_0);
                return Expr::JSXNamespacedName { 0: _0 };
            }
            Expr::JSXEmpty { 0: _0 } => {
                let _0 = _visitor.fold_jsx_empty_expr(_0);
                return Expr::JSXEmpty { 0: _0 };
            }
            Expr::JSXElement { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_jsx_element(*_0));
                return Expr::JSXElement { 0: _0 };
            }
            Expr::JSXFragment { 0: _0 } => {
                let _0 = _visitor.fold_jsx_fragment(_0);
                return Expr::JSXFragment { 0: _0 };
            }
            Expr::TsTypeAssertion { 0: _0 } => {
                let _0 = _visitor.fold_ts_type_assertion(_0);
                return Expr::TsTypeAssertion { 0: _0 };
            }
            Expr::TsConstAssertion { 0: _0 } => {
                let _0 = _visitor.fold_ts_const_assertion(_0);
                return Expr::TsConstAssertion { 0: _0 };
            }
            Expr::TsNonNull { 0: _0 } => {
                let _0 = _visitor.fold_ts_non_null_expr(_0);
                return Expr::TsNonNull { 0: _0 };
            }
            Expr::TsAs { 0: _0 } => {
                let _0 = _visitor.fold_ts_as_expr(_0);
                return Expr::TsAs { 0: _0 };
            }
            Expr::PrivateName { 0: _0 } => {
                let _0 = _visitor.fold_private_name(_0);
                return Expr::PrivateName { 0: _0 };
            }
            Expr::OptChain { 0: _0 } => {
                let _0 = _visitor.fold_opt_chain_expr(_0);
                return Expr::OptChain { 0: _0 };
            }
            Expr::Invalid { 0: _0 } => {
                let _0 = _visitor.fold_invalid(_0);
                return Expr::Invalid { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_expr_or_spread<V: ?Sized + Fold>(_visitor: &mut V, n: ExprOrSpread) -> ExprOrSpread {
    {
        match n {
            ExprOrSpread { spread, expr } => {
                let spread = _visitor.fold_opt_span(spread);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return ExprOrSpread { spread, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_expr_or_spreads<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<ExprOrSpread>,
) -> Vec<ExprOrSpread> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_expr_or_spread(v))
    }
}
#[allow(unused_variables)]
pub fn fold_expr_or_super<V: ?Sized + Fold>(_visitor: &mut V, n: ExprOrSuper) -> ExprOrSuper {
    {
        match n {
            ExprOrSuper::Super { 0: _0 } => {
                let _0 = _visitor.fold_super(_0);
                return ExprOrSuper::Super { 0: _0 };
            }
            ExprOrSuper::Expr { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_expr(*_0));
                return ExprOrSuper::Expr { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_expr_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: ExprStmt) -> ExprStmt {
    {
        match n {
            ExprStmt { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return ExprStmt { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_exprs<V: ?Sized + Fold>(_visitor: &mut V, n: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| {
            global_visit::util::map::Map::map(v, |v| _visitor.fold_expr(v))
        })
    }
}
#[allow(unused_variables)]
pub fn fold_fn_decl<V: ?Sized + Fold>(_visitor: &mut V, n: FnDecl) -> FnDecl {
    {
        match n {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                let ident = _visitor.fold_ident(ident);
                let function = _visitor.fold_function(function);
                return FnDecl {
                    ident,
                    declare,
                    function,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_fn_expr<V: ?Sized + Fold>(_visitor: &mut V, n: FnExpr) -> FnExpr {
    {
        match n {
            FnExpr { ident, function } => {
                let ident = _visitor.fold_opt_ident(ident);
                let function = _visitor.fold_function(function);
                return FnExpr { ident, function };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_for_in_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: ForInStmt) -> ForInStmt {
    {
        match n {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                let span = _visitor.fold_span(span);
                let left = _visitor.fold_var_decl_or_pat(left);
                let right = Box::new(_visitor.fold_expr(*right));
                let body = Box::new(_visitor.fold_stmt(*body));
                return ForInStmt {
                    span,
                    left,
                    right,
                    body,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_for_of_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: ForOfStmt) -> ForOfStmt {
    {
        match n {
            ForOfStmt {
                span,
                await_token,
                left,
                right,
                body,
            } => {
                let span = _visitor.fold_span(span);
                let await_token = _visitor.fold_opt_span(await_token);
                let left = _visitor.fold_var_decl_or_pat(left);
                let right = Box::new(_visitor.fold_expr(*right));
                let body = Box::new(_visitor.fold_stmt(*body));
                return ForOfStmt {
                    span,
                    await_token,
                    left,
                    right,
                    body,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_for_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: ForStmt) -> ForStmt {
    {
        match n {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                let span = _visitor.fold_span(span);
                let init = _visitor.fold_opt_var_decl_or_expr(init);
                let test = _visitor.fold_opt_expr(test);
                let update = _visitor.fold_opt_expr(update);
                let body = Box::new(_visitor.fold_stmt(*body));
                return ForStmt {
                    span,
                    init,
                    test,
                    update,
                    body,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_function<V: ?Sized + Fold>(_visitor: &mut V, n: Function) -> Function {
    {
        match n {
            Function {
                params,
                decorators,
                span,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                let params = _visitor.fold_params(params);
                let decorators = _visitor.fold_decorators(decorators);
                let span = _visitor.fold_span(span);
                let body = _visitor.fold_opt_block_stmt(body);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                let return_type = _visitor.fold_opt_ts_type_ann(return_type);
                return Function {
                    params,
                    decorators,
                    span,
                    body,
                    is_generator,
                    is_async,
                    type_params,
                    return_type,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_getter_prop<V: ?Sized + Fold>(_visitor: &mut V, n: GetterProp) -> GetterProp {
    {
        match n {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                let span = _visitor.fold_span(span);
                let key = _visitor.fold_prop_name(key);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                let body = _visitor.fold_opt_block_stmt(body);
                return GetterProp {
                    span,
                    key,
                    type_ann,
                    body,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ident<V: ?Sized + Fold>(_visitor: &mut V, n: Ident) -> Ident {
    {
        match n {
            Ident {
                span,
                sym,
                optional,
            } => {
                let span = _visitor.fold_span(span);
                let sym = _visitor.fold_js_word(sym);
                return Ident {
                    span,
                    sym,
                    optional,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_if_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: IfStmt) -> IfStmt {
    {
        match n {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                let span = _visitor.fold_span(span);
                let test = Box::new(_visitor.fold_expr(*test));
                let cons = Box::new(_visitor.fold_stmt(*cons));
                let alt = _visitor.fold_opt_stmt(alt);
                return IfStmt {
                    span,
                    test,
                    cons,
                    alt,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_import_decl<V: ?Sized + Fold>(_visitor: &mut V, n: ImportDecl) -> ImportDecl {
    {
        match n {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                asserts,
            } => {
                let span = _visitor.fold_span(span);
                let specifiers = _visitor.fold_import_specifiers(specifiers);
                let src = _visitor.fold_str(src);
                let asserts = _visitor.fold_opt_object_lit(asserts);
                return ImportDecl {
                    span,
                    specifiers,
                    src,
                    type_only,
                    asserts,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_import_default_specifier<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ImportDefaultSpecifier,
) -> ImportDefaultSpecifier {
    {
        match n {
            ImportDefaultSpecifier { span, local } => {
                let span = _visitor.fold_span(span);
                let local = _visitor.fold_ident(local);
                return ImportDefaultSpecifier { span, local };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_import_named_specifier<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ImportNamedSpecifier,
) -> ImportNamedSpecifier {
    {
        match n {
            ImportNamedSpecifier {
                span,
                local,
                imported,
            } => {
                let span = _visitor.fold_span(span);
                let local = _visitor.fold_ident(local);
                let imported = _visitor.fold_opt_ident(imported);
                return ImportNamedSpecifier {
                    span,
                    local,
                    imported,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_import_specifier<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ImportSpecifier,
) -> ImportSpecifier {
    {
        match n {
            ImportSpecifier::Named { 0: _0 } => {
                let _0 = _visitor.fold_import_named_specifier(_0);
                return ImportSpecifier::Named { 0: _0 };
            }
            ImportSpecifier::Default { 0: _0 } => {
                let _0 = _visitor.fold_import_default_specifier(_0);
                return ImportSpecifier::Default { 0: _0 };
            }
            ImportSpecifier::Namespace { 0: _0 } => {
                let _0 = _visitor.fold_import_star_as_specifier(_0);
                return ImportSpecifier::Namespace { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_import_specifiers<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<ImportSpecifier>,
) -> Vec<ImportSpecifier> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_import_specifier(v))
    }
}
#[allow(unused_variables)]
pub fn fold_import_star_as_specifier<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ImportStarAsSpecifier,
) -> ImportStarAsSpecifier {
    {
        match n {
            ImportStarAsSpecifier { span, local } => {
                let span = _visitor.fold_span(span);
                let local = _visitor.fold_ident(local);
                return ImportStarAsSpecifier { span, local };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_invalid<V: ?Sized + Fold>(_visitor: &mut V, n: Invalid) -> Invalid {
    {
        match n {
            Invalid { span } => {
                let span = _visitor.fold_span(span);
                return Invalid { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_js_word<V: ?Sized + Fold>(_visitor: &mut V, n: JsWord) -> JsWord {
    {
        return n;
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_attr<V: ?Sized + Fold>(_visitor: &mut V, n: JSXAttr) -> JSXAttr {
    {
        match n {
            JSXAttr { span, name, value } => {
                let span = _visitor.fold_span(span);
                let name = _visitor.fold_jsx_attr_name(name);
                let value = _visitor.fold_opt_jsx_attr_value(value);
                return JSXAttr { span, name, value };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_attr_name<V: ?Sized + Fold>(_visitor: &mut V, n: JSXAttrName) -> JSXAttrName {
    {
        match n {
            JSXAttrName::Ident { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return JSXAttrName::Ident { 0: _0 };
            }
            JSXAttrName::JSXNamespacedName { 0: _0 } => {
                let _0 = _visitor.fold_jsx_namespaced_name(_0);
                return JSXAttrName::JSXNamespacedName { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_attr_or_spread<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXAttrOrSpread,
) -> JSXAttrOrSpread {
    {
        match n {
            JSXAttrOrSpread::JSXAttr { 0: _0 } => {
                let _0 = _visitor.fold_jsx_attr(_0);
                return JSXAttrOrSpread::JSXAttr { 0: _0 };
            }
            JSXAttrOrSpread::SpreadElement { 0: _0 } => {
                let _0 = _visitor.fold_spread_element(_0);
                return JSXAttrOrSpread::SpreadElement { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_attr_or_spreads<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<JSXAttrOrSpread>,
) -> Vec<JSXAttrOrSpread> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_jsx_attr_or_spread(v))
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_attr_value<V: ?Sized + Fold>(_visitor: &mut V, n: JSXAttrValue) -> JSXAttrValue {
    {
        match n {
            JSXAttrValue::Lit { 0: _0 } => {
                let _0 = _visitor.fold_lit(_0);
                return JSXAttrValue::Lit { 0: _0 };
            }
            JSXAttrValue::JSXExprContainer { 0: _0 } => {
                let _0 = _visitor.fold_jsx_expr_container(_0);
                return JSXAttrValue::JSXExprContainer { 0: _0 };
            }
            JSXAttrValue::JSXElement { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_jsx_element(*_0));
                return JSXAttrValue::JSXElement { 0: _0 };
            }
            JSXAttrValue::JSXFragment { 0: _0 } => {
                let _0 = _visitor.fold_jsx_fragment(_0);
                return JSXAttrValue::JSXFragment { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_closing_element<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXClosingElement,
) -> JSXClosingElement {
    {
        match n {
            JSXClosingElement { span, name } => {
                let span = _visitor.fold_span(span);
                let name = _visitor.fold_jsx_element_name(name);
                return JSXClosingElement { span, name };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_closing_fragment<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXClosingFragment,
) -> JSXClosingFragment {
    {
        match n {
            JSXClosingFragment { span } => {
                let span = _visitor.fold_span(span);
                return JSXClosingFragment { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_element<V: ?Sized + Fold>(_visitor: &mut V, n: JSXElement) -> JSXElement {
    {
        match n {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                let span = _visitor.fold_span(span);
                let opening = _visitor.fold_jsx_opening_element(opening);
                let children = _visitor.fold_jsx_element_children(children);
                let closing = _visitor.fold_opt_jsx_closing_element(closing);
                return JSXElement {
                    span,
                    opening,
                    children,
                    closing,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_element_child<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXElementChild,
) -> JSXElementChild {
    {
        match n {
            JSXElementChild::JSXText { 0: _0 } => {
                let _0 = _visitor.fold_jsx_text(_0);
                return JSXElementChild::JSXText { 0: _0 };
            }
            JSXElementChild::JSXExprContainer { 0: _0 } => {
                let _0 = _visitor.fold_jsx_expr_container(_0);
                return JSXElementChild::JSXExprContainer { 0: _0 };
            }
            JSXElementChild::JSXSpreadChild { 0: _0 } => {
                let _0 = _visitor.fold_jsx_spread_child(_0);
                return JSXElementChild::JSXSpreadChild { 0: _0 };
            }
            JSXElementChild::JSXElement { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_jsx_element(*_0));
                return JSXElementChild::JSXElement { 0: _0 };
            }
            JSXElementChild::JSXFragment { 0: _0 } => {
                let _0 = _visitor.fold_jsx_fragment(_0);
                return JSXElementChild::JSXFragment { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_element_children<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<JSXElementChild>,
) -> Vec<JSXElementChild> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_jsx_element_child(v))
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_element_name<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXElementName,
) -> JSXElementName {
    {
        match n {
            JSXElementName::Ident { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return JSXElementName::Ident { 0: _0 };
            }
            JSXElementName::JSXMemberExpr { 0: _0 } => {
                let _0 = _visitor.fold_jsx_member_expr(_0);
                return JSXElementName::JSXMemberExpr { 0: _0 };
            }
            JSXElementName::JSXNamespacedName { 0: _0 } => {
                let _0 = _visitor.fold_jsx_namespaced_name(_0);
                return JSXElementName::JSXNamespacedName { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_empty_expr<V: ?Sized + Fold>(_visitor: &mut V, n: JSXEmptyExpr) -> JSXEmptyExpr {
    {
        match n {
            JSXEmptyExpr { span } => {
                let span = _visitor.fold_span(span);
                return JSXEmptyExpr { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_expr<V: ?Sized + Fold>(_visitor: &mut V, n: JSXExpr) -> JSXExpr {
    {
        match n {
            JSXExpr::JSXEmptyExpr { 0: _0 } => {
                let _0 = _visitor.fold_jsx_empty_expr(_0);
                return JSXExpr::JSXEmptyExpr { 0: _0 };
            }
            JSXExpr::Expr { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_expr(*_0));
                return JSXExpr::Expr { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_expr_container<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXExprContainer,
) -> JSXExprContainer {
    {
        match n {
            JSXExprContainer { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = _visitor.fold_jsx_expr(expr);
                return JSXExprContainer { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_fragment<V: ?Sized + Fold>(_visitor: &mut V, n: JSXFragment) -> JSXFragment {
    {
        match n {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                let span = _visitor.fold_span(span);
                let opening = _visitor.fold_jsx_opening_fragment(opening);
                let children = _visitor.fold_jsx_element_children(children);
                let closing = _visitor.fold_jsx_closing_fragment(closing);
                return JSXFragment {
                    span,
                    opening,
                    children,
                    closing,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_member_expr<V: ?Sized + Fold>(_visitor: &mut V, n: JSXMemberExpr) -> JSXMemberExpr {
    {
        match n {
            JSXMemberExpr { obj, prop } => {
                let obj = _visitor.fold_jsx_object(obj);
                let prop = _visitor.fold_ident(prop);
                return JSXMemberExpr { obj, prop };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_namespaced_name<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXNamespacedName,
) -> JSXNamespacedName {
    {
        match n {
            JSXNamespacedName { ns, name } => {
                let ns = _visitor.fold_ident(ns);
                let name = _visitor.fold_ident(name);
                return JSXNamespacedName { ns, name };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_object<V: ?Sized + Fold>(_visitor: &mut V, n: JSXObject) -> JSXObject {
    {
        match n {
            JSXObject::JSXMemberExpr { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_jsx_member_expr(*_0));
                return JSXObject::JSXMemberExpr { 0: _0 };
            }
            JSXObject::Ident { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return JSXObject::Ident { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_opening_element<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXOpeningElement,
) -> JSXOpeningElement {
    {
        match n {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                let name = _visitor.fold_jsx_element_name(name);
                let span = _visitor.fold_span(span);
                let attrs = _visitor.fold_jsx_attr_or_spreads(attrs);
                let type_args = _visitor.fold_opt_ts_type_param_instantiation(type_args);
                return JSXOpeningElement {
                    name,
                    span,
                    attrs,
                    self_closing,
                    type_args,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_opening_fragment<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXOpeningFragment,
) -> JSXOpeningFragment {
    {
        match n {
            JSXOpeningFragment { span } => {
                let span = _visitor.fold_span(span);
                return JSXOpeningFragment { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_spread_child<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: JSXSpreadChild,
) -> JSXSpreadChild {
    {
        match n {
            JSXSpreadChild { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return JSXSpreadChild { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_jsx_text<V: ?Sized + Fold>(_visitor: &mut V, n: JSXText) -> JSXText {
    {
        match n {
            JSXText { span, value, raw } => {
                let span = _visitor.fold_span(span);
                let value = _visitor.fold_js_word(value);
                let raw = _visitor.fold_js_word(raw);
                return JSXText { span, value, raw };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_key_value_pat_prop<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: KeyValuePatProp,
) -> KeyValuePatProp {
    {
        match n {
            KeyValuePatProp { key, value } => {
                let key = _visitor.fold_prop_name(key);
                let value = Box::new(_visitor.fold_pat(*value));
                return KeyValuePatProp { key, value };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_key_value_prop<V: ?Sized + Fold>(_visitor: &mut V, n: KeyValueProp) -> KeyValueProp {
    {
        match n {
            KeyValueProp { key, value } => {
                let key = _visitor.fold_prop_name(key);
                let value = Box::new(_visitor.fold_expr(*value));
                return KeyValueProp { key, value };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_labeled_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: LabeledStmt) -> LabeledStmt {
    {
        match n {
            LabeledStmt { span, label, body } => {
                let span = _visitor.fold_span(span);
                let label = _visitor.fold_ident(label);
                let body = Box::new(_visitor.fold_stmt(*body));
                return LabeledStmt { span, label, body };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_lit<V: ?Sized + Fold>(_visitor: &mut V, n: Lit) -> Lit {
    {
        match n {
            Lit::Str { 0: _0 } => {
                let _0 = _visitor.fold_str(_0);
                return Lit::Str { 0: _0 };
            }
            Lit::Bool { 0: _0 } => {
                let _0 = _visitor.fold_bool(_0);
                return Lit::Bool { 0: _0 };
            }
            Lit::Null { 0: _0 } => {
                let _0 = _visitor.fold_null(_0);
                return Lit::Null { 0: _0 };
            }
            Lit::Num { 0: _0 } => {
                let _0 = _visitor.fold_number(_0);
                return Lit::Num { 0: _0 };
            }
            Lit::BigInt { 0: _0 } => {
                let _0 = _visitor.fold_big_int(_0);
                return Lit::BigInt { 0: _0 };
            }
            Lit::Regex { 0: _0 } => {
                let _0 = _visitor.fold_regex(_0);
                return Lit::Regex { 0: _0 };
            }
            Lit::JSXText { 0: _0 } => {
                let _0 = _visitor.fold_jsx_text(_0);
                return Lit::JSXText { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_member_expr<V: ?Sized + Fold>(_visitor: &mut V, n: MemberExpr) -> MemberExpr {
    {
        match n {
            MemberExpr {
                span,
                obj,
                prop,
                computed,
            } => {
                let span = _visitor.fold_span(span);
                let obj = _visitor.fold_expr_or_super(obj);
                let prop = Box::new(_visitor.fold_expr(*prop));
                return MemberExpr {
                    span,
                    obj,
                    prop,
                    computed,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_meta_prop_expr<V: ?Sized + Fold>(_visitor: &mut V, n: MetaPropExpr) -> MetaPropExpr {
    {
        match n {
            MetaPropExpr { meta, prop } => {
                let meta = _visitor.fold_ident(meta);
                let prop = _visitor.fold_ident(prop);
                return MetaPropExpr { meta, prop };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_method_kind<V: ?Sized + Fold>(_visitor: &mut V, n: MethodKind) -> MethodKind {
    {
        match n {
            MethodKind::Method {} => {
                return MethodKind::Method {};
            }
            MethodKind::Getter {} => {
                return MethodKind::Getter {};
            }
            MethodKind::Setter {} => {
                return MethodKind::Setter {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_method_prop<V: ?Sized + Fold>(_visitor: &mut V, n: MethodProp) -> MethodProp {
    {
        match n {
            MethodProp { key, function } => {
                let key = _visitor.fold_prop_name(key);
                let function = _visitor.fold_function(function);
                return MethodProp { key, function };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_module<V: ?Sized + Fold>(_visitor: &mut V, n: Module) -> Module {
    {
        match n {
            Module {
                span,
                body,
                shebang,
            } => {
                let span = _visitor.fold_span(span);
                let body = _visitor.fold_module_items(body);
                let shebang = _visitor.fold_opt_js_word(shebang);
                return Module {
                    span,
                    body,
                    shebang,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_module_decl<V: ?Sized + Fold>(_visitor: &mut V, n: ModuleDecl) -> ModuleDecl {
    {
        match n {
            ModuleDecl::Import { 0: _0 } => {
                let _0 = _visitor.fold_import_decl(_0);
                return ModuleDecl::Import { 0: _0 };
            }
            ModuleDecl::ExportDecl { 0: _0 } => {
                let _0 = _visitor.fold_export_decl(_0);
                return ModuleDecl::ExportDecl { 0: _0 };
            }
            ModuleDecl::ExportNamed { 0: _0 } => {
                let _0 = _visitor.fold_named_export(_0);
                return ModuleDecl::ExportNamed { 0: _0 };
            }
            ModuleDecl::ExportDefaultDecl { 0: _0 } => {
                let _0 = _visitor.fold_export_default_decl(_0);
                return ModuleDecl::ExportDefaultDecl { 0: _0 };
            }
            ModuleDecl::ExportDefaultExpr { 0: _0 } => {
                let _0 = _visitor.fold_export_default_expr(_0);
                return ModuleDecl::ExportDefaultExpr { 0: _0 };
            }
            ModuleDecl::ExportAll { 0: _0 } => {
                let _0 = _visitor.fold_export_all(_0);
                return ModuleDecl::ExportAll { 0: _0 };
            }
            ModuleDecl::TsImportEquals { 0: _0 } => {
                let _0 = _visitor.fold_ts_import_equals_decl(_0);
                return ModuleDecl::TsImportEquals { 0: _0 };
            }
            ModuleDecl::TsExportAssignment { 0: _0 } => {
                let _0 = _visitor.fold_ts_export_assignment(_0);
                return ModuleDecl::TsExportAssignment { 0: _0 };
            }
            ModuleDecl::TsNamespaceExport { 0: _0 } => {
                let _0 = _visitor.fold_ts_namespace_export_decl(_0);
                return ModuleDecl::TsNamespaceExport { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_module_item<V: ?Sized + Fold>(_visitor: &mut V, n: ModuleItem) -> ModuleItem {
    {
        match n {
            ModuleItem::ModuleDecl { 0: _0 } => {
                let _0 = _visitor.fold_module_decl(_0);
                return ModuleItem::ModuleDecl { 0: _0 };
            }
            ModuleItem::Stmt { 0: _0 } => {
                let _0 = _visitor.fold_stmt(_0);
                return ModuleItem::Stmt { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_module_items<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<ModuleItem>,
) -> Vec<ModuleItem> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_module_item(v))
    }
}
#[allow(unused_variables)]
pub fn fold_named_export<V: ?Sized + Fold>(_visitor: &mut V, n: NamedExport) -> NamedExport {
    {
        match n {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                asserts,
            } => {
                let span = _visitor.fold_span(span);
                let specifiers = _visitor.fold_export_specifiers(specifiers);
                let src = _visitor.fold_opt_str(src);
                let asserts = _visitor.fold_opt_object_lit(asserts);
                return NamedExport {
                    span,
                    specifiers,
                    src,
                    type_only,
                    asserts,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_new_expr<V: ?Sized + Fold>(_visitor: &mut V, n: NewExpr) -> NewExpr {
    {
        match n {
            NewExpr {
                span,
                callee,
                args,
                type_args,
            } => {
                let span = _visitor.fold_span(span);
                let callee = Box::new(_visitor.fold_expr(*callee));
                let args = _visitor.fold_opt_expr_or_spreads(args);
                let type_args = _visitor.fold_opt_ts_type_param_instantiation(type_args);
                return NewExpr {
                    span,
                    callee,
                    args,
                    type_args,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_null<V: ?Sized + Fold>(_visitor: &mut V, n: Null) -> Null {
    {
        match n {
            Null { span } => {
                let span = _visitor.fold_span(span);
                return Null { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_number<V: ?Sized + Fold>(_visitor: &mut V, n: Number) -> Number {
    {
        match n {
            Number { span, value } => {
                let span = _visitor.fold_span(span);
                return Number { span, value };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_object_lit<V: ?Sized + Fold>(_visitor: &mut V, n: ObjectLit) -> ObjectLit {
    {
        match n {
            ObjectLit { span, props } => {
                let span = _visitor.fold_span(span);
                let props = _visitor.fold_prop_or_spreads(props);
                return ObjectLit { span, props };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_object_pat<V: ?Sized + Fold>(_visitor: &mut V, n: ObjectPat) -> ObjectPat {
    {
        match n {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let props = _visitor.fold_object_pat_props(props);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                return ObjectPat {
                    span,
                    props,
                    optional,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_object_pat_prop<V: ?Sized + Fold>(_visitor: &mut V, n: ObjectPatProp) -> ObjectPatProp {
    {
        match n {
            ObjectPatProp::KeyValue { 0: _0 } => {
                let _0 = _visitor.fold_key_value_pat_prop(_0);
                return ObjectPatProp::KeyValue { 0: _0 };
            }
            ObjectPatProp::Assign { 0: _0 } => {
                let _0 = _visitor.fold_assign_pat_prop(_0);
                return ObjectPatProp::Assign { 0: _0 };
            }
            ObjectPatProp::Rest { 0: _0 } => {
                let _0 = _visitor.fold_rest_pat(_0);
                return ObjectPatProp::Rest { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_object_pat_props<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<ObjectPatProp>,
) -> Vec<ObjectPatProp> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_object_pat_prop(v))
    }
}
#[allow(unused_variables)]
pub fn fold_opt_accessibility<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<Accessibility>,
) -> Option<Accessibility> {
    {
        match n {
            Some(n) => Some(_visitor.fold_accessibility(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_block_stmt<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<BlockStmt>,
) -> Option<BlockStmt> {
    {
        match n {
            Some(n) => Some(_visitor.fold_block_stmt(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_catch_clause<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<CatchClause>,
) -> Option<CatchClause> {
    {
        match n {
            Some(n) => Some(_visitor.fold_catch_clause(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_chain_expr<V: ?Sized + Fold>(_visitor: &mut V, n: OptChainExpr) -> OptChainExpr {
    {
        match n {
            OptChainExpr {
                span,
                question_dot_token,
                expr,
            } => {
                let span = _visitor.fold_span(span);
                let question_dot_token = _visitor.fold_span(question_dot_token);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return OptChainExpr {
                    span,
                    question_dot_token,
                    expr,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_expr<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<Box<Expr>>,
) -> Option<Box<Expr>> {
    {
        match n {
            Some(n) => Some(global_visit::util::map::Map::map(n, |n| {
                _visitor.fold_expr(n)
            })),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_expr_or_spread<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<ExprOrSpread>,
) -> Option<ExprOrSpread> {
    {
        match n {
            Some(n) => Some(_visitor.fold_expr_or_spread(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_expr_or_spreads<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<Vec<ExprOrSpread>>,
) -> Option<Vec<ExprOrSpread>> {
    {
        match n {
            Some(n) => Some(_visitor.fold_expr_or_spreads(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_ident<V: ?Sized + Fold>(_visitor: &mut V, n: Option<Ident>) -> Option<Ident> {
    {
        match n {
            Some(n) => Some(_visitor.fold_ident(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_js_word<V: ?Sized + Fold>(_visitor: &mut V, n: Option<JsWord>) -> Option<JsWord> {
    {
        match n {
            Some(n) => Some(_visitor.fold_js_word(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_jsx_attr_value<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<JSXAttrValue>,
) -> Option<JSXAttrValue> {
    {
        match n {
            Some(n) => Some(_visitor.fold_jsx_attr_value(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_jsx_closing_element<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<JSXClosingElement>,
) -> Option<JSXClosingElement> {
    {
        match n {
            Some(n) => Some(_visitor.fold_jsx_closing_element(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_object_lit<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<ObjectLit>,
) -> Option<ObjectLit> {
    {
        match n {
            Some(n) => Some(_visitor.fold_object_lit(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_pat<V: ?Sized + Fold>(_visitor: &mut V, n: Option<Pat>) -> Option<Pat> {
    {
        match n {
            Some(n) => Some(_visitor.fold_pat(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_span<V: ?Sized + Fold>(_visitor: &mut V, n: Option<Span>) -> Option<Span> {
    {
        match n {
            Some(n) => Some(_visitor.fold_span(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_stmt<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<Box<Stmt>>,
) -> Option<Box<Stmt>> {
    {
        match n {
            Some(n) => Some(global_visit::util::map::Map::map(n, |n| {
                _visitor.fold_stmt(n)
            })),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_str<V: ?Sized + Fold>(_visitor: &mut V, n: Option<Str>) -> Option<Str> {
    {
        match n {
            Some(n) => Some(_visitor.fold_str(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_true_plus_minus<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<TruePlusMinus>,
) -> Option<TruePlusMinus> {
    {
        match n {
            Some(n) => Some(_visitor.fold_true_plus_minus(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_ts_entity_name<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<TsEntityName>,
) -> Option<TsEntityName> {
    {
        match n {
            Some(n) => Some(_visitor.fold_ts_entity_name(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_ts_namespace_body<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<TsNamespaceBody>,
) -> Option<TsNamespaceBody> {
    {
        match n {
            Some(n) => Some(_visitor.fold_ts_namespace_body(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_ts_type<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<Box<TsType>>,
) -> Option<Box<TsType>> {
    {
        match n {
            Some(n) => Some(global_visit::util::map::Map::map(n, |n| {
                _visitor.fold_ts_type(n)
            })),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_ts_type_ann<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<TsTypeAnn>,
) -> Option<TsTypeAnn> {
    {
        match n {
            Some(n) => Some(_visitor.fold_ts_type_ann(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_ts_type_param_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<TsTypeParamDecl>,
) -> Option<TsTypeParamDecl> {
    {
        match n {
            Some(n) => Some(_visitor.fold_ts_type_param_decl(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_ts_type_param_instantiation<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<TsTypeParamInstantiation>,
) -> Option<TsTypeParamInstantiation> {
    {
        match n {
            Some(n) => Some(_visitor.fold_ts_type_param_instantiation(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_var_decl_or_expr<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Option<VarDeclOrExpr>,
) -> Option<VarDeclOrExpr> {
    {
        match n {
            Some(n) => Some(_visitor.fold_var_decl_or_expr(n)),
            None => None,
        }
    }
}
#[allow(unused_variables)]
pub fn fold_opt_vec_expr_or_spreads<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<Option<ExprOrSpread>>,
) -> Vec<Option<ExprOrSpread>> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_opt_expr_or_spread(v))
    }
}
#[allow(unused_variables)]
pub fn fold_opt_vec_pats<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<Option<Pat>>,
) -> Vec<Option<Pat>> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_opt_pat(v))
    }
}
#[allow(unused_variables)]
pub fn fold_param<V: ?Sized + Fold>(_visitor: &mut V, n: Param) -> Param {
    {
        match n {
            Param {
                span,
                decorators,
                pat,
            } => {
                let span = _visitor.fold_span(span);
                let decorators = _visitor.fold_decorators(decorators);
                let pat = _visitor.fold_pat(pat);
                return Param {
                    span,
                    decorators,
                    pat,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_param_or_ts_param_prop<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: ParamOrTsParamProp,
) -> ParamOrTsParamProp {
    {
        match n {
            ParamOrTsParamProp::TsParamProp { 0: _0 } => {
                let _0 = _visitor.fold_ts_param_prop(_0);
                return ParamOrTsParamProp::TsParamProp { 0: _0 };
            }
            ParamOrTsParamProp::Param { 0: _0 } => {
                let _0 = _visitor.fold_param(_0);
                return ParamOrTsParamProp::Param { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_param_or_ts_param_props<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<ParamOrTsParamProp>,
) -> Vec<ParamOrTsParamProp> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| {
            _visitor.fold_param_or_ts_param_prop(v)
        })
    }
}
#[allow(unused_variables)]
pub fn fold_params<V: ?Sized + Fold>(_visitor: &mut V, n: Vec<Param>) -> Vec<Param> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_param(v))
    }
}
#[allow(unused_variables)]
pub fn fold_paren_expr<V: ?Sized + Fold>(_visitor: &mut V, n: ParenExpr) -> ParenExpr {
    {
        match n {
            ParenExpr { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return ParenExpr { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_pat<V: ?Sized + Fold>(_visitor: &mut V, n: Pat) -> Pat {
    {
        match n {
            Pat::Ident { 0: _0 } => {
                let _0 = _visitor.fold_binding_ident(_0);
                return Pat::Ident { 0: _0 };
            }
            Pat::Array { 0: _0 } => {
                let _0 = _visitor.fold_array_pat(_0);
                return Pat::Array { 0: _0 };
            }
            Pat::Rest { 0: _0 } => {
                let _0 = _visitor.fold_rest_pat(_0);
                return Pat::Rest { 0: _0 };
            }
            Pat::Object { 0: _0 } => {
                let _0 = _visitor.fold_object_pat(_0);
                return Pat::Object { 0: _0 };
            }
            Pat::Assign { 0: _0 } => {
                let _0 = _visitor.fold_assign_pat(_0);
                return Pat::Assign { 0: _0 };
            }
            Pat::Invalid { 0: _0 } => {
                let _0 = _visitor.fold_invalid(_0);
                return Pat::Invalid { 0: _0 };
            }
            Pat::Expr { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_expr(*_0));
                return Pat::Expr { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_pat_or_expr<V: ?Sized + Fold>(_visitor: &mut V, n: PatOrExpr) -> PatOrExpr {
    {
        match n {
            PatOrExpr::Expr { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_expr(*_0));
                return PatOrExpr::Expr { 0: _0 };
            }
            PatOrExpr::Pat { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_pat(*_0));
                return PatOrExpr::Pat { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_pats<V: ?Sized + Fold>(_visitor: &mut V, n: Vec<Pat>) -> Vec<Pat> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_pat(v))
    }
}
#[allow(unused_variables)]
pub fn fold_private_method<V: ?Sized + Fold>(_visitor: &mut V, n: PrivateMethod) -> PrivateMethod {
    {
        match n {
            PrivateMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                let span = _visitor.fold_span(span);
                let key = _visitor.fold_private_name(key);
                let function = _visitor.fold_function(function);
                let kind = _visitor.fold_method_kind(kind);
                let accessibility = _visitor.fold_opt_accessibility(accessibility);
                return PrivateMethod {
                    span,
                    key,
                    function,
                    kind,
                    is_static,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_private_name<V: ?Sized + Fold>(_visitor: &mut V, n: PrivateName) -> PrivateName {
    {
        match n {
            PrivateName { span, id } => {
                let span = _visitor.fold_span(span);
                let id = _visitor.fold_ident(id);
                return PrivateName { span, id };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_private_prop<V: ?Sized + Fold>(_visitor: &mut V, n: PrivateProp) -> PrivateProp {
    {
        match n {
            PrivateProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                computed,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                let span = _visitor.fold_span(span);
                let key = _visitor.fold_private_name(key);
                let value = _visitor.fold_opt_expr(value);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                let decorators = _visitor.fold_decorators(decorators);
                let accessibility = _visitor.fold_opt_accessibility(accessibility);
                return PrivateProp {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    computed,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                    readonly,
                    definite,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_program<V: ?Sized + Fold>(_visitor: &mut V, n: Program) -> Program {
    {
        match n {
            Program::Module { 0: _0 } => {
                let _0 = _visitor.fold_module(_0);
                return Program::Module { 0: _0 };
            }
            Program::Script { 0: _0 } => {
                let _0 = _visitor.fold_script(_0);
                return Program::Script { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_prop<V: ?Sized + Fold>(_visitor: &mut V, n: Prop) -> Prop {
    {
        match n {
            Prop::Shorthand { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return Prop::Shorthand { 0: _0 };
            }
            Prop::KeyValue { 0: _0 } => {
                let _0 = _visitor.fold_key_value_prop(_0);
                return Prop::KeyValue { 0: _0 };
            }
            Prop::Assign { 0: _0 } => {
                let _0 = _visitor.fold_assign_prop(_0);
                return Prop::Assign { 0: _0 };
            }
            Prop::Getter { 0: _0 } => {
                let _0 = _visitor.fold_getter_prop(_0);
                return Prop::Getter { 0: _0 };
            }
            Prop::Setter { 0: _0 } => {
                let _0 = _visitor.fold_setter_prop(_0);
                return Prop::Setter { 0: _0 };
            }
            Prop::Method { 0: _0 } => {
                let _0 = _visitor.fold_method_prop(_0);
                return Prop::Method { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_prop_name<V: ?Sized + Fold>(_visitor: &mut V, n: PropName) -> PropName {
    {
        match n {
            PropName::Ident { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return PropName::Ident { 0: _0 };
            }
            PropName::Str { 0: _0 } => {
                let _0 = _visitor.fold_str(_0);
                return PropName::Str { 0: _0 };
            }
            PropName::Num { 0: _0 } => {
                let _0 = _visitor.fold_number(_0);
                return PropName::Num { 0: _0 };
            }
            PropName::BigInt { 0: _0 } => {
                let _0 = _visitor.fold_big_int(_0);
                return PropName::BigInt { 0: _0 };
            }
            PropName::Computed { 0: _0 } => {
                let _0 = _visitor.fold_computed_prop_name(_0);
                return PropName::Computed { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_prop_or_spread<V: ?Sized + Fold>(_visitor: &mut V, n: PropOrSpread) -> PropOrSpread {
    {
        match n {
            PropOrSpread::Spread { 0: _0 } => {
                let _0 = _visitor.fold_spread_element(_0);
                return PropOrSpread::Spread { 0: _0 };
            }
            PropOrSpread::Prop { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_prop(*_0));
                return PropOrSpread::Prop { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_prop_or_spreads<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<PropOrSpread>,
) -> Vec<PropOrSpread> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_prop_or_spread(v))
    }
}
#[allow(unused_variables)]
pub fn fold_regex<V: ?Sized + Fold>(_visitor: &mut V, n: Regex) -> Regex {
    {
        match n {
            Regex { span, exp, flags } => {
                let span = _visitor.fold_span(span);
                let exp = _visitor.fold_js_word(exp);
                let flags = _visitor.fold_js_word(flags);
                return Regex { span, exp, flags };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_rest_pat<V: ?Sized + Fold>(_visitor: &mut V, n: RestPat) -> RestPat {
    {
        match n {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let dot3_token = _visitor.fold_span(dot3_token);
                let arg = Box::new(_visitor.fold_pat(*arg));
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                return RestPat {
                    span,
                    dot3_token,
                    arg,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_return_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: ReturnStmt) -> ReturnStmt {
    {
        match n {
            ReturnStmt { span, arg } => {
                let span = _visitor.fold_span(span);
                let arg = _visitor.fold_opt_expr(arg);
                return ReturnStmt { span, arg };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_script<V: ?Sized + Fold>(_visitor: &mut V, n: Script) -> Script {
    {
        match n {
            Script {
                span,
                body,
                shebang,
            } => {
                let span = _visitor.fold_span(span);
                let body = _visitor.fold_stmts(body);
                let shebang = _visitor.fold_opt_js_word(shebang);
                return Script {
                    span,
                    body,
                    shebang,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_seq_expr<V: ?Sized + Fold>(_visitor: &mut V, n: SeqExpr) -> SeqExpr {
    {
        match n {
            SeqExpr { span, exprs } => {
                let span = _visitor.fold_span(span);
                let exprs = _visitor.fold_exprs(exprs);
                return SeqExpr { span, exprs };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_setter_prop<V: ?Sized + Fold>(_visitor: &mut V, n: SetterProp) -> SetterProp {
    {
        match n {
            SetterProp {
                span,
                key,
                param,
                body,
            } => {
                let span = _visitor.fold_span(span);
                let key = _visitor.fold_prop_name(key);
                let param = _visitor.fold_pat(param);
                let body = _visitor.fold_opt_block_stmt(body);
                return SetterProp {
                    span,
                    key,
                    param,
                    body,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_span<V: ?Sized + Fold>(_visitor: &mut V, n: Span) -> Span {
    {
        return n;
    }
}
#[allow(unused_variables)]
pub fn fold_spread_element<V: ?Sized + Fold>(_visitor: &mut V, n: SpreadElement) -> SpreadElement {
    {
        match n {
            SpreadElement { dot3_token, expr } => {
                let dot3_token = _visitor.fold_span(dot3_token);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return SpreadElement { dot3_token, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: Stmt) -> Stmt {
    {
        match n {
            Stmt::Block { 0: _0 } => {
                let _0 = _visitor.fold_block_stmt(_0);
                return Stmt::Block { 0: _0 };
            }
            Stmt::Empty { 0: _0 } => {
                let _0 = _visitor.fold_empty_stmt(_0);
                return Stmt::Empty { 0: _0 };
            }
            Stmt::Debugger { 0: _0 } => {
                let _0 = _visitor.fold_debugger_stmt(_0);
                return Stmt::Debugger { 0: _0 };
            }
            Stmt::With { 0: _0 } => {
                let _0 = _visitor.fold_with_stmt(_0);
                return Stmt::With { 0: _0 };
            }
            Stmt::Return { 0: _0 } => {
                let _0 = _visitor.fold_return_stmt(_0);
                return Stmt::Return { 0: _0 };
            }
            Stmt::Labeled { 0: _0 } => {
                let _0 = _visitor.fold_labeled_stmt(_0);
                return Stmt::Labeled { 0: _0 };
            }
            Stmt::Break { 0: _0 } => {
                let _0 = _visitor.fold_break_stmt(_0);
                return Stmt::Break { 0: _0 };
            }
            Stmt::Continue { 0: _0 } => {
                let _0 = _visitor.fold_continue_stmt(_0);
                return Stmt::Continue { 0: _0 };
            }
            Stmt::If { 0: _0 } => {
                let _0 = _visitor.fold_if_stmt(_0);
                return Stmt::If { 0: _0 };
            }
            Stmt::Switch { 0: _0 } => {
                let _0 = _visitor.fold_switch_stmt(_0);
                return Stmt::Switch { 0: _0 };
            }
            Stmt::Throw { 0: _0 } => {
                let _0 = _visitor.fold_throw_stmt(_0);
                return Stmt::Throw { 0: _0 };
            }
            Stmt::Try { 0: _0 } => {
                let _0 = _visitor.fold_try_stmt(_0);
                return Stmt::Try { 0: _0 };
            }
            Stmt::While { 0: _0 } => {
                let _0 = _visitor.fold_while_stmt(_0);
                return Stmt::While { 0: _0 };
            }
            Stmt::DoWhile { 0: _0 } => {
                let _0 = _visitor.fold_do_while_stmt(_0);
                return Stmt::DoWhile { 0: _0 };
            }
            Stmt::For { 0: _0 } => {
                let _0 = _visitor.fold_for_stmt(_0);
                return Stmt::For { 0: _0 };
            }
            Stmt::ForIn { 0: _0 } => {
                let _0 = _visitor.fold_for_in_stmt(_0);
                return Stmt::ForIn { 0: _0 };
            }
            Stmt::ForOf { 0: _0 } => {
                let _0 = _visitor.fold_for_of_stmt(_0);
                return Stmt::ForOf { 0: _0 };
            }
            Stmt::Decl { 0: _0 } => {
                let _0 = _visitor.fold_decl(_0);
                return Stmt::Decl { 0: _0 };
            }
            Stmt::Expr { 0: _0 } => {
                let _0 = _visitor.fold_expr_stmt(_0);
                return Stmt::Expr { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_stmts<V: ?Sized + Fold>(_visitor: &mut V, n: Vec<Stmt>) -> Vec<Stmt> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_stmt(v))
    }
}
#[allow(unused_variables)]
pub fn fold_str<V: ?Sized + Fold>(_visitor: &mut V, n: Str) -> Str {
    {
        match n {
            Str {
                span,
                value,
                has_escape,
                kind,
            } => {
                let span = _visitor.fold_span(span);
                let value = _visitor.fold_js_word(value);
                let kind = _visitor.fold_str_kind(kind);
                return Str {
                    span,
                    value,
                    has_escape,
                    kind,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_str_kind<V: ?Sized + Fold>(_visitor: &mut V, n: StrKind) -> StrKind {
    {
        return n;
    }
}
#[allow(unused_variables)]
pub fn fold_super<V: ?Sized + Fold>(_visitor: &mut V, n: Super) -> Super {
    {
        match n {
            Super { span } => {
                let span = _visitor.fold_span(span);
                return Super { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_switch_case<V: ?Sized + Fold>(_visitor: &mut V, n: SwitchCase) -> SwitchCase {
    {
        match n {
            SwitchCase { span, test, cons } => {
                let span = _visitor.fold_span(span);
                let test = _visitor.fold_opt_expr(test);
                let cons = _visitor.fold_stmts(cons);
                return SwitchCase { span, test, cons };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_switch_cases<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<SwitchCase>,
) -> Vec<SwitchCase> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_switch_case(v))
    }
}
#[allow(unused_variables)]
pub fn fold_switch_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: SwitchStmt) -> SwitchStmt {
    {
        match n {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                let span = _visitor.fold_span(span);
                let discriminant = Box::new(_visitor.fold_expr(*discriminant));
                let cases = _visitor.fold_switch_cases(cases);
                return SwitchStmt {
                    span,
                    discriminant,
                    cases,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_tagged_tpl<V: ?Sized + Fold>(_visitor: &mut V, n: TaggedTpl) -> TaggedTpl {
    {
        match n {
            TaggedTpl {
                span,
                tag,
                type_params,
                tpl,
            } => {
                let span = _visitor.fold_span(span);
                let tag = Box::new(_visitor.fold_expr(*tag));
                let type_params = _visitor.fold_opt_ts_type_param_instantiation(type_params);
                let tpl = _visitor.fold_tpl(tpl);
                return TaggedTpl {
                    span,
                    tag,
                    type_params,
                    tpl,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_this_expr<V: ?Sized + Fold>(_visitor: &mut V, n: ThisExpr) -> ThisExpr {
    {
        match n {
            ThisExpr { span } => {
                let span = _visitor.fold_span(span);
                return ThisExpr { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_throw_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: ThrowStmt) -> ThrowStmt {
    {
        match n {
            ThrowStmt { span, arg } => {
                let span = _visitor.fold_span(span);
                let arg = Box::new(_visitor.fold_expr(*arg));
                return ThrowStmt { span, arg };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_tpl<V: ?Sized + Fold>(_visitor: &mut V, n: Tpl) -> Tpl {
    {
        match n {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                let span = _visitor.fold_span(span);
                let exprs = _visitor.fold_exprs(exprs);
                let quasis = _visitor.fold_tpl_elements(quasis);
                return Tpl {
                    span,
                    exprs,
                    quasis,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_tpl_element<V: ?Sized + Fold>(_visitor: &mut V, n: TplElement) -> TplElement {
    {
        match n {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {
                let span = _visitor.fold_span(span);
                let cooked = _visitor.fold_opt_str(cooked);
                let raw = _visitor.fold_str(raw);
                return TplElement {
                    span,
                    tail,
                    cooked,
                    raw,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_tpl_elements<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<TplElement>,
) -> Vec<TplElement> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_tpl_element(v))
    }
}
#[allow(unused_variables)]
pub fn fold_true_plus_minus<V: ?Sized + Fold>(_visitor: &mut V, n: TruePlusMinus) -> TruePlusMinus {
    {
        match n {
            TruePlusMinus::True {} => {
                return TruePlusMinus::True {};
            }
            TruePlusMinus::Plus {} => {
                return TruePlusMinus::Plus {};
            }
            TruePlusMinus::Minus {} => {
                return TruePlusMinus::Minus {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_try_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: TryStmt) -> TryStmt {
    {
        match n {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                let span = _visitor.fold_span(span);
                let block = _visitor.fold_block_stmt(block);
                let handler = _visitor.fold_opt_catch_clause(handler);
                let finalizer = _visitor.fold_opt_block_stmt(finalizer);
                return TryStmt {
                    span,
                    block,
                    handler,
                    finalizer,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_array_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsArrayType) -> TsArrayType {
    {
        match n {
            TsArrayType { span, elem_type } => {
                let span = _visitor.fold_span(span);
                let elem_type = Box::new(_visitor.fold_ts_type(*elem_type));
                return TsArrayType { span, elem_type };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_as_expr<V: ?Sized + Fold>(_visitor: &mut V, n: TsAsExpr) -> TsAsExpr {
    {
        match n {
            TsAsExpr {
                span,
                expr,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                let type_ann = Box::new(_visitor.fold_ts_type(*type_ann));
                return TsAsExpr {
                    span,
                    expr,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_call_signature_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsCallSignatureDecl,
) -> TsCallSignatureDecl {
    {
        match n {
            TsCallSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                let span = _visitor.fold_span(span);
                let params = _visitor.fold_ts_fn_params(params);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                return TsCallSignatureDecl {
                    span,
                    params,
                    type_ann,
                    type_params,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_conditional_type<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsConditionalType,
) -> TsConditionalType {
    {
        match n {
            TsConditionalType {
                span,
                check_type,
                extends_type,
                true_type,
                false_type,
            } => {
                let span = _visitor.fold_span(span);
                let check_type = Box::new(_visitor.fold_ts_type(*check_type));
                let extends_type = Box::new(_visitor.fold_ts_type(*extends_type));
                let true_type = Box::new(_visitor.fold_ts_type(*true_type));
                let false_type = Box::new(_visitor.fold_ts_type(*false_type));
                return TsConditionalType {
                    span,
                    check_type,
                    extends_type,
                    true_type,
                    false_type,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_const_assertion<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsConstAssertion,
) -> TsConstAssertion {
    {
        match n {
            TsConstAssertion { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return TsConstAssertion { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_construct_signature_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsConstructSignatureDecl,
) -> TsConstructSignatureDecl {
    {
        match n {
            TsConstructSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                let span = _visitor.fold_span(span);
                let params = _visitor.fold_ts_fn_params(params);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                return TsConstructSignatureDecl {
                    span,
                    params,
                    type_ann,
                    type_params,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_constructor_type<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsConstructorType,
) -> TsConstructorType {
    {
        match n {
            TsConstructorType {
                span,
                params,
                type_params,
                type_ann,
                is_abstract,
            } => {
                let span = _visitor.fold_span(span);
                let params = _visitor.fold_ts_fn_params(params);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                let type_ann = _visitor.fold_ts_type_ann(type_ann);
                return TsConstructorType {
                    span,
                    params,
                    type_params,
                    type_ann,
                    is_abstract,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_entity_name<V: ?Sized + Fold>(_visitor: &mut V, n: TsEntityName) -> TsEntityName {
    {
        match n {
            TsEntityName::TsQualifiedName { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_ts_qualified_name(*_0));
                return TsEntityName::TsQualifiedName { 0: _0 };
            }
            TsEntityName::Ident { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return TsEntityName::Ident { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_enum_decl<V: ?Sized + Fold>(_visitor: &mut V, n: TsEnumDecl) -> TsEnumDecl {
    {
        match n {
            TsEnumDecl {
                span,
                declare,
                is_const,
                id,
                members,
            } => {
                let span = _visitor.fold_span(span);
                let id = _visitor.fold_ident(id);
                let members = _visitor.fold_ts_enum_members(members);
                return TsEnumDecl {
                    span,
                    declare,
                    is_const,
                    id,
                    members,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_enum_member<V: ?Sized + Fold>(_visitor: &mut V, n: TsEnumMember) -> TsEnumMember {
    {
        match n {
            TsEnumMember { span, id, init } => {
                let span = _visitor.fold_span(span);
                let id = _visitor.fold_ts_enum_member_id(id);
                let init = _visitor.fold_opt_expr(init);
                return TsEnumMember { span, id, init };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_enum_member_id<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsEnumMemberId,
) -> TsEnumMemberId {
    {
        match n {
            TsEnumMemberId::Ident { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return TsEnumMemberId::Ident { 0: _0 };
            }
            TsEnumMemberId::Str { 0: _0 } => {
                let _0 = _visitor.fold_str(_0);
                return TsEnumMemberId::Str { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_enum_members<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<TsEnumMember>,
) -> Vec<TsEnumMember> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_ts_enum_member(v))
    }
}
#[allow(unused_variables)]
pub fn fold_ts_export_assignment<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsExportAssignment,
) -> TsExportAssignment {
    {
        match n {
            TsExportAssignment { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return TsExportAssignment { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_expr_with_type_args<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsExprWithTypeArgs,
) -> TsExprWithTypeArgs {
    {
        match n {
            TsExprWithTypeArgs {
                span,
                expr,
                type_args,
            } => {
                let span = _visitor.fold_span(span);
                let expr = _visitor.fold_ts_entity_name(expr);
                let type_args = _visitor.fold_opt_ts_type_param_instantiation(type_args);
                return TsExprWithTypeArgs {
                    span,
                    expr,
                    type_args,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_expr_with_type_args_vec<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<TsExprWithTypeArgs>,
) -> Vec<TsExprWithTypeArgs> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| {
            _visitor.fold_ts_expr_with_type_args(v)
        })
    }
}
#[allow(unused_variables)]
pub fn fold_ts_external_module_ref<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsExternalModuleRef,
) -> TsExternalModuleRef {
    {
        match n {
            TsExternalModuleRef { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = _visitor.fold_str(expr);
                return TsExternalModuleRef { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_fn_or_constructor_type<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsFnOrConstructorType,
) -> TsFnOrConstructorType {
    {
        match n {
            TsFnOrConstructorType::TsFnType { 0: _0 } => {
                let _0 = _visitor.fold_ts_fn_type(_0);
                return TsFnOrConstructorType::TsFnType { 0: _0 };
            }
            TsFnOrConstructorType::TsConstructorType { 0: _0 } => {
                let _0 = _visitor.fold_ts_constructor_type(_0);
                return TsFnOrConstructorType::TsConstructorType { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_fn_param<V: ?Sized + Fold>(_visitor: &mut V, n: TsFnParam) -> TsFnParam {
    {
        match n {
            TsFnParam::Ident { 0: _0 } => {
                let _0 = _visitor.fold_binding_ident(_0);
                return TsFnParam::Ident { 0: _0 };
            }
            TsFnParam::Array { 0: _0 } => {
                let _0 = _visitor.fold_array_pat(_0);
                return TsFnParam::Array { 0: _0 };
            }
            TsFnParam::Rest { 0: _0 } => {
                let _0 = _visitor.fold_rest_pat(_0);
                return TsFnParam::Rest { 0: _0 };
            }
            TsFnParam::Object { 0: _0 } => {
                let _0 = _visitor.fold_object_pat(_0);
                return TsFnParam::Object { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_fn_params<V: ?Sized + Fold>(_visitor: &mut V, n: Vec<TsFnParam>) -> Vec<TsFnParam> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_ts_fn_param(v))
    }
}
#[allow(unused_variables)]
pub fn fold_ts_fn_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsFnType) -> TsFnType {
    {
        match n {
            TsFnType {
                span,
                params,
                type_params,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let params = _visitor.fold_ts_fn_params(params);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                let type_ann = _visitor.fold_ts_type_ann(type_ann);
                return TsFnType {
                    span,
                    params,
                    type_params,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_getter_signature<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsGetterSignature,
) -> TsGetterSignature {
    {
        match n {
            TsGetterSignature {
                span,
                readonly,
                key,
                computed,
                optional,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let key = Box::new(_visitor.fold_expr(*key));
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                return TsGetterSignature {
                    span,
                    readonly,
                    key,
                    computed,
                    optional,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_import_equals_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsImportEqualsDecl,
) -> TsImportEqualsDecl {
    {
        match n {
            TsImportEqualsDecl {
                span,
                declare,
                is_export,
                is_type_only,
                id,
                module_ref,
            } => {
                let span = _visitor.fold_span(span);
                let id = _visitor.fold_ident(id);
                let module_ref = _visitor.fold_ts_module_ref(module_ref);
                return TsImportEqualsDecl {
                    span,
                    declare,
                    is_export,
                    is_type_only,
                    id,
                    module_ref,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_import_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsImportType) -> TsImportType {
    {
        match n {
            TsImportType {
                span,
                arg,
                qualifier,
                type_args,
            } => {
                let span = _visitor.fold_span(span);
                let arg = _visitor.fold_str(arg);
                let qualifier = _visitor.fold_opt_ts_entity_name(qualifier);
                let type_args = _visitor.fold_opt_ts_type_param_instantiation(type_args);
                return TsImportType {
                    span,
                    arg,
                    qualifier,
                    type_args,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_index_signature<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsIndexSignature,
) -> TsIndexSignature {
    {
        match n {
            TsIndexSignature {
                params,
                type_ann,
                readonly,
                is_static,
                span,
            } => {
                let params = _visitor.fold_ts_fn_params(params);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                let span = _visitor.fold_span(span);
                return TsIndexSignature {
                    params,
                    type_ann,
                    readonly,
                    is_static,
                    span,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_indexed_access_type<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsIndexedAccessType,
) -> TsIndexedAccessType {
    {
        match n {
            TsIndexedAccessType {
                span,
                readonly,
                obj_type,
                index_type,
            } => {
                let span = _visitor.fold_span(span);
                let obj_type = Box::new(_visitor.fold_ts_type(*obj_type));
                let index_type = Box::new(_visitor.fold_ts_type(*index_type));
                return TsIndexedAccessType {
                    span,
                    readonly,
                    obj_type,
                    index_type,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_infer_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsInferType) -> TsInferType {
    {
        match n {
            TsInferType { span, type_param } => {
                let span = _visitor.fold_span(span);
                let type_param = _visitor.fold_ts_type_param(type_param);
                return TsInferType { span, type_param };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_interface_body<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsInterfaceBody,
) -> TsInterfaceBody {
    {
        match n {
            TsInterfaceBody { span, body } => {
                let span = _visitor.fold_span(span);
                let body = _visitor.fold_ts_type_elements(body);
                return TsInterfaceBody { span, body };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_interface_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsInterfaceDecl,
) -> TsInterfaceDecl {
    {
        match n {
            TsInterfaceDecl {
                span,
                id,
                declare,
                type_params,
                extends,
                body,
            } => {
                let span = _visitor.fold_span(span);
                let id = _visitor.fold_ident(id);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                let extends = _visitor.fold_ts_expr_with_type_args_vec(extends);
                let body = _visitor.fold_ts_interface_body(body);
                return TsInterfaceDecl {
                    span,
                    id,
                    declare,
                    type_params,
                    extends,
                    body,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_intersection_type<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsIntersectionType,
) -> TsIntersectionType {
    {
        match n {
            TsIntersectionType { span, types } => {
                let span = _visitor.fold_span(span);
                let types = _visitor.fold_ts_types(types);
                return TsIntersectionType { span, types };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_keyword_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsKeywordType) -> TsKeywordType {
    {
        match n {
            TsKeywordType { span, kind } => {
                let span = _visitor.fold_span(span);
                let kind = _visitor.fold_ts_keyword_type_kind(kind);
                return TsKeywordType { span, kind };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_keyword_type_kind<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsKeywordTypeKind,
) -> TsKeywordTypeKind {
    {
        match n {
            TsKeywordTypeKind::TsAnyKeyword {} => {
                return TsKeywordTypeKind::TsAnyKeyword {};
            }
            TsKeywordTypeKind::TsUnknownKeyword {} => {
                return TsKeywordTypeKind::TsUnknownKeyword {};
            }
            TsKeywordTypeKind::TsNumberKeyword {} => {
                return TsKeywordTypeKind::TsNumberKeyword {};
            }
            TsKeywordTypeKind::TsObjectKeyword {} => {
                return TsKeywordTypeKind::TsObjectKeyword {};
            }
            TsKeywordTypeKind::TsBooleanKeyword {} => {
                return TsKeywordTypeKind::TsBooleanKeyword {};
            }
            TsKeywordTypeKind::TsBigIntKeyword {} => {
                return TsKeywordTypeKind::TsBigIntKeyword {};
            }
            TsKeywordTypeKind::TsStringKeyword {} => {
                return TsKeywordTypeKind::TsStringKeyword {};
            }
            TsKeywordTypeKind::TsSymbolKeyword {} => {
                return TsKeywordTypeKind::TsSymbolKeyword {};
            }
            TsKeywordTypeKind::TsVoidKeyword {} => {
                return TsKeywordTypeKind::TsVoidKeyword {};
            }
            TsKeywordTypeKind::TsUndefinedKeyword {} => {
                return TsKeywordTypeKind::TsUndefinedKeyword {};
            }
            TsKeywordTypeKind::TsNullKeyword {} => {
                return TsKeywordTypeKind::TsNullKeyword {};
            }
            TsKeywordTypeKind::TsNeverKeyword {} => {
                return TsKeywordTypeKind::TsNeverKeyword {};
            }
            TsKeywordTypeKind::TsIntrinsicKeyword {} => {
                return TsKeywordTypeKind::TsIntrinsicKeyword {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_lit<V: ?Sized + Fold>(_visitor: &mut V, n: TsLit) -> TsLit {
    {
        match n {
            TsLit::BigInt { 0: _0 } => {
                let _0 = _visitor.fold_big_int(_0);
                return TsLit::BigInt { 0: _0 };
            }
            TsLit::Number { 0: _0 } => {
                let _0 = _visitor.fold_number(_0);
                return TsLit::Number { 0: _0 };
            }
            TsLit::Str { 0: _0 } => {
                let _0 = _visitor.fold_str(_0);
                return TsLit::Str { 0: _0 };
            }
            TsLit::Bool { 0: _0 } => {
                let _0 = _visitor.fold_bool(_0);
                return TsLit::Bool { 0: _0 };
            }
            TsLit::Tpl { 0: _0 } => {
                let _0 = _visitor.fold_ts_tpl_lit_type(_0);
                return TsLit::Tpl { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_lit_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsLitType) -> TsLitType {
    {
        match n {
            TsLitType { span, lit } => {
                let span = _visitor.fold_span(span);
                let lit = _visitor.fold_ts_lit(lit);
                return TsLitType { span, lit };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_mapped_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsMappedType) -> TsMappedType {
    {
        match n {
            TsMappedType {
                span,
                readonly,
                type_param,
                name_type,
                optional,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let readonly = _visitor.fold_opt_true_plus_minus(readonly);
                let type_param = _visitor.fold_ts_type_param(type_param);
                let name_type = _visitor.fold_opt_ts_type(name_type);
                let optional = _visitor.fold_opt_true_plus_minus(optional);
                let type_ann = _visitor.fold_opt_ts_type(type_ann);
                return TsMappedType {
                    span,
                    readonly,
                    type_param,
                    name_type,
                    optional,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_method_signature<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsMethodSignature,
) -> TsMethodSignature {
    {
        match n {
            TsMethodSignature {
                span,
                readonly,
                key,
                computed,
                optional,
                params,
                type_ann,
                type_params,
            } => {
                let span = _visitor.fold_span(span);
                let key = Box::new(_visitor.fold_expr(*key));
                let params = _visitor.fold_ts_fn_params(params);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                return TsMethodSignature {
                    span,
                    readonly,
                    key,
                    computed,
                    optional,
                    params,
                    type_ann,
                    type_params,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_module_block<V: ?Sized + Fold>(_visitor: &mut V, n: TsModuleBlock) -> TsModuleBlock {
    {
        match n {
            TsModuleBlock { span, body } => {
                let span = _visitor.fold_span(span);
                let body = _visitor.fold_module_items(body);
                return TsModuleBlock { span, body };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_module_decl<V: ?Sized + Fold>(_visitor: &mut V, n: TsModuleDecl) -> TsModuleDecl {
    {
        match n {
            TsModuleDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                let span = _visitor.fold_span(span);
                let id = _visitor.fold_ts_module_name(id);
                let body = _visitor.fold_opt_ts_namespace_body(body);
                return TsModuleDecl {
                    span,
                    declare,
                    global,
                    id,
                    body,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_module_name<V: ?Sized + Fold>(_visitor: &mut V, n: TsModuleName) -> TsModuleName {
    {
        match n {
            TsModuleName::Ident { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return TsModuleName::Ident { 0: _0 };
            }
            TsModuleName::Str { 0: _0 } => {
                let _0 = _visitor.fold_str(_0);
                return TsModuleName::Str { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_module_ref<V: ?Sized + Fold>(_visitor: &mut V, n: TsModuleRef) -> TsModuleRef {
    {
        match n {
            TsModuleRef::TsEntityName { 0: _0 } => {
                let _0 = _visitor.fold_ts_entity_name(_0);
                return TsModuleRef::TsEntityName { 0: _0 };
            }
            TsModuleRef::TsExternalModuleRef { 0: _0 } => {
                let _0 = _visitor.fold_ts_external_module_ref(_0);
                return TsModuleRef::TsExternalModuleRef { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_namespace_body<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsNamespaceBody,
) -> TsNamespaceBody {
    {
        match n {
            TsNamespaceBody::TsModuleBlock { 0: _0 } => {
                let _0 = _visitor.fold_ts_module_block(_0);
                return TsNamespaceBody::TsModuleBlock { 0: _0 };
            }
            TsNamespaceBody::TsNamespaceDecl { 0: _0 } => {
                let _0 = _visitor.fold_ts_namespace_decl(_0);
                return TsNamespaceBody::TsNamespaceDecl { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_namespace_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsNamespaceDecl,
) -> TsNamespaceDecl {
    {
        match n {
            TsNamespaceDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                let span = _visitor.fold_span(span);
                let id = _visitor.fold_ident(id);
                let body = Box::new(_visitor.fold_ts_namespace_body(*body));
                return TsNamespaceDecl {
                    span,
                    declare,
                    global,
                    id,
                    body,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_namespace_export_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsNamespaceExportDecl,
) -> TsNamespaceExportDecl {
    {
        match n {
            TsNamespaceExportDecl { span, id } => {
                let span = _visitor.fold_span(span);
                let id = _visitor.fold_ident(id);
                return TsNamespaceExportDecl { span, id };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_non_null_expr<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsNonNullExpr,
) -> TsNonNullExpr {
    {
        match n {
            TsNonNullExpr { span, expr } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                return TsNonNullExpr { span, expr };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_optional_type<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsOptionalType,
) -> TsOptionalType {
    {
        match n {
            TsOptionalType { span, type_ann } => {
                let span = _visitor.fold_span(span);
                let type_ann = Box::new(_visitor.fold_ts_type(*type_ann));
                return TsOptionalType { span, type_ann };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_param_prop<V: ?Sized + Fold>(_visitor: &mut V, n: TsParamProp) -> TsParamProp {
    {
        match n {
            TsParamProp {
                span,
                decorators,
                accessibility,
                is_override,
                readonly,
                param,
            } => {
                let span = _visitor.fold_span(span);
                let decorators = _visitor.fold_decorators(decorators);
                let accessibility = _visitor.fold_opt_accessibility(accessibility);
                let param = _visitor.fold_ts_param_prop_param(param);
                return TsParamProp {
                    span,
                    decorators,
                    accessibility,
                    is_override,
                    readonly,
                    param,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_param_prop_param<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsParamPropParam,
) -> TsParamPropParam {
    {
        match n {
            TsParamPropParam::Ident { 0: _0 } => {
                let _0 = _visitor.fold_binding_ident(_0);
                return TsParamPropParam::Ident { 0: _0 };
            }
            TsParamPropParam::Assign { 0: _0 } => {
                let _0 = _visitor.fold_assign_pat(_0);
                return TsParamPropParam::Assign { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_parenthesized_type<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsParenthesizedType,
) -> TsParenthesizedType {
    {
        match n {
            TsParenthesizedType { span, type_ann } => {
                let span = _visitor.fold_span(span);
                let type_ann = Box::new(_visitor.fold_ts_type(*type_ann));
                return TsParenthesizedType { span, type_ann };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_property_signature<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsPropertySignature,
) -> TsPropertySignature {
    {
        match n {
            TsPropertySignature {
                span,
                readonly,
                key,
                computed,
                optional,
                init,
                params,
                type_ann,
                type_params,
            } => {
                let span = _visitor.fold_span(span);
                let key = Box::new(_visitor.fold_expr(*key));
                let init = _visitor.fold_opt_expr(init);
                let params = _visitor.fold_ts_fn_params(params);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                return TsPropertySignature {
                    span,
                    readonly,
                    key,
                    computed,
                    optional,
                    init,
                    params,
                    type_ann,
                    type_params,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_qualified_name<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsQualifiedName,
) -> TsQualifiedName {
    {
        match n {
            TsQualifiedName { left, right } => {
                let left = _visitor.fold_ts_entity_name(left);
                let right = _visitor.fold_ident(right);
                return TsQualifiedName { left, right };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_rest_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsRestType) -> TsRestType {
    {
        match n {
            TsRestType { span, type_ann } => {
                let span = _visitor.fold_span(span);
                let type_ann = Box::new(_visitor.fold_ts_type(*type_ann));
                return TsRestType { span, type_ann };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_setter_signature<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsSetterSignature,
) -> TsSetterSignature {
    {
        match n {
            TsSetterSignature {
                span,
                readonly,
                key,
                computed,
                optional,
                param,
            } => {
                let span = _visitor.fold_span(span);
                let key = Box::new(_visitor.fold_expr(*key));
                let param = _visitor.fold_ts_fn_param(param);
                return TsSetterSignature {
                    span,
                    readonly,
                    key,
                    computed,
                    optional,
                    param,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_this_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsThisType) -> TsThisType {
    {
        match n {
            TsThisType { span } => {
                let span = _visitor.fold_span(span);
                return TsThisType { span };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_this_type_or_ident<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsThisTypeOrIdent,
) -> TsThisTypeOrIdent {
    {
        match n {
            TsThisTypeOrIdent::TsThisType { 0: _0 } => {
                let _0 = _visitor.fold_ts_this_type(_0);
                return TsThisTypeOrIdent::TsThisType { 0: _0 };
            }
            TsThisTypeOrIdent::Ident { 0: _0 } => {
                let _0 = _visitor.fold_ident(_0);
                return TsThisTypeOrIdent::Ident { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_tpl_lit_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsTplLitType) -> TsTplLitType {
    {
        match n {
            TsTplLitType {
                span,
                types,
                quasis,
            } => {
                let span = _visitor.fold_span(span);
                let types = _visitor.fold_ts_types(types);
                let quasis = _visitor.fold_tpl_elements(quasis);
                return TsTplLitType {
                    span,
                    types,
                    quasis,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_tuple_element<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsTupleElement,
) -> TsTupleElement {
    {
        match n {
            TsTupleElement { span, label, ty } => {
                let span = _visitor.fold_span(span);
                let label = _visitor.fold_opt_pat(label);
                let ty = _visitor.fold_ts_type(ty);
                return TsTupleElement { span, label, ty };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_tuple_elements<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<TsTupleElement>,
) -> Vec<TsTupleElement> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_ts_tuple_element(v))
    }
}
#[allow(unused_variables)]
pub fn fold_ts_tuple_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsTupleType) -> TsTupleType {
    {
        match n {
            TsTupleType { span, elem_types } => {
                let span = _visitor.fold_span(span);
                let elem_types = _visitor.fold_ts_tuple_elements(elem_types);
                return TsTupleType { span, elem_types };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsType) -> TsType {
    {
        match n {
            TsType::TsKeywordType { 0: _0 } => {
                let _0 = _visitor.fold_ts_keyword_type(_0);
                return TsType::TsKeywordType { 0: _0 };
            }
            TsType::TsThisType { 0: _0 } => {
                let _0 = _visitor.fold_ts_this_type(_0);
                return TsType::TsThisType { 0: _0 };
            }
            TsType::TsFnOrConstructorType { 0: _0 } => {
                let _0 = _visitor.fold_ts_fn_or_constructor_type(_0);
                return TsType::TsFnOrConstructorType { 0: _0 };
            }
            TsType::TsTypeRef { 0: _0 } => {
                let _0 = _visitor.fold_ts_type_ref(_0);
                return TsType::TsTypeRef { 0: _0 };
            }
            TsType::TsTypeQuery { 0: _0 } => {
                let _0 = _visitor.fold_ts_type_query(_0);
                return TsType::TsTypeQuery { 0: _0 };
            }
            TsType::TsTypeLit { 0: _0 } => {
                let _0 = _visitor.fold_ts_type_lit(_0);
                return TsType::TsTypeLit { 0: _0 };
            }
            TsType::TsArrayType { 0: _0 } => {
                let _0 = _visitor.fold_ts_array_type(_0);
                return TsType::TsArrayType { 0: _0 };
            }
            TsType::TsTupleType { 0: _0 } => {
                let _0 = _visitor.fold_ts_tuple_type(_0);
                return TsType::TsTupleType { 0: _0 };
            }
            TsType::TsOptionalType { 0: _0 } => {
                let _0 = _visitor.fold_ts_optional_type(_0);
                return TsType::TsOptionalType { 0: _0 };
            }
            TsType::TsRestType { 0: _0 } => {
                let _0 = _visitor.fold_ts_rest_type(_0);
                return TsType::TsRestType { 0: _0 };
            }
            TsType::TsUnionOrIntersectionType { 0: _0 } => {
                let _0 = _visitor.fold_ts_union_or_intersection_type(_0);
                return TsType::TsUnionOrIntersectionType { 0: _0 };
            }
            TsType::TsConditionalType { 0: _0 } => {
                let _0 = _visitor.fold_ts_conditional_type(_0);
                return TsType::TsConditionalType { 0: _0 };
            }
            TsType::TsInferType { 0: _0 } => {
                let _0 = _visitor.fold_ts_infer_type(_0);
                return TsType::TsInferType { 0: _0 };
            }
            TsType::TsParenthesizedType { 0: _0 } => {
                let _0 = _visitor.fold_ts_parenthesized_type(_0);
                return TsType::TsParenthesizedType { 0: _0 };
            }
            TsType::TsTypeOperator { 0: _0 } => {
                let _0 = _visitor.fold_ts_type_operator(_0);
                return TsType::TsTypeOperator { 0: _0 };
            }
            TsType::TsIndexedAccessType { 0: _0 } => {
                let _0 = _visitor.fold_ts_indexed_access_type(_0);
                return TsType::TsIndexedAccessType { 0: _0 };
            }
            TsType::TsMappedType { 0: _0 } => {
                let _0 = _visitor.fold_ts_mapped_type(_0);
                return TsType::TsMappedType { 0: _0 };
            }
            TsType::TsLitType { 0: _0 } => {
                let _0 = _visitor.fold_ts_lit_type(_0);
                return TsType::TsLitType { 0: _0 };
            }
            TsType::TsTypePredicate { 0: _0 } => {
                let _0 = _visitor.fold_ts_type_predicate(_0);
                return TsType::TsTypePredicate { 0: _0 };
            }
            TsType::TsImportType { 0: _0 } => {
                let _0 = _visitor.fold_ts_import_type(_0);
                return TsType::TsImportType { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_alias_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsTypeAliasDecl,
) -> TsTypeAliasDecl {
    {
        match n {
            TsTypeAliasDecl {
                span,
                declare,
                id,
                type_params,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let id = _visitor.fold_ident(id);
                let type_params = _visitor.fold_opt_ts_type_param_decl(type_params);
                let type_ann = Box::new(_visitor.fold_ts_type(*type_ann));
                return TsTypeAliasDecl {
                    span,
                    declare,
                    id,
                    type_params,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_ann<V: ?Sized + Fold>(_visitor: &mut V, n: TsTypeAnn) -> TsTypeAnn {
    {
        match n {
            TsTypeAnn { span, type_ann } => {
                let span = _visitor.fold_span(span);
                let type_ann = Box::new(_visitor.fold_ts_type(*type_ann));
                return TsTypeAnn { span, type_ann };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_assertion<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsTypeAssertion,
) -> TsTypeAssertion {
    {
        match n {
            TsTypeAssertion {
                span,
                expr,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let expr = Box::new(_visitor.fold_expr(*expr));
                let type_ann = Box::new(_visitor.fold_ts_type(*type_ann));
                return TsTypeAssertion {
                    span,
                    expr,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_element<V: ?Sized + Fold>(_visitor: &mut V, n: TsTypeElement) -> TsTypeElement {
    {
        match n {
            TsTypeElement::TsCallSignatureDecl { 0: _0 } => {
                let _0 = _visitor.fold_ts_call_signature_decl(_0);
                return TsTypeElement::TsCallSignatureDecl { 0: _0 };
            }
            TsTypeElement::TsConstructSignatureDecl { 0: _0 } => {
                let _0 = _visitor.fold_ts_construct_signature_decl(_0);
                return TsTypeElement::TsConstructSignatureDecl { 0: _0 };
            }
            TsTypeElement::TsPropertySignature { 0: _0 } => {
                let _0 = _visitor.fold_ts_property_signature(_0);
                return TsTypeElement::TsPropertySignature { 0: _0 };
            }
            TsTypeElement::TsGetterSignature { 0: _0 } => {
                let _0 = _visitor.fold_ts_getter_signature(_0);
                return TsTypeElement::TsGetterSignature { 0: _0 };
            }
            TsTypeElement::TsSetterSignature { 0: _0 } => {
                let _0 = _visitor.fold_ts_setter_signature(_0);
                return TsTypeElement::TsSetterSignature { 0: _0 };
            }
            TsTypeElement::TsMethodSignature { 0: _0 } => {
                let _0 = _visitor.fold_ts_method_signature(_0);
                return TsTypeElement::TsMethodSignature { 0: _0 };
            }
            TsTypeElement::TsIndexSignature { 0: _0 } => {
                let _0 = _visitor.fold_ts_index_signature(_0);
                return TsTypeElement::TsIndexSignature { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_elements<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<TsTypeElement>,
) -> Vec<TsTypeElement> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_ts_type_element(v))
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_lit<V: ?Sized + Fold>(_visitor: &mut V, n: TsTypeLit) -> TsTypeLit {
    {
        match n {
            TsTypeLit { span, members } => {
                let span = _visitor.fold_span(span);
                let members = _visitor.fold_ts_type_elements(members);
                return TsTypeLit { span, members };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_operator<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsTypeOperator,
) -> TsTypeOperator {
    {
        match n {
            TsTypeOperator { span, op, type_ann } => {
                let span = _visitor.fold_span(span);
                let op = _visitor.fold_ts_type_operator_op(op);
                let type_ann = Box::new(_visitor.fold_ts_type(*type_ann));
                return TsTypeOperator { span, op, type_ann };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_operator_op<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsTypeOperatorOp,
) -> TsTypeOperatorOp {
    {
        match n {
            TsTypeOperatorOp::KeyOf {} => {
                return TsTypeOperatorOp::KeyOf {};
            }
            TsTypeOperatorOp::Unique {} => {
                return TsTypeOperatorOp::Unique {};
            }
            TsTypeOperatorOp::ReadOnly {} => {
                return TsTypeOperatorOp::ReadOnly {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_param<V: ?Sized + Fold>(_visitor: &mut V, n: TsTypeParam) -> TsTypeParam {
    {
        match n {
            TsTypeParam {
                span,
                name,
                constraint,
                default,
            } => {
                let span = _visitor.fold_span(span);
                let name = _visitor.fold_ident(name);
                let constraint = _visitor.fold_opt_ts_type(constraint);
                let default = _visitor.fold_opt_ts_type(default);
                return TsTypeParam {
                    span,
                    name,
                    constraint,
                    default,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_param_decl<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsTypeParamDecl,
) -> TsTypeParamDecl {
    {
        match n {
            TsTypeParamDecl { span, params } => {
                let span = _visitor.fold_span(span);
                let params = _visitor.fold_ts_type_params(params);
                return TsTypeParamDecl { span, params };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_param_instantiation<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsTypeParamInstantiation,
) -> TsTypeParamInstantiation {
    {
        match n {
            TsTypeParamInstantiation { span, params } => {
                let span = _visitor.fold_span(span);
                let params = _visitor.fold_ts_types(params);
                return TsTypeParamInstantiation { span, params };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_params<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<TsTypeParam>,
) -> Vec<TsTypeParam> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_ts_type_param(v))
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_predicate<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsTypePredicate,
) -> TsTypePredicate {
    {
        match n {
            TsTypePredicate {
                span,
                asserts,
                param_name,
                type_ann,
            } => {
                let span = _visitor.fold_span(span);
                let param_name = _visitor.fold_ts_this_type_or_ident(param_name);
                let type_ann = _visitor.fold_opt_ts_type_ann(type_ann);
                return TsTypePredicate {
                    span,
                    asserts,
                    param_name,
                    type_ann,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_query<V: ?Sized + Fold>(_visitor: &mut V, n: TsTypeQuery) -> TsTypeQuery {
    {
        match n {
            TsTypeQuery { span, expr_name } => {
                let span = _visitor.fold_span(span);
                let expr_name = _visitor.fold_ts_type_query_expr(expr_name);
                return TsTypeQuery { span, expr_name };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_query_expr<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsTypeQueryExpr,
) -> TsTypeQueryExpr {
    {
        match n {
            TsTypeQueryExpr::TsEntityName { 0: _0 } => {
                let _0 = _visitor.fold_ts_entity_name(_0);
                return TsTypeQueryExpr::TsEntityName { 0: _0 };
            }
            TsTypeQueryExpr::Import { 0: _0 } => {
                let _0 = _visitor.fold_ts_import_type(_0);
                return TsTypeQueryExpr::Import { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_type_ref<V: ?Sized + Fold>(_visitor: &mut V, n: TsTypeRef) -> TsTypeRef {
    {
        match n {
            TsTypeRef {
                span,
                type_name,
                type_params,
            } => {
                let span = _visitor.fold_span(span);
                let type_name = _visitor.fold_ts_entity_name(type_name);
                let type_params = _visitor.fold_opt_ts_type_param_instantiation(type_params);
                return TsTypeRef {
                    span,
                    type_name,
                    type_params,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_types<V: ?Sized + Fold>(_visitor: &mut V, n: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| {
            global_visit::util::map::Map::map(v, |v| _visitor.fold_ts_type(v))
        })
    }
}
#[allow(unused_variables)]
pub fn fold_ts_union_or_intersection_type<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: TsUnionOrIntersectionType,
) -> TsUnionOrIntersectionType {
    {
        match n {
            TsUnionOrIntersectionType::TsUnionType { 0: _0 } => {
                let _0 = _visitor.fold_ts_union_type(_0);
                return TsUnionOrIntersectionType::TsUnionType { 0: _0 };
            }
            TsUnionOrIntersectionType::TsIntersectionType { 0: _0 } => {
                let _0 = _visitor.fold_ts_intersection_type(_0);
                return TsUnionOrIntersectionType::TsIntersectionType { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_ts_union_type<V: ?Sized + Fold>(_visitor: &mut V, n: TsUnionType) -> TsUnionType {
    {
        match n {
            TsUnionType { span, types } => {
                let span = _visitor.fold_span(span);
                let types = _visitor.fold_ts_types(types);
                return TsUnionType { span, types };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_unary_expr<V: ?Sized + Fold>(_visitor: &mut V, n: UnaryExpr) -> UnaryExpr {
    {
        match n {
            UnaryExpr { span, op, arg } => {
                let span = _visitor.fold_span(span);
                let op = _visitor.fold_unary_op(op);
                let arg = Box::new(_visitor.fold_expr(*arg));
                return UnaryExpr { span, op, arg };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_unary_op<V: ?Sized + Fold>(_visitor: &mut V, n: UnaryOp) -> UnaryOp {
    {
        match n {
            UnaryOp::Minus {} => {
                return UnaryOp::Minus {};
            }
            UnaryOp::Plus {} => {
                return UnaryOp::Plus {};
            }
            UnaryOp::Bang {} => {
                return UnaryOp::Bang {};
            }
            UnaryOp::Tilde {} => {
                return UnaryOp::Tilde {};
            }
            UnaryOp::TypeOf {} => {
                return UnaryOp::TypeOf {};
            }
            UnaryOp::Void {} => {
                return UnaryOp::Void {};
            }
            UnaryOp::Delete {} => {
                return UnaryOp::Delete {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_update_expr<V: ?Sized + Fold>(_visitor: &mut V, n: UpdateExpr) -> UpdateExpr {
    {
        match n {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                let span = _visitor.fold_span(span);
                let op = _visitor.fold_update_op(op);
                let arg = Box::new(_visitor.fold_expr(*arg));
                return UpdateExpr {
                    span,
                    op,
                    prefix,
                    arg,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_update_op<V: ?Sized + Fold>(_visitor: &mut V, n: UpdateOp) -> UpdateOp {
    {
        match n {
            UpdateOp::PlusPlus {} => {
                return UpdateOp::PlusPlus {};
            }
            UpdateOp::MinusMinus {} => {
                return UpdateOp::MinusMinus {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_var_decl<V: ?Sized + Fold>(_visitor: &mut V, n: VarDecl) -> VarDecl {
    {
        match n {
            VarDecl {
                span,
                kind,
                declare,
                decls,
            } => {
                let span = _visitor.fold_span(span);
                let kind = _visitor.fold_var_decl_kind(kind);
                let decls = _visitor.fold_var_declarators(decls);
                return VarDecl {
                    span,
                    kind,
                    declare,
                    decls,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_var_decl_kind<V: ?Sized + Fold>(_visitor: &mut V, n: VarDeclKind) -> VarDeclKind {
    {
        match n {
            VarDeclKind::Var {} => {
                return VarDeclKind::Var {};
            }
            VarDeclKind::Let {} => {
                return VarDeclKind::Let {};
            }
            VarDeclKind::Const {} => {
                return VarDeclKind::Const {};
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_var_decl_or_expr<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: VarDeclOrExpr,
) -> VarDeclOrExpr {
    {
        match n {
            VarDeclOrExpr::VarDecl { 0: _0 } => {
                let _0 = _visitor.fold_var_decl(_0);
                return VarDeclOrExpr::VarDecl { 0: _0 };
            }
            VarDeclOrExpr::Expr { 0: _0 } => {
                let _0 = Box::new(_visitor.fold_expr(*_0));
                return VarDeclOrExpr::Expr { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_var_decl_or_pat<V: ?Sized + Fold>(_visitor: &mut V, n: VarDeclOrPat) -> VarDeclOrPat {
    {
        match n {
            VarDeclOrPat::VarDecl { 0: _0 } => {
                let _0 = _visitor.fold_var_decl(_0);
                return VarDeclOrPat::VarDecl { 0: _0 };
            }
            VarDeclOrPat::Pat { 0: _0 } => {
                let _0 = _visitor.fold_pat(_0);
                return VarDeclOrPat::Pat { 0: _0 };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_var_declarator<V: ?Sized + Fold>(_visitor: &mut V, n: VarDeclarator) -> VarDeclarator {
    {
        match n {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                let span = _visitor.fold_span(span);
                let name = _visitor.fold_pat(name);
                let init = _visitor.fold_opt_expr(init);
                return VarDeclarator {
                    span,
                    name,
                    init,
                    definite,
                };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_var_declarators<V: ?Sized + Fold>(
    _visitor: &mut V,
    n: Vec<VarDeclarator>,
) -> Vec<VarDeclarator> {
    {
        global_visit::util::move_map::MoveMap::move_map(n, |v| _visitor.fold_var_declarator(v))
    }
}
#[allow(unused_variables)]
pub fn fold_while_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: WhileStmt) -> WhileStmt {
    {
        match n {
            WhileStmt { span, test, body } => {
                let span = _visitor.fold_span(span);
                let test = Box::new(_visitor.fold_expr(*test));
                let body = Box::new(_visitor.fold_stmt(*body));
                return WhileStmt { span, test, body };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_with_stmt<V: ?Sized + Fold>(_visitor: &mut V, n: WithStmt) -> WithStmt {
    {
        match n {
            WithStmt { span, obj, body } => {
                let span = _visitor.fold_span(span);
                let obj = Box::new(_visitor.fold_expr(*obj));
                let body = Box::new(_visitor.fold_stmt(*body));
                return WithStmt { span, obj, body };
            }
        }
    }
}
#[allow(unused_variables)]
pub fn fold_yield_expr<V: ?Sized + Fold>(_visitor: &mut V, n: YieldExpr) -> YieldExpr {
    {
        match n {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                let span = _visitor.fold_span(span);
                let arg = _visitor.fold_opt_expr(arg);
                return YieldExpr {
                    span,
                    arg,
                    delegate,
                };
            }
        }
    }
}
pub trait Fold {
    #[allow(unused_variables)]
    fn fold_accessibility(&mut self, n: Accessibility) -> Accessibility {
        fold_accessibility(self, n)
    }
    #[allow(unused_variables)]
    fn fold_array_lit(&mut self, n: ArrayLit) -> ArrayLit {
        fold_array_lit(self, n)
    }
    #[allow(unused_variables)]
    fn fold_array_pat(&mut self, n: ArrayPat) -> ArrayPat {
        fold_array_pat(self, n)
    }
    #[allow(unused_variables)]
    fn fold_arrow_expr(&mut self, n: ArrowExpr) -> ArrowExpr {
        fold_arrow_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_assign_expr(&mut self, n: AssignExpr) -> AssignExpr {
        fold_assign_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_assign_op(&mut self, n: AssignOp) -> AssignOp {
        fold_assign_op(self, n)
    }
    #[allow(unused_variables)]
    fn fold_assign_pat(&mut self, n: AssignPat) -> AssignPat {
        fold_assign_pat(self, n)
    }
    #[allow(unused_variables)]
    fn fold_assign_pat_prop(&mut self, n: AssignPatProp) -> AssignPatProp {
        fold_assign_pat_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_assign_prop(&mut self, n: AssignProp) -> AssignProp {
        fold_assign_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_await_expr(&mut self, n: AwaitExpr) -> AwaitExpr {
        fold_await_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_big_int(&mut self, n: BigInt) -> BigInt {
        fold_big_int(self, n)
    }
    #[allow(unused_variables)]
    fn fold_big_int_value(&mut self, n: BigIntValue) -> BigIntValue {
        fold_big_int_value(self, n)
    }
    #[allow(unused_variables)]
    fn fold_bin_expr(&mut self, n: BinExpr) -> BinExpr {
        fold_bin_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_binary_op(&mut self, n: BinaryOp) -> BinaryOp {
        fold_binary_op(self, n)
    }
    #[allow(unused_variables)]
    fn fold_binding_ident(&mut self, n: BindingIdent) -> BindingIdent {
        fold_binding_ident(self, n)
    }
    #[allow(unused_variables)]
    fn fold_block_stmt(&mut self, n: BlockStmt) -> BlockStmt {
        fold_block_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_block_stmt_or_expr(&mut self, n: BlockStmtOrExpr) -> BlockStmtOrExpr {
        fold_block_stmt_or_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_bool(&mut self, n: Bool) -> Bool {
        fold_bool(self, n)
    }
    #[allow(unused_variables)]
    fn fold_break_stmt(&mut self, n: BreakStmt) -> BreakStmt {
        fold_break_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_call_expr(&mut self, n: CallExpr) -> CallExpr {
        fold_call_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_catch_clause(&mut self, n: CatchClause) -> CatchClause {
        fold_catch_clause(self, n)
    }
    #[allow(unused_variables)]
    fn fold_class(&mut self, n: Class) -> Class {
        fold_class(self, n)
    }
    #[allow(unused_variables)]
    fn fold_class_decl(&mut self, n: ClassDecl) -> ClassDecl {
        fold_class_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_class_expr(&mut self, n: ClassExpr) -> ClassExpr {
        fold_class_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_class_member(&mut self, n: ClassMember) -> ClassMember {
        fold_class_member(self, n)
    }
    #[allow(unused_variables)]
    fn fold_class_members(&mut self, n: Vec<ClassMember>) -> Vec<ClassMember> {
        fold_class_members(self, n)
    }
    #[allow(unused_variables)]
    fn fold_class_method(&mut self, n: ClassMethod) -> ClassMethod {
        fold_class_method(self, n)
    }
    #[allow(unused_variables)]
    fn fold_class_prop(&mut self, n: ClassProp) -> ClassProp {
        fold_class_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_computed_prop_name(&mut self, n: ComputedPropName) -> ComputedPropName {
        fold_computed_prop_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_cond_expr(&mut self, n: CondExpr) -> CondExpr {
        fold_cond_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_constructor(&mut self, n: Constructor) -> Constructor {
        fold_constructor(self, n)
    }
    #[allow(unused_variables)]
    fn fold_continue_stmt(&mut self, n: ContinueStmt) -> ContinueStmt {
        fold_continue_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_debugger_stmt(&mut self, n: DebuggerStmt) -> DebuggerStmt {
        fold_debugger_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_decl(&mut self, n: Decl) -> Decl {
        fold_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_decorator(&mut self, n: Decorator) -> Decorator {
        fold_decorator(self, n)
    }
    #[allow(unused_variables)]
    fn fold_decorators(&mut self, n: Vec<Decorator>) -> Vec<Decorator> {
        fold_decorators(self, n)
    }
    #[allow(unused_variables)]
    fn fold_default_decl(&mut self, n: DefaultDecl) -> DefaultDecl {
        fold_default_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_do_while_stmt(&mut self, n: DoWhileStmt) -> DoWhileStmt {
        fold_do_while_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_empty_stmt(&mut self, n: EmptyStmt) -> EmptyStmt {
        fold_empty_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_export_all(&mut self, n: ExportAll) -> ExportAll {
        fold_export_all(self, n)
    }
    #[allow(unused_variables)]
    fn fold_export_decl(&mut self, n: ExportDecl) -> ExportDecl {
        fold_export_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_export_default_decl(&mut self, n: ExportDefaultDecl) -> ExportDefaultDecl {
        fold_export_default_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_export_default_expr(&mut self, n: ExportDefaultExpr) -> ExportDefaultExpr {
        fold_export_default_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_export_default_specifier(
        &mut self,
        n: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        fold_export_default_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn fold_export_named_specifier(&mut self, n: ExportNamedSpecifier) -> ExportNamedSpecifier {
        fold_export_named_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn fold_export_namespace_specifier(
        &mut self,
        n: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        fold_export_namespace_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn fold_export_specifier(&mut self, n: ExportSpecifier) -> ExportSpecifier {
        fold_export_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn fold_export_specifiers(&mut self, n: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        fold_export_specifiers(self, n)
    }
    #[allow(unused_variables)]
    fn fold_expr(&mut self, n: Expr) -> Expr {
        fold_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_expr_or_spread(&mut self, n: ExprOrSpread) -> ExprOrSpread {
        fold_expr_or_spread(self, n)
    }
    #[allow(unused_variables)]
    fn fold_expr_or_spreads(&mut self, n: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        fold_expr_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn fold_expr_or_super(&mut self, n: ExprOrSuper) -> ExprOrSuper {
        fold_expr_or_super(self, n)
    }
    #[allow(unused_variables)]
    fn fold_expr_stmt(&mut self, n: ExprStmt) -> ExprStmt {
        fold_expr_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_exprs(&mut self, n: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        fold_exprs(self, n)
    }
    #[allow(unused_variables)]
    fn fold_fn_decl(&mut self, n: FnDecl) -> FnDecl {
        fold_fn_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_fn_expr(&mut self, n: FnExpr) -> FnExpr {
        fold_fn_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_for_in_stmt(&mut self, n: ForInStmt) -> ForInStmt {
        fold_for_in_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_for_of_stmt(&mut self, n: ForOfStmt) -> ForOfStmt {
        fold_for_of_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_for_stmt(&mut self, n: ForStmt) -> ForStmt {
        fold_for_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_function(&mut self, n: Function) -> Function {
        fold_function(self, n)
    }
    #[allow(unused_variables)]
    fn fold_getter_prop(&mut self, n: GetterProp) -> GetterProp {
        fold_getter_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ident(&mut self, n: Ident) -> Ident {
        fold_ident(self, n)
    }
    #[allow(unused_variables)]
    fn fold_if_stmt(&mut self, n: IfStmt) -> IfStmt {
        fold_if_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_import_decl(&mut self, n: ImportDecl) -> ImportDecl {
        fold_import_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_import_default_specifier(
        &mut self,
        n: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        fold_import_default_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn fold_import_named_specifier(&mut self, n: ImportNamedSpecifier) -> ImportNamedSpecifier {
        fold_import_named_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn fold_import_specifier(&mut self, n: ImportSpecifier) -> ImportSpecifier {
        fold_import_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn fold_import_specifiers(&mut self, n: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        fold_import_specifiers(self, n)
    }
    #[allow(unused_variables)]
    fn fold_import_star_as_specifier(&mut self, n: ImportStarAsSpecifier) -> ImportStarAsSpecifier {
        fold_import_star_as_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn fold_invalid(&mut self, n: Invalid) -> Invalid {
        fold_invalid(self, n)
    }
    #[allow(unused_variables)]
    fn fold_js_word(&mut self, n: JsWord) -> JsWord {
        fold_js_word(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_attr(&mut self, n: JSXAttr) -> JSXAttr {
        fold_jsx_attr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_attr_name(&mut self, n: JSXAttrName) -> JSXAttrName {
        fold_jsx_attr_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_attr_or_spread(&mut self, n: JSXAttrOrSpread) -> JSXAttrOrSpread {
        fold_jsx_attr_or_spread(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_attr_or_spreads(&mut self, n: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        fold_jsx_attr_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_attr_value(&mut self, n: JSXAttrValue) -> JSXAttrValue {
        fold_jsx_attr_value(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_closing_element(&mut self, n: JSXClosingElement) -> JSXClosingElement {
        fold_jsx_closing_element(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_closing_fragment(&mut self, n: JSXClosingFragment) -> JSXClosingFragment {
        fold_jsx_closing_fragment(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_element(&mut self, n: JSXElement) -> JSXElement {
        fold_jsx_element(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_element_child(&mut self, n: JSXElementChild) -> JSXElementChild {
        fold_jsx_element_child(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_element_children(&mut self, n: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        fold_jsx_element_children(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_element_name(&mut self, n: JSXElementName) -> JSXElementName {
        fold_jsx_element_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_empty_expr(&mut self, n: JSXEmptyExpr) -> JSXEmptyExpr {
        fold_jsx_empty_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_expr(&mut self, n: JSXExpr) -> JSXExpr {
        fold_jsx_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_expr_container(&mut self, n: JSXExprContainer) -> JSXExprContainer {
        fold_jsx_expr_container(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_fragment(&mut self, n: JSXFragment) -> JSXFragment {
        fold_jsx_fragment(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_member_expr(&mut self, n: JSXMemberExpr) -> JSXMemberExpr {
        fold_jsx_member_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_namespaced_name(&mut self, n: JSXNamespacedName) -> JSXNamespacedName {
        fold_jsx_namespaced_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_object(&mut self, n: JSXObject) -> JSXObject {
        fold_jsx_object(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_opening_element(&mut self, n: JSXOpeningElement) -> JSXOpeningElement {
        fold_jsx_opening_element(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_opening_fragment(&mut self, n: JSXOpeningFragment) -> JSXOpeningFragment {
        fold_jsx_opening_fragment(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_spread_child(&mut self, n: JSXSpreadChild) -> JSXSpreadChild {
        fold_jsx_spread_child(self, n)
    }
    #[allow(unused_variables)]
    fn fold_jsx_text(&mut self, n: JSXText) -> JSXText {
        fold_jsx_text(self, n)
    }
    #[allow(unused_variables)]
    fn fold_key_value_pat_prop(&mut self, n: KeyValuePatProp) -> KeyValuePatProp {
        fold_key_value_pat_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_key_value_prop(&mut self, n: KeyValueProp) -> KeyValueProp {
        fold_key_value_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_labeled_stmt(&mut self, n: LabeledStmt) -> LabeledStmt {
        fold_labeled_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_lit(&mut self, n: Lit) -> Lit {
        fold_lit(self, n)
    }
    #[allow(unused_variables)]
    fn fold_member_expr(&mut self, n: MemberExpr) -> MemberExpr {
        fold_member_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_meta_prop_expr(&mut self, n: MetaPropExpr) -> MetaPropExpr {
        fold_meta_prop_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_method_kind(&mut self, n: MethodKind) -> MethodKind {
        fold_method_kind(self, n)
    }
    #[allow(unused_variables)]
    fn fold_method_prop(&mut self, n: MethodProp) -> MethodProp {
        fold_method_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_module(&mut self, n: Module) -> Module {
        fold_module(self, n)
    }
    #[allow(unused_variables)]
    fn fold_module_decl(&mut self, n: ModuleDecl) -> ModuleDecl {
        fold_module_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_module_item(&mut self, n: ModuleItem) -> ModuleItem {
        fold_module_item(self, n)
    }
    #[allow(unused_variables)]
    fn fold_module_items(&mut self, n: Vec<ModuleItem>) -> Vec<ModuleItem> {
        fold_module_items(self, n)
    }
    #[allow(unused_variables)]
    fn fold_named_export(&mut self, n: NamedExport) -> NamedExport {
        fold_named_export(self, n)
    }
    #[allow(unused_variables)]
    fn fold_new_expr(&mut self, n: NewExpr) -> NewExpr {
        fold_new_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_null(&mut self, n: Null) -> Null {
        fold_null(self, n)
    }
    #[allow(unused_variables)]
    fn fold_number(&mut self, n: Number) -> Number {
        fold_number(self, n)
    }
    #[allow(unused_variables)]
    fn fold_object_lit(&mut self, n: ObjectLit) -> ObjectLit {
        fold_object_lit(self, n)
    }
    #[allow(unused_variables)]
    fn fold_object_pat(&mut self, n: ObjectPat) -> ObjectPat {
        fold_object_pat(self, n)
    }
    #[allow(unused_variables)]
    fn fold_object_pat_prop(&mut self, n: ObjectPatProp) -> ObjectPatProp {
        fold_object_pat_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_object_pat_props(&mut self, n: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        fold_object_pat_props(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_accessibility(&mut self, n: Option<Accessibility>) -> Option<Accessibility> {
        fold_opt_accessibility(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_block_stmt(&mut self, n: Option<BlockStmt>) -> Option<BlockStmt> {
        fold_opt_block_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_catch_clause(&mut self, n: Option<CatchClause>) -> Option<CatchClause> {
        fold_opt_catch_clause(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_chain_expr(&mut self, n: OptChainExpr) -> OptChainExpr {
        fold_opt_chain_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_expr(&mut self, n: Option<Box<Expr>>) -> Option<Box<Expr>> {
        fold_opt_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_expr_or_spread(&mut self, n: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        fold_opt_expr_or_spread(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_expr_or_spreads(
        &mut self,
        n: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        fold_opt_expr_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_ident(&mut self, n: Option<Ident>) -> Option<Ident> {
        fold_opt_ident(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_js_word(&mut self, n: Option<JsWord>) -> Option<JsWord> {
        fold_opt_js_word(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_jsx_attr_value(&mut self, n: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        fold_opt_jsx_attr_value(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_jsx_closing_element(
        &mut self,
        n: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        fold_opt_jsx_closing_element(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_object_lit(&mut self, n: Option<ObjectLit>) -> Option<ObjectLit> {
        fold_opt_object_lit(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_pat(&mut self, n: Option<Pat>) -> Option<Pat> {
        fold_opt_pat(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_span(&mut self, n: Option<Span>) -> Option<Span> {
        fold_opt_span(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_stmt(&mut self, n: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        fold_opt_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_str(&mut self, n: Option<Str>) -> Option<Str> {
        fold_opt_str(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_true_plus_minus(&mut self, n: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        fold_opt_true_plus_minus(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_ts_entity_name(&mut self, n: Option<TsEntityName>) -> Option<TsEntityName> {
        fold_opt_ts_entity_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_ts_namespace_body(
        &mut self,
        n: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        fold_opt_ts_namespace_body(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_ts_type(&mut self, n: Option<Box<TsType>>) -> Option<Box<TsType>> {
        fold_opt_ts_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_ts_type_ann(&mut self, n: Option<TsTypeAnn>) -> Option<TsTypeAnn> {
        fold_opt_ts_type_ann(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_ts_type_param_decl(
        &mut self,
        n: Option<TsTypeParamDecl>,
    ) -> Option<TsTypeParamDecl> {
        fold_opt_ts_type_param_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        n: Option<TsTypeParamInstantiation>,
    ) -> Option<TsTypeParamInstantiation> {
        fold_opt_ts_type_param_instantiation(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_var_decl_or_expr(&mut self, n: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        fold_opt_var_decl_or_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        n: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        fold_opt_vec_expr_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn fold_opt_vec_pats(&mut self, n: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        fold_opt_vec_pats(self, n)
    }
    #[allow(unused_variables)]
    fn fold_param(&mut self, n: Param) -> Param {
        fold_param(self, n)
    }
    #[allow(unused_variables)]
    fn fold_param_or_ts_param_prop(&mut self, n: ParamOrTsParamProp) -> ParamOrTsParamProp {
        fold_param_or_ts_param_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_param_or_ts_param_props(
        &mut self,
        n: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        fold_param_or_ts_param_props(self, n)
    }
    #[allow(unused_variables)]
    fn fold_params(&mut self, n: Vec<Param>) -> Vec<Param> {
        fold_params(self, n)
    }
    #[allow(unused_variables)]
    fn fold_paren_expr(&mut self, n: ParenExpr) -> ParenExpr {
        fold_paren_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_pat(&mut self, n: Pat) -> Pat {
        fold_pat(self, n)
    }
    #[allow(unused_variables)]
    fn fold_pat_or_expr(&mut self, n: PatOrExpr) -> PatOrExpr {
        fold_pat_or_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_pats(&mut self, n: Vec<Pat>) -> Vec<Pat> {
        fold_pats(self, n)
    }
    #[allow(unused_variables)]
    fn fold_private_method(&mut self, n: PrivateMethod) -> PrivateMethod {
        fold_private_method(self, n)
    }
    #[allow(unused_variables)]
    fn fold_private_name(&mut self, n: PrivateName) -> PrivateName {
        fold_private_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_private_prop(&mut self, n: PrivateProp) -> PrivateProp {
        fold_private_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_program(&mut self, n: Program) -> Program {
        fold_program(self, n)
    }
    #[allow(unused_variables)]
    fn fold_prop(&mut self, n: Prop) -> Prop {
        fold_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_prop_name(&mut self, n: PropName) -> PropName {
        fold_prop_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_prop_or_spread(&mut self, n: PropOrSpread) -> PropOrSpread {
        fold_prop_or_spread(self, n)
    }
    #[allow(unused_variables)]
    fn fold_prop_or_spreads(&mut self, n: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        fold_prop_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn fold_regex(&mut self, n: Regex) -> Regex {
        fold_regex(self, n)
    }
    #[allow(unused_variables)]
    fn fold_rest_pat(&mut self, n: RestPat) -> RestPat {
        fold_rest_pat(self, n)
    }
    #[allow(unused_variables)]
    fn fold_return_stmt(&mut self, n: ReturnStmt) -> ReturnStmt {
        fold_return_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_script(&mut self, n: Script) -> Script {
        fold_script(self, n)
    }
    #[allow(unused_variables)]
    fn fold_seq_expr(&mut self, n: SeqExpr) -> SeqExpr {
        fold_seq_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_setter_prop(&mut self, n: SetterProp) -> SetterProp {
        fold_setter_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_span(&mut self, n: Span) -> Span {
        fold_span(self, n)
    }
    #[allow(unused_variables)]
    fn fold_spread_element(&mut self, n: SpreadElement) -> SpreadElement {
        fold_spread_element(self, n)
    }
    #[allow(unused_variables)]
    fn fold_stmt(&mut self, n: Stmt) -> Stmt {
        fold_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_stmts(&mut self, n: Vec<Stmt>) -> Vec<Stmt> {
        fold_stmts(self, n)
    }
    #[allow(unused_variables)]
    fn fold_str(&mut self, n: Str) -> Str {
        fold_str(self, n)
    }
    #[allow(unused_variables)]
    fn fold_str_kind(&mut self, n: StrKind) -> StrKind {
        fold_str_kind(self, n)
    }
    #[allow(unused_variables)]
    fn fold_super(&mut self, n: Super) -> Super {
        fold_super(self, n)
    }
    #[allow(unused_variables)]
    fn fold_switch_case(&mut self, n: SwitchCase) -> SwitchCase {
        fold_switch_case(self, n)
    }
    #[allow(unused_variables)]
    fn fold_switch_cases(&mut self, n: Vec<SwitchCase>) -> Vec<SwitchCase> {
        fold_switch_cases(self, n)
    }
    #[allow(unused_variables)]
    fn fold_switch_stmt(&mut self, n: SwitchStmt) -> SwitchStmt {
        fold_switch_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_tagged_tpl(&mut self, n: TaggedTpl) -> TaggedTpl {
        fold_tagged_tpl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_this_expr(&mut self, n: ThisExpr) -> ThisExpr {
        fold_this_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_throw_stmt(&mut self, n: ThrowStmt) -> ThrowStmt {
        fold_throw_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_tpl(&mut self, n: Tpl) -> Tpl {
        fold_tpl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_tpl_element(&mut self, n: TplElement) -> TplElement {
        fold_tpl_element(self, n)
    }
    #[allow(unused_variables)]
    fn fold_tpl_elements(&mut self, n: Vec<TplElement>) -> Vec<TplElement> {
        fold_tpl_elements(self, n)
    }
    #[allow(unused_variables)]
    fn fold_true_plus_minus(&mut self, n: TruePlusMinus) -> TruePlusMinus {
        fold_true_plus_minus(self, n)
    }
    #[allow(unused_variables)]
    fn fold_try_stmt(&mut self, n: TryStmt) -> TryStmt {
        fold_try_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_array_type(&mut self, n: TsArrayType) -> TsArrayType {
        fold_ts_array_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_as_expr(&mut self, n: TsAsExpr) -> TsAsExpr {
        fold_ts_as_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_call_signature_decl(&mut self, n: TsCallSignatureDecl) -> TsCallSignatureDecl {
        fold_ts_call_signature_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_conditional_type(&mut self, n: TsConditionalType) -> TsConditionalType {
        fold_ts_conditional_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_const_assertion(&mut self, n: TsConstAssertion) -> TsConstAssertion {
        fold_ts_const_assertion(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_construct_signature_decl(
        &mut self,
        n: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        fold_ts_construct_signature_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_constructor_type(&mut self, n: TsConstructorType) -> TsConstructorType {
        fold_ts_constructor_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_entity_name(&mut self, n: TsEntityName) -> TsEntityName {
        fold_ts_entity_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_enum_decl(&mut self, n: TsEnumDecl) -> TsEnumDecl {
        fold_ts_enum_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_enum_member(&mut self, n: TsEnumMember) -> TsEnumMember {
        fold_ts_enum_member(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_enum_member_id(&mut self, n: TsEnumMemberId) -> TsEnumMemberId {
        fold_ts_enum_member_id(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_enum_members(&mut self, n: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        fold_ts_enum_members(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_export_assignment(&mut self, n: TsExportAssignment) -> TsExportAssignment {
        fold_ts_export_assignment(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_expr_with_type_args(&mut self, n: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        fold_ts_expr_with_type_args(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_expr_with_type_args_vec(
        &mut self,
        n: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        fold_ts_expr_with_type_args_vec(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_external_module_ref(&mut self, n: TsExternalModuleRef) -> TsExternalModuleRef {
        fold_ts_external_module_ref(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_fn_or_constructor_type(
        &mut self,
        n: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        fold_ts_fn_or_constructor_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_fn_param(&mut self, n: TsFnParam) -> TsFnParam {
        fold_ts_fn_param(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_fn_params(&mut self, n: Vec<TsFnParam>) -> Vec<TsFnParam> {
        fold_ts_fn_params(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_fn_type(&mut self, n: TsFnType) -> TsFnType {
        fold_ts_fn_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_getter_signature(&mut self, n: TsGetterSignature) -> TsGetterSignature {
        fold_ts_getter_signature(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_import_equals_decl(&mut self, n: TsImportEqualsDecl) -> TsImportEqualsDecl {
        fold_ts_import_equals_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_import_type(&mut self, n: TsImportType) -> TsImportType {
        fold_ts_import_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_index_signature(&mut self, n: TsIndexSignature) -> TsIndexSignature {
        fold_ts_index_signature(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_indexed_access_type(&mut self, n: TsIndexedAccessType) -> TsIndexedAccessType {
        fold_ts_indexed_access_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_infer_type(&mut self, n: TsInferType) -> TsInferType {
        fold_ts_infer_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_interface_body(&mut self, n: TsInterfaceBody) -> TsInterfaceBody {
        fold_ts_interface_body(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_interface_decl(&mut self, n: TsInterfaceDecl) -> TsInterfaceDecl {
        fold_ts_interface_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_intersection_type(&mut self, n: TsIntersectionType) -> TsIntersectionType {
        fold_ts_intersection_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_keyword_type(&mut self, n: TsKeywordType) -> TsKeywordType {
        fold_ts_keyword_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_keyword_type_kind(&mut self, n: TsKeywordTypeKind) -> TsKeywordTypeKind {
        fold_ts_keyword_type_kind(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_lit(&mut self, n: TsLit) -> TsLit {
        fold_ts_lit(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_lit_type(&mut self, n: TsLitType) -> TsLitType {
        fold_ts_lit_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_mapped_type(&mut self, n: TsMappedType) -> TsMappedType {
        fold_ts_mapped_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_method_signature(&mut self, n: TsMethodSignature) -> TsMethodSignature {
        fold_ts_method_signature(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_module_block(&mut self, n: TsModuleBlock) -> TsModuleBlock {
        fold_ts_module_block(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_module_decl(&mut self, n: TsModuleDecl) -> TsModuleDecl {
        fold_ts_module_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_module_name(&mut self, n: TsModuleName) -> TsModuleName {
        fold_ts_module_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_module_ref(&mut self, n: TsModuleRef) -> TsModuleRef {
        fold_ts_module_ref(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_namespace_body(&mut self, n: TsNamespaceBody) -> TsNamespaceBody {
        fold_ts_namespace_body(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_namespace_decl(&mut self, n: TsNamespaceDecl) -> TsNamespaceDecl {
        fold_ts_namespace_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_namespace_export_decl(&mut self, n: TsNamespaceExportDecl) -> TsNamespaceExportDecl {
        fold_ts_namespace_export_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_non_null_expr(&mut self, n: TsNonNullExpr) -> TsNonNullExpr {
        fold_ts_non_null_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_optional_type(&mut self, n: TsOptionalType) -> TsOptionalType {
        fold_ts_optional_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_param_prop(&mut self, n: TsParamProp) -> TsParamProp {
        fold_ts_param_prop(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_param_prop_param(&mut self, n: TsParamPropParam) -> TsParamPropParam {
        fold_ts_param_prop_param(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_parenthesized_type(&mut self, n: TsParenthesizedType) -> TsParenthesizedType {
        fold_ts_parenthesized_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_property_signature(&mut self, n: TsPropertySignature) -> TsPropertySignature {
        fold_ts_property_signature(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_qualified_name(&mut self, n: TsQualifiedName) -> TsQualifiedName {
        fold_ts_qualified_name(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_rest_type(&mut self, n: TsRestType) -> TsRestType {
        fold_ts_rest_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_setter_signature(&mut self, n: TsSetterSignature) -> TsSetterSignature {
        fold_ts_setter_signature(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_this_type(&mut self, n: TsThisType) -> TsThisType {
        fold_ts_this_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_this_type_or_ident(&mut self, n: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        fold_ts_this_type_or_ident(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_tpl_lit_type(&mut self, n: TsTplLitType) -> TsTplLitType {
        fold_ts_tpl_lit_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_tuple_element(&mut self, n: TsTupleElement) -> TsTupleElement {
        fold_ts_tuple_element(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_tuple_elements(&mut self, n: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        fold_ts_tuple_elements(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_tuple_type(&mut self, n: TsTupleType) -> TsTupleType {
        fold_ts_tuple_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type(&mut self, n: TsType) -> TsType {
        fold_ts_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_alias_decl(&mut self, n: TsTypeAliasDecl) -> TsTypeAliasDecl {
        fold_ts_type_alias_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_ann(&mut self, n: TsTypeAnn) -> TsTypeAnn {
        fold_ts_type_ann(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_assertion(&mut self, n: TsTypeAssertion) -> TsTypeAssertion {
        fold_ts_type_assertion(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_element(&mut self, n: TsTypeElement) -> TsTypeElement {
        fold_ts_type_element(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_elements(&mut self, n: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        fold_ts_type_elements(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_lit(&mut self, n: TsTypeLit) -> TsTypeLit {
        fold_ts_type_lit(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_operator(&mut self, n: TsTypeOperator) -> TsTypeOperator {
        fold_ts_type_operator(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_operator_op(&mut self, n: TsTypeOperatorOp) -> TsTypeOperatorOp {
        fold_ts_type_operator_op(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_param(&mut self, n: TsTypeParam) -> TsTypeParam {
        fold_ts_type_param(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_param_decl(&mut self, n: TsTypeParamDecl) -> TsTypeParamDecl {
        fold_ts_type_param_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_param_instantiation(
        &mut self,
        n: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        fold_ts_type_param_instantiation(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_params(&mut self, n: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        fold_ts_type_params(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_predicate(&mut self, n: TsTypePredicate) -> TsTypePredicate {
        fold_ts_type_predicate(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_query(&mut self, n: TsTypeQuery) -> TsTypeQuery {
        fold_ts_type_query(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_query_expr(&mut self, n: TsTypeQueryExpr) -> TsTypeQueryExpr {
        fold_ts_type_query_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_type_ref(&mut self, n: TsTypeRef) -> TsTypeRef {
        fold_ts_type_ref(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_types(&mut self, n: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        fold_ts_types(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_union_or_intersection_type(
        &mut self,
        n: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        fold_ts_union_or_intersection_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_ts_union_type(&mut self, n: TsUnionType) -> TsUnionType {
        fold_ts_union_type(self, n)
    }
    #[allow(unused_variables)]
    fn fold_unary_expr(&mut self, n: UnaryExpr) -> UnaryExpr {
        fold_unary_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_unary_op(&mut self, n: UnaryOp) -> UnaryOp {
        fold_unary_op(self, n)
    }
    #[allow(unused_variables)]
    fn fold_update_expr(&mut self, n: UpdateExpr) -> UpdateExpr {
        fold_update_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_update_op(&mut self, n: UpdateOp) -> UpdateOp {
        fold_update_op(self, n)
    }
    #[allow(unused_variables)]
    fn fold_var_decl(&mut self, n: VarDecl) -> VarDecl {
        fold_var_decl(self, n)
    }
    #[allow(unused_variables)]
    fn fold_var_decl_kind(&mut self, n: VarDeclKind) -> VarDeclKind {
        fold_var_decl_kind(self, n)
    }
    #[allow(unused_variables)]
    fn fold_var_decl_or_expr(&mut self, n: VarDeclOrExpr) -> VarDeclOrExpr {
        fold_var_decl_or_expr(self, n)
    }
    #[allow(unused_variables)]
    fn fold_var_decl_or_pat(&mut self, n: VarDeclOrPat) -> VarDeclOrPat {
        fold_var_decl_or_pat(self, n)
    }
    #[allow(unused_variables)]
    fn fold_var_declarator(&mut self, n: VarDeclarator) -> VarDeclarator {
        fold_var_declarator(self, n)
    }
    #[allow(unused_variables)]
    fn fold_var_declarators(&mut self, n: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        fold_var_declarators(self, n)
    }
    #[allow(unused_variables)]
    fn fold_while_stmt(&mut self, n: WhileStmt) -> WhileStmt {
        fold_while_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_with_stmt(&mut self, n: WithStmt) -> WithStmt {
        fold_with_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn fold_yield_expr(&mut self, n: YieldExpr) -> YieldExpr {
        fold_yield_expr(self, n)
    }
}
impl<'a, V> Fold for &'a mut V
where
    V: ?Sized + Fold,
{
    fn fold_accessibility(&mut self, n: Accessibility) -> Accessibility {
        (**self).fold_accessibility(n)
    }
    fn fold_array_lit(&mut self, n: ArrayLit) -> ArrayLit {
        (**self).fold_array_lit(n)
    }
    fn fold_array_pat(&mut self, n: ArrayPat) -> ArrayPat {
        (**self).fold_array_pat(n)
    }
    fn fold_arrow_expr(&mut self, n: ArrowExpr) -> ArrowExpr {
        (**self).fold_arrow_expr(n)
    }
    fn fold_assign_expr(&mut self, n: AssignExpr) -> AssignExpr {
        (**self).fold_assign_expr(n)
    }
    fn fold_assign_op(&mut self, n: AssignOp) -> AssignOp {
        (**self).fold_assign_op(n)
    }
    fn fold_assign_pat(&mut self, n: AssignPat) -> AssignPat {
        (**self).fold_assign_pat(n)
    }
    fn fold_assign_pat_prop(&mut self, n: AssignPatProp) -> AssignPatProp {
        (**self).fold_assign_pat_prop(n)
    }
    fn fold_assign_prop(&mut self, n: AssignProp) -> AssignProp {
        (**self).fold_assign_prop(n)
    }
    fn fold_await_expr(&mut self, n: AwaitExpr) -> AwaitExpr {
        (**self).fold_await_expr(n)
    }
    fn fold_big_int(&mut self, n: BigInt) -> BigInt {
        (**self).fold_big_int(n)
    }
    fn fold_big_int_value(&mut self, n: BigIntValue) -> BigIntValue {
        (**self).fold_big_int_value(n)
    }
    fn fold_bin_expr(&mut self, n: BinExpr) -> BinExpr {
        (**self).fold_bin_expr(n)
    }
    fn fold_binary_op(&mut self, n: BinaryOp) -> BinaryOp {
        (**self).fold_binary_op(n)
    }
    fn fold_binding_ident(&mut self, n: BindingIdent) -> BindingIdent {
        (**self).fold_binding_ident(n)
    }
    fn fold_block_stmt(&mut self, n: BlockStmt) -> BlockStmt {
        (**self).fold_block_stmt(n)
    }
    fn fold_block_stmt_or_expr(&mut self, n: BlockStmtOrExpr) -> BlockStmtOrExpr {
        (**self).fold_block_stmt_or_expr(n)
    }
    fn fold_bool(&mut self, n: Bool) -> Bool {
        (**self).fold_bool(n)
    }
    fn fold_break_stmt(&mut self, n: BreakStmt) -> BreakStmt {
        (**self).fold_break_stmt(n)
    }
    fn fold_call_expr(&mut self, n: CallExpr) -> CallExpr {
        (**self).fold_call_expr(n)
    }
    fn fold_catch_clause(&mut self, n: CatchClause) -> CatchClause {
        (**self).fold_catch_clause(n)
    }
    fn fold_class(&mut self, n: Class) -> Class {
        (**self).fold_class(n)
    }
    fn fold_class_decl(&mut self, n: ClassDecl) -> ClassDecl {
        (**self).fold_class_decl(n)
    }
    fn fold_class_expr(&mut self, n: ClassExpr) -> ClassExpr {
        (**self).fold_class_expr(n)
    }
    fn fold_class_member(&mut self, n: ClassMember) -> ClassMember {
        (**self).fold_class_member(n)
    }
    fn fold_class_members(&mut self, n: Vec<ClassMember>) -> Vec<ClassMember> {
        (**self).fold_class_members(n)
    }
    fn fold_class_method(&mut self, n: ClassMethod) -> ClassMethod {
        (**self).fold_class_method(n)
    }
    fn fold_class_prop(&mut self, n: ClassProp) -> ClassProp {
        (**self).fold_class_prop(n)
    }
    fn fold_computed_prop_name(&mut self, n: ComputedPropName) -> ComputedPropName {
        (**self).fold_computed_prop_name(n)
    }
    fn fold_cond_expr(&mut self, n: CondExpr) -> CondExpr {
        (**self).fold_cond_expr(n)
    }
    fn fold_constructor(&mut self, n: Constructor) -> Constructor {
        (**self).fold_constructor(n)
    }
    fn fold_continue_stmt(&mut self, n: ContinueStmt) -> ContinueStmt {
        (**self).fold_continue_stmt(n)
    }
    fn fold_debugger_stmt(&mut self, n: DebuggerStmt) -> DebuggerStmt {
        (**self).fold_debugger_stmt(n)
    }
    fn fold_decl(&mut self, n: Decl) -> Decl {
        (**self).fold_decl(n)
    }
    fn fold_decorator(&mut self, n: Decorator) -> Decorator {
        (**self).fold_decorator(n)
    }
    fn fold_decorators(&mut self, n: Vec<Decorator>) -> Vec<Decorator> {
        (**self).fold_decorators(n)
    }
    fn fold_default_decl(&mut self, n: DefaultDecl) -> DefaultDecl {
        (**self).fold_default_decl(n)
    }
    fn fold_do_while_stmt(&mut self, n: DoWhileStmt) -> DoWhileStmt {
        (**self).fold_do_while_stmt(n)
    }
    fn fold_empty_stmt(&mut self, n: EmptyStmt) -> EmptyStmt {
        (**self).fold_empty_stmt(n)
    }
    fn fold_export_all(&mut self, n: ExportAll) -> ExportAll {
        (**self).fold_export_all(n)
    }
    fn fold_export_decl(&mut self, n: ExportDecl) -> ExportDecl {
        (**self).fold_export_decl(n)
    }
    fn fold_export_default_decl(&mut self, n: ExportDefaultDecl) -> ExportDefaultDecl {
        (**self).fold_export_default_decl(n)
    }
    fn fold_export_default_expr(&mut self, n: ExportDefaultExpr) -> ExportDefaultExpr {
        (**self).fold_export_default_expr(n)
    }
    fn fold_export_default_specifier(
        &mut self,
        n: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        (**self).fold_export_default_specifier(n)
    }
    fn fold_export_named_specifier(&mut self, n: ExportNamedSpecifier) -> ExportNamedSpecifier {
        (**self).fold_export_named_specifier(n)
    }
    fn fold_export_namespace_specifier(
        &mut self,
        n: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        (**self).fold_export_namespace_specifier(n)
    }
    fn fold_export_specifier(&mut self, n: ExportSpecifier) -> ExportSpecifier {
        (**self).fold_export_specifier(n)
    }
    fn fold_export_specifiers(&mut self, n: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        (**self).fold_export_specifiers(n)
    }
    fn fold_expr(&mut self, n: Expr) -> Expr {
        (**self).fold_expr(n)
    }
    fn fold_expr_or_spread(&mut self, n: ExprOrSpread) -> ExprOrSpread {
        (**self).fold_expr_or_spread(n)
    }
    fn fold_expr_or_spreads(&mut self, n: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        (**self).fold_expr_or_spreads(n)
    }
    fn fold_expr_or_super(&mut self, n: ExprOrSuper) -> ExprOrSuper {
        (**self).fold_expr_or_super(n)
    }
    fn fold_expr_stmt(&mut self, n: ExprStmt) -> ExprStmt {
        (**self).fold_expr_stmt(n)
    }
    fn fold_exprs(&mut self, n: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        (**self).fold_exprs(n)
    }
    fn fold_fn_decl(&mut self, n: FnDecl) -> FnDecl {
        (**self).fold_fn_decl(n)
    }
    fn fold_fn_expr(&mut self, n: FnExpr) -> FnExpr {
        (**self).fold_fn_expr(n)
    }
    fn fold_for_in_stmt(&mut self, n: ForInStmt) -> ForInStmt {
        (**self).fold_for_in_stmt(n)
    }
    fn fold_for_of_stmt(&mut self, n: ForOfStmt) -> ForOfStmt {
        (**self).fold_for_of_stmt(n)
    }
    fn fold_for_stmt(&mut self, n: ForStmt) -> ForStmt {
        (**self).fold_for_stmt(n)
    }
    fn fold_function(&mut self, n: Function) -> Function {
        (**self).fold_function(n)
    }
    fn fold_getter_prop(&mut self, n: GetterProp) -> GetterProp {
        (**self).fold_getter_prop(n)
    }
    fn fold_ident(&mut self, n: Ident) -> Ident {
        (**self).fold_ident(n)
    }
    fn fold_if_stmt(&mut self, n: IfStmt) -> IfStmt {
        (**self).fold_if_stmt(n)
    }
    fn fold_import_decl(&mut self, n: ImportDecl) -> ImportDecl {
        (**self).fold_import_decl(n)
    }
    fn fold_import_default_specifier(
        &mut self,
        n: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        (**self).fold_import_default_specifier(n)
    }
    fn fold_import_named_specifier(&mut self, n: ImportNamedSpecifier) -> ImportNamedSpecifier {
        (**self).fold_import_named_specifier(n)
    }
    fn fold_import_specifier(&mut self, n: ImportSpecifier) -> ImportSpecifier {
        (**self).fold_import_specifier(n)
    }
    fn fold_import_specifiers(&mut self, n: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        (**self).fold_import_specifiers(n)
    }
    fn fold_import_star_as_specifier(&mut self, n: ImportStarAsSpecifier) -> ImportStarAsSpecifier {
        (**self).fold_import_star_as_specifier(n)
    }
    fn fold_invalid(&mut self, n: Invalid) -> Invalid {
        (**self).fold_invalid(n)
    }
    fn fold_js_word(&mut self, n: JsWord) -> JsWord {
        (**self).fold_js_word(n)
    }
    fn fold_jsx_attr(&mut self, n: JSXAttr) -> JSXAttr {
        (**self).fold_jsx_attr(n)
    }
    fn fold_jsx_attr_name(&mut self, n: JSXAttrName) -> JSXAttrName {
        (**self).fold_jsx_attr_name(n)
    }
    fn fold_jsx_attr_or_spread(&mut self, n: JSXAttrOrSpread) -> JSXAttrOrSpread {
        (**self).fold_jsx_attr_or_spread(n)
    }
    fn fold_jsx_attr_or_spreads(&mut self, n: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        (**self).fold_jsx_attr_or_spreads(n)
    }
    fn fold_jsx_attr_value(&mut self, n: JSXAttrValue) -> JSXAttrValue {
        (**self).fold_jsx_attr_value(n)
    }
    fn fold_jsx_closing_element(&mut self, n: JSXClosingElement) -> JSXClosingElement {
        (**self).fold_jsx_closing_element(n)
    }
    fn fold_jsx_closing_fragment(&mut self, n: JSXClosingFragment) -> JSXClosingFragment {
        (**self).fold_jsx_closing_fragment(n)
    }
    fn fold_jsx_element(&mut self, n: JSXElement) -> JSXElement {
        (**self).fold_jsx_element(n)
    }
    fn fold_jsx_element_child(&mut self, n: JSXElementChild) -> JSXElementChild {
        (**self).fold_jsx_element_child(n)
    }
    fn fold_jsx_element_children(&mut self, n: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        (**self).fold_jsx_element_children(n)
    }
    fn fold_jsx_element_name(&mut self, n: JSXElementName) -> JSXElementName {
        (**self).fold_jsx_element_name(n)
    }
    fn fold_jsx_empty_expr(&mut self, n: JSXEmptyExpr) -> JSXEmptyExpr {
        (**self).fold_jsx_empty_expr(n)
    }
    fn fold_jsx_expr(&mut self, n: JSXExpr) -> JSXExpr {
        (**self).fold_jsx_expr(n)
    }
    fn fold_jsx_expr_container(&mut self, n: JSXExprContainer) -> JSXExprContainer {
        (**self).fold_jsx_expr_container(n)
    }
    fn fold_jsx_fragment(&mut self, n: JSXFragment) -> JSXFragment {
        (**self).fold_jsx_fragment(n)
    }
    fn fold_jsx_member_expr(&mut self, n: JSXMemberExpr) -> JSXMemberExpr {
        (**self).fold_jsx_member_expr(n)
    }
    fn fold_jsx_namespaced_name(&mut self, n: JSXNamespacedName) -> JSXNamespacedName {
        (**self).fold_jsx_namespaced_name(n)
    }
    fn fold_jsx_object(&mut self, n: JSXObject) -> JSXObject {
        (**self).fold_jsx_object(n)
    }
    fn fold_jsx_opening_element(&mut self, n: JSXOpeningElement) -> JSXOpeningElement {
        (**self).fold_jsx_opening_element(n)
    }
    fn fold_jsx_opening_fragment(&mut self, n: JSXOpeningFragment) -> JSXOpeningFragment {
        (**self).fold_jsx_opening_fragment(n)
    }
    fn fold_jsx_spread_child(&mut self, n: JSXSpreadChild) -> JSXSpreadChild {
        (**self).fold_jsx_spread_child(n)
    }
    fn fold_jsx_text(&mut self, n: JSXText) -> JSXText {
        (**self).fold_jsx_text(n)
    }
    fn fold_key_value_pat_prop(&mut self, n: KeyValuePatProp) -> KeyValuePatProp {
        (**self).fold_key_value_pat_prop(n)
    }
    fn fold_key_value_prop(&mut self, n: KeyValueProp) -> KeyValueProp {
        (**self).fold_key_value_prop(n)
    }
    fn fold_labeled_stmt(&mut self, n: LabeledStmt) -> LabeledStmt {
        (**self).fold_labeled_stmt(n)
    }
    fn fold_lit(&mut self, n: Lit) -> Lit {
        (**self).fold_lit(n)
    }
    fn fold_member_expr(&mut self, n: MemberExpr) -> MemberExpr {
        (**self).fold_member_expr(n)
    }
    fn fold_meta_prop_expr(&mut self, n: MetaPropExpr) -> MetaPropExpr {
        (**self).fold_meta_prop_expr(n)
    }
    fn fold_method_kind(&mut self, n: MethodKind) -> MethodKind {
        (**self).fold_method_kind(n)
    }
    fn fold_method_prop(&mut self, n: MethodProp) -> MethodProp {
        (**self).fold_method_prop(n)
    }
    fn fold_module(&mut self, n: Module) -> Module {
        (**self).fold_module(n)
    }
    fn fold_module_decl(&mut self, n: ModuleDecl) -> ModuleDecl {
        (**self).fold_module_decl(n)
    }
    fn fold_module_item(&mut self, n: ModuleItem) -> ModuleItem {
        (**self).fold_module_item(n)
    }
    fn fold_module_items(&mut self, n: Vec<ModuleItem>) -> Vec<ModuleItem> {
        (**self).fold_module_items(n)
    }
    fn fold_named_export(&mut self, n: NamedExport) -> NamedExport {
        (**self).fold_named_export(n)
    }
    fn fold_new_expr(&mut self, n: NewExpr) -> NewExpr {
        (**self).fold_new_expr(n)
    }
    fn fold_null(&mut self, n: Null) -> Null {
        (**self).fold_null(n)
    }
    fn fold_number(&mut self, n: Number) -> Number {
        (**self).fold_number(n)
    }
    fn fold_object_lit(&mut self, n: ObjectLit) -> ObjectLit {
        (**self).fold_object_lit(n)
    }
    fn fold_object_pat(&mut self, n: ObjectPat) -> ObjectPat {
        (**self).fold_object_pat(n)
    }
    fn fold_object_pat_prop(&mut self, n: ObjectPatProp) -> ObjectPatProp {
        (**self).fold_object_pat_prop(n)
    }
    fn fold_object_pat_props(&mut self, n: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        (**self).fold_object_pat_props(n)
    }
    fn fold_opt_accessibility(&mut self, n: Option<Accessibility>) -> Option<Accessibility> {
        (**self).fold_opt_accessibility(n)
    }
    fn fold_opt_block_stmt(&mut self, n: Option<BlockStmt>) -> Option<BlockStmt> {
        (**self).fold_opt_block_stmt(n)
    }
    fn fold_opt_catch_clause(&mut self, n: Option<CatchClause>) -> Option<CatchClause> {
        (**self).fold_opt_catch_clause(n)
    }
    fn fold_opt_chain_expr(&mut self, n: OptChainExpr) -> OptChainExpr {
        (**self).fold_opt_chain_expr(n)
    }
    fn fold_opt_expr(&mut self, n: Option<Box<Expr>>) -> Option<Box<Expr>> {
        (**self).fold_opt_expr(n)
    }
    fn fold_opt_expr_or_spread(&mut self, n: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        (**self).fold_opt_expr_or_spread(n)
    }
    fn fold_opt_expr_or_spreads(
        &mut self,
        n: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        (**self).fold_opt_expr_or_spreads(n)
    }
    fn fold_opt_ident(&mut self, n: Option<Ident>) -> Option<Ident> {
        (**self).fold_opt_ident(n)
    }
    fn fold_opt_js_word(&mut self, n: Option<JsWord>) -> Option<JsWord> {
        (**self).fold_opt_js_word(n)
    }
    fn fold_opt_jsx_attr_value(&mut self, n: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        (**self).fold_opt_jsx_attr_value(n)
    }
    fn fold_opt_jsx_closing_element(
        &mut self,
        n: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        (**self).fold_opt_jsx_closing_element(n)
    }
    fn fold_opt_object_lit(&mut self, n: Option<ObjectLit>) -> Option<ObjectLit> {
        (**self).fold_opt_object_lit(n)
    }
    fn fold_opt_pat(&mut self, n: Option<Pat>) -> Option<Pat> {
        (**self).fold_opt_pat(n)
    }
    fn fold_opt_span(&mut self, n: Option<Span>) -> Option<Span> {
        (**self).fold_opt_span(n)
    }
    fn fold_opt_stmt(&mut self, n: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        (**self).fold_opt_stmt(n)
    }
    fn fold_opt_str(&mut self, n: Option<Str>) -> Option<Str> {
        (**self).fold_opt_str(n)
    }
    fn fold_opt_true_plus_minus(&mut self, n: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        (**self).fold_opt_true_plus_minus(n)
    }
    fn fold_opt_ts_entity_name(&mut self, n: Option<TsEntityName>) -> Option<TsEntityName> {
        (**self).fold_opt_ts_entity_name(n)
    }
    fn fold_opt_ts_namespace_body(
        &mut self,
        n: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        (**self).fold_opt_ts_namespace_body(n)
    }
    fn fold_opt_ts_type(&mut self, n: Option<Box<TsType>>) -> Option<Box<TsType>> {
        (**self).fold_opt_ts_type(n)
    }
    fn fold_opt_ts_type_ann(&mut self, n: Option<TsTypeAnn>) -> Option<TsTypeAnn> {
        (**self).fold_opt_ts_type_ann(n)
    }
    fn fold_opt_ts_type_param_decl(
        &mut self,
        n: Option<TsTypeParamDecl>,
    ) -> Option<TsTypeParamDecl> {
        (**self).fold_opt_ts_type_param_decl(n)
    }
    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        n: Option<TsTypeParamInstantiation>,
    ) -> Option<TsTypeParamInstantiation> {
        (**self).fold_opt_ts_type_param_instantiation(n)
    }
    fn fold_opt_var_decl_or_expr(&mut self, n: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        (**self).fold_opt_var_decl_or_expr(n)
    }
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        n: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        (**self).fold_opt_vec_expr_or_spreads(n)
    }
    fn fold_opt_vec_pats(&mut self, n: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        (**self).fold_opt_vec_pats(n)
    }
    fn fold_param(&mut self, n: Param) -> Param {
        (**self).fold_param(n)
    }
    fn fold_param_or_ts_param_prop(&mut self, n: ParamOrTsParamProp) -> ParamOrTsParamProp {
        (**self).fold_param_or_ts_param_prop(n)
    }
    fn fold_param_or_ts_param_props(
        &mut self,
        n: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        (**self).fold_param_or_ts_param_props(n)
    }
    fn fold_params(&mut self, n: Vec<Param>) -> Vec<Param> {
        (**self).fold_params(n)
    }
    fn fold_paren_expr(&mut self, n: ParenExpr) -> ParenExpr {
        (**self).fold_paren_expr(n)
    }
    fn fold_pat(&mut self, n: Pat) -> Pat {
        (**self).fold_pat(n)
    }
    fn fold_pat_or_expr(&mut self, n: PatOrExpr) -> PatOrExpr {
        (**self).fold_pat_or_expr(n)
    }
    fn fold_pats(&mut self, n: Vec<Pat>) -> Vec<Pat> {
        (**self).fold_pats(n)
    }
    fn fold_private_method(&mut self, n: PrivateMethod) -> PrivateMethod {
        (**self).fold_private_method(n)
    }
    fn fold_private_name(&mut self, n: PrivateName) -> PrivateName {
        (**self).fold_private_name(n)
    }
    fn fold_private_prop(&mut self, n: PrivateProp) -> PrivateProp {
        (**self).fold_private_prop(n)
    }
    fn fold_program(&mut self, n: Program) -> Program {
        (**self).fold_program(n)
    }
    fn fold_prop(&mut self, n: Prop) -> Prop {
        (**self).fold_prop(n)
    }
    fn fold_prop_name(&mut self, n: PropName) -> PropName {
        (**self).fold_prop_name(n)
    }
    fn fold_prop_or_spread(&mut self, n: PropOrSpread) -> PropOrSpread {
        (**self).fold_prop_or_spread(n)
    }
    fn fold_prop_or_spreads(&mut self, n: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        (**self).fold_prop_or_spreads(n)
    }
    fn fold_regex(&mut self, n: Regex) -> Regex {
        (**self).fold_regex(n)
    }
    fn fold_rest_pat(&mut self, n: RestPat) -> RestPat {
        (**self).fold_rest_pat(n)
    }
    fn fold_return_stmt(&mut self, n: ReturnStmt) -> ReturnStmt {
        (**self).fold_return_stmt(n)
    }
    fn fold_script(&mut self, n: Script) -> Script {
        (**self).fold_script(n)
    }
    fn fold_seq_expr(&mut self, n: SeqExpr) -> SeqExpr {
        (**self).fold_seq_expr(n)
    }
    fn fold_setter_prop(&mut self, n: SetterProp) -> SetterProp {
        (**self).fold_setter_prop(n)
    }
    fn fold_span(&mut self, n: Span) -> Span {
        (**self).fold_span(n)
    }
    fn fold_spread_element(&mut self, n: SpreadElement) -> SpreadElement {
        (**self).fold_spread_element(n)
    }
    fn fold_stmt(&mut self, n: Stmt) -> Stmt {
        (**self).fold_stmt(n)
    }
    fn fold_stmts(&mut self, n: Vec<Stmt>) -> Vec<Stmt> {
        (**self).fold_stmts(n)
    }
    fn fold_str(&mut self, n: Str) -> Str {
        (**self).fold_str(n)
    }
    fn fold_str_kind(&mut self, n: StrKind) -> StrKind {
        (**self).fold_str_kind(n)
    }
    fn fold_super(&mut self, n: Super) -> Super {
        (**self).fold_super(n)
    }
    fn fold_switch_case(&mut self, n: SwitchCase) -> SwitchCase {
        (**self).fold_switch_case(n)
    }
    fn fold_switch_cases(&mut self, n: Vec<SwitchCase>) -> Vec<SwitchCase> {
        (**self).fold_switch_cases(n)
    }
    fn fold_switch_stmt(&mut self, n: SwitchStmt) -> SwitchStmt {
        (**self).fold_switch_stmt(n)
    }
    fn fold_tagged_tpl(&mut self, n: TaggedTpl) -> TaggedTpl {
        (**self).fold_tagged_tpl(n)
    }
    fn fold_this_expr(&mut self, n: ThisExpr) -> ThisExpr {
        (**self).fold_this_expr(n)
    }
    fn fold_throw_stmt(&mut self, n: ThrowStmt) -> ThrowStmt {
        (**self).fold_throw_stmt(n)
    }
    fn fold_tpl(&mut self, n: Tpl) -> Tpl {
        (**self).fold_tpl(n)
    }
    fn fold_tpl_element(&mut self, n: TplElement) -> TplElement {
        (**self).fold_tpl_element(n)
    }
    fn fold_tpl_elements(&mut self, n: Vec<TplElement>) -> Vec<TplElement> {
        (**self).fold_tpl_elements(n)
    }
    fn fold_true_plus_minus(&mut self, n: TruePlusMinus) -> TruePlusMinus {
        (**self).fold_true_plus_minus(n)
    }
    fn fold_try_stmt(&mut self, n: TryStmt) -> TryStmt {
        (**self).fold_try_stmt(n)
    }
    fn fold_ts_array_type(&mut self, n: TsArrayType) -> TsArrayType {
        (**self).fold_ts_array_type(n)
    }
    fn fold_ts_as_expr(&mut self, n: TsAsExpr) -> TsAsExpr {
        (**self).fold_ts_as_expr(n)
    }
    fn fold_ts_call_signature_decl(&mut self, n: TsCallSignatureDecl) -> TsCallSignatureDecl {
        (**self).fold_ts_call_signature_decl(n)
    }
    fn fold_ts_conditional_type(&mut self, n: TsConditionalType) -> TsConditionalType {
        (**self).fold_ts_conditional_type(n)
    }
    fn fold_ts_const_assertion(&mut self, n: TsConstAssertion) -> TsConstAssertion {
        (**self).fold_ts_const_assertion(n)
    }
    fn fold_ts_construct_signature_decl(
        &mut self,
        n: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        (**self).fold_ts_construct_signature_decl(n)
    }
    fn fold_ts_constructor_type(&mut self, n: TsConstructorType) -> TsConstructorType {
        (**self).fold_ts_constructor_type(n)
    }
    fn fold_ts_entity_name(&mut self, n: TsEntityName) -> TsEntityName {
        (**self).fold_ts_entity_name(n)
    }
    fn fold_ts_enum_decl(&mut self, n: TsEnumDecl) -> TsEnumDecl {
        (**self).fold_ts_enum_decl(n)
    }
    fn fold_ts_enum_member(&mut self, n: TsEnumMember) -> TsEnumMember {
        (**self).fold_ts_enum_member(n)
    }
    fn fold_ts_enum_member_id(&mut self, n: TsEnumMemberId) -> TsEnumMemberId {
        (**self).fold_ts_enum_member_id(n)
    }
    fn fold_ts_enum_members(&mut self, n: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        (**self).fold_ts_enum_members(n)
    }
    fn fold_ts_export_assignment(&mut self, n: TsExportAssignment) -> TsExportAssignment {
        (**self).fold_ts_export_assignment(n)
    }
    fn fold_ts_expr_with_type_args(&mut self, n: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        (**self).fold_ts_expr_with_type_args(n)
    }
    fn fold_ts_expr_with_type_args_vec(
        &mut self,
        n: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        (**self).fold_ts_expr_with_type_args_vec(n)
    }
    fn fold_ts_external_module_ref(&mut self, n: TsExternalModuleRef) -> TsExternalModuleRef {
        (**self).fold_ts_external_module_ref(n)
    }
    fn fold_ts_fn_or_constructor_type(
        &mut self,
        n: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        (**self).fold_ts_fn_or_constructor_type(n)
    }
    fn fold_ts_fn_param(&mut self, n: TsFnParam) -> TsFnParam {
        (**self).fold_ts_fn_param(n)
    }
    fn fold_ts_fn_params(&mut self, n: Vec<TsFnParam>) -> Vec<TsFnParam> {
        (**self).fold_ts_fn_params(n)
    }
    fn fold_ts_fn_type(&mut self, n: TsFnType) -> TsFnType {
        (**self).fold_ts_fn_type(n)
    }
    fn fold_ts_getter_signature(&mut self, n: TsGetterSignature) -> TsGetterSignature {
        (**self).fold_ts_getter_signature(n)
    }
    fn fold_ts_import_equals_decl(&mut self, n: TsImportEqualsDecl) -> TsImportEqualsDecl {
        (**self).fold_ts_import_equals_decl(n)
    }
    fn fold_ts_import_type(&mut self, n: TsImportType) -> TsImportType {
        (**self).fold_ts_import_type(n)
    }
    fn fold_ts_index_signature(&mut self, n: TsIndexSignature) -> TsIndexSignature {
        (**self).fold_ts_index_signature(n)
    }
    fn fold_ts_indexed_access_type(&mut self, n: TsIndexedAccessType) -> TsIndexedAccessType {
        (**self).fold_ts_indexed_access_type(n)
    }
    fn fold_ts_infer_type(&mut self, n: TsInferType) -> TsInferType {
        (**self).fold_ts_infer_type(n)
    }
    fn fold_ts_interface_body(&mut self, n: TsInterfaceBody) -> TsInterfaceBody {
        (**self).fold_ts_interface_body(n)
    }
    fn fold_ts_interface_decl(&mut self, n: TsInterfaceDecl) -> TsInterfaceDecl {
        (**self).fold_ts_interface_decl(n)
    }
    fn fold_ts_intersection_type(&mut self, n: TsIntersectionType) -> TsIntersectionType {
        (**self).fold_ts_intersection_type(n)
    }
    fn fold_ts_keyword_type(&mut self, n: TsKeywordType) -> TsKeywordType {
        (**self).fold_ts_keyword_type(n)
    }
    fn fold_ts_keyword_type_kind(&mut self, n: TsKeywordTypeKind) -> TsKeywordTypeKind {
        (**self).fold_ts_keyword_type_kind(n)
    }
    fn fold_ts_lit(&mut self, n: TsLit) -> TsLit {
        (**self).fold_ts_lit(n)
    }
    fn fold_ts_lit_type(&mut self, n: TsLitType) -> TsLitType {
        (**self).fold_ts_lit_type(n)
    }
    fn fold_ts_mapped_type(&mut self, n: TsMappedType) -> TsMappedType {
        (**self).fold_ts_mapped_type(n)
    }
    fn fold_ts_method_signature(&mut self, n: TsMethodSignature) -> TsMethodSignature {
        (**self).fold_ts_method_signature(n)
    }
    fn fold_ts_module_block(&mut self, n: TsModuleBlock) -> TsModuleBlock {
        (**self).fold_ts_module_block(n)
    }
    fn fold_ts_module_decl(&mut self, n: TsModuleDecl) -> TsModuleDecl {
        (**self).fold_ts_module_decl(n)
    }
    fn fold_ts_module_name(&mut self, n: TsModuleName) -> TsModuleName {
        (**self).fold_ts_module_name(n)
    }
    fn fold_ts_module_ref(&mut self, n: TsModuleRef) -> TsModuleRef {
        (**self).fold_ts_module_ref(n)
    }
    fn fold_ts_namespace_body(&mut self, n: TsNamespaceBody) -> TsNamespaceBody {
        (**self).fold_ts_namespace_body(n)
    }
    fn fold_ts_namespace_decl(&mut self, n: TsNamespaceDecl) -> TsNamespaceDecl {
        (**self).fold_ts_namespace_decl(n)
    }
    fn fold_ts_namespace_export_decl(&mut self, n: TsNamespaceExportDecl) -> TsNamespaceExportDecl {
        (**self).fold_ts_namespace_export_decl(n)
    }
    fn fold_ts_non_null_expr(&mut self, n: TsNonNullExpr) -> TsNonNullExpr {
        (**self).fold_ts_non_null_expr(n)
    }
    fn fold_ts_optional_type(&mut self, n: TsOptionalType) -> TsOptionalType {
        (**self).fold_ts_optional_type(n)
    }
    fn fold_ts_param_prop(&mut self, n: TsParamProp) -> TsParamProp {
        (**self).fold_ts_param_prop(n)
    }
    fn fold_ts_param_prop_param(&mut self, n: TsParamPropParam) -> TsParamPropParam {
        (**self).fold_ts_param_prop_param(n)
    }
    fn fold_ts_parenthesized_type(&mut self, n: TsParenthesizedType) -> TsParenthesizedType {
        (**self).fold_ts_parenthesized_type(n)
    }
    fn fold_ts_property_signature(&mut self, n: TsPropertySignature) -> TsPropertySignature {
        (**self).fold_ts_property_signature(n)
    }
    fn fold_ts_qualified_name(&mut self, n: TsQualifiedName) -> TsQualifiedName {
        (**self).fold_ts_qualified_name(n)
    }
    fn fold_ts_rest_type(&mut self, n: TsRestType) -> TsRestType {
        (**self).fold_ts_rest_type(n)
    }
    fn fold_ts_setter_signature(&mut self, n: TsSetterSignature) -> TsSetterSignature {
        (**self).fold_ts_setter_signature(n)
    }
    fn fold_ts_this_type(&mut self, n: TsThisType) -> TsThisType {
        (**self).fold_ts_this_type(n)
    }
    fn fold_ts_this_type_or_ident(&mut self, n: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        (**self).fold_ts_this_type_or_ident(n)
    }
    fn fold_ts_tpl_lit_type(&mut self, n: TsTplLitType) -> TsTplLitType {
        (**self).fold_ts_tpl_lit_type(n)
    }
    fn fold_ts_tuple_element(&mut self, n: TsTupleElement) -> TsTupleElement {
        (**self).fold_ts_tuple_element(n)
    }
    fn fold_ts_tuple_elements(&mut self, n: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        (**self).fold_ts_tuple_elements(n)
    }
    fn fold_ts_tuple_type(&mut self, n: TsTupleType) -> TsTupleType {
        (**self).fold_ts_tuple_type(n)
    }
    fn fold_ts_type(&mut self, n: TsType) -> TsType {
        (**self).fold_ts_type(n)
    }
    fn fold_ts_type_alias_decl(&mut self, n: TsTypeAliasDecl) -> TsTypeAliasDecl {
        (**self).fold_ts_type_alias_decl(n)
    }
    fn fold_ts_type_ann(&mut self, n: TsTypeAnn) -> TsTypeAnn {
        (**self).fold_ts_type_ann(n)
    }
    fn fold_ts_type_assertion(&mut self, n: TsTypeAssertion) -> TsTypeAssertion {
        (**self).fold_ts_type_assertion(n)
    }
    fn fold_ts_type_element(&mut self, n: TsTypeElement) -> TsTypeElement {
        (**self).fold_ts_type_element(n)
    }
    fn fold_ts_type_elements(&mut self, n: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        (**self).fold_ts_type_elements(n)
    }
    fn fold_ts_type_lit(&mut self, n: TsTypeLit) -> TsTypeLit {
        (**self).fold_ts_type_lit(n)
    }
    fn fold_ts_type_operator(&mut self, n: TsTypeOperator) -> TsTypeOperator {
        (**self).fold_ts_type_operator(n)
    }
    fn fold_ts_type_operator_op(&mut self, n: TsTypeOperatorOp) -> TsTypeOperatorOp {
        (**self).fold_ts_type_operator_op(n)
    }
    fn fold_ts_type_param(&mut self, n: TsTypeParam) -> TsTypeParam {
        (**self).fold_ts_type_param(n)
    }
    fn fold_ts_type_param_decl(&mut self, n: TsTypeParamDecl) -> TsTypeParamDecl {
        (**self).fold_ts_type_param_decl(n)
    }
    fn fold_ts_type_param_instantiation(
        &mut self,
        n: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        (**self).fold_ts_type_param_instantiation(n)
    }
    fn fold_ts_type_params(&mut self, n: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        (**self).fold_ts_type_params(n)
    }
    fn fold_ts_type_predicate(&mut self, n: TsTypePredicate) -> TsTypePredicate {
        (**self).fold_ts_type_predicate(n)
    }
    fn fold_ts_type_query(&mut self, n: TsTypeQuery) -> TsTypeQuery {
        (**self).fold_ts_type_query(n)
    }
    fn fold_ts_type_query_expr(&mut self, n: TsTypeQueryExpr) -> TsTypeQueryExpr {
        (**self).fold_ts_type_query_expr(n)
    }
    fn fold_ts_type_ref(&mut self, n: TsTypeRef) -> TsTypeRef {
        (**self).fold_ts_type_ref(n)
    }
    fn fold_ts_types(&mut self, n: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        (**self).fold_ts_types(n)
    }
    fn fold_ts_union_or_intersection_type(
        &mut self,
        n: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        (**self).fold_ts_union_or_intersection_type(n)
    }
    fn fold_ts_union_type(&mut self, n: TsUnionType) -> TsUnionType {
        (**self).fold_ts_union_type(n)
    }
    fn fold_unary_expr(&mut self, n: UnaryExpr) -> UnaryExpr {
        (**self).fold_unary_expr(n)
    }
    fn fold_unary_op(&mut self, n: UnaryOp) -> UnaryOp {
        (**self).fold_unary_op(n)
    }
    fn fold_update_expr(&mut self, n: UpdateExpr) -> UpdateExpr {
        (**self).fold_update_expr(n)
    }
    fn fold_update_op(&mut self, n: UpdateOp) -> UpdateOp {
        (**self).fold_update_op(n)
    }
    fn fold_var_decl(&mut self, n: VarDecl) -> VarDecl {
        (**self).fold_var_decl(n)
    }
    fn fold_var_decl_kind(&mut self, n: VarDeclKind) -> VarDeclKind {
        (**self).fold_var_decl_kind(n)
    }
    fn fold_var_decl_or_expr(&mut self, n: VarDeclOrExpr) -> VarDeclOrExpr {
        (**self).fold_var_decl_or_expr(n)
    }
    fn fold_var_decl_or_pat(&mut self, n: VarDeclOrPat) -> VarDeclOrPat {
        (**self).fold_var_decl_or_pat(n)
    }
    fn fold_var_declarator(&mut self, n: VarDeclarator) -> VarDeclarator {
        (**self).fold_var_declarator(n)
    }
    fn fold_var_declarators(&mut self, n: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        (**self).fold_var_declarators(n)
    }
    fn fold_while_stmt(&mut self, n: WhileStmt) -> WhileStmt {
        (**self).fold_while_stmt(n)
    }
    fn fold_with_stmt(&mut self, n: WithStmt) -> WithStmt {
        (**self).fold_with_stmt(n)
    }
    fn fold_yield_expr(&mut self, n: YieldExpr) -> YieldExpr {
        (**self).fold_yield_expr(n)
    }
}
impl<V> Fold for Box<V>
where
    V: ?Sized + Fold,
{
    fn fold_accessibility(&mut self, n: Accessibility) -> Accessibility {
        (**self).fold_accessibility(n)
    }
    fn fold_array_lit(&mut self, n: ArrayLit) -> ArrayLit {
        (**self).fold_array_lit(n)
    }
    fn fold_array_pat(&mut self, n: ArrayPat) -> ArrayPat {
        (**self).fold_array_pat(n)
    }
    fn fold_arrow_expr(&mut self, n: ArrowExpr) -> ArrowExpr {
        (**self).fold_arrow_expr(n)
    }
    fn fold_assign_expr(&mut self, n: AssignExpr) -> AssignExpr {
        (**self).fold_assign_expr(n)
    }
    fn fold_assign_op(&mut self, n: AssignOp) -> AssignOp {
        (**self).fold_assign_op(n)
    }
    fn fold_assign_pat(&mut self, n: AssignPat) -> AssignPat {
        (**self).fold_assign_pat(n)
    }
    fn fold_assign_pat_prop(&mut self, n: AssignPatProp) -> AssignPatProp {
        (**self).fold_assign_pat_prop(n)
    }
    fn fold_assign_prop(&mut self, n: AssignProp) -> AssignProp {
        (**self).fold_assign_prop(n)
    }
    fn fold_await_expr(&mut self, n: AwaitExpr) -> AwaitExpr {
        (**self).fold_await_expr(n)
    }
    fn fold_big_int(&mut self, n: BigInt) -> BigInt {
        (**self).fold_big_int(n)
    }
    fn fold_big_int_value(&mut self, n: BigIntValue) -> BigIntValue {
        (**self).fold_big_int_value(n)
    }
    fn fold_bin_expr(&mut self, n: BinExpr) -> BinExpr {
        (**self).fold_bin_expr(n)
    }
    fn fold_binary_op(&mut self, n: BinaryOp) -> BinaryOp {
        (**self).fold_binary_op(n)
    }
    fn fold_binding_ident(&mut self, n: BindingIdent) -> BindingIdent {
        (**self).fold_binding_ident(n)
    }
    fn fold_block_stmt(&mut self, n: BlockStmt) -> BlockStmt {
        (**self).fold_block_stmt(n)
    }
    fn fold_block_stmt_or_expr(&mut self, n: BlockStmtOrExpr) -> BlockStmtOrExpr {
        (**self).fold_block_stmt_or_expr(n)
    }
    fn fold_bool(&mut self, n: Bool) -> Bool {
        (**self).fold_bool(n)
    }
    fn fold_break_stmt(&mut self, n: BreakStmt) -> BreakStmt {
        (**self).fold_break_stmt(n)
    }
    fn fold_call_expr(&mut self, n: CallExpr) -> CallExpr {
        (**self).fold_call_expr(n)
    }
    fn fold_catch_clause(&mut self, n: CatchClause) -> CatchClause {
        (**self).fold_catch_clause(n)
    }
    fn fold_class(&mut self, n: Class) -> Class {
        (**self).fold_class(n)
    }
    fn fold_class_decl(&mut self, n: ClassDecl) -> ClassDecl {
        (**self).fold_class_decl(n)
    }
    fn fold_class_expr(&mut self, n: ClassExpr) -> ClassExpr {
        (**self).fold_class_expr(n)
    }
    fn fold_class_member(&mut self, n: ClassMember) -> ClassMember {
        (**self).fold_class_member(n)
    }
    fn fold_class_members(&mut self, n: Vec<ClassMember>) -> Vec<ClassMember> {
        (**self).fold_class_members(n)
    }
    fn fold_class_method(&mut self, n: ClassMethod) -> ClassMethod {
        (**self).fold_class_method(n)
    }
    fn fold_class_prop(&mut self, n: ClassProp) -> ClassProp {
        (**self).fold_class_prop(n)
    }
    fn fold_computed_prop_name(&mut self, n: ComputedPropName) -> ComputedPropName {
        (**self).fold_computed_prop_name(n)
    }
    fn fold_cond_expr(&mut self, n: CondExpr) -> CondExpr {
        (**self).fold_cond_expr(n)
    }
    fn fold_constructor(&mut self, n: Constructor) -> Constructor {
        (**self).fold_constructor(n)
    }
    fn fold_continue_stmt(&mut self, n: ContinueStmt) -> ContinueStmt {
        (**self).fold_continue_stmt(n)
    }
    fn fold_debugger_stmt(&mut self, n: DebuggerStmt) -> DebuggerStmt {
        (**self).fold_debugger_stmt(n)
    }
    fn fold_decl(&mut self, n: Decl) -> Decl {
        (**self).fold_decl(n)
    }
    fn fold_decorator(&mut self, n: Decorator) -> Decorator {
        (**self).fold_decorator(n)
    }
    fn fold_decorators(&mut self, n: Vec<Decorator>) -> Vec<Decorator> {
        (**self).fold_decorators(n)
    }
    fn fold_default_decl(&mut self, n: DefaultDecl) -> DefaultDecl {
        (**self).fold_default_decl(n)
    }
    fn fold_do_while_stmt(&mut self, n: DoWhileStmt) -> DoWhileStmt {
        (**self).fold_do_while_stmt(n)
    }
    fn fold_empty_stmt(&mut self, n: EmptyStmt) -> EmptyStmt {
        (**self).fold_empty_stmt(n)
    }
    fn fold_export_all(&mut self, n: ExportAll) -> ExportAll {
        (**self).fold_export_all(n)
    }
    fn fold_export_decl(&mut self, n: ExportDecl) -> ExportDecl {
        (**self).fold_export_decl(n)
    }
    fn fold_export_default_decl(&mut self, n: ExportDefaultDecl) -> ExportDefaultDecl {
        (**self).fold_export_default_decl(n)
    }
    fn fold_export_default_expr(&mut self, n: ExportDefaultExpr) -> ExportDefaultExpr {
        (**self).fold_export_default_expr(n)
    }
    fn fold_export_default_specifier(
        &mut self,
        n: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        (**self).fold_export_default_specifier(n)
    }
    fn fold_export_named_specifier(&mut self, n: ExportNamedSpecifier) -> ExportNamedSpecifier {
        (**self).fold_export_named_specifier(n)
    }
    fn fold_export_namespace_specifier(
        &mut self,
        n: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        (**self).fold_export_namespace_specifier(n)
    }
    fn fold_export_specifier(&mut self, n: ExportSpecifier) -> ExportSpecifier {
        (**self).fold_export_specifier(n)
    }
    fn fold_export_specifiers(&mut self, n: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        (**self).fold_export_specifiers(n)
    }
    fn fold_expr(&mut self, n: Expr) -> Expr {
        (**self).fold_expr(n)
    }
    fn fold_expr_or_spread(&mut self, n: ExprOrSpread) -> ExprOrSpread {
        (**self).fold_expr_or_spread(n)
    }
    fn fold_expr_or_spreads(&mut self, n: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        (**self).fold_expr_or_spreads(n)
    }
    fn fold_expr_or_super(&mut self, n: ExprOrSuper) -> ExprOrSuper {
        (**self).fold_expr_or_super(n)
    }
    fn fold_expr_stmt(&mut self, n: ExprStmt) -> ExprStmt {
        (**self).fold_expr_stmt(n)
    }
    fn fold_exprs(&mut self, n: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        (**self).fold_exprs(n)
    }
    fn fold_fn_decl(&mut self, n: FnDecl) -> FnDecl {
        (**self).fold_fn_decl(n)
    }
    fn fold_fn_expr(&mut self, n: FnExpr) -> FnExpr {
        (**self).fold_fn_expr(n)
    }
    fn fold_for_in_stmt(&mut self, n: ForInStmt) -> ForInStmt {
        (**self).fold_for_in_stmt(n)
    }
    fn fold_for_of_stmt(&mut self, n: ForOfStmt) -> ForOfStmt {
        (**self).fold_for_of_stmt(n)
    }
    fn fold_for_stmt(&mut self, n: ForStmt) -> ForStmt {
        (**self).fold_for_stmt(n)
    }
    fn fold_function(&mut self, n: Function) -> Function {
        (**self).fold_function(n)
    }
    fn fold_getter_prop(&mut self, n: GetterProp) -> GetterProp {
        (**self).fold_getter_prop(n)
    }
    fn fold_ident(&mut self, n: Ident) -> Ident {
        (**self).fold_ident(n)
    }
    fn fold_if_stmt(&mut self, n: IfStmt) -> IfStmt {
        (**self).fold_if_stmt(n)
    }
    fn fold_import_decl(&mut self, n: ImportDecl) -> ImportDecl {
        (**self).fold_import_decl(n)
    }
    fn fold_import_default_specifier(
        &mut self,
        n: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        (**self).fold_import_default_specifier(n)
    }
    fn fold_import_named_specifier(&mut self, n: ImportNamedSpecifier) -> ImportNamedSpecifier {
        (**self).fold_import_named_specifier(n)
    }
    fn fold_import_specifier(&mut self, n: ImportSpecifier) -> ImportSpecifier {
        (**self).fold_import_specifier(n)
    }
    fn fold_import_specifiers(&mut self, n: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        (**self).fold_import_specifiers(n)
    }
    fn fold_import_star_as_specifier(&mut self, n: ImportStarAsSpecifier) -> ImportStarAsSpecifier {
        (**self).fold_import_star_as_specifier(n)
    }
    fn fold_invalid(&mut self, n: Invalid) -> Invalid {
        (**self).fold_invalid(n)
    }
    fn fold_js_word(&mut self, n: JsWord) -> JsWord {
        (**self).fold_js_word(n)
    }
    fn fold_jsx_attr(&mut self, n: JSXAttr) -> JSXAttr {
        (**self).fold_jsx_attr(n)
    }
    fn fold_jsx_attr_name(&mut self, n: JSXAttrName) -> JSXAttrName {
        (**self).fold_jsx_attr_name(n)
    }
    fn fold_jsx_attr_or_spread(&mut self, n: JSXAttrOrSpread) -> JSXAttrOrSpread {
        (**self).fold_jsx_attr_or_spread(n)
    }
    fn fold_jsx_attr_or_spreads(&mut self, n: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        (**self).fold_jsx_attr_or_spreads(n)
    }
    fn fold_jsx_attr_value(&mut self, n: JSXAttrValue) -> JSXAttrValue {
        (**self).fold_jsx_attr_value(n)
    }
    fn fold_jsx_closing_element(&mut self, n: JSXClosingElement) -> JSXClosingElement {
        (**self).fold_jsx_closing_element(n)
    }
    fn fold_jsx_closing_fragment(&mut self, n: JSXClosingFragment) -> JSXClosingFragment {
        (**self).fold_jsx_closing_fragment(n)
    }
    fn fold_jsx_element(&mut self, n: JSXElement) -> JSXElement {
        (**self).fold_jsx_element(n)
    }
    fn fold_jsx_element_child(&mut self, n: JSXElementChild) -> JSXElementChild {
        (**self).fold_jsx_element_child(n)
    }
    fn fold_jsx_element_children(&mut self, n: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        (**self).fold_jsx_element_children(n)
    }
    fn fold_jsx_element_name(&mut self, n: JSXElementName) -> JSXElementName {
        (**self).fold_jsx_element_name(n)
    }
    fn fold_jsx_empty_expr(&mut self, n: JSXEmptyExpr) -> JSXEmptyExpr {
        (**self).fold_jsx_empty_expr(n)
    }
    fn fold_jsx_expr(&mut self, n: JSXExpr) -> JSXExpr {
        (**self).fold_jsx_expr(n)
    }
    fn fold_jsx_expr_container(&mut self, n: JSXExprContainer) -> JSXExprContainer {
        (**self).fold_jsx_expr_container(n)
    }
    fn fold_jsx_fragment(&mut self, n: JSXFragment) -> JSXFragment {
        (**self).fold_jsx_fragment(n)
    }
    fn fold_jsx_member_expr(&mut self, n: JSXMemberExpr) -> JSXMemberExpr {
        (**self).fold_jsx_member_expr(n)
    }
    fn fold_jsx_namespaced_name(&mut self, n: JSXNamespacedName) -> JSXNamespacedName {
        (**self).fold_jsx_namespaced_name(n)
    }
    fn fold_jsx_object(&mut self, n: JSXObject) -> JSXObject {
        (**self).fold_jsx_object(n)
    }
    fn fold_jsx_opening_element(&mut self, n: JSXOpeningElement) -> JSXOpeningElement {
        (**self).fold_jsx_opening_element(n)
    }
    fn fold_jsx_opening_fragment(&mut self, n: JSXOpeningFragment) -> JSXOpeningFragment {
        (**self).fold_jsx_opening_fragment(n)
    }
    fn fold_jsx_spread_child(&mut self, n: JSXSpreadChild) -> JSXSpreadChild {
        (**self).fold_jsx_spread_child(n)
    }
    fn fold_jsx_text(&mut self, n: JSXText) -> JSXText {
        (**self).fold_jsx_text(n)
    }
    fn fold_key_value_pat_prop(&mut self, n: KeyValuePatProp) -> KeyValuePatProp {
        (**self).fold_key_value_pat_prop(n)
    }
    fn fold_key_value_prop(&mut self, n: KeyValueProp) -> KeyValueProp {
        (**self).fold_key_value_prop(n)
    }
    fn fold_labeled_stmt(&mut self, n: LabeledStmt) -> LabeledStmt {
        (**self).fold_labeled_stmt(n)
    }
    fn fold_lit(&mut self, n: Lit) -> Lit {
        (**self).fold_lit(n)
    }
    fn fold_member_expr(&mut self, n: MemberExpr) -> MemberExpr {
        (**self).fold_member_expr(n)
    }
    fn fold_meta_prop_expr(&mut self, n: MetaPropExpr) -> MetaPropExpr {
        (**self).fold_meta_prop_expr(n)
    }
    fn fold_method_kind(&mut self, n: MethodKind) -> MethodKind {
        (**self).fold_method_kind(n)
    }
    fn fold_method_prop(&mut self, n: MethodProp) -> MethodProp {
        (**self).fold_method_prop(n)
    }
    fn fold_module(&mut self, n: Module) -> Module {
        (**self).fold_module(n)
    }
    fn fold_module_decl(&mut self, n: ModuleDecl) -> ModuleDecl {
        (**self).fold_module_decl(n)
    }
    fn fold_module_item(&mut self, n: ModuleItem) -> ModuleItem {
        (**self).fold_module_item(n)
    }
    fn fold_module_items(&mut self, n: Vec<ModuleItem>) -> Vec<ModuleItem> {
        (**self).fold_module_items(n)
    }
    fn fold_named_export(&mut self, n: NamedExport) -> NamedExport {
        (**self).fold_named_export(n)
    }
    fn fold_new_expr(&mut self, n: NewExpr) -> NewExpr {
        (**self).fold_new_expr(n)
    }
    fn fold_null(&mut self, n: Null) -> Null {
        (**self).fold_null(n)
    }
    fn fold_number(&mut self, n: Number) -> Number {
        (**self).fold_number(n)
    }
    fn fold_object_lit(&mut self, n: ObjectLit) -> ObjectLit {
        (**self).fold_object_lit(n)
    }
    fn fold_object_pat(&mut self, n: ObjectPat) -> ObjectPat {
        (**self).fold_object_pat(n)
    }
    fn fold_object_pat_prop(&mut self, n: ObjectPatProp) -> ObjectPatProp {
        (**self).fold_object_pat_prop(n)
    }
    fn fold_object_pat_props(&mut self, n: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        (**self).fold_object_pat_props(n)
    }
    fn fold_opt_accessibility(&mut self, n: Option<Accessibility>) -> Option<Accessibility> {
        (**self).fold_opt_accessibility(n)
    }
    fn fold_opt_block_stmt(&mut self, n: Option<BlockStmt>) -> Option<BlockStmt> {
        (**self).fold_opt_block_stmt(n)
    }
    fn fold_opt_catch_clause(&mut self, n: Option<CatchClause>) -> Option<CatchClause> {
        (**self).fold_opt_catch_clause(n)
    }
    fn fold_opt_chain_expr(&mut self, n: OptChainExpr) -> OptChainExpr {
        (**self).fold_opt_chain_expr(n)
    }
    fn fold_opt_expr(&mut self, n: Option<Box<Expr>>) -> Option<Box<Expr>> {
        (**self).fold_opt_expr(n)
    }
    fn fold_opt_expr_or_spread(&mut self, n: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        (**self).fold_opt_expr_or_spread(n)
    }
    fn fold_opt_expr_or_spreads(
        &mut self,
        n: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        (**self).fold_opt_expr_or_spreads(n)
    }
    fn fold_opt_ident(&mut self, n: Option<Ident>) -> Option<Ident> {
        (**self).fold_opt_ident(n)
    }
    fn fold_opt_js_word(&mut self, n: Option<JsWord>) -> Option<JsWord> {
        (**self).fold_opt_js_word(n)
    }
    fn fold_opt_jsx_attr_value(&mut self, n: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        (**self).fold_opt_jsx_attr_value(n)
    }
    fn fold_opt_jsx_closing_element(
        &mut self,
        n: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        (**self).fold_opt_jsx_closing_element(n)
    }
    fn fold_opt_object_lit(&mut self, n: Option<ObjectLit>) -> Option<ObjectLit> {
        (**self).fold_opt_object_lit(n)
    }
    fn fold_opt_pat(&mut self, n: Option<Pat>) -> Option<Pat> {
        (**self).fold_opt_pat(n)
    }
    fn fold_opt_span(&mut self, n: Option<Span>) -> Option<Span> {
        (**self).fold_opt_span(n)
    }
    fn fold_opt_stmt(&mut self, n: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        (**self).fold_opt_stmt(n)
    }
    fn fold_opt_str(&mut self, n: Option<Str>) -> Option<Str> {
        (**self).fold_opt_str(n)
    }
    fn fold_opt_true_plus_minus(&mut self, n: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        (**self).fold_opt_true_plus_minus(n)
    }
    fn fold_opt_ts_entity_name(&mut self, n: Option<TsEntityName>) -> Option<TsEntityName> {
        (**self).fold_opt_ts_entity_name(n)
    }
    fn fold_opt_ts_namespace_body(
        &mut self,
        n: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        (**self).fold_opt_ts_namespace_body(n)
    }
    fn fold_opt_ts_type(&mut self, n: Option<Box<TsType>>) -> Option<Box<TsType>> {
        (**self).fold_opt_ts_type(n)
    }
    fn fold_opt_ts_type_ann(&mut self, n: Option<TsTypeAnn>) -> Option<TsTypeAnn> {
        (**self).fold_opt_ts_type_ann(n)
    }
    fn fold_opt_ts_type_param_decl(
        &mut self,
        n: Option<TsTypeParamDecl>,
    ) -> Option<TsTypeParamDecl> {
        (**self).fold_opt_ts_type_param_decl(n)
    }
    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        n: Option<TsTypeParamInstantiation>,
    ) -> Option<TsTypeParamInstantiation> {
        (**self).fold_opt_ts_type_param_instantiation(n)
    }
    fn fold_opt_var_decl_or_expr(&mut self, n: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        (**self).fold_opt_var_decl_or_expr(n)
    }
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        n: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        (**self).fold_opt_vec_expr_or_spreads(n)
    }
    fn fold_opt_vec_pats(&mut self, n: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        (**self).fold_opt_vec_pats(n)
    }
    fn fold_param(&mut self, n: Param) -> Param {
        (**self).fold_param(n)
    }
    fn fold_param_or_ts_param_prop(&mut self, n: ParamOrTsParamProp) -> ParamOrTsParamProp {
        (**self).fold_param_or_ts_param_prop(n)
    }
    fn fold_param_or_ts_param_props(
        &mut self,
        n: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        (**self).fold_param_or_ts_param_props(n)
    }
    fn fold_params(&mut self, n: Vec<Param>) -> Vec<Param> {
        (**self).fold_params(n)
    }
    fn fold_paren_expr(&mut self, n: ParenExpr) -> ParenExpr {
        (**self).fold_paren_expr(n)
    }
    fn fold_pat(&mut self, n: Pat) -> Pat {
        (**self).fold_pat(n)
    }
    fn fold_pat_or_expr(&mut self, n: PatOrExpr) -> PatOrExpr {
        (**self).fold_pat_or_expr(n)
    }
    fn fold_pats(&mut self, n: Vec<Pat>) -> Vec<Pat> {
        (**self).fold_pats(n)
    }
    fn fold_private_method(&mut self, n: PrivateMethod) -> PrivateMethod {
        (**self).fold_private_method(n)
    }
    fn fold_private_name(&mut self, n: PrivateName) -> PrivateName {
        (**self).fold_private_name(n)
    }
    fn fold_private_prop(&mut self, n: PrivateProp) -> PrivateProp {
        (**self).fold_private_prop(n)
    }
    fn fold_program(&mut self, n: Program) -> Program {
        (**self).fold_program(n)
    }
    fn fold_prop(&mut self, n: Prop) -> Prop {
        (**self).fold_prop(n)
    }
    fn fold_prop_name(&mut self, n: PropName) -> PropName {
        (**self).fold_prop_name(n)
    }
    fn fold_prop_or_spread(&mut self, n: PropOrSpread) -> PropOrSpread {
        (**self).fold_prop_or_spread(n)
    }
    fn fold_prop_or_spreads(&mut self, n: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        (**self).fold_prop_or_spreads(n)
    }
    fn fold_regex(&mut self, n: Regex) -> Regex {
        (**self).fold_regex(n)
    }
    fn fold_rest_pat(&mut self, n: RestPat) -> RestPat {
        (**self).fold_rest_pat(n)
    }
    fn fold_return_stmt(&mut self, n: ReturnStmt) -> ReturnStmt {
        (**self).fold_return_stmt(n)
    }
    fn fold_script(&mut self, n: Script) -> Script {
        (**self).fold_script(n)
    }
    fn fold_seq_expr(&mut self, n: SeqExpr) -> SeqExpr {
        (**self).fold_seq_expr(n)
    }
    fn fold_setter_prop(&mut self, n: SetterProp) -> SetterProp {
        (**self).fold_setter_prop(n)
    }
    fn fold_span(&mut self, n: Span) -> Span {
        (**self).fold_span(n)
    }
    fn fold_spread_element(&mut self, n: SpreadElement) -> SpreadElement {
        (**self).fold_spread_element(n)
    }
    fn fold_stmt(&mut self, n: Stmt) -> Stmt {
        (**self).fold_stmt(n)
    }
    fn fold_stmts(&mut self, n: Vec<Stmt>) -> Vec<Stmt> {
        (**self).fold_stmts(n)
    }
    fn fold_str(&mut self, n: Str) -> Str {
        (**self).fold_str(n)
    }
    fn fold_str_kind(&mut self, n: StrKind) -> StrKind {
        (**self).fold_str_kind(n)
    }
    fn fold_super(&mut self, n: Super) -> Super {
        (**self).fold_super(n)
    }
    fn fold_switch_case(&mut self, n: SwitchCase) -> SwitchCase {
        (**self).fold_switch_case(n)
    }
    fn fold_switch_cases(&mut self, n: Vec<SwitchCase>) -> Vec<SwitchCase> {
        (**self).fold_switch_cases(n)
    }
    fn fold_switch_stmt(&mut self, n: SwitchStmt) -> SwitchStmt {
        (**self).fold_switch_stmt(n)
    }
    fn fold_tagged_tpl(&mut self, n: TaggedTpl) -> TaggedTpl {
        (**self).fold_tagged_tpl(n)
    }
    fn fold_this_expr(&mut self, n: ThisExpr) -> ThisExpr {
        (**self).fold_this_expr(n)
    }
    fn fold_throw_stmt(&mut self, n: ThrowStmt) -> ThrowStmt {
        (**self).fold_throw_stmt(n)
    }
    fn fold_tpl(&mut self, n: Tpl) -> Tpl {
        (**self).fold_tpl(n)
    }
    fn fold_tpl_element(&mut self, n: TplElement) -> TplElement {
        (**self).fold_tpl_element(n)
    }
    fn fold_tpl_elements(&mut self, n: Vec<TplElement>) -> Vec<TplElement> {
        (**self).fold_tpl_elements(n)
    }
    fn fold_true_plus_minus(&mut self, n: TruePlusMinus) -> TruePlusMinus {
        (**self).fold_true_plus_minus(n)
    }
    fn fold_try_stmt(&mut self, n: TryStmt) -> TryStmt {
        (**self).fold_try_stmt(n)
    }
    fn fold_ts_array_type(&mut self, n: TsArrayType) -> TsArrayType {
        (**self).fold_ts_array_type(n)
    }
    fn fold_ts_as_expr(&mut self, n: TsAsExpr) -> TsAsExpr {
        (**self).fold_ts_as_expr(n)
    }
    fn fold_ts_call_signature_decl(&mut self, n: TsCallSignatureDecl) -> TsCallSignatureDecl {
        (**self).fold_ts_call_signature_decl(n)
    }
    fn fold_ts_conditional_type(&mut self, n: TsConditionalType) -> TsConditionalType {
        (**self).fold_ts_conditional_type(n)
    }
    fn fold_ts_const_assertion(&mut self, n: TsConstAssertion) -> TsConstAssertion {
        (**self).fold_ts_const_assertion(n)
    }
    fn fold_ts_construct_signature_decl(
        &mut self,
        n: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        (**self).fold_ts_construct_signature_decl(n)
    }
    fn fold_ts_constructor_type(&mut self, n: TsConstructorType) -> TsConstructorType {
        (**self).fold_ts_constructor_type(n)
    }
    fn fold_ts_entity_name(&mut self, n: TsEntityName) -> TsEntityName {
        (**self).fold_ts_entity_name(n)
    }
    fn fold_ts_enum_decl(&mut self, n: TsEnumDecl) -> TsEnumDecl {
        (**self).fold_ts_enum_decl(n)
    }
    fn fold_ts_enum_member(&mut self, n: TsEnumMember) -> TsEnumMember {
        (**self).fold_ts_enum_member(n)
    }
    fn fold_ts_enum_member_id(&mut self, n: TsEnumMemberId) -> TsEnumMemberId {
        (**self).fold_ts_enum_member_id(n)
    }
    fn fold_ts_enum_members(&mut self, n: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        (**self).fold_ts_enum_members(n)
    }
    fn fold_ts_export_assignment(&mut self, n: TsExportAssignment) -> TsExportAssignment {
        (**self).fold_ts_export_assignment(n)
    }
    fn fold_ts_expr_with_type_args(&mut self, n: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        (**self).fold_ts_expr_with_type_args(n)
    }
    fn fold_ts_expr_with_type_args_vec(
        &mut self,
        n: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        (**self).fold_ts_expr_with_type_args_vec(n)
    }
    fn fold_ts_external_module_ref(&mut self, n: TsExternalModuleRef) -> TsExternalModuleRef {
        (**self).fold_ts_external_module_ref(n)
    }
    fn fold_ts_fn_or_constructor_type(
        &mut self,
        n: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        (**self).fold_ts_fn_or_constructor_type(n)
    }
    fn fold_ts_fn_param(&mut self, n: TsFnParam) -> TsFnParam {
        (**self).fold_ts_fn_param(n)
    }
    fn fold_ts_fn_params(&mut self, n: Vec<TsFnParam>) -> Vec<TsFnParam> {
        (**self).fold_ts_fn_params(n)
    }
    fn fold_ts_fn_type(&mut self, n: TsFnType) -> TsFnType {
        (**self).fold_ts_fn_type(n)
    }
    fn fold_ts_getter_signature(&mut self, n: TsGetterSignature) -> TsGetterSignature {
        (**self).fold_ts_getter_signature(n)
    }
    fn fold_ts_import_equals_decl(&mut self, n: TsImportEqualsDecl) -> TsImportEqualsDecl {
        (**self).fold_ts_import_equals_decl(n)
    }
    fn fold_ts_import_type(&mut self, n: TsImportType) -> TsImportType {
        (**self).fold_ts_import_type(n)
    }
    fn fold_ts_index_signature(&mut self, n: TsIndexSignature) -> TsIndexSignature {
        (**self).fold_ts_index_signature(n)
    }
    fn fold_ts_indexed_access_type(&mut self, n: TsIndexedAccessType) -> TsIndexedAccessType {
        (**self).fold_ts_indexed_access_type(n)
    }
    fn fold_ts_infer_type(&mut self, n: TsInferType) -> TsInferType {
        (**self).fold_ts_infer_type(n)
    }
    fn fold_ts_interface_body(&mut self, n: TsInterfaceBody) -> TsInterfaceBody {
        (**self).fold_ts_interface_body(n)
    }
    fn fold_ts_interface_decl(&mut self, n: TsInterfaceDecl) -> TsInterfaceDecl {
        (**self).fold_ts_interface_decl(n)
    }
    fn fold_ts_intersection_type(&mut self, n: TsIntersectionType) -> TsIntersectionType {
        (**self).fold_ts_intersection_type(n)
    }
    fn fold_ts_keyword_type(&mut self, n: TsKeywordType) -> TsKeywordType {
        (**self).fold_ts_keyword_type(n)
    }
    fn fold_ts_keyword_type_kind(&mut self, n: TsKeywordTypeKind) -> TsKeywordTypeKind {
        (**self).fold_ts_keyword_type_kind(n)
    }
    fn fold_ts_lit(&mut self, n: TsLit) -> TsLit {
        (**self).fold_ts_lit(n)
    }
    fn fold_ts_lit_type(&mut self, n: TsLitType) -> TsLitType {
        (**self).fold_ts_lit_type(n)
    }
    fn fold_ts_mapped_type(&mut self, n: TsMappedType) -> TsMappedType {
        (**self).fold_ts_mapped_type(n)
    }
    fn fold_ts_method_signature(&mut self, n: TsMethodSignature) -> TsMethodSignature {
        (**self).fold_ts_method_signature(n)
    }
    fn fold_ts_module_block(&mut self, n: TsModuleBlock) -> TsModuleBlock {
        (**self).fold_ts_module_block(n)
    }
    fn fold_ts_module_decl(&mut self, n: TsModuleDecl) -> TsModuleDecl {
        (**self).fold_ts_module_decl(n)
    }
    fn fold_ts_module_name(&mut self, n: TsModuleName) -> TsModuleName {
        (**self).fold_ts_module_name(n)
    }
    fn fold_ts_module_ref(&mut self, n: TsModuleRef) -> TsModuleRef {
        (**self).fold_ts_module_ref(n)
    }
    fn fold_ts_namespace_body(&mut self, n: TsNamespaceBody) -> TsNamespaceBody {
        (**self).fold_ts_namespace_body(n)
    }
    fn fold_ts_namespace_decl(&mut self, n: TsNamespaceDecl) -> TsNamespaceDecl {
        (**self).fold_ts_namespace_decl(n)
    }
    fn fold_ts_namespace_export_decl(&mut self, n: TsNamespaceExportDecl) -> TsNamespaceExportDecl {
        (**self).fold_ts_namespace_export_decl(n)
    }
    fn fold_ts_non_null_expr(&mut self, n: TsNonNullExpr) -> TsNonNullExpr {
        (**self).fold_ts_non_null_expr(n)
    }
    fn fold_ts_optional_type(&mut self, n: TsOptionalType) -> TsOptionalType {
        (**self).fold_ts_optional_type(n)
    }
    fn fold_ts_param_prop(&mut self, n: TsParamProp) -> TsParamProp {
        (**self).fold_ts_param_prop(n)
    }
    fn fold_ts_param_prop_param(&mut self, n: TsParamPropParam) -> TsParamPropParam {
        (**self).fold_ts_param_prop_param(n)
    }
    fn fold_ts_parenthesized_type(&mut self, n: TsParenthesizedType) -> TsParenthesizedType {
        (**self).fold_ts_parenthesized_type(n)
    }
    fn fold_ts_property_signature(&mut self, n: TsPropertySignature) -> TsPropertySignature {
        (**self).fold_ts_property_signature(n)
    }
    fn fold_ts_qualified_name(&mut self, n: TsQualifiedName) -> TsQualifiedName {
        (**self).fold_ts_qualified_name(n)
    }
    fn fold_ts_rest_type(&mut self, n: TsRestType) -> TsRestType {
        (**self).fold_ts_rest_type(n)
    }
    fn fold_ts_setter_signature(&mut self, n: TsSetterSignature) -> TsSetterSignature {
        (**self).fold_ts_setter_signature(n)
    }
    fn fold_ts_this_type(&mut self, n: TsThisType) -> TsThisType {
        (**self).fold_ts_this_type(n)
    }
    fn fold_ts_this_type_or_ident(&mut self, n: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        (**self).fold_ts_this_type_or_ident(n)
    }
    fn fold_ts_tpl_lit_type(&mut self, n: TsTplLitType) -> TsTplLitType {
        (**self).fold_ts_tpl_lit_type(n)
    }
    fn fold_ts_tuple_element(&mut self, n: TsTupleElement) -> TsTupleElement {
        (**self).fold_ts_tuple_element(n)
    }
    fn fold_ts_tuple_elements(&mut self, n: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        (**self).fold_ts_tuple_elements(n)
    }
    fn fold_ts_tuple_type(&mut self, n: TsTupleType) -> TsTupleType {
        (**self).fold_ts_tuple_type(n)
    }
    fn fold_ts_type(&mut self, n: TsType) -> TsType {
        (**self).fold_ts_type(n)
    }
    fn fold_ts_type_alias_decl(&mut self, n: TsTypeAliasDecl) -> TsTypeAliasDecl {
        (**self).fold_ts_type_alias_decl(n)
    }
    fn fold_ts_type_ann(&mut self, n: TsTypeAnn) -> TsTypeAnn {
        (**self).fold_ts_type_ann(n)
    }
    fn fold_ts_type_assertion(&mut self, n: TsTypeAssertion) -> TsTypeAssertion {
        (**self).fold_ts_type_assertion(n)
    }
    fn fold_ts_type_element(&mut self, n: TsTypeElement) -> TsTypeElement {
        (**self).fold_ts_type_element(n)
    }
    fn fold_ts_type_elements(&mut self, n: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        (**self).fold_ts_type_elements(n)
    }
    fn fold_ts_type_lit(&mut self, n: TsTypeLit) -> TsTypeLit {
        (**self).fold_ts_type_lit(n)
    }
    fn fold_ts_type_operator(&mut self, n: TsTypeOperator) -> TsTypeOperator {
        (**self).fold_ts_type_operator(n)
    }
    fn fold_ts_type_operator_op(&mut self, n: TsTypeOperatorOp) -> TsTypeOperatorOp {
        (**self).fold_ts_type_operator_op(n)
    }
    fn fold_ts_type_param(&mut self, n: TsTypeParam) -> TsTypeParam {
        (**self).fold_ts_type_param(n)
    }
    fn fold_ts_type_param_decl(&mut self, n: TsTypeParamDecl) -> TsTypeParamDecl {
        (**self).fold_ts_type_param_decl(n)
    }
    fn fold_ts_type_param_instantiation(
        &mut self,
        n: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        (**self).fold_ts_type_param_instantiation(n)
    }
    fn fold_ts_type_params(&mut self, n: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        (**self).fold_ts_type_params(n)
    }
    fn fold_ts_type_predicate(&mut self, n: TsTypePredicate) -> TsTypePredicate {
        (**self).fold_ts_type_predicate(n)
    }
    fn fold_ts_type_query(&mut self, n: TsTypeQuery) -> TsTypeQuery {
        (**self).fold_ts_type_query(n)
    }
    fn fold_ts_type_query_expr(&mut self, n: TsTypeQueryExpr) -> TsTypeQueryExpr {
        (**self).fold_ts_type_query_expr(n)
    }
    fn fold_ts_type_ref(&mut self, n: TsTypeRef) -> TsTypeRef {
        (**self).fold_ts_type_ref(n)
    }
    fn fold_ts_types(&mut self, n: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        (**self).fold_ts_types(n)
    }
    fn fold_ts_union_or_intersection_type(
        &mut self,
        n: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        (**self).fold_ts_union_or_intersection_type(n)
    }
    fn fold_ts_union_type(&mut self, n: TsUnionType) -> TsUnionType {
        (**self).fold_ts_union_type(n)
    }
    fn fold_unary_expr(&mut self, n: UnaryExpr) -> UnaryExpr {
        (**self).fold_unary_expr(n)
    }
    fn fold_unary_op(&mut self, n: UnaryOp) -> UnaryOp {
        (**self).fold_unary_op(n)
    }
    fn fold_update_expr(&mut self, n: UpdateExpr) -> UpdateExpr {
        (**self).fold_update_expr(n)
    }
    fn fold_update_op(&mut self, n: UpdateOp) -> UpdateOp {
        (**self).fold_update_op(n)
    }
    fn fold_var_decl(&mut self, n: VarDecl) -> VarDecl {
        (**self).fold_var_decl(n)
    }
    fn fold_var_decl_kind(&mut self, n: VarDeclKind) -> VarDeclKind {
        (**self).fold_var_decl_kind(n)
    }
    fn fold_var_decl_or_expr(&mut self, n: VarDeclOrExpr) -> VarDeclOrExpr {
        (**self).fold_var_decl_or_expr(n)
    }
    fn fold_var_decl_or_pat(&mut self, n: VarDeclOrPat) -> VarDeclOrPat {
        (**self).fold_var_decl_or_pat(n)
    }
    fn fold_var_declarator(&mut self, n: VarDeclarator) -> VarDeclarator {
        (**self).fold_var_declarator(n)
    }
    fn fold_var_declarators(&mut self, n: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        (**self).fold_var_declarators(n)
    }
    fn fold_while_stmt(&mut self, n: WhileStmt) -> WhileStmt {
        (**self).fold_while_stmt(n)
    }
    fn fold_with_stmt(&mut self, n: WithStmt) -> WithStmt {
        (**self).fold_with_stmt(n)
    }
    fn fold_yield_expr(&mut self, n: YieldExpr) -> YieldExpr {
        (**self).fold_yield_expr(n)
    }
}
impl<V> Fold for ::global_visit::Optional<V>
where
    V: Fold,
{
    fn fold_accessibility(&mut self, n: Accessibility) -> Accessibility {
        if self.enabled {
            self.visitor.fold_accessibility(n)
        } else {
            n
        }
    }
    fn fold_array_lit(&mut self, n: ArrayLit) -> ArrayLit {
        if self.enabled {
            self.visitor.fold_array_lit(n)
        } else {
            n
        }
    }
    fn fold_array_pat(&mut self, n: ArrayPat) -> ArrayPat {
        if self.enabled {
            self.visitor.fold_array_pat(n)
        } else {
            n
        }
    }
    fn fold_arrow_expr(&mut self, n: ArrowExpr) -> ArrowExpr {
        if self.enabled {
            self.visitor.fold_arrow_expr(n)
        } else {
            n
        }
    }
    fn fold_assign_expr(&mut self, n: AssignExpr) -> AssignExpr {
        if self.enabled {
            self.visitor.fold_assign_expr(n)
        } else {
            n
        }
    }
    fn fold_assign_op(&mut self, n: AssignOp) -> AssignOp {
        if self.enabled {
            self.visitor.fold_assign_op(n)
        } else {
            n
        }
    }
    fn fold_assign_pat(&mut self, n: AssignPat) -> AssignPat {
        if self.enabled {
            self.visitor.fold_assign_pat(n)
        } else {
            n
        }
    }
    fn fold_assign_pat_prop(&mut self, n: AssignPatProp) -> AssignPatProp {
        if self.enabled {
            self.visitor.fold_assign_pat_prop(n)
        } else {
            n
        }
    }
    fn fold_assign_prop(&mut self, n: AssignProp) -> AssignProp {
        if self.enabled {
            self.visitor.fold_assign_prop(n)
        } else {
            n
        }
    }
    fn fold_await_expr(&mut self, n: AwaitExpr) -> AwaitExpr {
        if self.enabled {
            self.visitor.fold_await_expr(n)
        } else {
            n
        }
    }
    fn fold_big_int(&mut self, n: BigInt) -> BigInt {
        if self.enabled {
            self.visitor.fold_big_int(n)
        } else {
            n
        }
    }
    fn fold_big_int_value(&mut self, n: BigIntValue) -> BigIntValue {
        if self.enabled {
            self.visitor.fold_big_int_value(n)
        } else {
            n
        }
    }
    fn fold_bin_expr(&mut self, n: BinExpr) -> BinExpr {
        if self.enabled {
            self.visitor.fold_bin_expr(n)
        } else {
            n
        }
    }
    fn fold_binary_op(&mut self, n: BinaryOp) -> BinaryOp {
        if self.enabled {
            self.visitor.fold_binary_op(n)
        } else {
            n
        }
    }
    fn fold_binding_ident(&mut self, n: BindingIdent) -> BindingIdent {
        if self.enabled {
            self.visitor.fold_binding_ident(n)
        } else {
            n
        }
    }
    fn fold_block_stmt(&mut self, n: BlockStmt) -> BlockStmt {
        if self.enabled {
            self.visitor.fold_block_stmt(n)
        } else {
            n
        }
    }
    fn fold_block_stmt_or_expr(&mut self, n: BlockStmtOrExpr) -> BlockStmtOrExpr {
        if self.enabled {
            self.visitor.fold_block_stmt_or_expr(n)
        } else {
            n
        }
    }
    fn fold_bool(&mut self, n: Bool) -> Bool {
        if self.enabled {
            self.visitor.fold_bool(n)
        } else {
            n
        }
    }
    fn fold_break_stmt(&mut self, n: BreakStmt) -> BreakStmt {
        if self.enabled {
            self.visitor.fold_break_stmt(n)
        } else {
            n
        }
    }
    fn fold_call_expr(&mut self, n: CallExpr) -> CallExpr {
        if self.enabled {
            self.visitor.fold_call_expr(n)
        } else {
            n
        }
    }
    fn fold_catch_clause(&mut self, n: CatchClause) -> CatchClause {
        if self.enabled {
            self.visitor.fold_catch_clause(n)
        } else {
            n
        }
    }
    fn fold_class(&mut self, n: Class) -> Class {
        if self.enabled {
            self.visitor.fold_class(n)
        } else {
            n
        }
    }
    fn fold_class_decl(&mut self, n: ClassDecl) -> ClassDecl {
        if self.enabled {
            self.visitor.fold_class_decl(n)
        } else {
            n
        }
    }
    fn fold_class_expr(&mut self, n: ClassExpr) -> ClassExpr {
        if self.enabled {
            self.visitor.fold_class_expr(n)
        } else {
            n
        }
    }
    fn fold_class_member(&mut self, n: ClassMember) -> ClassMember {
        if self.enabled {
            self.visitor.fold_class_member(n)
        } else {
            n
        }
    }
    fn fold_class_members(&mut self, n: Vec<ClassMember>) -> Vec<ClassMember> {
        if self.enabled {
            self.visitor.fold_class_members(n)
        } else {
            n
        }
    }
    fn fold_class_method(&mut self, n: ClassMethod) -> ClassMethod {
        if self.enabled {
            self.visitor.fold_class_method(n)
        } else {
            n
        }
    }
    fn fold_class_prop(&mut self, n: ClassProp) -> ClassProp {
        if self.enabled {
            self.visitor.fold_class_prop(n)
        } else {
            n
        }
    }
    fn fold_computed_prop_name(&mut self, n: ComputedPropName) -> ComputedPropName {
        if self.enabled {
            self.visitor.fold_computed_prop_name(n)
        } else {
            n
        }
    }
    fn fold_cond_expr(&mut self, n: CondExpr) -> CondExpr {
        if self.enabled {
            self.visitor.fold_cond_expr(n)
        } else {
            n
        }
    }
    fn fold_constructor(&mut self, n: Constructor) -> Constructor {
        if self.enabled {
            self.visitor.fold_constructor(n)
        } else {
            n
        }
    }
    fn fold_continue_stmt(&mut self, n: ContinueStmt) -> ContinueStmt {
        if self.enabled {
            self.visitor.fold_continue_stmt(n)
        } else {
            n
        }
    }
    fn fold_debugger_stmt(&mut self, n: DebuggerStmt) -> DebuggerStmt {
        if self.enabled {
            self.visitor.fold_debugger_stmt(n)
        } else {
            n
        }
    }
    fn fold_decl(&mut self, n: Decl) -> Decl {
        if self.enabled {
            self.visitor.fold_decl(n)
        } else {
            n
        }
    }
    fn fold_decorator(&mut self, n: Decorator) -> Decorator {
        if self.enabled {
            self.visitor.fold_decorator(n)
        } else {
            n
        }
    }
    fn fold_decorators(&mut self, n: Vec<Decorator>) -> Vec<Decorator> {
        if self.enabled {
            self.visitor.fold_decorators(n)
        } else {
            n
        }
    }
    fn fold_default_decl(&mut self, n: DefaultDecl) -> DefaultDecl {
        if self.enabled {
            self.visitor.fold_default_decl(n)
        } else {
            n
        }
    }
    fn fold_do_while_stmt(&mut self, n: DoWhileStmt) -> DoWhileStmt {
        if self.enabled {
            self.visitor.fold_do_while_stmt(n)
        } else {
            n
        }
    }
    fn fold_empty_stmt(&mut self, n: EmptyStmt) -> EmptyStmt {
        if self.enabled {
            self.visitor.fold_empty_stmt(n)
        } else {
            n
        }
    }
    fn fold_export_all(&mut self, n: ExportAll) -> ExportAll {
        if self.enabled {
            self.visitor.fold_export_all(n)
        } else {
            n
        }
    }
    fn fold_export_decl(&mut self, n: ExportDecl) -> ExportDecl {
        if self.enabled {
            self.visitor.fold_export_decl(n)
        } else {
            n
        }
    }
    fn fold_export_default_decl(&mut self, n: ExportDefaultDecl) -> ExportDefaultDecl {
        if self.enabled {
            self.visitor.fold_export_default_decl(n)
        } else {
            n
        }
    }
    fn fold_export_default_expr(&mut self, n: ExportDefaultExpr) -> ExportDefaultExpr {
        if self.enabled {
            self.visitor.fold_export_default_expr(n)
        } else {
            n
        }
    }
    fn fold_export_default_specifier(
        &mut self,
        n: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        if self.enabled {
            self.visitor.fold_export_default_specifier(n)
        } else {
            n
        }
    }
    fn fold_export_named_specifier(&mut self, n: ExportNamedSpecifier) -> ExportNamedSpecifier {
        if self.enabled {
            self.visitor.fold_export_named_specifier(n)
        } else {
            n
        }
    }
    fn fold_export_namespace_specifier(
        &mut self,
        n: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        if self.enabled {
            self.visitor.fold_export_namespace_specifier(n)
        } else {
            n
        }
    }
    fn fold_export_specifier(&mut self, n: ExportSpecifier) -> ExportSpecifier {
        if self.enabled {
            self.visitor.fold_export_specifier(n)
        } else {
            n
        }
    }
    fn fold_export_specifiers(&mut self, n: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        if self.enabled {
            self.visitor.fold_export_specifiers(n)
        } else {
            n
        }
    }
    fn fold_expr(&mut self, n: Expr) -> Expr {
        if self.enabled {
            self.visitor.fold_expr(n)
        } else {
            n
        }
    }
    fn fold_expr_or_spread(&mut self, n: ExprOrSpread) -> ExprOrSpread {
        if self.enabled {
            self.visitor.fold_expr_or_spread(n)
        } else {
            n
        }
    }
    fn fold_expr_or_spreads(&mut self, n: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        if self.enabled {
            self.visitor.fold_expr_or_spreads(n)
        } else {
            n
        }
    }
    fn fold_expr_or_super(&mut self, n: ExprOrSuper) -> ExprOrSuper {
        if self.enabled {
            self.visitor.fold_expr_or_super(n)
        } else {
            n
        }
    }
    fn fold_expr_stmt(&mut self, n: ExprStmt) -> ExprStmt {
        if self.enabled {
            self.visitor.fold_expr_stmt(n)
        } else {
            n
        }
    }
    fn fold_exprs(&mut self, n: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        if self.enabled {
            self.visitor.fold_exprs(n)
        } else {
            n
        }
    }
    fn fold_fn_decl(&mut self, n: FnDecl) -> FnDecl {
        if self.enabled {
            self.visitor.fold_fn_decl(n)
        } else {
            n
        }
    }
    fn fold_fn_expr(&mut self, n: FnExpr) -> FnExpr {
        if self.enabled {
            self.visitor.fold_fn_expr(n)
        } else {
            n
        }
    }
    fn fold_for_in_stmt(&mut self, n: ForInStmt) -> ForInStmt {
        if self.enabled {
            self.visitor.fold_for_in_stmt(n)
        } else {
            n
        }
    }
    fn fold_for_of_stmt(&mut self, n: ForOfStmt) -> ForOfStmt {
        if self.enabled {
            self.visitor.fold_for_of_stmt(n)
        } else {
            n
        }
    }
    fn fold_for_stmt(&mut self, n: ForStmt) -> ForStmt {
        if self.enabled {
            self.visitor.fold_for_stmt(n)
        } else {
            n
        }
    }
    fn fold_function(&mut self, n: Function) -> Function {
        if self.enabled {
            self.visitor.fold_function(n)
        } else {
            n
        }
    }
    fn fold_getter_prop(&mut self, n: GetterProp) -> GetterProp {
        if self.enabled {
            self.visitor.fold_getter_prop(n)
        } else {
            n
        }
    }
    fn fold_ident(&mut self, n: Ident) -> Ident {
        if self.enabled {
            self.visitor.fold_ident(n)
        } else {
            n
        }
    }
    fn fold_if_stmt(&mut self, n: IfStmt) -> IfStmt {
        if self.enabled {
            self.visitor.fold_if_stmt(n)
        } else {
            n
        }
    }
    fn fold_import_decl(&mut self, n: ImportDecl) -> ImportDecl {
        if self.enabled {
            self.visitor.fold_import_decl(n)
        } else {
            n
        }
    }
    fn fold_import_default_specifier(
        &mut self,
        n: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        if self.enabled {
            self.visitor.fold_import_default_specifier(n)
        } else {
            n
        }
    }
    fn fold_import_named_specifier(&mut self, n: ImportNamedSpecifier) -> ImportNamedSpecifier {
        if self.enabled {
            self.visitor.fold_import_named_specifier(n)
        } else {
            n
        }
    }
    fn fold_import_specifier(&mut self, n: ImportSpecifier) -> ImportSpecifier {
        if self.enabled {
            self.visitor.fold_import_specifier(n)
        } else {
            n
        }
    }
    fn fold_import_specifiers(&mut self, n: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        if self.enabled {
            self.visitor.fold_import_specifiers(n)
        } else {
            n
        }
    }
    fn fold_import_star_as_specifier(&mut self, n: ImportStarAsSpecifier) -> ImportStarAsSpecifier {
        if self.enabled {
            self.visitor.fold_import_star_as_specifier(n)
        } else {
            n
        }
    }
    fn fold_invalid(&mut self, n: Invalid) -> Invalid {
        if self.enabled {
            self.visitor.fold_invalid(n)
        } else {
            n
        }
    }
    fn fold_js_word(&mut self, n: JsWord) -> JsWord {
        if self.enabled {
            self.visitor.fold_js_word(n)
        } else {
            n
        }
    }
    fn fold_jsx_attr(&mut self, n: JSXAttr) -> JSXAttr {
        if self.enabled {
            self.visitor.fold_jsx_attr(n)
        } else {
            n
        }
    }
    fn fold_jsx_attr_name(&mut self, n: JSXAttrName) -> JSXAttrName {
        if self.enabled {
            self.visitor.fold_jsx_attr_name(n)
        } else {
            n
        }
    }
    fn fold_jsx_attr_or_spread(&mut self, n: JSXAttrOrSpread) -> JSXAttrOrSpread {
        if self.enabled {
            self.visitor.fold_jsx_attr_or_spread(n)
        } else {
            n
        }
    }
    fn fold_jsx_attr_or_spreads(&mut self, n: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        if self.enabled {
            self.visitor.fold_jsx_attr_or_spreads(n)
        } else {
            n
        }
    }
    fn fold_jsx_attr_value(&mut self, n: JSXAttrValue) -> JSXAttrValue {
        if self.enabled {
            self.visitor.fold_jsx_attr_value(n)
        } else {
            n
        }
    }
    fn fold_jsx_closing_element(&mut self, n: JSXClosingElement) -> JSXClosingElement {
        if self.enabled {
            self.visitor.fold_jsx_closing_element(n)
        } else {
            n
        }
    }
    fn fold_jsx_closing_fragment(&mut self, n: JSXClosingFragment) -> JSXClosingFragment {
        if self.enabled {
            self.visitor.fold_jsx_closing_fragment(n)
        } else {
            n
        }
    }
    fn fold_jsx_element(&mut self, n: JSXElement) -> JSXElement {
        if self.enabled {
            self.visitor.fold_jsx_element(n)
        } else {
            n
        }
    }
    fn fold_jsx_element_child(&mut self, n: JSXElementChild) -> JSXElementChild {
        if self.enabled {
            self.visitor.fold_jsx_element_child(n)
        } else {
            n
        }
    }
    fn fold_jsx_element_children(&mut self, n: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        if self.enabled {
            self.visitor.fold_jsx_element_children(n)
        } else {
            n
        }
    }
    fn fold_jsx_element_name(&mut self, n: JSXElementName) -> JSXElementName {
        if self.enabled {
            self.visitor.fold_jsx_element_name(n)
        } else {
            n
        }
    }
    fn fold_jsx_empty_expr(&mut self, n: JSXEmptyExpr) -> JSXEmptyExpr {
        if self.enabled {
            self.visitor.fold_jsx_empty_expr(n)
        } else {
            n
        }
    }
    fn fold_jsx_expr(&mut self, n: JSXExpr) -> JSXExpr {
        if self.enabled {
            self.visitor.fold_jsx_expr(n)
        } else {
            n
        }
    }
    fn fold_jsx_expr_container(&mut self, n: JSXExprContainer) -> JSXExprContainer {
        if self.enabled {
            self.visitor.fold_jsx_expr_container(n)
        } else {
            n
        }
    }
    fn fold_jsx_fragment(&mut self, n: JSXFragment) -> JSXFragment {
        if self.enabled {
            self.visitor.fold_jsx_fragment(n)
        } else {
            n
        }
    }
    fn fold_jsx_member_expr(&mut self, n: JSXMemberExpr) -> JSXMemberExpr {
        if self.enabled {
            self.visitor.fold_jsx_member_expr(n)
        } else {
            n
        }
    }
    fn fold_jsx_namespaced_name(&mut self, n: JSXNamespacedName) -> JSXNamespacedName {
        if self.enabled {
            self.visitor.fold_jsx_namespaced_name(n)
        } else {
            n
        }
    }
    fn fold_jsx_object(&mut self, n: JSXObject) -> JSXObject {
        if self.enabled {
            self.visitor.fold_jsx_object(n)
        } else {
            n
        }
    }
    fn fold_jsx_opening_element(&mut self, n: JSXOpeningElement) -> JSXOpeningElement {
        if self.enabled {
            self.visitor.fold_jsx_opening_element(n)
        } else {
            n
        }
    }
    fn fold_jsx_opening_fragment(&mut self, n: JSXOpeningFragment) -> JSXOpeningFragment {
        if self.enabled {
            self.visitor.fold_jsx_opening_fragment(n)
        } else {
            n
        }
    }
    fn fold_jsx_spread_child(&mut self, n: JSXSpreadChild) -> JSXSpreadChild {
        if self.enabled {
            self.visitor.fold_jsx_spread_child(n)
        } else {
            n
        }
    }
    fn fold_jsx_text(&mut self, n: JSXText) -> JSXText {
        if self.enabled {
            self.visitor.fold_jsx_text(n)
        } else {
            n
        }
    }
    fn fold_key_value_pat_prop(&mut self, n: KeyValuePatProp) -> KeyValuePatProp {
        if self.enabled {
            self.visitor.fold_key_value_pat_prop(n)
        } else {
            n
        }
    }
    fn fold_key_value_prop(&mut self, n: KeyValueProp) -> KeyValueProp {
        if self.enabled {
            self.visitor.fold_key_value_prop(n)
        } else {
            n
        }
    }
    fn fold_labeled_stmt(&mut self, n: LabeledStmt) -> LabeledStmt {
        if self.enabled {
            self.visitor.fold_labeled_stmt(n)
        } else {
            n
        }
    }
    fn fold_lit(&mut self, n: Lit) -> Lit {
        if self.enabled {
            self.visitor.fold_lit(n)
        } else {
            n
        }
    }
    fn fold_member_expr(&mut self, n: MemberExpr) -> MemberExpr {
        if self.enabled {
            self.visitor.fold_member_expr(n)
        } else {
            n
        }
    }
    fn fold_meta_prop_expr(&mut self, n: MetaPropExpr) -> MetaPropExpr {
        if self.enabled {
            self.visitor.fold_meta_prop_expr(n)
        } else {
            n
        }
    }
    fn fold_method_kind(&mut self, n: MethodKind) -> MethodKind {
        if self.enabled {
            self.visitor.fold_method_kind(n)
        } else {
            n
        }
    }
    fn fold_method_prop(&mut self, n: MethodProp) -> MethodProp {
        if self.enabled {
            self.visitor.fold_method_prop(n)
        } else {
            n
        }
    }
    fn fold_module(&mut self, n: Module) -> Module {
        if self.enabled {
            self.visitor.fold_module(n)
        } else {
            n
        }
    }
    fn fold_module_decl(&mut self, n: ModuleDecl) -> ModuleDecl {
        if self.enabled {
            self.visitor.fold_module_decl(n)
        } else {
            n
        }
    }
    fn fold_module_item(&mut self, n: ModuleItem) -> ModuleItem {
        if self.enabled {
            self.visitor.fold_module_item(n)
        } else {
            n
        }
    }
    fn fold_module_items(&mut self, n: Vec<ModuleItem>) -> Vec<ModuleItem> {
        if self.enabled {
            self.visitor.fold_module_items(n)
        } else {
            n
        }
    }
    fn fold_named_export(&mut self, n: NamedExport) -> NamedExport {
        if self.enabled {
            self.visitor.fold_named_export(n)
        } else {
            n
        }
    }
    fn fold_new_expr(&mut self, n: NewExpr) -> NewExpr {
        if self.enabled {
            self.visitor.fold_new_expr(n)
        } else {
            n
        }
    }
    fn fold_null(&mut self, n: Null) -> Null {
        if self.enabled {
            self.visitor.fold_null(n)
        } else {
            n
        }
    }
    fn fold_number(&mut self, n: Number) -> Number {
        if self.enabled {
            self.visitor.fold_number(n)
        } else {
            n
        }
    }
    fn fold_object_lit(&mut self, n: ObjectLit) -> ObjectLit {
        if self.enabled {
            self.visitor.fold_object_lit(n)
        } else {
            n
        }
    }
    fn fold_object_pat(&mut self, n: ObjectPat) -> ObjectPat {
        if self.enabled {
            self.visitor.fold_object_pat(n)
        } else {
            n
        }
    }
    fn fold_object_pat_prop(&mut self, n: ObjectPatProp) -> ObjectPatProp {
        if self.enabled {
            self.visitor.fold_object_pat_prop(n)
        } else {
            n
        }
    }
    fn fold_object_pat_props(&mut self, n: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        if self.enabled {
            self.visitor.fold_object_pat_props(n)
        } else {
            n
        }
    }
    fn fold_opt_accessibility(&mut self, n: Option<Accessibility>) -> Option<Accessibility> {
        if self.enabled {
            self.visitor.fold_opt_accessibility(n)
        } else {
            n
        }
    }
    fn fold_opt_block_stmt(&mut self, n: Option<BlockStmt>) -> Option<BlockStmt> {
        if self.enabled {
            self.visitor.fold_opt_block_stmt(n)
        } else {
            n
        }
    }
    fn fold_opt_catch_clause(&mut self, n: Option<CatchClause>) -> Option<CatchClause> {
        if self.enabled {
            self.visitor.fold_opt_catch_clause(n)
        } else {
            n
        }
    }
    fn fold_opt_chain_expr(&mut self, n: OptChainExpr) -> OptChainExpr {
        if self.enabled {
            self.visitor.fold_opt_chain_expr(n)
        } else {
            n
        }
    }
    fn fold_opt_expr(&mut self, n: Option<Box<Expr>>) -> Option<Box<Expr>> {
        if self.enabled {
            self.visitor.fold_opt_expr(n)
        } else {
            n
        }
    }
    fn fold_opt_expr_or_spread(&mut self, n: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        if self.enabled {
            self.visitor.fold_opt_expr_or_spread(n)
        } else {
            n
        }
    }
    fn fold_opt_expr_or_spreads(
        &mut self,
        n: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        if self.enabled {
            self.visitor.fold_opt_expr_or_spreads(n)
        } else {
            n
        }
    }
    fn fold_opt_ident(&mut self, n: Option<Ident>) -> Option<Ident> {
        if self.enabled {
            self.visitor.fold_opt_ident(n)
        } else {
            n
        }
    }
    fn fold_opt_js_word(&mut self, n: Option<JsWord>) -> Option<JsWord> {
        if self.enabled {
            self.visitor.fold_opt_js_word(n)
        } else {
            n
        }
    }
    fn fold_opt_jsx_attr_value(&mut self, n: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        if self.enabled {
            self.visitor.fold_opt_jsx_attr_value(n)
        } else {
            n
        }
    }
    fn fold_opt_jsx_closing_element(
        &mut self,
        n: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        if self.enabled {
            self.visitor.fold_opt_jsx_closing_element(n)
        } else {
            n
        }
    }
    fn fold_opt_object_lit(&mut self, n: Option<ObjectLit>) -> Option<ObjectLit> {
        if self.enabled {
            self.visitor.fold_opt_object_lit(n)
        } else {
            n
        }
    }
    fn fold_opt_pat(&mut self, n: Option<Pat>) -> Option<Pat> {
        if self.enabled {
            self.visitor.fold_opt_pat(n)
        } else {
            n
        }
    }
    fn fold_opt_span(&mut self, n: Option<Span>) -> Option<Span> {
        if self.enabled {
            self.visitor.fold_opt_span(n)
        } else {
            n
        }
    }
    fn fold_opt_stmt(&mut self, n: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        if self.enabled {
            self.visitor.fold_opt_stmt(n)
        } else {
            n
        }
    }
    fn fold_opt_str(&mut self, n: Option<Str>) -> Option<Str> {
        if self.enabled {
            self.visitor.fold_opt_str(n)
        } else {
            n
        }
    }
    fn fold_opt_true_plus_minus(&mut self, n: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        if self.enabled {
            self.visitor.fold_opt_true_plus_minus(n)
        } else {
            n
        }
    }
    fn fold_opt_ts_entity_name(&mut self, n: Option<TsEntityName>) -> Option<TsEntityName> {
        if self.enabled {
            self.visitor.fold_opt_ts_entity_name(n)
        } else {
            n
        }
    }
    fn fold_opt_ts_namespace_body(
        &mut self,
        n: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        if self.enabled {
            self.visitor.fold_opt_ts_namespace_body(n)
        } else {
            n
        }
    }
    fn fold_opt_ts_type(&mut self, n: Option<Box<TsType>>) -> Option<Box<TsType>> {
        if self.enabled {
            self.visitor.fold_opt_ts_type(n)
        } else {
            n
        }
    }
    fn fold_opt_ts_type_ann(&mut self, n: Option<TsTypeAnn>) -> Option<TsTypeAnn> {
        if self.enabled {
            self.visitor.fold_opt_ts_type_ann(n)
        } else {
            n
        }
    }
    fn fold_opt_ts_type_param_decl(
        &mut self,
        n: Option<TsTypeParamDecl>,
    ) -> Option<TsTypeParamDecl> {
        if self.enabled {
            self.visitor.fold_opt_ts_type_param_decl(n)
        } else {
            n
        }
    }
    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        n: Option<TsTypeParamInstantiation>,
    ) -> Option<TsTypeParamInstantiation> {
        if self.enabled {
            self.visitor.fold_opt_ts_type_param_instantiation(n)
        } else {
            n
        }
    }
    fn fold_opt_var_decl_or_expr(&mut self, n: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        if self.enabled {
            self.visitor.fold_opt_var_decl_or_expr(n)
        } else {
            n
        }
    }
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        n: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        if self.enabled {
            self.visitor.fold_opt_vec_expr_or_spreads(n)
        } else {
            n
        }
    }
    fn fold_opt_vec_pats(&mut self, n: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        if self.enabled {
            self.visitor.fold_opt_vec_pats(n)
        } else {
            n
        }
    }
    fn fold_param(&mut self, n: Param) -> Param {
        if self.enabled {
            self.visitor.fold_param(n)
        } else {
            n
        }
    }
    fn fold_param_or_ts_param_prop(&mut self, n: ParamOrTsParamProp) -> ParamOrTsParamProp {
        if self.enabled {
            self.visitor.fold_param_or_ts_param_prop(n)
        } else {
            n
        }
    }
    fn fold_param_or_ts_param_props(
        &mut self,
        n: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        if self.enabled {
            self.visitor.fold_param_or_ts_param_props(n)
        } else {
            n
        }
    }
    fn fold_params(&mut self, n: Vec<Param>) -> Vec<Param> {
        if self.enabled {
            self.visitor.fold_params(n)
        } else {
            n
        }
    }
    fn fold_paren_expr(&mut self, n: ParenExpr) -> ParenExpr {
        if self.enabled {
            self.visitor.fold_paren_expr(n)
        } else {
            n
        }
    }
    fn fold_pat(&mut self, n: Pat) -> Pat {
        if self.enabled {
            self.visitor.fold_pat(n)
        } else {
            n
        }
    }
    fn fold_pat_or_expr(&mut self, n: PatOrExpr) -> PatOrExpr {
        if self.enabled {
            self.visitor.fold_pat_or_expr(n)
        } else {
            n
        }
    }
    fn fold_pats(&mut self, n: Vec<Pat>) -> Vec<Pat> {
        if self.enabled {
            self.visitor.fold_pats(n)
        } else {
            n
        }
    }
    fn fold_private_method(&mut self, n: PrivateMethod) -> PrivateMethod {
        if self.enabled {
            self.visitor.fold_private_method(n)
        } else {
            n
        }
    }
    fn fold_private_name(&mut self, n: PrivateName) -> PrivateName {
        if self.enabled {
            self.visitor.fold_private_name(n)
        } else {
            n
        }
    }
    fn fold_private_prop(&mut self, n: PrivateProp) -> PrivateProp {
        if self.enabled {
            self.visitor.fold_private_prop(n)
        } else {
            n
        }
    }
    fn fold_program(&mut self, n: Program) -> Program {
        if self.enabled {
            self.visitor.fold_program(n)
        } else {
            n
        }
    }
    fn fold_prop(&mut self, n: Prop) -> Prop {
        if self.enabled {
            self.visitor.fold_prop(n)
        } else {
            n
        }
    }
    fn fold_prop_name(&mut self, n: PropName) -> PropName {
        if self.enabled {
            self.visitor.fold_prop_name(n)
        } else {
            n
        }
    }
    fn fold_prop_or_spread(&mut self, n: PropOrSpread) -> PropOrSpread {
        if self.enabled {
            self.visitor.fold_prop_or_spread(n)
        } else {
            n
        }
    }
    fn fold_prop_or_spreads(&mut self, n: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        if self.enabled {
            self.visitor.fold_prop_or_spreads(n)
        } else {
            n
        }
    }
    fn fold_regex(&mut self, n: Regex) -> Regex {
        if self.enabled {
            self.visitor.fold_regex(n)
        } else {
            n
        }
    }
    fn fold_rest_pat(&mut self, n: RestPat) -> RestPat {
        if self.enabled {
            self.visitor.fold_rest_pat(n)
        } else {
            n
        }
    }
    fn fold_return_stmt(&mut self, n: ReturnStmt) -> ReturnStmt {
        if self.enabled {
            self.visitor.fold_return_stmt(n)
        } else {
            n
        }
    }
    fn fold_script(&mut self, n: Script) -> Script {
        if self.enabled {
            self.visitor.fold_script(n)
        } else {
            n
        }
    }
    fn fold_seq_expr(&mut self, n: SeqExpr) -> SeqExpr {
        if self.enabled {
            self.visitor.fold_seq_expr(n)
        } else {
            n
        }
    }
    fn fold_setter_prop(&mut self, n: SetterProp) -> SetterProp {
        if self.enabled {
            self.visitor.fold_setter_prop(n)
        } else {
            n
        }
    }
    fn fold_span(&mut self, n: Span) -> Span {
        if self.enabled {
            self.visitor.fold_span(n)
        } else {
            n
        }
    }
    fn fold_spread_element(&mut self, n: SpreadElement) -> SpreadElement {
        if self.enabled {
            self.visitor.fold_spread_element(n)
        } else {
            n
        }
    }
    fn fold_stmt(&mut self, n: Stmt) -> Stmt {
        if self.enabled {
            self.visitor.fold_stmt(n)
        } else {
            n
        }
    }
    fn fold_stmts(&mut self, n: Vec<Stmt>) -> Vec<Stmt> {
        if self.enabled {
            self.visitor.fold_stmts(n)
        } else {
            n
        }
    }
    fn fold_str(&mut self, n: Str) -> Str {
        if self.enabled {
            self.visitor.fold_str(n)
        } else {
            n
        }
    }
    fn fold_str_kind(&mut self, n: StrKind) -> StrKind {
        if self.enabled {
            self.visitor.fold_str_kind(n)
        } else {
            n
        }
    }
    fn fold_super(&mut self, n: Super) -> Super {
        if self.enabled {
            self.visitor.fold_super(n)
        } else {
            n
        }
    }
    fn fold_switch_case(&mut self, n: SwitchCase) -> SwitchCase {
        if self.enabled {
            self.visitor.fold_switch_case(n)
        } else {
            n
        }
    }
    fn fold_switch_cases(&mut self, n: Vec<SwitchCase>) -> Vec<SwitchCase> {
        if self.enabled {
            self.visitor.fold_switch_cases(n)
        } else {
            n
        }
    }
    fn fold_switch_stmt(&mut self, n: SwitchStmt) -> SwitchStmt {
        if self.enabled {
            self.visitor.fold_switch_stmt(n)
        } else {
            n
        }
    }
    fn fold_tagged_tpl(&mut self, n: TaggedTpl) -> TaggedTpl {
        if self.enabled {
            self.visitor.fold_tagged_tpl(n)
        } else {
            n
        }
    }
    fn fold_this_expr(&mut self, n: ThisExpr) -> ThisExpr {
        if self.enabled {
            self.visitor.fold_this_expr(n)
        } else {
            n
        }
    }
    fn fold_throw_stmt(&mut self, n: ThrowStmt) -> ThrowStmt {
        if self.enabled {
            self.visitor.fold_throw_stmt(n)
        } else {
            n
        }
    }
    fn fold_tpl(&mut self, n: Tpl) -> Tpl {
        if self.enabled {
            self.visitor.fold_tpl(n)
        } else {
            n
        }
    }
    fn fold_tpl_element(&mut self, n: TplElement) -> TplElement {
        if self.enabled {
            self.visitor.fold_tpl_element(n)
        } else {
            n
        }
    }
    fn fold_tpl_elements(&mut self, n: Vec<TplElement>) -> Vec<TplElement> {
        if self.enabled {
            self.visitor.fold_tpl_elements(n)
        } else {
            n
        }
    }
    fn fold_true_plus_minus(&mut self, n: TruePlusMinus) -> TruePlusMinus {
        if self.enabled {
            self.visitor.fold_true_plus_minus(n)
        } else {
            n
        }
    }
    fn fold_try_stmt(&mut self, n: TryStmt) -> TryStmt {
        if self.enabled {
            self.visitor.fold_try_stmt(n)
        } else {
            n
        }
    }
    fn fold_ts_array_type(&mut self, n: TsArrayType) -> TsArrayType {
        if self.enabled {
            self.visitor.fold_ts_array_type(n)
        } else {
            n
        }
    }
    fn fold_ts_as_expr(&mut self, n: TsAsExpr) -> TsAsExpr {
        if self.enabled {
            self.visitor.fold_ts_as_expr(n)
        } else {
            n
        }
    }
    fn fold_ts_call_signature_decl(&mut self, n: TsCallSignatureDecl) -> TsCallSignatureDecl {
        if self.enabled {
            self.visitor.fold_ts_call_signature_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_conditional_type(&mut self, n: TsConditionalType) -> TsConditionalType {
        if self.enabled {
            self.visitor.fold_ts_conditional_type(n)
        } else {
            n
        }
    }
    fn fold_ts_const_assertion(&mut self, n: TsConstAssertion) -> TsConstAssertion {
        if self.enabled {
            self.visitor.fold_ts_const_assertion(n)
        } else {
            n
        }
    }
    fn fold_ts_construct_signature_decl(
        &mut self,
        n: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        if self.enabled {
            self.visitor.fold_ts_construct_signature_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_constructor_type(&mut self, n: TsConstructorType) -> TsConstructorType {
        if self.enabled {
            self.visitor.fold_ts_constructor_type(n)
        } else {
            n
        }
    }
    fn fold_ts_entity_name(&mut self, n: TsEntityName) -> TsEntityName {
        if self.enabled {
            self.visitor.fold_ts_entity_name(n)
        } else {
            n
        }
    }
    fn fold_ts_enum_decl(&mut self, n: TsEnumDecl) -> TsEnumDecl {
        if self.enabled {
            self.visitor.fold_ts_enum_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_enum_member(&mut self, n: TsEnumMember) -> TsEnumMember {
        if self.enabled {
            self.visitor.fold_ts_enum_member(n)
        } else {
            n
        }
    }
    fn fold_ts_enum_member_id(&mut self, n: TsEnumMemberId) -> TsEnumMemberId {
        if self.enabled {
            self.visitor.fold_ts_enum_member_id(n)
        } else {
            n
        }
    }
    fn fold_ts_enum_members(&mut self, n: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        if self.enabled {
            self.visitor.fold_ts_enum_members(n)
        } else {
            n
        }
    }
    fn fold_ts_export_assignment(&mut self, n: TsExportAssignment) -> TsExportAssignment {
        if self.enabled {
            self.visitor.fold_ts_export_assignment(n)
        } else {
            n
        }
    }
    fn fold_ts_expr_with_type_args(&mut self, n: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        if self.enabled {
            self.visitor.fold_ts_expr_with_type_args(n)
        } else {
            n
        }
    }
    fn fold_ts_expr_with_type_args_vec(
        &mut self,
        n: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        if self.enabled {
            self.visitor.fold_ts_expr_with_type_args_vec(n)
        } else {
            n
        }
    }
    fn fold_ts_external_module_ref(&mut self, n: TsExternalModuleRef) -> TsExternalModuleRef {
        if self.enabled {
            self.visitor.fold_ts_external_module_ref(n)
        } else {
            n
        }
    }
    fn fold_ts_fn_or_constructor_type(
        &mut self,
        n: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        if self.enabled {
            self.visitor.fold_ts_fn_or_constructor_type(n)
        } else {
            n
        }
    }
    fn fold_ts_fn_param(&mut self, n: TsFnParam) -> TsFnParam {
        if self.enabled {
            self.visitor.fold_ts_fn_param(n)
        } else {
            n
        }
    }
    fn fold_ts_fn_params(&mut self, n: Vec<TsFnParam>) -> Vec<TsFnParam> {
        if self.enabled {
            self.visitor.fold_ts_fn_params(n)
        } else {
            n
        }
    }
    fn fold_ts_fn_type(&mut self, n: TsFnType) -> TsFnType {
        if self.enabled {
            self.visitor.fold_ts_fn_type(n)
        } else {
            n
        }
    }
    fn fold_ts_getter_signature(&mut self, n: TsGetterSignature) -> TsGetterSignature {
        if self.enabled {
            self.visitor.fold_ts_getter_signature(n)
        } else {
            n
        }
    }
    fn fold_ts_import_equals_decl(&mut self, n: TsImportEqualsDecl) -> TsImportEqualsDecl {
        if self.enabled {
            self.visitor.fold_ts_import_equals_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_import_type(&mut self, n: TsImportType) -> TsImportType {
        if self.enabled {
            self.visitor.fold_ts_import_type(n)
        } else {
            n
        }
    }
    fn fold_ts_index_signature(&mut self, n: TsIndexSignature) -> TsIndexSignature {
        if self.enabled {
            self.visitor.fold_ts_index_signature(n)
        } else {
            n
        }
    }
    fn fold_ts_indexed_access_type(&mut self, n: TsIndexedAccessType) -> TsIndexedAccessType {
        if self.enabled {
            self.visitor.fold_ts_indexed_access_type(n)
        } else {
            n
        }
    }
    fn fold_ts_infer_type(&mut self, n: TsInferType) -> TsInferType {
        if self.enabled {
            self.visitor.fold_ts_infer_type(n)
        } else {
            n
        }
    }
    fn fold_ts_interface_body(&mut self, n: TsInterfaceBody) -> TsInterfaceBody {
        if self.enabled {
            self.visitor.fold_ts_interface_body(n)
        } else {
            n
        }
    }
    fn fold_ts_interface_decl(&mut self, n: TsInterfaceDecl) -> TsInterfaceDecl {
        if self.enabled {
            self.visitor.fold_ts_interface_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_intersection_type(&mut self, n: TsIntersectionType) -> TsIntersectionType {
        if self.enabled {
            self.visitor.fold_ts_intersection_type(n)
        } else {
            n
        }
    }
    fn fold_ts_keyword_type(&mut self, n: TsKeywordType) -> TsKeywordType {
        if self.enabled {
            self.visitor.fold_ts_keyword_type(n)
        } else {
            n
        }
    }
    fn fold_ts_keyword_type_kind(&mut self, n: TsKeywordTypeKind) -> TsKeywordTypeKind {
        if self.enabled {
            self.visitor.fold_ts_keyword_type_kind(n)
        } else {
            n
        }
    }
    fn fold_ts_lit(&mut self, n: TsLit) -> TsLit {
        if self.enabled {
            self.visitor.fold_ts_lit(n)
        } else {
            n
        }
    }
    fn fold_ts_lit_type(&mut self, n: TsLitType) -> TsLitType {
        if self.enabled {
            self.visitor.fold_ts_lit_type(n)
        } else {
            n
        }
    }
    fn fold_ts_mapped_type(&mut self, n: TsMappedType) -> TsMappedType {
        if self.enabled {
            self.visitor.fold_ts_mapped_type(n)
        } else {
            n
        }
    }
    fn fold_ts_method_signature(&mut self, n: TsMethodSignature) -> TsMethodSignature {
        if self.enabled {
            self.visitor.fold_ts_method_signature(n)
        } else {
            n
        }
    }
    fn fold_ts_module_block(&mut self, n: TsModuleBlock) -> TsModuleBlock {
        if self.enabled {
            self.visitor.fold_ts_module_block(n)
        } else {
            n
        }
    }
    fn fold_ts_module_decl(&mut self, n: TsModuleDecl) -> TsModuleDecl {
        if self.enabled {
            self.visitor.fold_ts_module_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_module_name(&mut self, n: TsModuleName) -> TsModuleName {
        if self.enabled {
            self.visitor.fold_ts_module_name(n)
        } else {
            n
        }
    }
    fn fold_ts_module_ref(&mut self, n: TsModuleRef) -> TsModuleRef {
        if self.enabled {
            self.visitor.fold_ts_module_ref(n)
        } else {
            n
        }
    }
    fn fold_ts_namespace_body(&mut self, n: TsNamespaceBody) -> TsNamespaceBody {
        if self.enabled {
            self.visitor.fold_ts_namespace_body(n)
        } else {
            n
        }
    }
    fn fold_ts_namespace_decl(&mut self, n: TsNamespaceDecl) -> TsNamespaceDecl {
        if self.enabled {
            self.visitor.fold_ts_namespace_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_namespace_export_decl(&mut self, n: TsNamespaceExportDecl) -> TsNamespaceExportDecl {
        if self.enabled {
            self.visitor.fold_ts_namespace_export_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_non_null_expr(&mut self, n: TsNonNullExpr) -> TsNonNullExpr {
        if self.enabled {
            self.visitor.fold_ts_non_null_expr(n)
        } else {
            n
        }
    }
    fn fold_ts_optional_type(&mut self, n: TsOptionalType) -> TsOptionalType {
        if self.enabled {
            self.visitor.fold_ts_optional_type(n)
        } else {
            n
        }
    }
    fn fold_ts_param_prop(&mut self, n: TsParamProp) -> TsParamProp {
        if self.enabled {
            self.visitor.fold_ts_param_prop(n)
        } else {
            n
        }
    }
    fn fold_ts_param_prop_param(&mut self, n: TsParamPropParam) -> TsParamPropParam {
        if self.enabled {
            self.visitor.fold_ts_param_prop_param(n)
        } else {
            n
        }
    }
    fn fold_ts_parenthesized_type(&mut self, n: TsParenthesizedType) -> TsParenthesizedType {
        if self.enabled {
            self.visitor.fold_ts_parenthesized_type(n)
        } else {
            n
        }
    }
    fn fold_ts_property_signature(&mut self, n: TsPropertySignature) -> TsPropertySignature {
        if self.enabled {
            self.visitor.fold_ts_property_signature(n)
        } else {
            n
        }
    }
    fn fold_ts_qualified_name(&mut self, n: TsQualifiedName) -> TsQualifiedName {
        if self.enabled {
            self.visitor.fold_ts_qualified_name(n)
        } else {
            n
        }
    }
    fn fold_ts_rest_type(&mut self, n: TsRestType) -> TsRestType {
        if self.enabled {
            self.visitor.fold_ts_rest_type(n)
        } else {
            n
        }
    }
    fn fold_ts_setter_signature(&mut self, n: TsSetterSignature) -> TsSetterSignature {
        if self.enabled {
            self.visitor.fold_ts_setter_signature(n)
        } else {
            n
        }
    }
    fn fold_ts_this_type(&mut self, n: TsThisType) -> TsThisType {
        if self.enabled {
            self.visitor.fold_ts_this_type(n)
        } else {
            n
        }
    }
    fn fold_ts_this_type_or_ident(&mut self, n: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        if self.enabled {
            self.visitor.fold_ts_this_type_or_ident(n)
        } else {
            n
        }
    }
    fn fold_ts_tpl_lit_type(&mut self, n: TsTplLitType) -> TsTplLitType {
        if self.enabled {
            self.visitor.fold_ts_tpl_lit_type(n)
        } else {
            n
        }
    }
    fn fold_ts_tuple_element(&mut self, n: TsTupleElement) -> TsTupleElement {
        if self.enabled {
            self.visitor.fold_ts_tuple_element(n)
        } else {
            n
        }
    }
    fn fold_ts_tuple_elements(&mut self, n: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        if self.enabled {
            self.visitor.fold_ts_tuple_elements(n)
        } else {
            n
        }
    }
    fn fold_ts_tuple_type(&mut self, n: TsTupleType) -> TsTupleType {
        if self.enabled {
            self.visitor.fold_ts_tuple_type(n)
        } else {
            n
        }
    }
    fn fold_ts_type(&mut self, n: TsType) -> TsType {
        if self.enabled {
            self.visitor.fold_ts_type(n)
        } else {
            n
        }
    }
    fn fold_ts_type_alias_decl(&mut self, n: TsTypeAliasDecl) -> TsTypeAliasDecl {
        if self.enabled {
            self.visitor.fold_ts_type_alias_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_type_ann(&mut self, n: TsTypeAnn) -> TsTypeAnn {
        if self.enabled {
            self.visitor.fold_ts_type_ann(n)
        } else {
            n
        }
    }
    fn fold_ts_type_assertion(&mut self, n: TsTypeAssertion) -> TsTypeAssertion {
        if self.enabled {
            self.visitor.fold_ts_type_assertion(n)
        } else {
            n
        }
    }
    fn fold_ts_type_element(&mut self, n: TsTypeElement) -> TsTypeElement {
        if self.enabled {
            self.visitor.fold_ts_type_element(n)
        } else {
            n
        }
    }
    fn fold_ts_type_elements(&mut self, n: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        if self.enabled {
            self.visitor.fold_ts_type_elements(n)
        } else {
            n
        }
    }
    fn fold_ts_type_lit(&mut self, n: TsTypeLit) -> TsTypeLit {
        if self.enabled {
            self.visitor.fold_ts_type_lit(n)
        } else {
            n
        }
    }
    fn fold_ts_type_operator(&mut self, n: TsTypeOperator) -> TsTypeOperator {
        if self.enabled {
            self.visitor.fold_ts_type_operator(n)
        } else {
            n
        }
    }
    fn fold_ts_type_operator_op(&mut self, n: TsTypeOperatorOp) -> TsTypeOperatorOp {
        if self.enabled {
            self.visitor.fold_ts_type_operator_op(n)
        } else {
            n
        }
    }
    fn fold_ts_type_param(&mut self, n: TsTypeParam) -> TsTypeParam {
        if self.enabled {
            self.visitor.fold_ts_type_param(n)
        } else {
            n
        }
    }
    fn fold_ts_type_param_decl(&mut self, n: TsTypeParamDecl) -> TsTypeParamDecl {
        if self.enabled {
            self.visitor.fold_ts_type_param_decl(n)
        } else {
            n
        }
    }
    fn fold_ts_type_param_instantiation(
        &mut self,
        n: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        if self.enabled {
            self.visitor.fold_ts_type_param_instantiation(n)
        } else {
            n
        }
    }
    fn fold_ts_type_params(&mut self, n: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        if self.enabled {
            self.visitor.fold_ts_type_params(n)
        } else {
            n
        }
    }
    fn fold_ts_type_predicate(&mut self, n: TsTypePredicate) -> TsTypePredicate {
        if self.enabled {
            self.visitor.fold_ts_type_predicate(n)
        } else {
            n
        }
    }
    fn fold_ts_type_query(&mut self, n: TsTypeQuery) -> TsTypeQuery {
        if self.enabled {
            self.visitor.fold_ts_type_query(n)
        } else {
            n
        }
    }
    fn fold_ts_type_query_expr(&mut self, n: TsTypeQueryExpr) -> TsTypeQueryExpr {
        if self.enabled {
            self.visitor.fold_ts_type_query_expr(n)
        } else {
            n
        }
    }
    fn fold_ts_type_ref(&mut self, n: TsTypeRef) -> TsTypeRef {
        if self.enabled {
            self.visitor.fold_ts_type_ref(n)
        } else {
            n
        }
    }
    fn fold_ts_types(&mut self, n: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        if self.enabled {
            self.visitor.fold_ts_types(n)
        } else {
            n
        }
    }
    fn fold_ts_union_or_intersection_type(
        &mut self,
        n: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        if self.enabled {
            self.visitor.fold_ts_union_or_intersection_type(n)
        } else {
            n
        }
    }
    fn fold_ts_union_type(&mut self, n: TsUnionType) -> TsUnionType {
        if self.enabled {
            self.visitor.fold_ts_union_type(n)
        } else {
            n
        }
    }
    fn fold_unary_expr(&mut self, n: UnaryExpr) -> UnaryExpr {
        if self.enabled {
            self.visitor.fold_unary_expr(n)
        } else {
            n
        }
    }
    fn fold_unary_op(&mut self, n: UnaryOp) -> UnaryOp {
        if self.enabled {
            self.visitor.fold_unary_op(n)
        } else {
            n
        }
    }
    fn fold_update_expr(&mut self, n: UpdateExpr) -> UpdateExpr {
        if self.enabled {
            self.visitor.fold_update_expr(n)
        } else {
            n
        }
    }
    fn fold_update_op(&mut self, n: UpdateOp) -> UpdateOp {
        if self.enabled {
            self.visitor.fold_update_op(n)
        } else {
            n
        }
    }
    fn fold_var_decl(&mut self, n: VarDecl) -> VarDecl {
        if self.enabled {
            self.visitor.fold_var_decl(n)
        } else {
            n
        }
    }
    fn fold_var_decl_kind(&mut self, n: VarDeclKind) -> VarDeclKind {
        if self.enabled {
            self.visitor.fold_var_decl_kind(n)
        } else {
            n
        }
    }
    fn fold_var_decl_or_expr(&mut self, n: VarDeclOrExpr) -> VarDeclOrExpr {
        if self.enabled {
            self.visitor.fold_var_decl_or_expr(n)
        } else {
            n
        }
    }
    fn fold_var_decl_or_pat(&mut self, n: VarDeclOrPat) -> VarDeclOrPat {
        if self.enabled {
            self.visitor.fold_var_decl_or_pat(n)
        } else {
            n
        }
    }
    fn fold_var_declarator(&mut self, n: VarDeclarator) -> VarDeclarator {
        if self.enabled {
            self.visitor.fold_var_declarator(n)
        } else {
            n
        }
    }
    fn fold_var_declarators(&mut self, n: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        if self.enabled {
            self.visitor.fold_var_declarators(n)
        } else {
            n
        }
    }
    fn fold_while_stmt(&mut self, n: WhileStmt) -> WhileStmt {
        if self.enabled {
            self.visitor.fold_while_stmt(n)
        } else {
            n
        }
    }
    fn fold_with_stmt(&mut self, n: WithStmt) -> WithStmt {
        if self.enabled {
            self.visitor.fold_with_stmt(n)
        } else {
            n
        }
    }
    fn fold_yield_expr(&mut self, n: YieldExpr) -> YieldExpr {
        if self.enabled {
            self.visitor.fold_yield_expr(n)
        } else {
            n
        }
    }
}
impl<A, B> Fold for ::global_visit::Either<A, B>
where
    A: Fold,
    B: Fold,
{
    fn fold_accessibility(&mut self, n: Accessibility) -> Accessibility {
        match self {
            global_visit::Either::Left(v) => v.fold_accessibility(n),
            global_visit::Either::Right(v) => v.fold_accessibility(n),
        }
    }
    fn fold_array_lit(&mut self, n: ArrayLit) -> ArrayLit {
        match self {
            global_visit::Either::Left(v) => v.fold_array_lit(n),
            global_visit::Either::Right(v) => v.fold_array_lit(n),
        }
    }
    fn fold_array_pat(&mut self, n: ArrayPat) -> ArrayPat {
        match self {
            global_visit::Either::Left(v) => v.fold_array_pat(n),
            global_visit::Either::Right(v) => v.fold_array_pat(n),
        }
    }
    fn fold_arrow_expr(&mut self, n: ArrowExpr) -> ArrowExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_arrow_expr(n),
            global_visit::Either::Right(v) => v.fold_arrow_expr(n),
        }
    }
    fn fold_assign_expr(&mut self, n: AssignExpr) -> AssignExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_assign_expr(n),
            global_visit::Either::Right(v) => v.fold_assign_expr(n),
        }
    }
    fn fold_assign_op(&mut self, n: AssignOp) -> AssignOp {
        match self {
            global_visit::Either::Left(v) => v.fold_assign_op(n),
            global_visit::Either::Right(v) => v.fold_assign_op(n),
        }
    }
    fn fold_assign_pat(&mut self, n: AssignPat) -> AssignPat {
        match self {
            global_visit::Either::Left(v) => v.fold_assign_pat(n),
            global_visit::Either::Right(v) => v.fold_assign_pat(n),
        }
    }
    fn fold_assign_pat_prop(&mut self, n: AssignPatProp) -> AssignPatProp {
        match self {
            global_visit::Either::Left(v) => v.fold_assign_pat_prop(n),
            global_visit::Either::Right(v) => v.fold_assign_pat_prop(n),
        }
    }
    fn fold_assign_prop(&mut self, n: AssignProp) -> AssignProp {
        match self {
            global_visit::Either::Left(v) => v.fold_assign_prop(n),
            global_visit::Either::Right(v) => v.fold_assign_prop(n),
        }
    }
    fn fold_await_expr(&mut self, n: AwaitExpr) -> AwaitExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_await_expr(n),
            global_visit::Either::Right(v) => v.fold_await_expr(n),
        }
    }
    fn fold_big_int(&mut self, n: BigInt) -> BigInt {
        match self {
            global_visit::Either::Left(v) => v.fold_big_int(n),
            global_visit::Either::Right(v) => v.fold_big_int(n),
        }
    }
    fn fold_big_int_value(&mut self, n: BigIntValue) -> BigIntValue {
        match self {
            global_visit::Either::Left(v) => v.fold_big_int_value(n),
            global_visit::Either::Right(v) => v.fold_big_int_value(n),
        }
    }
    fn fold_bin_expr(&mut self, n: BinExpr) -> BinExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_bin_expr(n),
            global_visit::Either::Right(v) => v.fold_bin_expr(n),
        }
    }
    fn fold_binary_op(&mut self, n: BinaryOp) -> BinaryOp {
        match self {
            global_visit::Either::Left(v) => v.fold_binary_op(n),
            global_visit::Either::Right(v) => v.fold_binary_op(n),
        }
    }
    fn fold_binding_ident(&mut self, n: BindingIdent) -> BindingIdent {
        match self {
            global_visit::Either::Left(v) => v.fold_binding_ident(n),
            global_visit::Either::Right(v) => v.fold_binding_ident(n),
        }
    }
    fn fold_block_stmt(&mut self, n: BlockStmt) -> BlockStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_block_stmt(n),
            global_visit::Either::Right(v) => v.fold_block_stmt(n),
        }
    }
    fn fold_block_stmt_or_expr(&mut self, n: BlockStmtOrExpr) -> BlockStmtOrExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_block_stmt_or_expr(n),
            global_visit::Either::Right(v) => v.fold_block_stmt_or_expr(n),
        }
    }
    fn fold_bool(&mut self, n: Bool) -> Bool {
        match self {
            global_visit::Either::Left(v) => v.fold_bool(n),
            global_visit::Either::Right(v) => v.fold_bool(n),
        }
    }
    fn fold_break_stmt(&mut self, n: BreakStmt) -> BreakStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_break_stmt(n),
            global_visit::Either::Right(v) => v.fold_break_stmt(n),
        }
    }
    fn fold_call_expr(&mut self, n: CallExpr) -> CallExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_call_expr(n),
            global_visit::Either::Right(v) => v.fold_call_expr(n),
        }
    }
    fn fold_catch_clause(&mut self, n: CatchClause) -> CatchClause {
        match self {
            global_visit::Either::Left(v) => v.fold_catch_clause(n),
            global_visit::Either::Right(v) => v.fold_catch_clause(n),
        }
    }
    fn fold_class(&mut self, n: Class) -> Class {
        match self {
            global_visit::Either::Left(v) => v.fold_class(n),
            global_visit::Either::Right(v) => v.fold_class(n),
        }
    }
    fn fold_class_decl(&mut self, n: ClassDecl) -> ClassDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_class_decl(n),
            global_visit::Either::Right(v) => v.fold_class_decl(n),
        }
    }
    fn fold_class_expr(&mut self, n: ClassExpr) -> ClassExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_class_expr(n),
            global_visit::Either::Right(v) => v.fold_class_expr(n),
        }
    }
    fn fold_class_member(&mut self, n: ClassMember) -> ClassMember {
        match self {
            global_visit::Either::Left(v) => v.fold_class_member(n),
            global_visit::Either::Right(v) => v.fold_class_member(n),
        }
    }
    fn fold_class_members(&mut self, n: Vec<ClassMember>) -> Vec<ClassMember> {
        match self {
            global_visit::Either::Left(v) => v.fold_class_members(n),
            global_visit::Either::Right(v) => v.fold_class_members(n),
        }
    }
    fn fold_class_method(&mut self, n: ClassMethod) -> ClassMethod {
        match self {
            global_visit::Either::Left(v) => v.fold_class_method(n),
            global_visit::Either::Right(v) => v.fold_class_method(n),
        }
    }
    fn fold_class_prop(&mut self, n: ClassProp) -> ClassProp {
        match self {
            global_visit::Either::Left(v) => v.fold_class_prop(n),
            global_visit::Either::Right(v) => v.fold_class_prop(n),
        }
    }
    fn fold_computed_prop_name(&mut self, n: ComputedPropName) -> ComputedPropName {
        match self {
            global_visit::Either::Left(v) => v.fold_computed_prop_name(n),
            global_visit::Either::Right(v) => v.fold_computed_prop_name(n),
        }
    }
    fn fold_cond_expr(&mut self, n: CondExpr) -> CondExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_cond_expr(n),
            global_visit::Either::Right(v) => v.fold_cond_expr(n),
        }
    }
    fn fold_constructor(&mut self, n: Constructor) -> Constructor {
        match self {
            global_visit::Either::Left(v) => v.fold_constructor(n),
            global_visit::Either::Right(v) => v.fold_constructor(n),
        }
    }
    fn fold_continue_stmt(&mut self, n: ContinueStmt) -> ContinueStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_continue_stmt(n),
            global_visit::Either::Right(v) => v.fold_continue_stmt(n),
        }
    }
    fn fold_debugger_stmt(&mut self, n: DebuggerStmt) -> DebuggerStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_debugger_stmt(n),
            global_visit::Either::Right(v) => v.fold_debugger_stmt(n),
        }
    }
    fn fold_decl(&mut self, n: Decl) -> Decl {
        match self {
            global_visit::Either::Left(v) => v.fold_decl(n),
            global_visit::Either::Right(v) => v.fold_decl(n),
        }
    }
    fn fold_decorator(&mut self, n: Decorator) -> Decorator {
        match self {
            global_visit::Either::Left(v) => v.fold_decorator(n),
            global_visit::Either::Right(v) => v.fold_decorator(n),
        }
    }
    fn fold_decorators(&mut self, n: Vec<Decorator>) -> Vec<Decorator> {
        match self {
            global_visit::Either::Left(v) => v.fold_decorators(n),
            global_visit::Either::Right(v) => v.fold_decorators(n),
        }
    }
    fn fold_default_decl(&mut self, n: DefaultDecl) -> DefaultDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_default_decl(n),
            global_visit::Either::Right(v) => v.fold_default_decl(n),
        }
    }
    fn fold_do_while_stmt(&mut self, n: DoWhileStmt) -> DoWhileStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_do_while_stmt(n),
            global_visit::Either::Right(v) => v.fold_do_while_stmt(n),
        }
    }
    fn fold_empty_stmt(&mut self, n: EmptyStmt) -> EmptyStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_empty_stmt(n),
            global_visit::Either::Right(v) => v.fold_empty_stmt(n),
        }
    }
    fn fold_export_all(&mut self, n: ExportAll) -> ExportAll {
        match self {
            global_visit::Either::Left(v) => v.fold_export_all(n),
            global_visit::Either::Right(v) => v.fold_export_all(n),
        }
    }
    fn fold_export_decl(&mut self, n: ExportDecl) -> ExportDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_export_decl(n),
            global_visit::Either::Right(v) => v.fold_export_decl(n),
        }
    }
    fn fold_export_default_decl(&mut self, n: ExportDefaultDecl) -> ExportDefaultDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_export_default_decl(n),
            global_visit::Either::Right(v) => v.fold_export_default_decl(n),
        }
    }
    fn fold_export_default_expr(&mut self, n: ExportDefaultExpr) -> ExportDefaultExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_export_default_expr(n),
            global_visit::Either::Right(v) => v.fold_export_default_expr(n),
        }
    }
    fn fold_export_default_specifier(
        &mut self,
        n: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        match self {
            global_visit::Either::Left(v) => v.fold_export_default_specifier(n),
            global_visit::Either::Right(v) => v.fold_export_default_specifier(n),
        }
    }
    fn fold_export_named_specifier(&mut self, n: ExportNamedSpecifier) -> ExportNamedSpecifier {
        match self {
            global_visit::Either::Left(v) => v.fold_export_named_specifier(n),
            global_visit::Either::Right(v) => v.fold_export_named_specifier(n),
        }
    }
    fn fold_export_namespace_specifier(
        &mut self,
        n: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        match self {
            global_visit::Either::Left(v) => v.fold_export_namespace_specifier(n),
            global_visit::Either::Right(v) => v.fold_export_namespace_specifier(n),
        }
    }
    fn fold_export_specifier(&mut self, n: ExportSpecifier) -> ExportSpecifier {
        match self {
            global_visit::Either::Left(v) => v.fold_export_specifier(n),
            global_visit::Either::Right(v) => v.fold_export_specifier(n),
        }
    }
    fn fold_export_specifiers(&mut self, n: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        match self {
            global_visit::Either::Left(v) => v.fold_export_specifiers(n),
            global_visit::Either::Right(v) => v.fold_export_specifiers(n),
        }
    }
    fn fold_expr(&mut self, n: Expr) -> Expr {
        match self {
            global_visit::Either::Left(v) => v.fold_expr(n),
            global_visit::Either::Right(v) => v.fold_expr(n),
        }
    }
    fn fold_expr_or_spread(&mut self, n: ExprOrSpread) -> ExprOrSpread {
        match self {
            global_visit::Either::Left(v) => v.fold_expr_or_spread(n),
            global_visit::Either::Right(v) => v.fold_expr_or_spread(n),
        }
    }
    fn fold_expr_or_spreads(&mut self, n: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        match self {
            global_visit::Either::Left(v) => v.fold_expr_or_spreads(n),
            global_visit::Either::Right(v) => v.fold_expr_or_spreads(n),
        }
    }
    fn fold_expr_or_super(&mut self, n: ExprOrSuper) -> ExprOrSuper {
        match self {
            global_visit::Either::Left(v) => v.fold_expr_or_super(n),
            global_visit::Either::Right(v) => v.fold_expr_or_super(n),
        }
    }
    fn fold_expr_stmt(&mut self, n: ExprStmt) -> ExprStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_expr_stmt(n),
            global_visit::Either::Right(v) => v.fold_expr_stmt(n),
        }
    }
    fn fold_exprs(&mut self, n: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        match self {
            global_visit::Either::Left(v) => v.fold_exprs(n),
            global_visit::Either::Right(v) => v.fold_exprs(n),
        }
    }
    fn fold_fn_decl(&mut self, n: FnDecl) -> FnDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_fn_decl(n),
            global_visit::Either::Right(v) => v.fold_fn_decl(n),
        }
    }
    fn fold_fn_expr(&mut self, n: FnExpr) -> FnExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_fn_expr(n),
            global_visit::Either::Right(v) => v.fold_fn_expr(n),
        }
    }
    fn fold_for_in_stmt(&mut self, n: ForInStmt) -> ForInStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_for_in_stmt(n),
            global_visit::Either::Right(v) => v.fold_for_in_stmt(n),
        }
    }
    fn fold_for_of_stmt(&mut self, n: ForOfStmt) -> ForOfStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_for_of_stmt(n),
            global_visit::Either::Right(v) => v.fold_for_of_stmt(n),
        }
    }
    fn fold_for_stmt(&mut self, n: ForStmt) -> ForStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_for_stmt(n),
            global_visit::Either::Right(v) => v.fold_for_stmt(n),
        }
    }
    fn fold_function(&mut self, n: Function) -> Function {
        match self {
            global_visit::Either::Left(v) => v.fold_function(n),
            global_visit::Either::Right(v) => v.fold_function(n),
        }
    }
    fn fold_getter_prop(&mut self, n: GetterProp) -> GetterProp {
        match self {
            global_visit::Either::Left(v) => v.fold_getter_prop(n),
            global_visit::Either::Right(v) => v.fold_getter_prop(n),
        }
    }
    fn fold_ident(&mut self, n: Ident) -> Ident {
        match self {
            global_visit::Either::Left(v) => v.fold_ident(n),
            global_visit::Either::Right(v) => v.fold_ident(n),
        }
    }
    fn fold_if_stmt(&mut self, n: IfStmt) -> IfStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_if_stmt(n),
            global_visit::Either::Right(v) => v.fold_if_stmt(n),
        }
    }
    fn fold_import_decl(&mut self, n: ImportDecl) -> ImportDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_import_decl(n),
            global_visit::Either::Right(v) => v.fold_import_decl(n),
        }
    }
    fn fold_import_default_specifier(
        &mut self,
        n: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        match self {
            global_visit::Either::Left(v) => v.fold_import_default_specifier(n),
            global_visit::Either::Right(v) => v.fold_import_default_specifier(n),
        }
    }
    fn fold_import_named_specifier(&mut self, n: ImportNamedSpecifier) -> ImportNamedSpecifier {
        match self {
            global_visit::Either::Left(v) => v.fold_import_named_specifier(n),
            global_visit::Either::Right(v) => v.fold_import_named_specifier(n),
        }
    }
    fn fold_import_specifier(&mut self, n: ImportSpecifier) -> ImportSpecifier {
        match self {
            global_visit::Either::Left(v) => v.fold_import_specifier(n),
            global_visit::Either::Right(v) => v.fold_import_specifier(n),
        }
    }
    fn fold_import_specifiers(&mut self, n: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        match self {
            global_visit::Either::Left(v) => v.fold_import_specifiers(n),
            global_visit::Either::Right(v) => v.fold_import_specifiers(n),
        }
    }
    fn fold_import_star_as_specifier(&mut self, n: ImportStarAsSpecifier) -> ImportStarAsSpecifier {
        match self {
            global_visit::Either::Left(v) => v.fold_import_star_as_specifier(n),
            global_visit::Either::Right(v) => v.fold_import_star_as_specifier(n),
        }
    }
    fn fold_invalid(&mut self, n: Invalid) -> Invalid {
        match self {
            global_visit::Either::Left(v) => v.fold_invalid(n),
            global_visit::Either::Right(v) => v.fold_invalid(n),
        }
    }
    fn fold_js_word(&mut self, n: JsWord) -> JsWord {
        match self {
            global_visit::Either::Left(v) => v.fold_js_word(n),
            global_visit::Either::Right(v) => v.fold_js_word(n),
        }
    }
    fn fold_jsx_attr(&mut self, n: JSXAttr) -> JSXAttr {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_attr(n),
            global_visit::Either::Right(v) => v.fold_jsx_attr(n),
        }
    }
    fn fold_jsx_attr_name(&mut self, n: JSXAttrName) -> JSXAttrName {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_attr_name(n),
            global_visit::Either::Right(v) => v.fold_jsx_attr_name(n),
        }
    }
    fn fold_jsx_attr_or_spread(&mut self, n: JSXAttrOrSpread) -> JSXAttrOrSpread {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_attr_or_spread(n),
            global_visit::Either::Right(v) => v.fold_jsx_attr_or_spread(n),
        }
    }
    fn fold_jsx_attr_or_spreads(&mut self, n: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_attr_or_spreads(n),
            global_visit::Either::Right(v) => v.fold_jsx_attr_or_spreads(n),
        }
    }
    fn fold_jsx_attr_value(&mut self, n: JSXAttrValue) -> JSXAttrValue {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_attr_value(n),
            global_visit::Either::Right(v) => v.fold_jsx_attr_value(n),
        }
    }
    fn fold_jsx_closing_element(&mut self, n: JSXClosingElement) -> JSXClosingElement {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_closing_element(n),
            global_visit::Either::Right(v) => v.fold_jsx_closing_element(n),
        }
    }
    fn fold_jsx_closing_fragment(&mut self, n: JSXClosingFragment) -> JSXClosingFragment {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_closing_fragment(n),
            global_visit::Either::Right(v) => v.fold_jsx_closing_fragment(n),
        }
    }
    fn fold_jsx_element(&mut self, n: JSXElement) -> JSXElement {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_element(n),
            global_visit::Either::Right(v) => v.fold_jsx_element(n),
        }
    }
    fn fold_jsx_element_child(&mut self, n: JSXElementChild) -> JSXElementChild {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_element_child(n),
            global_visit::Either::Right(v) => v.fold_jsx_element_child(n),
        }
    }
    fn fold_jsx_element_children(&mut self, n: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_element_children(n),
            global_visit::Either::Right(v) => v.fold_jsx_element_children(n),
        }
    }
    fn fold_jsx_element_name(&mut self, n: JSXElementName) -> JSXElementName {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_element_name(n),
            global_visit::Either::Right(v) => v.fold_jsx_element_name(n),
        }
    }
    fn fold_jsx_empty_expr(&mut self, n: JSXEmptyExpr) -> JSXEmptyExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_empty_expr(n),
            global_visit::Either::Right(v) => v.fold_jsx_empty_expr(n),
        }
    }
    fn fold_jsx_expr(&mut self, n: JSXExpr) -> JSXExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_expr(n),
            global_visit::Either::Right(v) => v.fold_jsx_expr(n),
        }
    }
    fn fold_jsx_expr_container(&mut self, n: JSXExprContainer) -> JSXExprContainer {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_expr_container(n),
            global_visit::Either::Right(v) => v.fold_jsx_expr_container(n),
        }
    }
    fn fold_jsx_fragment(&mut self, n: JSXFragment) -> JSXFragment {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_fragment(n),
            global_visit::Either::Right(v) => v.fold_jsx_fragment(n),
        }
    }
    fn fold_jsx_member_expr(&mut self, n: JSXMemberExpr) -> JSXMemberExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_member_expr(n),
            global_visit::Either::Right(v) => v.fold_jsx_member_expr(n),
        }
    }
    fn fold_jsx_namespaced_name(&mut self, n: JSXNamespacedName) -> JSXNamespacedName {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_namespaced_name(n),
            global_visit::Either::Right(v) => v.fold_jsx_namespaced_name(n),
        }
    }
    fn fold_jsx_object(&mut self, n: JSXObject) -> JSXObject {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_object(n),
            global_visit::Either::Right(v) => v.fold_jsx_object(n),
        }
    }
    fn fold_jsx_opening_element(&mut self, n: JSXOpeningElement) -> JSXOpeningElement {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_opening_element(n),
            global_visit::Either::Right(v) => v.fold_jsx_opening_element(n),
        }
    }
    fn fold_jsx_opening_fragment(&mut self, n: JSXOpeningFragment) -> JSXOpeningFragment {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_opening_fragment(n),
            global_visit::Either::Right(v) => v.fold_jsx_opening_fragment(n),
        }
    }
    fn fold_jsx_spread_child(&mut self, n: JSXSpreadChild) -> JSXSpreadChild {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_spread_child(n),
            global_visit::Either::Right(v) => v.fold_jsx_spread_child(n),
        }
    }
    fn fold_jsx_text(&mut self, n: JSXText) -> JSXText {
        match self {
            global_visit::Either::Left(v) => v.fold_jsx_text(n),
            global_visit::Either::Right(v) => v.fold_jsx_text(n),
        }
    }
    fn fold_key_value_pat_prop(&mut self, n: KeyValuePatProp) -> KeyValuePatProp {
        match self {
            global_visit::Either::Left(v) => v.fold_key_value_pat_prop(n),
            global_visit::Either::Right(v) => v.fold_key_value_pat_prop(n),
        }
    }
    fn fold_key_value_prop(&mut self, n: KeyValueProp) -> KeyValueProp {
        match self {
            global_visit::Either::Left(v) => v.fold_key_value_prop(n),
            global_visit::Either::Right(v) => v.fold_key_value_prop(n),
        }
    }
    fn fold_labeled_stmt(&mut self, n: LabeledStmt) -> LabeledStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_labeled_stmt(n),
            global_visit::Either::Right(v) => v.fold_labeled_stmt(n),
        }
    }
    fn fold_lit(&mut self, n: Lit) -> Lit {
        match self {
            global_visit::Either::Left(v) => v.fold_lit(n),
            global_visit::Either::Right(v) => v.fold_lit(n),
        }
    }
    fn fold_member_expr(&mut self, n: MemberExpr) -> MemberExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_member_expr(n),
            global_visit::Either::Right(v) => v.fold_member_expr(n),
        }
    }
    fn fold_meta_prop_expr(&mut self, n: MetaPropExpr) -> MetaPropExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_meta_prop_expr(n),
            global_visit::Either::Right(v) => v.fold_meta_prop_expr(n),
        }
    }
    fn fold_method_kind(&mut self, n: MethodKind) -> MethodKind {
        match self {
            global_visit::Either::Left(v) => v.fold_method_kind(n),
            global_visit::Either::Right(v) => v.fold_method_kind(n),
        }
    }
    fn fold_method_prop(&mut self, n: MethodProp) -> MethodProp {
        match self {
            global_visit::Either::Left(v) => v.fold_method_prop(n),
            global_visit::Either::Right(v) => v.fold_method_prop(n),
        }
    }
    fn fold_module(&mut self, n: Module) -> Module {
        match self {
            global_visit::Either::Left(v) => v.fold_module(n),
            global_visit::Either::Right(v) => v.fold_module(n),
        }
    }
    fn fold_module_decl(&mut self, n: ModuleDecl) -> ModuleDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_module_decl(n),
            global_visit::Either::Right(v) => v.fold_module_decl(n),
        }
    }
    fn fold_module_item(&mut self, n: ModuleItem) -> ModuleItem {
        match self {
            global_visit::Either::Left(v) => v.fold_module_item(n),
            global_visit::Either::Right(v) => v.fold_module_item(n),
        }
    }
    fn fold_module_items(&mut self, n: Vec<ModuleItem>) -> Vec<ModuleItem> {
        match self {
            global_visit::Either::Left(v) => v.fold_module_items(n),
            global_visit::Either::Right(v) => v.fold_module_items(n),
        }
    }
    fn fold_named_export(&mut self, n: NamedExport) -> NamedExport {
        match self {
            global_visit::Either::Left(v) => v.fold_named_export(n),
            global_visit::Either::Right(v) => v.fold_named_export(n),
        }
    }
    fn fold_new_expr(&mut self, n: NewExpr) -> NewExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_new_expr(n),
            global_visit::Either::Right(v) => v.fold_new_expr(n),
        }
    }
    fn fold_null(&mut self, n: Null) -> Null {
        match self {
            global_visit::Either::Left(v) => v.fold_null(n),
            global_visit::Either::Right(v) => v.fold_null(n),
        }
    }
    fn fold_number(&mut self, n: Number) -> Number {
        match self {
            global_visit::Either::Left(v) => v.fold_number(n),
            global_visit::Either::Right(v) => v.fold_number(n),
        }
    }
    fn fold_object_lit(&mut self, n: ObjectLit) -> ObjectLit {
        match self {
            global_visit::Either::Left(v) => v.fold_object_lit(n),
            global_visit::Either::Right(v) => v.fold_object_lit(n),
        }
    }
    fn fold_object_pat(&mut self, n: ObjectPat) -> ObjectPat {
        match self {
            global_visit::Either::Left(v) => v.fold_object_pat(n),
            global_visit::Either::Right(v) => v.fold_object_pat(n),
        }
    }
    fn fold_object_pat_prop(&mut self, n: ObjectPatProp) -> ObjectPatProp {
        match self {
            global_visit::Either::Left(v) => v.fold_object_pat_prop(n),
            global_visit::Either::Right(v) => v.fold_object_pat_prop(n),
        }
    }
    fn fold_object_pat_props(&mut self, n: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        match self {
            global_visit::Either::Left(v) => v.fold_object_pat_props(n),
            global_visit::Either::Right(v) => v.fold_object_pat_props(n),
        }
    }
    fn fold_opt_accessibility(&mut self, n: Option<Accessibility>) -> Option<Accessibility> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_accessibility(n),
            global_visit::Either::Right(v) => v.fold_opt_accessibility(n),
        }
    }
    fn fold_opt_block_stmt(&mut self, n: Option<BlockStmt>) -> Option<BlockStmt> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_block_stmt(n),
            global_visit::Either::Right(v) => v.fold_opt_block_stmt(n),
        }
    }
    fn fold_opt_catch_clause(&mut self, n: Option<CatchClause>) -> Option<CatchClause> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_catch_clause(n),
            global_visit::Either::Right(v) => v.fold_opt_catch_clause(n),
        }
    }
    fn fold_opt_chain_expr(&mut self, n: OptChainExpr) -> OptChainExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_chain_expr(n),
            global_visit::Either::Right(v) => v.fold_opt_chain_expr(n),
        }
    }
    fn fold_opt_expr(&mut self, n: Option<Box<Expr>>) -> Option<Box<Expr>> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_expr(n),
            global_visit::Either::Right(v) => v.fold_opt_expr(n),
        }
    }
    fn fold_opt_expr_or_spread(&mut self, n: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_expr_or_spread(n),
            global_visit::Either::Right(v) => v.fold_opt_expr_or_spread(n),
        }
    }
    fn fold_opt_expr_or_spreads(
        &mut self,
        n: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_expr_or_spreads(n),
            global_visit::Either::Right(v) => v.fold_opt_expr_or_spreads(n),
        }
    }
    fn fold_opt_ident(&mut self, n: Option<Ident>) -> Option<Ident> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_ident(n),
            global_visit::Either::Right(v) => v.fold_opt_ident(n),
        }
    }
    fn fold_opt_js_word(&mut self, n: Option<JsWord>) -> Option<JsWord> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_js_word(n),
            global_visit::Either::Right(v) => v.fold_opt_js_word(n),
        }
    }
    fn fold_opt_jsx_attr_value(&mut self, n: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_jsx_attr_value(n),
            global_visit::Either::Right(v) => v.fold_opt_jsx_attr_value(n),
        }
    }
    fn fold_opt_jsx_closing_element(
        &mut self,
        n: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_jsx_closing_element(n),
            global_visit::Either::Right(v) => v.fold_opt_jsx_closing_element(n),
        }
    }
    fn fold_opt_object_lit(&mut self, n: Option<ObjectLit>) -> Option<ObjectLit> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_object_lit(n),
            global_visit::Either::Right(v) => v.fold_opt_object_lit(n),
        }
    }
    fn fold_opt_pat(&mut self, n: Option<Pat>) -> Option<Pat> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_pat(n),
            global_visit::Either::Right(v) => v.fold_opt_pat(n),
        }
    }
    fn fold_opt_span(&mut self, n: Option<Span>) -> Option<Span> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_span(n),
            global_visit::Either::Right(v) => v.fold_opt_span(n),
        }
    }
    fn fold_opt_stmt(&mut self, n: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_stmt(n),
            global_visit::Either::Right(v) => v.fold_opt_stmt(n),
        }
    }
    fn fold_opt_str(&mut self, n: Option<Str>) -> Option<Str> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_str(n),
            global_visit::Either::Right(v) => v.fold_opt_str(n),
        }
    }
    fn fold_opt_true_plus_minus(&mut self, n: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_true_plus_minus(n),
            global_visit::Either::Right(v) => v.fold_opt_true_plus_minus(n),
        }
    }
    fn fold_opt_ts_entity_name(&mut self, n: Option<TsEntityName>) -> Option<TsEntityName> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_ts_entity_name(n),
            global_visit::Either::Right(v) => v.fold_opt_ts_entity_name(n),
        }
    }
    fn fold_opt_ts_namespace_body(
        &mut self,
        n: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_ts_namespace_body(n),
            global_visit::Either::Right(v) => v.fold_opt_ts_namespace_body(n),
        }
    }
    fn fold_opt_ts_type(&mut self, n: Option<Box<TsType>>) -> Option<Box<TsType>> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_ts_type(n),
            global_visit::Either::Right(v) => v.fold_opt_ts_type(n),
        }
    }
    fn fold_opt_ts_type_ann(&mut self, n: Option<TsTypeAnn>) -> Option<TsTypeAnn> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_ts_type_ann(n),
            global_visit::Either::Right(v) => v.fold_opt_ts_type_ann(n),
        }
    }
    fn fold_opt_ts_type_param_decl(
        &mut self,
        n: Option<TsTypeParamDecl>,
    ) -> Option<TsTypeParamDecl> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_ts_type_param_decl(n),
            global_visit::Either::Right(v) => v.fold_opt_ts_type_param_decl(n),
        }
    }
    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        n: Option<TsTypeParamInstantiation>,
    ) -> Option<TsTypeParamInstantiation> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_ts_type_param_instantiation(n),
            global_visit::Either::Right(v) => v.fold_opt_ts_type_param_instantiation(n),
        }
    }
    fn fold_opt_var_decl_or_expr(&mut self, n: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_var_decl_or_expr(n),
            global_visit::Either::Right(v) => v.fold_opt_var_decl_or_expr(n),
        }
    }
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        n: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_vec_expr_or_spreads(n),
            global_visit::Either::Right(v) => v.fold_opt_vec_expr_or_spreads(n),
        }
    }
    fn fold_opt_vec_pats(&mut self, n: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        match self {
            global_visit::Either::Left(v) => v.fold_opt_vec_pats(n),
            global_visit::Either::Right(v) => v.fold_opt_vec_pats(n),
        }
    }
    fn fold_param(&mut self, n: Param) -> Param {
        match self {
            global_visit::Either::Left(v) => v.fold_param(n),
            global_visit::Either::Right(v) => v.fold_param(n),
        }
    }
    fn fold_param_or_ts_param_prop(&mut self, n: ParamOrTsParamProp) -> ParamOrTsParamProp {
        match self {
            global_visit::Either::Left(v) => v.fold_param_or_ts_param_prop(n),
            global_visit::Either::Right(v) => v.fold_param_or_ts_param_prop(n),
        }
    }
    fn fold_param_or_ts_param_props(
        &mut self,
        n: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        match self {
            global_visit::Either::Left(v) => v.fold_param_or_ts_param_props(n),
            global_visit::Either::Right(v) => v.fold_param_or_ts_param_props(n),
        }
    }
    fn fold_params(&mut self, n: Vec<Param>) -> Vec<Param> {
        match self {
            global_visit::Either::Left(v) => v.fold_params(n),
            global_visit::Either::Right(v) => v.fold_params(n),
        }
    }
    fn fold_paren_expr(&mut self, n: ParenExpr) -> ParenExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_paren_expr(n),
            global_visit::Either::Right(v) => v.fold_paren_expr(n),
        }
    }
    fn fold_pat(&mut self, n: Pat) -> Pat {
        match self {
            global_visit::Either::Left(v) => v.fold_pat(n),
            global_visit::Either::Right(v) => v.fold_pat(n),
        }
    }
    fn fold_pat_or_expr(&mut self, n: PatOrExpr) -> PatOrExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_pat_or_expr(n),
            global_visit::Either::Right(v) => v.fold_pat_or_expr(n),
        }
    }
    fn fold_pats(&mut self, n: Vec<Pat>) -> Vec<Pat> {
        match self {
            global_visit::Either::Left(v) => v.fold_pats(n),
            global_visit::Either::Right(v) => v.fold_pats(n),
        }
    }
    fn fold_private_method(&mut self, n: PrivateMethod) -> PrivateMethod {
        match self {
            global_visit::Either::Left(v) => v.fold_private_method(n),
            global_visit::Either::Right(v) => v.fold_private_method(n),
        }
    }
    fn fold_private_name(&mut self, n: PrivateName) -> PrivateName {
        match self {
            global_visit::Either::Left(v) => v.fold_private_name(n),
            global_visit::Either::Right(v) => v.fold_private_name(n),
        }
    }
    fn fold_private_prop(&mut self, n: PrivateProp) -> PrivateProp {
        match self {
            global_visit::Either::Left(v) => v.fold_private_prop(n),
            global_visit::Either::Right(v) => v.fold_private_prop(n),
        }
    }
    fn fold_program(&mut self, n: Program) -> Program {
        match self {
            global_visit::Either::Left(v) => v.fold_program(n),
            global_visit::Either::Right(v) => v.fold_program(n),
        }
    }
    fn fold_prop(&mut self, n: Prop) -> Prop {
        match self {
            global_visit::Either::Left(v) => v.fold_prop(n),
            global_visit::Either::Right(v) => v.fold_prop(n),
        }
    }
    fn fold_prop_name(&mut self, n: PropName) -> PropName {
        match self {
            global_visit::Either::Left(v) => v.fold_prop_name(n),
            global_visit::Either::Right(v) => v.fold_prop_name(n),
        }
    }
    fn fold_prop_or_spread(&mut self, n: PropOrSpread) -> PropOrSpread {
        match self {
            global_visit::Either::Left(v) => v.fold_prop_or_spread(n),
            global_visit::Either::Right(v) => v.fold_prop_or_spread(n),
        }
    }
    fn fold_prop_or_spreads(&mut self, n: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        match self {
            global_visit::Either::Left(v) => v.fold_prop_or_spreads(n),
            global_visit::Either::Right(v) => v.fold_prop_or_spreads(n),
        }
    }
    fn fold_regex(&mut self, n: Regex) -> Regex {
        match self {
            global_visit::Either::Left(v) => v.fold_regex(n),
            global_visit::Either::Right(v) => v.fold_regex(n),
        }
    }
    fn fold_rest_pat(&mut self, n: RestPat) -> RestPat {
        match self {
            global_visit::Either::Left(v) => v.fold_rest_pat(n),
            global_visit::Either::Right(v) => v.fold_rest_pat(n),
        }
    }
    fn fold_return_stmt(&mut self, n: ReturnStmt) -> ReturnStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_return_stmt(n),
            global_visit::Either::Right(v) => v.fold_return_stmt(n),
        }
    }
    fn fold_script(&mut self, n: Script) -> Script {
        match self {
            global_visit::Either::Left(v) => v.fold_script(n),
            global_visit::Either::Right(v) => v.fold_script(n),
        }
    }
    fn fold_seq_expr(&mut self, n: SeqExpr) -> SeqExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_seq_expr(n),
            global_visit::Either::Right(v) => v.fold_seq_expr(n),
        }
    }
    fn fold_setter_prop(&mut self, n: SetterProp) -> SetterProp {
        match self {
            global_visit::Either::Left(v) => v.fold_setter_prop(n),
            global_visit::Either::Right(v) => v.fold_setter_prop(n),
        }
    }
    fn fold_span(&mut self, n: Span) -> Span {
        match self {
            global_visit::Either::Left(v) => v.fold_span(n),
            global_visit::Either::Right(v) => v.fold_span(n),
        }
    }
    fn fold_spread_element(&mut self, n: SpreadElement) -> SpreadElement {
        match self {
            global_visit::Either::Left(v) => v.fold_spread_element(n),
            global_visit::Either::Right(v) => v.fold_spread_element(n),
        }
    }
    fn fold_stmt(&mut self, n: Stmt) -> Stmt {
        match self {
            global_visit::Either::Left(v) => v.fold_stmt(n),
            global_visit::Either::Right(v) => v.fold_stmt(n),
        }
    }
    fn fold_stmts(&mut self, n: Vec<Stmt>) -> Vec<Stmt> {
        match self {
            global_visit::Either::Left(v) => v.fold_stmts(n),
            global_visit::Either::Right(v) => v.fold_stmts(n),
        }
    }
    fn fold_str(&mut self, n: Str) -> Str {
        match self {
            global_visit::Either::Left(v) => v.fold_str(n),
            global_visit::Either::Right(v) => v.fold_str(n),
        }
    }
    fn fold_str_kind(&mut self, n: StrKind) -> StrKind {
        match self {
            global_visit::Either::Left(v) => v.fold_str_kind(n),
            global_visit::Either::Right(v) => v.fold_str_kind(n),
        }
    }
    fn fold_super(&mut self, n: Super) -> Super {
        match self {
            global_visit::Either::Left(v) => v.fold_super(n),
            global_visit::Either::Right(v) => v.fold_super(n),
        }
    }
    fn fold_switch_case(&mut self, n: SwitchCase) -> SwitchCase {
        match self {
            global_visit::Either::Left(v) => v.fold_switch_case(n),
            global_visit::Either::Right(v) => v.fold_switch_case(n),
        }
    }
    fn fold_switch_cases(&mut self, n: Vec<SwitchCase>) -> Vec<SwitchCase> {
        match self {
            global_visit::Either::Left(v) => v.fold_switch_cases(n),
            global_visit::Either::Right(v) => v.fold_switch_cases(n),
        }
    }
    fn fold_switch_stmt(&mut self, n: SwitchStmt) -> SwitchStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_switch_stmt(n),
            global_visit::Either::Right(v) => v.fold_switch_stmt(n),
        }
    }
    fn fold_tagged_tpl(&mut self, n: TaggedTpl) -> TaggedTpl {
        match self {
            global_visit::Either::Left(v) => v.fold_tagged_tpl(n),
            global_visit::Either::Right(v) => v.fold_tagged_tpl(n),
        }
    }
    fn fold_this_expr(&mut self, n: ThisExpr) -> ThisExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_this_expr(n),
            global_visit::Either::Right(v) => v.fold_this_expr(n),
        }
    }
    fn fold_throw_stmt(&mut self, n: ThrowStmt) -> ThrowStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_throw_stmt(n),
            global_visit::Either::Right(v) => v.fold_throw_stmt(n),
        }
    }
    fn fold_tpl(&mut self, n: Tpl) -> Tpl {
        match self {
            global_visit::Either::Left(v) => v.fold_tpl(n),
            global_visit::Either::Right(v) => v.fold_tpl(n),
        }
    }
    fn fold_tpl_element(&mut self, n: TplElement) -> TplElement {
        match self {
            global_visit::Either::Left(v) => v.fold_tpl_element(n),
            global_visit::Either::Right(v) => v.fold_tpl_element(n),
        }
    }
    fn fold_tpl_elements(&mut self, n: Vec<TplElement>) -> Vec<TplElement> {
        match self {
            global_visit::Either::Left(v) => v.fold_tpl_elements(n),
            global_visit::Either::Right(v) => v.fold_tpl_elements(n),
        }
    }
    fn fold_true_plus_minus(&mut self, n: TruePlusMinus) -> TruePlusMinus {
        match self {
            global_visit::Either::Left(v) => v.fold_true_plus_minus(n),
            global_visit::Either::Right(v) => v.fold_true_plus_minus(n),
        }
    }
    fn fold_try_stmt(&mut self, n: TryStmt) -> TryStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_try_stmt(n),
            global_visit::Either::Right(v) => v.fold_try_stmt(n),
        }
    }
    fn fold_ts_array_type(&mut self, n: TsArrayType) -> TsArrayType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_array_type(n),
            global_visit::Either::Right(v) => v.fold_ts_array_type(n),
        }
    }
    fn fold_ts_as_expr(&mut self, n: TsAsExpr) -> TsAsExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_as_expr(n),
            global_visit::Either::Right(v) => v.fold_ts_as_expr(n),
        }
    }
    fn fold_ts_call_signature_decl(&mut self, n: TsCallSignatureDecl) -> TsCallSignatureDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_call_signature_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_call_signature_decl(n),
        }
    }
    fn fold_ts_conditional_type(&mut self, n: TsConditionalType) -> TsConditionalType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_conditional_type(n),
            global_visit::Either::Right(v) => v.fold_ts_conditional_type(n),
        }
    }
    fn fold_ts_const_assertion(&mut self, n: TsConstAssertion) -> TsConstAssertion {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_const_assertion(n),
            global_visit::Either::Right(v) => v.fold_ts_const_assertion(n),
        }
    }
    fn fold_ts_construct_signature_decl(
        &mut self,
        n: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_construct_signature_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_construct_signature_decl(n),
        }
    }
    fn fold_ts_constructor_type(&mut self, n: TsConstructorType) -> TsConstructorType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_constructor_type(n),
            global_visit::Either::Right(v) => v.fold_ts_constructor_type(n),
        }
    }
    fn fold_ts_entity_name(&mut self, n: TsEntityName) -> TsEntityName {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_entity_name(n),
            global_visit::Either::Right(v) => v.fold_ts_entity_name(n),
        }
    }
    fn fold_ts_enum_decl(&mut self, n: TsEnumDecl) -> TsEnumDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_enum_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_enum_decl(n),
        }
    }
    fn fold_ts_enum_member(&mut self, n: TsEnumMember) -> TsEnumMember {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_enum_member(n),
            global_visit::Either::Right(v) => v.fold_ts_enum_member(n),
        }
    }
    fn fold_ts_enum_member_id(&mut self, n: TsEnumMemberId) -> TsEnumMemberId {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_enum_member_id(n),
            global_visit::Either::Right(v) => v.fold_ts_enum_member_id(n),
        }
    }
    fn fold_ts_enum_members(&mut self, n: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_enum_members(n),
            global_visit::Either::Right(v) => v.fold_ts_enum_members(n),
        }
    }
    fn fold_ts_export_assignment(&mut self, n: TsExportAssignment) -> TsExportAssignment {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_export_assignment(n),
            global_visit::Either::Right(v) => v.fold_ts_export_assignment(n),
        }
    }
    fn fold_ts_expr_with_type_args(&mut self, n: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_expr_with_type_args(n),
            global_visit::Either::Right(v) => v.fold_ts_expr_with_type_args(n),
        }
    }
    fn fold_ts_expr_with_type_args_vec(
        &mut self,
        n: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_expr_with_type_args_vec(n),
            global_visit::Either::Right(v) => v.fold_ts_expr_with_type_args_vec(n),
        }
    }
    fn fold_ts_external_module_ref(&mut self, n: TsExternalModuleRef) -> TsExternalModuleRef {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_external_module_ref(n),
            global_visit::Either::Right(v) => v.fold_ts_external_module_ref(n),
        }
    }
    fn fold_ts_fn_or_constructor_type(
        &mut self,
        n: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_fn_or_constructor_type(n),
            global_visit::Either::Right(v) => v.fold_ts_fn_or_constructor_type(n),
        }
    }
    fn fold_ts_fn_param(&mut self, n: TsFnParam) -> TsFnParam {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_fn_param(n),
            global_visit::Either::Right(v) => v.fold_ts_fn_param(n),
        }
    }
    fn fold_ts_fn_params(&mut self, n: Vec<TsFnParam>) -> Vec<TsFnParam> {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_fn_params(n),
            global_visit::Either::Right(v) => v.fold_ts_fn_params(n),
        }
    }
    fn fold_ts_fn_type(&mut self, n: TsFnType) -> TsFnType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_fn_type(n),
            global_visit::Either::Right(v) => v.fold_ts_fn_type(n),
        }
    }
    fn fold_ts_getter_signature(&mut self, n: TsGetterSignature) -> TsGetterSignature {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_getter_signature(n),
            global_visit::Either::Right(v) => v.fold_ts_getter_signature(n),
        }
    }
    fn fold_ts_import_equals_decl(&mut self, n: TsImportEqualsDecl) -> TsImportEqualsDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_import_equals_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_import_equals_decl(n),
        }
    }
    fn fold_ts_import_type(&mut self, n: TsImportType) -> TsImportType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_import_type(n),
            global_visit::Either::Right(v) => v.fold_ts_import_type(n),
        }
    }
    fn fold_ts_index_signature(&mut self, n: TsIndexSignature) -> TsIndexSignature {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_index_signature(n),
            global_visit::Either::Right(v) => v.fold_ts_index_signature(n),
        }
    }
    fn fold_ts_indexed_access_type(&mut self, n: TsIndexedAccessType) -> TsIndexedAccessType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_indexed_access_type(n),
            global_visit::Either::Right(v) => v.fold_ts_indexed_access_type(n),
        }
    }
    fn fold_ts_infer_type(&mut self, n: TsInferType) -> TsInferType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_infer_type(n),
            global_visit::Either::Right(v) => v.fold_ts_infer_type(n),
        }
    }
    fn fold_ts_interface_body(&mut self, n: TsInterfaceBody) -> TsInterfaceBody {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_interface_body(n),
            global_visit::Either::Right(v) => v.fold_ts_interface_body(n),
        }
    }
    fn fold_ts_interface_decl(&mut self, n: TsInterfaceDecl) -> TsInterfaceDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_interface_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_interface_decl(n),
        }
    }
    fn fold_ts_intersection_type(&mut self, n: TsIntersectionType) -> TsIntersectionType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_intersection_type(n),
            global_visit::Either::Right(v) => v.fold_ts_intersection_type(n),
        }
    }
    fn fold_ts_keyword_type(&mut self, n: TsKeywordType) -> TsKeywordType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_keyword_type(n),
            global_visit::Either::Right(v) => v.fold_ts_keyword_type(n),
        }
    }
    fn fold_ts_keyword_type_kind(&mut self, n: TsKeywordTypeKind) -> TsKeywordTypeKind {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_keyword_type_kind(n),
            global_visit::Either::Right(v) => v.fold_ts_keyword_type_kind(n),
        }
    }
    fn fold_ts_lit(&mut self, n: TsLit) -> TsLit {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_lit(n),
            global_visit::Either::Right(v) => v.fold_ts_lit(n),
        }
    }
    fn fold_ts_lit_type(&mut self, n: TsLitType) -> TsLitType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_lit_type(n),
            global_visit::Either::Right(v) => v.fold_ts_lit_type(n),
        }
    }
    fn fold_ts_mapped_type(&mut self, n: TsMappedType) -> TsMappedType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_mapped_type(n),
            global_visit::Either::Right(v) => v.fold_ts_mapped_type(n),
        }
    }
    fn fold_ts_method_signature(&mut self, n: TsMethodSignature) -> TsMethodSignature {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_method_signature(n),
            global_visit::Either::Right(v) => v.fold_ts_method_signature(n),
        }
    }
    fn fold_ts_module_block(&mut self, n: TsModuleBlock) -> TsModuleBlock {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_module_block(n),
            global_visit::Either::Right(v) => v.fold_ts_module_block(n),
        }
    }
    fn fold_ts_module_decl(&mut self, n: TsModuleDecl) -> TsModuleDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_module_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_module_decl(n),
        }
    }
    fn fold_ts_module_name(&mut self, n: TsModuleName) -> TsModuleName {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_module_name(n),
            global_visit::Either::Right(v) => v.fold_ts_module_name(n),
        }
    }
    fn fold_ts_module_ref(&mut self, n: TsModuleRef) -> TsModuleRef {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_module_ref(n),
            global_visit::Either::Right(v) => v.fold_ts_module_ref(n),
        }
    }
    fn fold_ts_namespace_body(&mut self, n: TsNamespaceBody) -> TsNamespaceBody {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_namespace_body(n),
            global_visit::Either::Right(v) => v.fold_ts_namespace_body(n),
        }
    }
    fn fold_ts_namespace_decl(&mut self, n: TsNamespaceDecl) -> TsNamespaceDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_namespace_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_namespace_decl(n),
        }
    }
    fn fold_ts_namespace_export_decl(&mut self, n: TsNamespaceExportDecl) -> TsNamespaceExportDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_namespace_export_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_namespace_export_decl(n),
        }
    }
    fn fold_ts_non_null_expr(&mut self, n: TsNonNullExpr) -> TsNonNullExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_non_null_expr(n),
            global_visit::Either::Right(v) => v.fold_ts_non_null_expr(n),
        }
    }
    fn fold_ts_optional_type(&mut self, n: TsOptionalType) -> TsOptionalType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_optional_type(n),
            global_visit::Either::Right(v) => v.fold_ts_optional_type(n),
        }
    }
    fn fold_ts_param_prop(&mut self, n: TsParamProp) -> TsParamProp {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_param_prop(n),
            global_visit::Either::Right(v) => v.fold_ts_param_prop(n),
        }
    }
    fn fold_ts_param_prop_param(&mut self, n: TsParamPropParam) -> TsParamPropParam {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_param_prop_param(n),
            global_visit::Either::Right(v) => v.fold_ts_param_prop_param(n),
        }
    }
    fn fold_ts_parenthesized_type(&mut self, n: TsParenthesizedType) -> TsParenthesizedType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_parenthesized_type(n),
            global_visit::Either::Right(v) => v.fold_ts_parenthesized_type(n),
        }
    }
    fn fold_ts_property_signature(&mut self, n: TsPropertySignature) -> TsPropertySignature {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_property_signature(n),
            global_visit::Either::Right(v) => v.fold_ts_property_signature(n),
        }
    }
    fn fold_ts_qualified_name(&mut self, n: TsQualifiedName) -> TsQualifiedName {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_qualified_name(n),
            global_visit::Either::Right(v) => v.fold_ts_qualified_name(n),
        }
    }
    fn fold_ts_rest_type(&mut self, n: TsRestType) -> TsRestType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_rest_type(n),
            global_visit::Either::Right(v) => v.fold_ts_rest_type(n),
        }
    }
    fn fold_ts_setter_signature(&mut self, n: TsSetterSignature) -> TsSetterSignature {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_setter_signature(n),
            global_visit::Either::Right(v) => v.fold_ts_setter_signature(n),
        }
    }
    fn fold_ts_this_type(&mut self, n: TsThisType) -> TsThisType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_this_type(n),
            global_visit::Either::Right(v) => v.fold_ts_this_type(n),
        }
    }
    fn fold_ts_this_type_or_ident(&mut self, n: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_this_type_or_ident(n),
            global_visit::Either::Right(v) => v.fold_ts_this_type_or_ident(n),
        }
    }
    fn fold_ts_tpl_lit_type(&mut self, n: TsTplLitType) -> TsTplLitType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_tpl_lit_type(n),
            global_visit::Either::Right(v) => v.fold_ts_tpl_lit_type(n),
        }
    }
    fn fold_ts_tuple_element(&mut self, n: TsTupleElement) -> TsTupleElement {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_tuple_element(n),
            global_visit::Either::Right(v) => v.fold_ts_tuple_element(n),
        }
    }
    fn fold_ts_tuple_elements(&mut self, n: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_tuple_elements(n),
            global_visit::Either::Right(v) => v.fold_ts_tuple_elements(n),
        }
    }
    fn fold_ts_tuple_type(&mut self, n: TsTupleType) -> TsTupleType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_tuple_type(n),
            global_visit::Either::Right(v) => v.fold_ts_tuple_type(n),
        }
    }
    fn fold_ts_type(&mut self, n: TsType) -> TsType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type(n),
            global_visit::Either::Right(v) => v.fold_ts_type(n),
        }
    }
    fn fold_ts_type_alias_decl(&mut self, n: TsTypeAliasDecl) -> TsTypeAliasDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_alias_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_type_alias_decl(n),
        }
    }
    fn fold_ts_type_ann(&mut self, n: TsTypeAnn) -> TsTypeAnn {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_ann(n),
            global_visit::Either::Right(v) => v.fold_ts_type_ann(n),
        }
    }
    fn fold_ts_type_assertion(&mut self, n: TsTypeAssertion) -> TsTypeAssertion {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_assertion(n),
            global_visit::Either::Right(v) => v.fold_ts_type_assertion(n),
        }
    }
    fn fold_ts_type_element(&mut self, n: TsTypeElement) -> TsTypeElement {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_element(n),
            global_visit::Either::Right(v) => v.fold_ts_type_element(n),
        }
    }
    fn fold_ts_type_elements(&mut self, n: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_elements(n),
            global_visit::Either::Right(v) => v.fold_ts_type_elements(n),
        }
    }
    fn fold_ts_type_lit(&mut self, n: TsTypeLit) -> TsTypeLit {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_lit(n),
            global_visit::Either::Right(v) => v.fold_ts_type_lit(n),
        }
    }
    fn fold_ts_type_operator(&mut self, n: TsTypeOperator) -> TsTypeOperator {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_operator(n),
            global_visit::Either::Right(v) => v.fold_ts_type_operator(n),
        }
    }
    fn fold_ts_type_operator_op(&mut self, n: TsTypeOperatorOp) -> TsTypeOperatorOp {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_operator_op(n),
            global_visit::Either::Right(v) => v.fold_ts_type_operator_op(n),
        }
    }
    fn fold_ts_type_param(&mut self, n: TsTypeParam) -> TsTypeParam {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_param(n),
            global_visit::Either::Right(v) => v.fold_ts_type_param(n),
        }
    }
    fn fold_ts_type_param_decl(&mut self, n: TsTypeParamDecl) -> TsTypeParamDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_param_decl(n),
            global_visit::Either::Right(v) => v.fold_ts_type_param_decl(n),
        }
    }
    fn fold_ts_type_param_instantiation(
        &mut self,
        n: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_param_instantiation(n),
            global_visit::Either::Right(v) => v.fold_ts_type_param_instantiation(n),
        }
    }
    fn fold_ts_type_params(&mut self, n: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_params(n),
            global_visit::Either::Right(v) => v.fold_ts_type_params(n),
        }
    }
    fn fold_ts_type_predicate(&mut self, n: TsTypePredicate) -> TsTypePredicate {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_predicate(n),
            global_visit::Either::Right(v) => v.fold_ts_type_predicate(n),
        }
    }
    fn fold_ts_type_query(&mut self, n: TsTypeQuery) -> TsTypeQuery {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_query(n),
            global_visit::Either::Right(v) => v.fold_ts_type_query(n),
        }
    }
    fn fold_ts_type_query_expr(&mut self, n: TsTypeQueryExpr) -> TsTypeQueryExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_query_expr(n),
            global_visit::Either::Right(v) => v.fold_ts_type_query_expr(n),
        }
    }
    fn fold_ts_type_ref(&mut self, n: TsTypeRef) -> TsTypeRef {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_type_ref(n),
            global_visit::Either::Right(v) => v.fold_ts_type_ref(n),
        }
    }
    fn fold_ts_types(&mut self, n: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_types(n),
            global_visit::Either::Right(v) => v.fold_ts_types(n),
        }
    }
    fn fold_ts_union_or_intersection_type(
        &mut self,
        n: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_union_or_intersection_type(n),
            global_visit::Either::Right(v) => v.fold_ts_union_or_intersection_type(n),
        }
    }
    fn fold_ts_union_type(&mut self, n: TsUnionType) -> TsUnionType {
        match self {
            global_visit::Either::Left(v) => v.fold_ts_union_type(n),
            global_visit::Either::Right(v) => v.fold_ts_union_type(n),
        }
    }
    fn fold_unary_expr(&mut self, n: UnaryExpr) -> UnaryExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_unary_expr(n),
            global_visit::Either::Right(v) => v.fold_unary_expr(n),
        }
    }
    fn fold_unary_op(&mut self, n: UnaryOp) -> UnaryOp {
        match self {
            global_visit::Either::Left(v) => v.fold_unary_op(n),
            global_visit::Either::Right(v) => v.fold_unary_op(n),
        }
    }
    fn fold_update_expr(&mut self, n: UpdateExpr) -> UpdateExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_update_expr(n),
            global_visit::Either::Right(v) => v.fold_update_expr(n),
        }
    }
    fn fold_update_op(&mut self, n: UpdateOp) -> UpdateOp {
        match self {
            global_visit::Either::Left(v) => v.fold_update_op(n),
            global_visit::Either::Right(v) => v.fold_update_op(n),
        }
    }
    fn fold_var_decl(&mut self, n: VarDecl) -> VarDecl {
        match self {
            global_visit::Either::Left(v) => v.fold_var_decl(n),
            global_visit::Either::Right(v) => v.fold_var_decl(n),
        }
    }
    fn fold_var_decl_kind(&mut self, n: VarDeclKind) -> VarDeclKind {
        match self {
            global_visit::Either::Left(v) => v.fold_var_decl_kind(n),
            global_visit::Either::Right(v) => v.fold_var_decl_kind(n),
        }
    }
    fn fold_var_decl_or_expr(&mut self, n: VarDeclOrExpr) -> VarDeclOrExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_var_decl_or_expr(n),
            global_visit::Either::Right(v) => v.fold_var_decl_or_expr(n),
        }
    }
    fn fold_var_decl_or_pat(&mut self, n: VarDeclOrPat) -> VarDeclOrPat {
        match self {
            global_visit::Either::Left(v) => v.fold_var_decl_or_pat(n),
            global_visit::Either::Right(v) => v.fold_var_decl_or_pat(n),
        }
    }
    fn fold_var_declarator(&mut self, n: VarDeclarator) -> VarDeclarator {
        match self {
            global_visit::Either::Left(v) => v.fold_var_declarator(n),
            global_visit::Either::Right(v) => v.fold_var_declarator(n),
        }
    }
    fn fold_var_declarators(&mut self, n: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        match self {
            global_visit::Either::Left(v) => v.fold_var_declarators(n),
            global_visit::Either::Right(v) => v.fold_var_declarators(n),
        }
    }
    fn fold_while_stmt(&mut self, n: WhileStmt) -> WhileStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_while_stmt(n),
            global_visit::Either::Right(v) => v.fold_while_stmt(n),
        }
    }
    fn fold_with_stmt(&mut self, n: WithStmt) -> WithStmt {
        match self {
            global_visit::Either::Left(v) => v.fold_with_stmt(n),
            global_visit::Either::Right(v) => v.fold_with_stmt(n),
        }
    }
    fn fold_yield_expr(&mut self, n: YieldExpr) -> YieldExpr {
        match self {
            global_visit::Either::Left(v) => v.fold_yield_expr(n),
            global_visit::Either::Right(v) => v.fold_yield_expr(n),
        }
    }
}
pub trait FoldWith<V: Fold> {
    fn fold_with(self, v: &mut V) -> Self;
    /// Visit children nodes of self with `v`
    fn fold_children_with(self, v: &mut V) -> Self;
}
impl<V, T> FoldWith<V> for Box<T>
where
    V: Fold,
    T: 'static + FoldWith<V>,
{
    fn fold_with(self, v: &mut V) -> Self {
        global_visit::util::map::Map::map(self, |value| value.fold_with(v))
    }
    /// Visit children nodes of self with `v`
    fn fold_children_with(self, v: &mut V) -> Self {
        global_visit::util::map::Map::map(self, |value| value.fold_children_with(v))
    }
}
impl<V: Fold> FoldWith<V> for Accessibility {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_accessibility(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_accessibility(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ArrayLit {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_array_lit(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_array_lit(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ArrayPat {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_array_pat(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_array_pat(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ArrowExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_arrow_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_arrow_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for AssignExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_assign_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_assign_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for AssignOp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_assign_op(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_assign_op(v, self)
    }
}
impl<V: Fold> FoldWith<V> for AssignPat {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_assign_pat(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_assign_pat(v, self)
    }
}
impl<V: Fold> FoldWith<V> for AssignPatProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_assign_pat_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_assign_pat_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for AssignProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_assign_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_assign_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for AwaitExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_await_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_await_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for BigInt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_big_int(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_big_int(v, self)
    }
}
impl<V: Fold> FoldWith<V> for BigIntValue {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_big_int_value(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_big_int_value(v, self)
    }
}
impl<V: Fold> FoldWith<V> for BinExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_bin_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_bin_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for BinaryOp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_binary_op(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_binary_op(v, self)
    }
}
impl<V: Fold> FoldWith<V> for BindingIdent {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_binding_ident(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_binding_ident(v, self)
    }
}
impl<V: Fold> FoldWith<V> for BlockStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_block_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_block_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for BlockStmtOrExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_block_stmt_or_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_block_stmt_or_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Bool {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_bool(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_bool(v, self)
    }
}
impl<V: Fold> FoldWith<V> for BreakStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_break_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_break_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for CallExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_call_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_call_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for CatchClause {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_catch_clause(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_catch_clause(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Class {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_class(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_class(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ClassDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_class_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_class_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ClassExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_class_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_class_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ClassMember {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_class_member(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_class_member(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<ClassMember> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_class_members(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_class_members(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ClassMethod {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_class_method(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_class_method(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ClassProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_class_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_class_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ComputedPropName {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_computed_prop_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_computed_prop_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for CondExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_cond_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_cond_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Constructor {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_constructor(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_constructor(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ContinueStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_continue_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_continue_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for DebuggerStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_debugger_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_debugger_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Decl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Decorator {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_decorator(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_decorator(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<Decorator> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_decorators(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_decorators(v, self)
    }
}
impl<V: Fold> FoldWith<V> for DefaultDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_default_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_default_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for DoWhileStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_do_while_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_do_while_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for EmptyStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_empty_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_empty_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExportAll {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_export_all(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_export_all(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExportDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_export_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_export_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExportDefaultDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_export_default_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_export_default_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExportDefaultExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_export_default_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_export_default_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExportDefaultSpecifier {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_export_default_specifier(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_export_default_specifier(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExportNamedSpecifier {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_export_named_specifier(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_export_named_specifier(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExportNamespaceSpecifier {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_export_namespace_specifier(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_export_namespace_specifier(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExportSpecifier {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_export_specifier(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_export_specifier(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<ExportSpecifier> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_export_specifiers(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_export_specifiers(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Expr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExprOrSpread {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_expr_or_spread(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_expr_or_spread(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<ExprOrSpread> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_expr_or_spreads(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_expr_or_spreads(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExprOrSuper {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_expr_or_super(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_expr_or_super(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ExprStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_expr_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_expr_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<Box<Expr>> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_exprs(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_exprs(v, self)
    }
}
impl<V: Fold> FoldWith<V> for FnDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_fn_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_fn_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for FnExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_fn_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_fn_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ForInStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_for_in_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_for_in_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ForOfStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_for_of_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_for_of_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ForStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_for_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_for_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Function {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_function(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_function(v, self)
    }
}
impl<V: Fold> FoldWith<V> for GetterProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_getter_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_getter_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Ident {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ident(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ident(v, self)
    }
}
impl<V: Fold> FoldWith<V> for IfStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_if_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_if_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ImportDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_import_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_import_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ImportDefaultSpecifier {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_import_default_specifier(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_import_default_specifier(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ImportNamedSpecifier {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_import_named_specifier(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_import_named_specifier(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ImportSpecifier {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_import_specifier(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_import_specifier(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<ImportSpecifier> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_import_specifiers(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_import_specifiers(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ImportStarAsSpecifier {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_import_star_as_specifier(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_import_star_as_specifier(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Invalid {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_invalid(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_invalid(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JsWord {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_js_word(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_js_word(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXAttr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_attr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_attr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXAttrName {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_attr_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_attr_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXAttrOrSpread {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_attr_or_spread(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_attr_or_spread(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<JSXAttrOrSpread> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_attr_or_spreads(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_attr_or_spreads(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXAttrValue {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_attr_value(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_attr_value(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXClosingElement {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_closing_element(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_closing_element(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXClosingFragment {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_closing_fragment(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_closing_fragment(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXElement {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_element(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_element(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXElementChild {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_element_child(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_element_child(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<JSXElementChild> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_element_children(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_element_children(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXElementName {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_element_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_element_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXEmptyExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_empty_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_empty_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXExprContainer {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_expr_container(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_expr_container(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXFragment {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_fragment(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_fragment(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXMemberExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_member_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_member_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXNamespacedName {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_namespaced_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_namespaced_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXObject {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_object(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_object(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXOpeningElement {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_opening_element(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_opening_element(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXOpeningFragment {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_opening_fragment(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_opening_fragment(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXSpreadChild {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_spread_child(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_spread_child(v, self)
    }
}
impl<V: Fold> FoldWith<V> for JSXText {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_jsx_text(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_jsx_text(v, self)
    }
}
impl<V: Fold> FoldWith<V> for KeyValuePatProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_key_value_pat_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_key_value_pat_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for KeyValueProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_key_value_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_key_value_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for LabeledStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_labeled_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_labeled_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Lit {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_lit(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_lit(v, self)
    }
}
impl<V: Fold> FoldWith<V> for MemberExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_member_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_member_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for MetaPropExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_meta_prop_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_meta_prop_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for MethodKind {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_method_kind(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_method_kind(v, self)
    }
}
impl<V: Fold> FoldWith<V> for MethodProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_method_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_method_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Module {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_module(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_module(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ModuleDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_module_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_module_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ModuleItem {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_module_item(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_module_item(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<ModuleItem> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_module_items(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_module_items(v, self)
    }
}
impl<V: Fold> FoldWith<V> for NamedExport {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_named_export(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_named_export(v, self)
    }
}
impl<V: Fold> FoldWith<V> for NewExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_new_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_new_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Null {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_null(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_null(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Number {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_number(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_number(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ObjectLit {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_object_lit(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_object_lit(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ObjectPat {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_object_pat(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_object_pat(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ObjectPatProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_object_pat_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_object_pat_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<ObjectPatProp> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_object_pat_props(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_object_pat_props(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<Accessibility> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_accessibility(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_accessibility(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<BlockStmt> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_block_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_block_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<CatchClause> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_catch_clause(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_catch_clause(v, self)
    }
}
impl<V: Fold> FoldWith<V> for OptChainExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_chain_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_chain_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<Box<Expr>> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<ExprOrSpread> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_expr_or_spread(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_expr_or_spread(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<Vec<ExprOrSpread>> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_expr_or_spreads(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_expr_or_spreads(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<Ident> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_ident(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_ident(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<JsWord> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_js_word(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_js_word(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<JSXAttrValue> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_jsx_attr_value(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_jsx_attr_value(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<JSXClosingElement> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_jsx_closing_element(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_jsx_closing_element(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<ObjectLit> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_object_lit(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_object_lit(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<Pat> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_pat(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_pat(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<Span> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_span(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_span(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<Box<Stmt>> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<Str> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_str(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_str(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<TruePlusMinus> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_true_plus_minus(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_true_plus_minus(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<TsEntityName> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_ts_entity_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_ts_entity_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<TsNamespaceBody> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_ts_namespace_body(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_ts_namespace_body(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<Box<TsType>> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_ts_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_ts_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<TsTypeAnn> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_ts_type_ann(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_ts_type_ann(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<TsTypeParamDecl> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_ts_type_param_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_ts_type_param_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<TsTypeParamInstantiation> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_ts_type_param_instantiation(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_ts_type_param_instantiation(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Option<VarDeclOrExpr> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_var_decl_or_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_var_decl_or_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<Option<ExprOrSpread>> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_vec_expr_or_spreads(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_vec_expr_or_spreads(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<Option<Pat>> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_opt_vec_pats(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_opt_vec_pats(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Param {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_param(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_param(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ParamOrTsParamProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_param_or_ts_param_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_param_or_ts_param_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<ParamOrTsParamProp> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_param_or_ts_param_props(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_param_or_ts_param_props(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<Param> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_params(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_params(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ParenExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_paren_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_paren_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Pat {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_pat(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_pat(v, self)
    }
}
impl<V: Fold> FoldWith<V> for PatOrExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_pat_or_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_pat_or_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<Pat> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_pats(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_pats(v, self)
    }
}
impl<V: Fold> FoldWith<V> for PrivateMethod {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_private_method(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_private_method(v, self)
    }
}
impl<V: Fold> FoldWith<V> for PrivateName {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_private_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_private_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for PrivateProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_private_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_private_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Program {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_program(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_program(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Prop {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for PropName {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_prop_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_prop_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for PropOrSpread {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_prop_or_spread(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_prop_or_spread(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<PropOrSpread> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_prop_or_spreads(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_prop_or_spreads(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Regex {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_regex(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_regex(v, self)
    }
}
impl<V: Fold> FoldWith<V> for RestPat {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_rest_pat(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_rest_pat(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ReturnStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_return_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_return_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Script {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_script(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_script(v, self)
    }
}
impl<V: Fold> FoldWith<V> for SeqExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_seq_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_seq_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for SetterProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_setter_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_setter_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Span {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_span(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_span(v, self)
    }
}
impl<V: Fold> FoldWith<V> for SpreadElement {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_spread_element(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_spread_element(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Stmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<Stmt> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_stmts(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_stmts(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Str {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_str(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_str(v, self)
    }
}
impl<V: Fold> FoldWith<V> for StrKind {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_str_kind(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_str_kind(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Super {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_super(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_super(v, self)
    }
}
impl<V: Fold> FoldWith<V> for SwitchCase {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_switch_case(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_switch_case(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<SwitchCase> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_switch_cases(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_switch_cases(v, self)
    }
}
impl<V: Fold> FoldWith<V> for SwitchStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_switch_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_switch_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TaggedTpl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_tagged_tpl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_tagged_tpl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ThisExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_this_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_this_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for ThrowStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_throw_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_throw_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Tpl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_tpl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_tpl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TplElement {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_tpl_element(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_tpl_element(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<TplElement> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_tpl_elements(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_tpl_elements(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TruePlusMinus {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_true_plus_minus(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_true_plus_minus(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TryStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_try_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_try_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsArrayType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_array_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_array_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsAsExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_as_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_as_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsCallSignatureDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_call_signature_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_call_signature_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsConditionalType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_conditional_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_conditional_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsConstAssertion {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_const_assertion(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_const_assertion(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsConstructSignatureDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_construct_signature_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_construct_signature_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsConstructorType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_constructor_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_constructor_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsEntityName {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_entity_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_entity_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsEnumDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_enum_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_enum_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsEnumMember {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_enum_member(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_enum_member(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsEnumMemberId {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_enum_member_id(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_enum_member_id(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<TsEnumMember> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_enum_members(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_enum_members(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsExportAssignment {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_export_assignment(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_export_assignment(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsExprWithTypeArgs {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_expr_with_type_args(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_expr_with_type_args(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<TsExprWithTypeArgs> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_expr_with_type_args_vec(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_expr_with_type_args_vec(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsExternalModuleRef {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_external_module_ref(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_external_module_ref(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsFnOrConstructorType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_fn_or_constructor_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_fn_or_constructor_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsFnParam {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_fn_param(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_fn_param(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<TsFnParam> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_fn_params(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_fn_params(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsFnType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_fn_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_fn_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsGetterSignature {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_getter_signature(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_getter_signature(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsImportEqualsDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_import_equals_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_import_equals_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsImportType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_import_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_import_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsIndexSignature {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_index_signature(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_index_signature(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsIndexedAccessType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_indexed_access_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_indexed_access_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsInferType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_infer_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_infer_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsInterfaceBody {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_interface_body(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_interface_body(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsInterfaceDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_interface_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_interface_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsIntersectionType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_intersection_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_intersection_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsKeywordType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_keyword_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_keyword_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsKeywordTypeKind {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_keyword_type_kind(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_keyword_type_kind(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsLit {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_lit(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_lit(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsLitType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_lit_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_lit_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsMappedType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_mapped_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_mapped_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsMethodSignature {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_method_signature(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_method_signature(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsModuleBlock {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_module_block(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_module_block(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsModuleDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_module_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_module_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsModuleName {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_module_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_module_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsModuleRef {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_module_ref(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_module_ref(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsNamespaceBody {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_namespace_body(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_namespace_body(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsNamespaceDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_namespace_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_namespace_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsNamespaceExportDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_namespace_export_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_namespace_export_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsNonNullExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_non_null_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_non_null_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsOptionalType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_optional_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_optional_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsParamProp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_param_prop(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_param_prop(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsParamPropParam {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_param_prop_param(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_param_prop_param(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsParenthesizedType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_parenthesized_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_parenthesized_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsPropertySignature {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_property_signature(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_property_signature(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsQualifiedName {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_qualified_name(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_qualified_name(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsRestType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_rest_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_rest_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsSetterSignature {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_setter_signature(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_setter_signature(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsThisType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_this_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_this_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsThisTypeOrIdent {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_this_type_or_ident(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_this_type_or_ident(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTplLitType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_tpl_lit_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_tpl_lit_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTupleElement {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_tuple_element(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_tuple_element(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<TsTupleElement> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_tuple_elements(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_tuple_elements(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTupleType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_tuple_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_tuple_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeAliasDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_alias_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_alias_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeAnn {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_ann(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_ann(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeAssertion {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_assertion(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_assertion(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeElement {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_element(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_element(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<TsTypeElement> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_elements(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_elements(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeLit {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_lit(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_lit(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeOperator {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_operator(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_operator(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeOperatorOp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_operator_op(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_operator_op(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeParam {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_param(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_param(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeParamDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_param_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_param_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeParamInstantiation {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_param_instantiation(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_param_instantiation(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<TsTypeParam> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_params(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_params(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypePredicate {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_predicate(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_predicate(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeQuery {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_query(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_query(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeQueryExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_query_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_query_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsTypeRef {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_type_ref(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_type_ref(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<Box<TsType>> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_types(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_types(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsUnionOrIntersectionType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_union_or_intersection_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_union_or_intersection_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for TsUnionType {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_ts_union_type(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_ts_union_type(v, self)
    }
}
impl<V: Fold> FoldWith<V> for UnaryExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_unary_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_unary_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for UnaryOp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_unary_op(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_unary_op(v, self)
    }
}
impl<V: Fold> FoldWith<V> for UpdateExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_update_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_update_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for UpdateOp {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_update_op(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_update_op(v, self)
    }
}
impl<V: Fold> FoldWith<V> for VarDecl {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_var_decl(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_var_decl(v, self)
    }
}
impl<V: Fold> FoldWith<V> for VarDeclKind {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_var_decl_kind(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_var_decl_kind(v, self)
    }
}
impl<V: Fold> FoldWith<V> for VarDeclOrExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_var_decl_or_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_var_decl_or_expr(v, self)
    }
}
impl<V: Fold> FoldWith<V> for VarDeclOrPat {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_var_decl_or_pat(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_var_decl_or_pat(v, self)
    }
}
impl<V: Fold> FoldWith<V> for VarDeclarator {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_var_declarator(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_var_declarator(v, self)
    }
}
impl<V: Fold> FoldWith<V> for Vec<VarDeclarator> {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_var_declarators(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_var_declarators(v, self)
    }
}
impl<V: Fold> FoldWith<V> for WhileStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_while_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_while_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for WithStmt {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_with_stmt(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_with_stmt(v, self)
    }
}
impl<V: Fold> FoldWith<V> for YieldExpr {
    fn fold_with(self, v: &mut V) -> Self {
        v.fold_yield_expr(self)
    }
    fn fold_children_with(self, v: &mut V) -> Self {
        fold_yield_expr(v, self)
    }
}
#[allow(unused_variables)]
pub fn visit_accessibility<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast Accessibility,
) {
    {
        match n {
            Accessibility::Public {} => {}
            Accessibility::Protected {} => {}
            Accessibility::Private {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_array_lit<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ArrayLit) {
    {
        match n {
            ArrayLit { span, elems } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_vec_expr_or_spreads(elems);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_array_pat<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ArrayPat) {
    {
        match n {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_vec_pats(elems);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_arrow_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ArrowExpr) {
    {
        match n {
            ArrowExpr {
                span,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_pats(params);
                _visitor.visit_block_stmt_or_expr(body);
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
                _visitor.visit_opt_ts_type_ann(return_type.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_assign_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast AssignExpr) {
    {
        match n {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_assign_op(op);
                _visitor.visit_pat_or_expr(left);
                _visitor.visit_expr(right);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_assign_op<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast AssignOp) {
    {
        match n {
            AssignOp::Assign {} => {}
            AssignOp::AddAssign {} => {}
            AssignOp::SubAssign {} => {}
            AssignOp::MulAssign {} => {}
            AssignOp::DivAssign {} => {}
            AssignOp::ModAssign {} => {}
            AssignOp::LShiftAssign {} => {}
            AssignOp::RShiftAssign {} => {}
            AssignOp::ZeroFillRShiftAssign {} => {}
            AssignOp::BitOrAssign {} => {}
            AssignOp::BitXorAssign {} => {}
            AssignOp::BitAndAssign {} => {}
            AssignOp::ExpAssign {} => {}
            AssignOp::AndAssign {} => {}
            AssignOp::OrAssign {} => {}
            AssignOp::NullishAssign {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_assign_pat<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast AssignPat) {
    {
        match n {
            AssignPat {
                span,
                left,
                right,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_pat(left);
                _visitor.visit_expr(right);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_assign_pat_prop<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast AssignPatProp,
) {
    {
        match n {
            AssignPatProp { span, key, value } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(key);
                _visitor.visit_opt_expr(value.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_assign_prop<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast AssignProp) {
    {
        match n {
            AssignProp { key, value } => {
                _visitor.visit_ident(key);
                _visitor.visit_expr(value);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_await_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast AwaitExpr) {
    {
        match n {
            AwaitExpr { span, arg } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(arg);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_big_int<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast BigInt) {
    {
        match n {
            BigInt { span, value } => {
                _visitor.visit_span(span);
                _visitor.visit_big_int_value(value);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_big_int_value<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast BigIntValue) {
    {}
}
#[allow(unused_variables)]
pub fn visit_bin_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast BinExpr) {
    {
        match n {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_binary_op(op);
                _visitor.visit_expr(left);
                _visitor.visit_expr(right);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_binary_op<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast BinaryOp) {
    {
        match n {
            BinaryOp::EqEq {} => {}
            BinaryOp::NotEq {} => {}
            BinaryOp::EqEqEq {} => {}
            BinaryOp::NotEqEq {} => {}
            BinaryOp::Lt {} => {}
            BinaryOp::LtEq {} => {}
            BinaryOp::Gt {} => {}
            BinaryOp::GtEq {} => {}
            BinaryOp::LShift {} => {}
            BinaryOp::RShift {} => {}
            BinaryOp::ZeroFillRShift {} => {}
            BinaryOp::Add {} => {}
            BinaryOp::Sub {} => {}
            BinaryOp::Mul {} => {}
            BinaryOp::Div {} => {}
            BinaryOp::Mod {} => {}
            BinaryOp::BitOr {} => {}
            BinaryOp::BitXor {} => {}
            BinaryOp::BitAnd {} => {}
            BinaryOp::LogicalOr {} => {}
            BinaryOp::LogicalAnd {} => {}
            BinaryOp::In {} => {}
            BinaryOp::InstanceOf {} => {}
            BinaryOp::Exp {} => {}
            BinaryOp::NullishCoalescing {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_binding_ident<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast BindingIdent) {
    {
        match n {
            BindingIdent { id, type_ann } => {
                _visitor.visit_ident(id);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_block_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast BlockStmt) {
    {
        match n {
            BlockStmt { span, stmts } => {
                _visitor.visit_span(span);
                _visitor.visit_stmts(stmts);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_block_stmt_or_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast BlockStmtOrExpr,
) {
    {
        match n {
            BlockStmtOrExpr::BlockStmt { 0: _0 } => {
                _visitor.visit_block_stmt(_0);
            }
            BlockStmtOrExpr::Expr { 0: _0 } => {
                _visitor.visit_expr(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_bool<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Bool) {
    {
        match n {
            Bool { span, value } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_break_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast BreakStmt) {
    {
        match n {
            BreakStmt { span, label } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_ident(label.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_call_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast CallExpr) {
    {
        match n {
            CallExpr {
                span,
                callee,
                args,
                type_args,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr_or_super(callee);
                _visitor.visit_expr_or_spreads(args);
                _visitor.visit_opt_ts_type_param_instantiation(type_args.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_catch_clause<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast CatchClause) {
    {
        match n {
            CatchClause { span, param, body } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_pat(param.as_ref());
                _visitor.visit_block_stmt(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_class<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Class) {
    {
        match n {
            Class {
                span,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_decorators(decorators);
                _visitor.visit_class_members(body);
                _visitor.visit_opt_expr(super_class.as_ref());
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
                _visitor.visit_opt_ts_type_param_instantiation(super_type_params.as_ref());
                _visitor.visit_ts_expr_with_type_args_vec(implements);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_class_decl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ClassDecl) {
    {
        match n {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                _visitor.visit_ident(ident);
                _visitor.visit_class(class);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_class_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ClassExpr) {
    {
        match n {
            ClassExpr { ident, class } => {
                _visitor.visit_opt_ident(ident.as_ref());
                _visitor.visit_class(class);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_class_member<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ClassMember) {
    {
        match n {
            ClassMember::Constructor { 0: _0 } => {
                _visitor.visit_constructor(_0);
            }
            ClassMember::Method { 0: _0 } => {
                _visitor.visit_class_method(_0);
            }
            ClassMember::PrivateMethod { 0: _0 } => {
                _visitor.visit_private_method(_0);
            }
            ClassMember::ClassProp { 0: _0 } => {
                _visitor.visit_class_prop(_0);
            }
            ClassMember::PrivateProp { 0: _0 } => {
                _visitor.visit_private_prop(_0);
            }
            ClassMember::TsIndexSignature { 0: _0 } => {
                _visitor.visit_ts_index_signature(_0);
            }
            ClassMember::Empty { 0: _0 } => {
                _visitor.visit_empty_stmt(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_class_members<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [ClassMember],
) {
    {
        n.iter().for_each(|v| _visitor.visit_class_member(v))
    }
}
#[allow(unused_variables)]
pub fn visit_class_method<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ClassMethod) {
    {
        match n {
            ClassMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_prop_name(key);
                _visitor.visit_function(function);
                _visitor.visit_method_kind(kind);
                _visitor.visit_opt_accessibility(accessibility.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_class_prop<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ClassProp) {
    {
        match n {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                computed,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(key);
                _visitor.visit_opt_expr(value.as_ref());
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
                _visitor.visit_decorators(decorators);
                _visitor.visit_opt_accessibility(accessibility.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_computed_prop_name<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ComputedPropName,
) {
    {
        match n {
            ComputedPropName { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_cond_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast CondExpr) {
    {
        match n {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(test);
                _visitor.visit_expr(cons);
                _visitor.visit_expr(alt);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_constructor<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Constructor) {
    {
        match n {
            Constructor {
                span,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_prop_name(key);
                _visitor.visit_param_or_ts_param_props(params);
                _visitor.visit_opt_block_stmt(body.as_ref());
                _visitor.visit_opt_accessibility(accessibility.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_continue_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ContinueStmt) {
    {
        match n {
            ContinueStmt { span, label } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_ident(label.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_debugger_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast DebuggerStmt) {
    {
        match n {
            DebuggerStmt { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_decl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Decl) {
    {
        match n {
            Decl::Class { 0: _0 } => {
                _visitor.visit_class_decl(_0);
            }
            Decl::Fn { 0: _0 } => {
                _visitor.visit_fn_decl(_0);
            }
            Decl::Var { 0: _0 } => {
                _visitor.visit_var_decl(_0);
            }
            Decl::TsInterface { 0: _0 } => {
                _visitor.visit_ts_interface_decl(_0);
            }
            Decl::TsTypeAlias { 0: _0 } => {
                _visitor.visit_ts_type_alias_decl(_0);
            }
            Decl::TsEnum { 0: _0 } => {
                _visitor.visit_ts_enum_decl(_0);
            }
            Decl::TsModule { 0: _0 } => {
                _visitor.visit_ts_module_decl(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_decorator<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Decorator) {
    {
        match n {
            Decorator { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_decorators<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [Decorator]) {
    {
        n.iter().for_each(|v| _visitor.visit_decorator(v))
    }
}
#[allow(unused_variables)]
pub fn visit_default_decl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast DefaultDecl) {
    {
        match n {
            DefaultDecl::Class { 0: _0 } => {
                _visitor.visit_class_expr(_0);
            }
            DefaultDecl::Fn { 0: _0 } => {
                _visitor.visit_fn_expr(_0);
            }
            DefaultDecl::TsInterfaceDecl { 0: _0 } => {
                _visitor.visit_ts_interface_decl(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_do_while_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast DoWhileStmt) {
    {
        match n {
            DoWhileStmt { span, test, body } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(test);
                _visitor.visit_stmt(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_empty_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast EmptyStmt) {
    {
        match n {
            EmptyStmt { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_export_all<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ExportAll) {
    {
        match n {
            ExportAll { span, src, asserts } => {
                _visitor.visit_span(span);
                _visitor.visit_str(src);
                _visitor.visit_opt_object_lit(asserts.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_export_decl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ExportDecl) {
    {
        match n {
            ExportDecl { span, decl } => {
                _visitor.visit_span(span);
                _visitor.visit_decl(decl);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_export_default_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ExportDefaultDecl,
) {
    {
        match n {
            ExportDefaultDecl { span, decl } => {
                _visitor.visit_span(span);
                _visitor.visit_default_decl(decl);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_export_default_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ExportDefaultExpr,
) {
    {
        match n {
            ExportDefaultExpr { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_export_default_specifier<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ExportDefaultSpecifier,
) {
    {
        match n {
            ExportDefaultSpecifier { exported } => {
                _visitor.visit_ident(exported);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_export_named_specifier<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ExportNamedSpecifier,
) {
    {
        match n {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(orig);
                _visitor.visit_opt_ident(exported.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_export_namespace_specifier<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ExportNamespaceSpecifier,
) {
    {
        match n {
            ExportNamespaceSpecifier { span, name } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(name);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_export_specifier<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ExportSpecifier,
) {
    {
        match n {
            ExportSpecifier::Namespace { 0: _0 } => {
                _visitor.visit_export_namespace_specifier(_0);
            }
            ExportSpecifier::Default { 0: _0 } => {
                _visitor.visit_export_default_specifier(_0);
            }
            ExportSpecifier::Named { 0: _0 } => {
                _visitor.visit_export_named_specifier(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_export_specifiers<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [ExportSpecifier],
) {
    {
        n.iter().for_each(|v| _visitor.visit_export_specifier(v))
    }
}
#[allow(unused_variables)]
pub fn visit_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Expr) {
    {
        match n {
            Expr::This { 0: _0 } => {
                _visitor.visit_this_expr(_0);
            }
            Expr::Array { 0: _0 } => {
                _visitor.visit_array_lit(_0);
            }
            Expr::Object { 0: _0 } => {
                _visitor.visit_object_lit(_0);
            }
            Expr::Fn { 0: _0 } => {
                _visitor.visit_fn_expr(_0);
            }
            Expr::Unary { 0: _0 } => {
                _visitor.visit_unary_expr(_0);
            }
            Expr::Update { 0: _0 } => {
                _visitor.visit_update_expr(_0);
            }
            Expr::Bin { 0: _0 } => {
                _visitor.visit_bin_expr(_0);
            }
            Expr::Assign { 0: _0 } => {
                _visitor.visit_assign_expr(_0);
            }
            Expr::Member { 0: _0 } => {
                _visitor.visit_member_expr(_0);
            }
            Expr::Cond { 0: _0 } => {
                _visitor.visit_cond_expr(_0);
            }
            Expr::Call { 0: _0 } => {
                _visitor.visit_call_expr(_0);
            }
            Expr::New { 0: _0 } => {
                _visitor.visit_new_expr(_0);
            }
            Expr::Seq { 0: _0 } => {
                _visitor.visit_seq_expr(_0);
            }
            Expr::Ident { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
            Expr::Lit { 0: _0 } => {
                _visitor.visit_lit(_0);
            }
            Expr::Tpl { 0: _0 } => {
                _visitor.visit_tpl(_0);
            }
            Expr::TaggedTpl { 0: _0 } => {
                _visitor.visit_tagged_tpl(_0);
            }
            Expr::Arrow { 0: _0 } => {
                _visitor.visit_arrow_expr(_0);
            }
            Expr::Class { 0: _0 } => {
                _visitor.visit_class_expr(_0);
            }
            Expr::Yield { 0: _0 } => {
                _visitor.visit_yield_expr(_0);
            }
            Expr::MetaProp { 0: _0 } => {
                _visitor.visit_meta_prop_expr(_0);
            }
            Expr::Await { 0: _0 } => {
                _visitor.visit_await_expr(_0);
            }
            Expr::Paren { 0: _0 } => {
                _visitor.visit_paren_expr(_0);
            }
            Expr::JSXMember { 0: _0 } => {
                _visitor.visit_jsx_member_expr(_0);
            }
            Expr::JSXNamespacedName { 0: _0 } => {
                _visitor.visit_jsx_namespaced_name(_0);
            }
            Expr::JSXEmpty { 0: _0 } => {
                _visitor.visit_jsx_empty_expr(_0);
            }
            Expr::JSXElement { 0: _0 } => {
                _visitor.visit_jsx_element(_0);
            }
            Expr::JSXFragment { 0: _0 } => {
                _visitor.visit_jsx_fragment(_0);
            }
            Expr::TsTypeAssertion { 0: _0 } => {
                _visitor.visit_ts_type_assertion(_0);
            }
            Expr::TsConstAssertion { 0: _0 } => {
                _visitor.visit_ts_const_assertion(_0);
            }
            Expr::TsNonNull { 0: _0 } => {
                _visitor.visit_ts_non_null_expr(_0);
            }
            Expr::TsAs { 0: _0 } => {
                _visitor.visit_ts_as_expr(_0);
            }
            Expr::PrivateName { 0: _0 } => {
                _visitor.visit_private_name(_0);
            }
            Expr::OptChain { 0: _0 } => {
                _visitor.visit_opt_chain_expr(_0);
            }
            Expr::Invalid { 0: _0 } => {
                _visitor.visit_invalid(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_expr_or_spread<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ExprOrSpread,
) {
    {
        match n {
            ExprOrSpread { spread, expr } => {
                _visitor.visit_opt_span(spread.as_ref());
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_expr_or_spreads<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [ExprOrSpread],
) {
    {
        n.iter().for_each(|v| _visitor.visit_expr_or_spread(v))
    }
}
#[allow(unused_variables)]
pub fn visit_expr_or_super<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ExprOrSuper) {
    {
        match n {
            ExprOrSuper::Super { 0: _0 } => {
                _visitor.visit_super(_0);
            }
            ExprOrSuper::Expr { 0: _0 } => {
                _visitor.visit_expr(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_expr_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ExprStmt) {
    {
        match n {
            ExprStmt { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_exprs<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [Box<Expr>]) {
    {
        n.iter().for_each(|v| _visitor.visit_expr(v))
    }
}
#[allow(unused_variables)]
pub fn visit_fn_decl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast FnDecl) {
    {
        match n {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                _visitor.visit_ident(ident);
                _visitor.visit_function(function);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_fn_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast FnExpr) {
    {
        match n {
            FnExpr { ident, function } => {
                _visitor.visit_opt_ident(ident.as_ref());
                _visitor.visit_function(function);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_for_in_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ForInStmt) {
    {
        match n {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_var_decl_or_pat(left);
                _visitor.visit_expr(right);
                _visitor.visit_stmt(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_for_of_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ForOfStmt) {
    {
        match n {
            ForOfStmt {
                span,
                await_token,
                left,
                right,
                body,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_span(await_token.as_ref());
                _visitor.visit_var_decl_or_pat(left);
                _visitor.visit_expr(right);
                _visitor.visit_stmt(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_for_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ForStmt) {
    {
        match n {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_var_decl_or_expr(init.as_ref());
                _visitor.visit_opt_expr(test.as_ref());
                _visitor.visit_opt_expr(update.as_ref());
                _visitor.visit_stmt(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_function<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Function) {
    {
        match n {
            Function {
                params,
                decorators,
                span,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                _visitor.visit_params(params);
                _visitor.visit_decorators(decorators);
                _visitor.visit_span(span);
                _visitor.visit_opt_block_stmt(body.as_ref());
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
                _visitor.visit_opt_ts_type_ann(return_type.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_getter_prop<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast GetterProp) {
    {
        match n {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_prop_name(key);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
                _visitor.visit_opt_block_stmt(body.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ident<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Ident) {
    {
        match n {
            Ident {
                span,
                sym,
                optional,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_js_word(sym);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_if_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast IfStmt) {
    {
        match n {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(test);
                _visitor.visit_stmt(cons);
                _visitor.visit_opt_stmt(alt.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_import_decl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ImportDecl) {
    {
        match n {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                asserts,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_import_specifiers(specifiers);
                _visitor.visit_str(src);
                _visitor.visit_opt_object_lit(asserts.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_import_default_specifier<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ImportDefaultSpecifier,
) {
    {
        match n {
            ImportDefaultSpecifier { span, local } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(local);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_import_named_specifier<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ImportNamedSpecifier,
) {
    {
        match n {
            ImportNamedSpecifier {
                span,
                local,
                imported,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(local);
                _visitor.visit_opt_ident(imported.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_import_specifier<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ImportSpecifier,
) {
    {
        match n {
            ImportSpecifier::Named { 0: _0 } => {
                _visitor.visit_import_named_specifier(_0);
            }
            ImportSpecifier::Default { 0: _0 } => {
                _visitor.visit_import_default_specifier(_0);
            }
            ImportSpecifier::Namespace { 0: _0 } => {
                _visitor.visit_import_star_as_specifier(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_import_specifiers<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [ImportSpecifier],
) {
    {
        n.iter().for_each(|v| _visitor.visit_import_specifier(v))
    }
}
#[allow(unused_variables)]
pub fn visit_import_star_as_specifier<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ImportStarAsSpecifier,
) {
    {
        match n {
            ImportStarAsSpecifier { span, local } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(local);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_invalid<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Invalid) {
    {
        match n {
            Invalid { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_js_word<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast JsWord) {
    {}
}
#[allow(unused_variables)]
pub fn visit_jsx_attr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast JSXAttr) {
    {
        match n {
            JSXAttr { span, name, value } => {
                _visitor.visit_span(span);
                _visitor.visit_jsx_attr_name(name);
                _visitor.visit_opt_jsx_attr_value(value.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_attr_name<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast JSXAttrName) {
    {
        match n {
            JSXAttrName::Ident { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
            JSXAttrName::JSXNamespacedName { 0: _0 } => {
                _visitor.visit_jsx_namespaced_name(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_attr_or_spread<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXAttrOrSpread,
) {
    {
        match n {
            JSXAttrOrSpread::JSXAttr { 0: _0 } => {
                _visitor.visit_jsx_attr(_0);
            }
            JSXAttrOrSpread::SpreadElement { 0: _0 } => {
                _visitor.visit_spread_element(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_attr_or_spreads<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [JSXAttrOrSpread],
) {
    {
        n.iter().for_each(|v| _visitor.visit_jsx_attr_or_spread(v))
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_attr_value<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXAttrValue,
) {
    {
        match n {
            JSXAttrValue::Lit { 0: _0 } => {
                _visitor.visit_lit(_0);
            }
            JSXAttrValue::JSXExprContainer { 0: _0 } => {
                _visitor.visit_jsx_expr_container(_0);
            }
            JSXAttrValue::JSXElement { 0: _0 } => {
                _visitor.visit_jsx_element(_0);
            }
            JSXAttrValue::JSXFragment { 0: _0 } => {
                _visitor.visit_jsx_fragment(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_closing_element<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXClosingElement,
) {
    {
        match n {
            JSXClosingElement { span, name } => {
                _visitor.visit_span(span);
                _visitor.visit_jsx_element_name(name);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_closing_fragment<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXClosingFragment,
) {
    {
        match n {
            JSXClosingFragment { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_element<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast JSXElement) {
    {
        match n {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_jsx_opening_element(opening);
                _visitor.visit_jsx_element_children(children);
                _visitor.visit_opt_jsx_closing_element(closing.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_element_child<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXElementChild,
) {
    {
        match n {
            JSXElementChild::JSXText { 0: _0 } => {
                _visitor.visit_jsx_text(_0);
            }
            JSXElementChild::JSXExprContainer { 0: _0 } => {
                _visitor.visit_jsx_expr_container(_0);
            }
            JSXElementChild::JSXSpreadChild { 0: _0 } => {
                _visitor.visit_jsx_spread_child(_0);
            }
            JSXElementChild::JSXElement { 0: _0 } => {
                _visitor.visit_jsx_element(_0);
            }
            JSXElementChild::JSXFragment { 0: _0 } => {
                _visitor.visit_jsx_fragment(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_element_children<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [JSXElementChild],
) {
    {
        n.iter().for_each(|v| _visitor.visit_jsx_element_child(v))
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_element_name<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXElementName,
) {
    {
        match n {
            JSXElementName::Ident { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
            JSXElementName::JSXMemberExpr { 0: _0 } => {
                _visitor.visit_jsx_member_expr(_0);
            }
            JSXElementName::JSXNamespacedName { 0: _0 } => {
                _visitor.visit_jsx_namespaced_name(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_empty_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXEmptyExpr,
) {
    {
        match n {
            JSXEmptyExpr { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast JSXExpr) {
    {
        match n {
            JSXExpr::JSXEmptyExpr { 0: _0 } => {
                _visitor.visit_jsx_empty_expr(_0);
            }
            JSXExpr::Expr { 0: _0 } => {
                _visitor.visit_expr(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_expr_container<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXExprContainer,
) {
    {
        match n {
            JSXExprContainer { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_jsx_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_fragment<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast JSXFragment) {
    {
        match n {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_jsx_opening_fragment(opening);
                _visitor.visit_jsx_element_children(children);
                _visitor.visit_jsx_closing_fragment(closing);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_member_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXMemberExpr,
) {
    {
        match n {
            JSXMemberExpr { obj, prop } => {
                _visitor.visit_jsx_object(obj);
                _visitor.visit_ident(prop);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_namespaced_name<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXNamespacedName,
) {
    {
        match n {
            JSXNamespacedName { ns, name } => {
                _visitor.visit_ident(ns);
                _visitor.visit_ident(name);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_object<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast JSXObject) {
    {
        match n {
            JSXObject::JSXMemberExpr { 0: _0 } => {
                _visitor.visit_jsx_member_expr(_0);
            }
            JSXObject::Ident { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_opening_element<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXOpeningElement,
) {
    {
        match n {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                _visitor.visit_jsx_element_name(name);
                _visitor.visit_span(span);
                _visitor.visit_jsx_attr_or_spreads(attrs);
                _visitor.visit_opt_ts_type_param_instantiation(type_args.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_opening_fragment<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXOpeningFragment,
) {
    {
        match n {
            JSXOpeningFragment { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_spread_child<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast JSXSpreadChild,
) {
    {
        match n {
            JSXSpreadChild { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_jsx_text<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast JSXText) {
    {
        match n {
            JSXText { span, value, raw } => {
                _visitor.visit_span(span);
                _visitor.visit_js_word(value);
                _visitor.visit_js_word(raw);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_key_value_pat_prop<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast KeyValuePatProp,
) {
    {
        match n {
            KeyValuePatProp { key, value } => {
                _visitor.visit_prop_name(key);
                _visitor.visit_pat(value);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_key_value_prop<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast KeyValueProp,
) {
    {
        match n {
            KeyValueProp { key, value } => {
                _visitor.visit_prop_name(key);
                _visitor.visit_expr(value);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_labeled_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast LabeledStmt) {
    {
        match n {
            LabeledStmt { span, label, body } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(label);
                _visitor.visit_stmt(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_lit<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Lit) {
    {
        match n {
            Lit::Str { 0: _0 } => {
                _visitor.visit_str(_0);
            }
            Lit::Bool { 0: _0 } => {
                _visitor.visit_bool(_0);
            }
            Lit::Null { 0: _0 } => {
                _visitor.visit_null(_0);
            }
            Lit::Num { 0: _0 } => {
                _visitor.visit_number(_0);
            }
            Lit::BigInt { 0: _0 } => {
                _visitor.visit_big_int(_0);
            }
            Lit::Regex { 0: _0 } => {
                _visitor.visit_regex(_0);
            }
            Lit::JSXText { 0: _0 } => {
                _visitor.visit_jsx_text(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_member_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast MemberExpr) {
    {
        match n {
            MemberExpr {
                span,
                obj,
                prop,
                computed,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr_or_super(obj);
                _visitor.visit_expr(prop);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_meta_prop_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast MetaPropExpr,
) {
    {
        match n {
            MetaPropExpr { meta, prop } => {
                _visitor.visit_ident(meta);
                _visitor.visit_ident(prop);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_method_kind<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast MethodKind) {
    {
        match n {
            MethodKind::Method {} => {}
            MethodKind::Getter {} => {}
            MethodKind::Setter {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_method_prop<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast MethodProp) {
    {
        match n {
            MethodProp { key, function } => {
                _visitor.visit_prop_name(key);
                _visitor.visit_function(function);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_module<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Module) {
    {
        match n {
            Module {
                span,
                body,
                shebang,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_module_items(body);
                _visitor.visit_opt_js_word(shebang.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_module_decl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ModuleDecl) {
    {
        match n {
            ModuleDecl::Import { 0: _0 } => {
                _visitor.visit_import_decl(_0);
            }
            ModuleDecl::ExportDecl { 0: _0 } => {
                _visitor.visit_export_decl(_0);
            }
            ModuleDecl::ExportNamed { 0: _0 } => {
                _visitor.visit_named_export(_0);
            }
            ModuleDecl::ExportDefaultDecl { 0: _0 } => {
                _visitor.visit_export_default_decl(_0);
            }
            ModuleDecl::ExportDefaultExpr { 0: _0 } => {
                _visitor.visit_export_default_expr(_0);
            }
            ModuleDecl::ExportAll { 0: _0 } => {
                _visitor.visit_export_all(_0);
            }
            ModuleDecl::TsImportEquals { 0: _0 } => {
                _visitor.visit_ts_import_equals_decl(_0);
            }
            ModuleDecl::TsExportAssignment { 0: _0 } => {
                _visitor.visit_ts_export_assignment(_0);
            }
            ModuleDecl::TsNamespaceExport { 0: _0 } => {
                _visitor.visit_ts_namespace_export_decl(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_module_item<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ModuleItem) {
    {
        match n {
            ModuleItem::ModuleDecl { 0: _0 } => {
                _visitor.visit_module_decl(_0);
            }
            ModuleItem::Stmt { 0: _0 } => {
                _visitor.visit_stmt(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_module_items<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [ModuleItem]) {
    {
        n.iter().for_each(|v| _visitor.visit_module_item(v))
    }
}
#[allow(unused_variables)]
pub fn visit_named_export<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast NamedExport) {
    {
        match n {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                asserts,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_export_specifiers(specifiers);
                _visitor.visit_opt_str(src.as_ref());
                _visitor.visit_opt_object_lit(asserts.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_new_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast NewExpr) {
    {
        match n {
            NewExpr {
                span,
                callee,
                args,
                type_args,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(callee);
                _visitor.visit_opt_expr_or_spreads(args.as_ref().map(|v| &**v));
                _visitor.visit_opt_ts_type_param_instantiation(type_args.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_null<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Null) {
    {
        match n {
            Null { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_number<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Number) {
    {
        match n {
            Number { span, value } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_object_lit<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ObjectLit) {
    {
        match n {
            ObjectLit { span, props } => {
                _visitor.visit_span(span);
                _visitor.visit_prop_or_spreads(props);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_object_pat<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ObjectPat) {
    {
        match n {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_object_pat_props(props);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_object_pat_prop<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ObjectPatProp,
) {
    {
        match n {
            ObjectPatProp::KeyValue { 0: _0 } => {
                _visitor.visit_key_value_pat_prop(_0);
            }
            ObjectPatProp::Assign { 0: _0 } => {
                _visitor.visit_assign_pat_prop(_0);
            }
            ObjectPatProp::Rest { 0: _0 } => {
                _visitor.visit_rest_pat(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_object_pat_props<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [ObjectPatProp],
) {
    {
        n.iter().for_each(|v| _visitor.visit_object_pat_prop(v))
    }
}
#[allow(unused_variables)]
pub fn visit_opt_accessibility<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast Accessibility>,
) {
    {
        match n {
            Some(n) => _visitor.visit_accessibility(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_block_stmt<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast BlockStmt>,
) {
    {
        match n {
            Some(n) => _visitor.visit_block_stmt(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_catch_clause<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast CatchClause>,
) {
    {
        match n {
            Some(n) => _visitor.visit_catch_clause(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_chain_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast OptChainExpr,
) {
    {
        match n {
            OptChainExpr {
                span,
                question_dot_token,
                expr,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_span(question_dot_token);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: Option<&'ast Box<Expr>>) {
    {
        match n {
            Some(n) => _visitor.visit_expr(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_expr_or_spread<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast ExprOrSpread>,
) {
    {
        match n {
            Some(n) => _visitor.visit_expr_or_spread(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_expr_or_spreads<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast [ExprOrSpread]>,
) {
    {
        match n {
            Some(n) => _visitor.visit_expr_or_spreads(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_ident<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: Option<&'ast Ident>) {
    {
        match n {
            Some(n) => _visitor.visit_ident(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_js_word<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: Option<&'ast JsWord>) {
    {
        match n {
            Some(n) => _visitor.visit_js_word(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_jsx_attr_value<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast JSXAttrValue>,
) {
    {
        match n {
            Some(n) => _visitor.visit_jsx_attr_value(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_jsx_closing_element<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast JSXClosingElement>,
) {
    {
        match n {
            Some(n) => _visitor.visit_jsx_closing_element(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_object_lit<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast ObjectLit>,
) {
    {
        match n {
            Some(n) => _visitor.visit_object_lit(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_pat<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: Option<&'ast Pat>) {
    {
        match n {
            Some(n) => _visitor.visit_pat(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_span<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: Option<&'ast Span>) {
    {
        match n {
            Some(n) => _visitor.visit_span(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: Option<&'ast Box<Stmt>>) {
    {
        match n {
            Some(n) => _visitor.visit_stmt(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_str<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: Option<&'ast Str>) {
    {
        match n {
            Some(n) => _visitor.visit_str(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_true_plus_minus<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast TruePlusMinus>,
) {
    {
        match n {
            Some(n) => _visitor.visit_true_plus_minus(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_ts_entity_name<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast TsEntityName>,
) {
    {
        match n {
            Some(n) => _visitor.visit_ts_entity_name(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_ts_namespace_body<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast TsNamespaceBody>,
) {
    {
        match n {
            Some(n) => _visitor.visit_ts_namespace_body(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_ts_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast Box<TsType>>,
) {
    {
        match n {
            Some(n) => _visitor.visit_ts_type(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_ts_type_ann<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast TsTypeAnn>,
) {
    {
        match n {
            Some(n) => _visitor.visit_ts_type_ann(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_ts_type_param_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast TsTypeParamDecl>,
) {
    {
        match n {
            Some(n) => _visitor.visit_ts_type_param_decl(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_ts_type_param_instantiation<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast TsTypeParamInstantiation>,
) {
    {
        match n {
            Some(n) => _visitor.visit_ts_type_param_instantiation(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_var_decl_or_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: Option<&'ast VarDeclOrExpr>,
) {
    {
        match n {
            Some(n) => _visitor.visit_var_decl_or_expr(n),
            None => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_opt_vec_expr_or_spreads<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [Option<ExprOrSpread>],
) {
    {
        n.iter()
            .for_each(|v| _visitor.visit_opt_expr_or_spread(v.as_ref()))
    }
}
#[allow(unused_variables)]
pub fn visit_opt_vec_pats<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [Option<Pat>]) {
    {
        n.iter().for_each(|v| _visitor.visit_opt_pat(v.as_ref()))
    }
}
#[allow(unused_variables)]
pub fn visit_param<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Param) {
    {
        match n {
            Param {
                span,
                decorators,
                pat,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_decorators(decorators);
                _visitor.visit_pat(pat);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_param_or_ts_param_prop<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast ParamOrTsParamProp,
) {
    {
        match n {
            ParamOrTsParamProp::TsParamProp { 0: _0 } => {
                _visitor.visit_ts_param_prop(_0);
            }
            ParamOrTsParamProp::Param { 0: _0 } => {
                _visitor.visit_param(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_param_or_ts_param_props<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [ParamOrTsParamProp],
) {
    {
        n.iter()
            .for_each(|v| _visitor.visit_param_or_ts_param_prop(v))
    }
}
#[allow(unused_variables)]
pub fn visit_params<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [Param]) {
    {
        n.iter().for_each(|v| _visitor.visit_param(v))
    }
}
#[allow(unused_variables)]
pub fn visit_paren_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ParenExpr) {
    {
        match n {
            ParenExpr { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_pat<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Pat) {
    {
        match n {
            Pat::Ident { 0: _0 } => {
                _visitor.visit_binding_ident(_0);
            }
            Pat::Array { 0: _0 } => {
                _visitor.visit_array_pat(_0);
            }
            Pat::Rest { 0: _0 } => {
                _visitor.visit_rest_pat(_0);
            }
            Pat::Object { 0: _0 } => {
                _visitor.visit_object_pat(_0);
            }
            Pat::Assign { 0: _0 } => {
                _visitor.visit_assign_pat(_0);
            }
            Pat::Invalid { 0: _0 } => {
                _visitor.visit_invalid(_0);
            }
            Pat::Expr { 0: _0 } => {
                _visitor.visit_expr(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_pat_or_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast PatOrExpr) {
    {
        match n {
            PatOrExpr::Expr { 0: _0 } => {
                _visitor.visit_expr(_0);
            }
            PatOrExpr::Pat { 0: _0 } => {
                _visitor.visit_pat(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_pats<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [Pat]) {
    {
        n.iter().for_each(|v| _visitor.visit_pat(v))
    }
}
#[allow(unused_variables)]
pub fn visit_private_method<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast PrivateMethod,
) {
    {
        match n {
            PrivateMethod {
                span,
                key,
                function,
                kind,
                is_static,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_private_name(key);
                _visitor.visit_function(function);
                _visitor.visit_method_kind(kind);
                _visitor.visit_opt_accessibility(accessibility.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_private_name<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast PrivateName) {
    {
        match n {
            PrivateName { span, id } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(id);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_private_prop<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast PrivateProp) {
    {
        match n {
            PrivateProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                computed,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_private_name(key);
                _visitor.visit_opt_expr(value.as_ref());
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
                _visitor.visit_decorators(decorators);
                _visitor.visit_opt_accessibility(accessibility.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_program<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Program) {
    {
        match n {
            Program::Module { 0: _0 } => {
                _visitor.visit_module(_0);
            }
            Program::Script { 0: _0 } => {
                _visitor.visit_script(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_prop<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Prop) {
    {
        match n {
            Prop::Shorthand { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
            Prop::KeyValue { 0: _0 } => {
                _visitor.visit_key_value_prop(_0);
            }
            Prop::Assign { 0: _0 } => {
                _visitor.visit_assign_prop(_0);
            }
            Prop::Getter { 0: _0 } => {
                _visitor.visit_getter_prop(_0);
            }
            Prop::Setter { 0: _0 } => {
                _visitor.visit_setter_prop(_0);
            }
            Prop::Method { 0: _0 } => {
                _visitor.visit_method_prop(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_prop_name<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast PropName) {
    {
        match n {
            PropName::Ident { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
            PropName::Str { 0: _0 } => {
                _visitor.visit_str(_0);
            }
            PropName::Num { 0: _0 } => {
                _visitor.visit_number(_0);
            }
            PropName::BigInt { 0: _0 } => {
                _visitor.visit_big_int(_0);
            }
            PropName::Computed { 0: _0 } => {
                _visitor.visit_computed_prop_name(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_prop_or_spread<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast PropOrSpread,
) {
    {
        match n {
            PropOrSpread::Spread { 0: _0 } => {
                _visitor.visit_spread_element(_0);
            }
            PropOrSpread::Prop { 0: _0 } => {
                _visitor.visit_prop(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_prop_or_spreads<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [PropOrSpread],
) {
    {
        n.iter().for_each(|v| _visitor.visit_prop_or_spread(v))
    }
}
#[allow(unused_variables)]
pub fn visit_regex<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Regex) {
    {
        match n {
            Regex { span, exp, flags } => {
                _visitor.visit_span(span);
                _visitor.visit_js_word(exp);
                _visitor.visit_js_word(flags);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_rest_pat<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast RestPat) {
    {
        match n {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_span(dot3_token);
                _visitor.visit_pat(arg);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_return_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ReturnStmt) {
    {
        match n {
            ReturnStmt { span, arg } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_expr(arg.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_script<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Script) {
    {
        match n {
            Script {
                span,
                body,
                shebang,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_stmts(body);
                _visitor.visit_opt_js_word(shebang.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_seq_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast SeqExpr) {
    {
        match n {
            SeqExpr { span, exprs } => {
                _visitor.visit_span(span);
                _visitor.visit_exprs(exprs);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_setter_prop<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast SetterProp) {
    {
        match n {
            SetterProp {
                span,
                key,
                param,
                body,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_prop_name(key);
                _visitor.visit_pat(param);
                _visitor.visit_opt_block_stmt(body.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_span<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Span) {
    {}
}
#[allow(unused_variables)]
pub fn visit_spread_element<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast SpreadElement,
) {
    {
        match n {
            SpreadElement { dot3_token, expr } => {
                _visitor.visit_span(dot3_token);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Stmt) {
    {
        match n {
            Stmt::Block { 0: _0 } => {
                _visitor.visit_block_stmt(_0);
            }
            Stmt::Empty { 0: _0 } => {
                _visitor.visit_empty_stmt(_0);
            }
            Stmt::Debugger { 0: _0 } => {
                _visitor.visit_debugger_stmt(_0);
            }
            Stmt::With { 0: _0 } => {
                _visitor.visit_with_stmt(_0);
            }
            Stmt::Return { 0: _0 } => {
                _visitor.visit_return_stmt(_0);
            }
            Stmt::Labeled { 0: _0 } => {
                _visitor.visit_labeled_stmt(_0);
            }
            Stmt::Break { 0: _0 } => {
                _visitor.visit_break_stmt(_0);
            }
            Stmt::Continue { 0: _0 } => {
                _visitor.visit_continue_stmt(_0);
            }
            Stmt::If { 0: _0 } => {
                _visitor.visit_if_stmt(_0);
            }
            Stmt::Switch { 0: _0 } => {
                _visitor.visit_switch_stmt(_0);
            }
            Stmt::Throw { 0: _0 } => {
                _visitor.visit_throw_stmt(_0);
            }
            Stmt::Try { 0: _0 } => {
                _visitor.visit_try_stmt(_0);
            }
            Stmt::While { 0: _0 } => {
                _visitor.visit_while_stmt(_0);
            }
            Stmt::DoWhile { 0: _0 } => {
                _visitor.visit_do_while_stmt(_0);
            }
            Stmt::For { 0: _0 } => {
                _visitor.visit_for_stmt(_0);
            }
            Stmt::ForIn { 0: _0 } => {
                _visitor.visit_for_in_stmt(_0);
            }
            Stmt::ForOf { 0: _0 } => {
                _visitor.visit_for_of_stmt(_0);
            }
            Stmt::Decl { 0: _0 } => {
                _visitor.visit_decl(_0);
            }
            Stmt::Expr { 0: _0 } => {
                _visitor.visit_expr_stmt(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_stmts<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [Stmt]) {
    {
        n.iter().for_each(|v| _visitor.visit_stmt(v))
    }
}
#[allow(unused_variables)]
pub fn visit_str<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Str) {
    {
        match n {
            Str {
                span,
                value,
                has_escape,
                kind,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_js_word(value);
                _visitor.visit_str_kind(kind);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_str_kind<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast StrKind) {
    {}
}
#[allow(unused_variables)]
pub fn visit_super<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Super) {
    {
        match n {
            Super { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_switch_case<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast SwitchCase) {
    {
        match n {
            SwitchCase { span, test, cons } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_expr(test.as_ref());
                _visitor.visit_stmts(cons);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_switch_cases<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [SwitchCase]) {
    {
        n.iter().for_each(|v| _visitor.visit_switch_case(v))
    }
}
#[allow(unused_variables)]
pub fn visit_switch_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast SwitchStmt) {
    {
        match n {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(discriminant);
                _visitor.visit_switch_cases(cases);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_tagged_tpl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TaggedTpl) {
    {
        match n {
            TaggedTpl {
                span,
                tag,
                type_params,
                tpl,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(tag);
                _visitor.visit_opt_ts_type_param_instantiation(type_params.as_ref());
                _visitor.visit_tpl(tpl);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_this_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ThisExpr) {
    {
        match n {
            ThisExpr { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_throw_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast ThrowStmt) {
    {
        match n {
            ThrowStmt { span, arg } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(arg);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_tpl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast Tpl) {
    {
        match n {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_exprs(exprs);
                _visitor.visit_tpl_elements(quasis);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_tpl_element<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TplElement) {
    {
        match n {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_str(cooked.as_ref());
                _visitor.visit_str(raw);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_tpl_elements<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [TplElement]) {
    {
        n.iter().for_each(|v| _visitor.visit_tpl_element(v))
    }
}
#[allow(unused_variables)]
pub fn visit_true_plus_minus<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TruePlusMinus,
) {
    {
        match n {
            TruePlusMinus::True {} => {}
            TruePlusMinus::Plus {} => {}
            TruePlusMinus::Minus {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_try_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TryStmt) {
    {
        match n {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_block_stmt(block);
                _visitor.visit_opt_catch_clause(handler.as_ref());
                _visitor.visit_opt_block_stmt(finalizer.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_array_type<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsArrayType) {
    {
        match n {
            TsArrayType { span, elem_type } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type(elem_type);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_as_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsAsExpr) {
    {
        match n {
            TsAsExpr {
                span,
                expr,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
                _visitor.visit_ts_type(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_call_signature_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsCallSignatureDecl,
) {
    {
        match n {
            TsCallSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_fn_params(params);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_conditional_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsConditionalType,
) {
    {
        match n {
            TsConditionalType {
                span,
                check_type,
                extends_type,
                true_type,
                false_type,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type(check_type);
                _visitor.visit_ts_type(extends_type);
                _visitor.visit_ts_type(true_type);
                _visitor.visit_ts_type(false_type);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_const_assertion<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsConstAssertion,
) {
    {
        match n {
            TsConstAssertion { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_construct_signature_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsConstructSignatureDecl,
) {
    {
        match n {
            TsConstructSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_fn_params(params);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_constructor_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsConstructorType,
) {
    {
        match n {
            TsConstructorType {
                span,
                params,
                type_params,
                type_ann,
                is_abstract,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_fn_params(params);
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
                _visitor.visit_ts_type_ann(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_entity_name<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsEntityName,
) {
    {
        match n {
            TsEntityName::TsQualifiedName { 0: _0 } => {
                _visitor.visit_ts_qualified_name(_0);
            }
            TsEntityName::Ident { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_enum_decl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsEnumDecl) {
    {
        match n {
            TsEnumDecl {
                span,
                declare,
                is_const,
                id,
                members,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(id);
                _visitor.visit_ts_enum_members(members);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_enum_member<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsEnumMember,
) {
    {
        match n {
            TsEnumMember { span, id, init } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_enum_member_id(id);
                _visitor.visit_opt_expr(init.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_enum_member_id<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsEnumMemberId,
) {
    {
        match n {
            TsEnumMemberId::Ident { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
            TsEnumMemberId::Str { 0: _0 } => {
                _visitor.visit_str(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_enum_members<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [TsEnumMember],
) {
    {
        n.iter().for_each(|v| _visitor.visit_ts_enum_member(v))
    }
}
#[allow(unused_variables)]
pub fn visit_ts_export_assignment<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsExportAssignment,
) {
    {
        match n {
            TsExportAssignment { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_expr_with_type_args<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsExprWithTypeArgs,
) {
    {
        match n {
            TsExprWithTypeArgs {
                span,
                expr,
                type_args,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_entity_name(expr);
                _visitor.visit_opt_ts_type_param_instantiation(type_args.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_expr_with_type_args_vec<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [TsExprWithTypeArgs],
) {
    {
        n.iter()
            .for_each(|v| _visitor.visit_ts_expr_with_type_args(v))
    }
}
#[allow(unused_variables)]
pub fn visit_ts_external_module_ref<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsExternalModuleRef,
) {
    {
        match n {
            TsExternalModuleRef { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_str(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_fn_or_constructor_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsFnOrConstructorType,
) {
    {
        match n {
            TsFnOrConstructorType::TsFnType { 0: _0 } => {
                _visitor.visit_ts_fn_type(_0);
            }
            TsFnOrConstructorType::TsConstructorType { 0: _0 } => {
                _visitor.visit_ts_constructor_type(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_fn_param<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsFnParam) {
    {
        match n {
            TsFnParam::Ident { 0: _0 } => {
                _visitor.visit_binding_ident(_0);
            }
            TsFnParam::Array { 0: _0 } => {
                _visitor.visit_array_pat(_0);
            }
            TsFnParam::Rest { 0: _0 } => {
                _visitor.visit_rest_pat(_0);
            }
            TsFnParam::Object { 0: _0 } => {
                _visitor.visit_object_pat(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_fn_params<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [TsFnParam]) {
    {
        n.iter().for_each(|v| _visitor.visit_ts_fn_param(v))
    }
}
#[allow(unused_variables)]
pub fn visit_ts_fn_type<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsFnType) {
    {
        match n {
            TsFnType {
                span,
                params,
                type_params,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_fn_params(params);
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
                _visitor.visit_ts_type_ann(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_getter_signature<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsGetterSignature,
) {
    {
        match n {
            TsGetterSignature {
                span,
                readonly,
                key,
                computed,
                optional,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(key);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_import_equals_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsImportEqualsDecl,
) {
    {
        match n {
            TsImportEqualsDecl {
                span,
                declare,
                is_export,
                is_type_only,
                id,
                module_ref,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(id);
                _visitor.visit_ts_module_ref(module_ref);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_import_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsImportType,
) {
    {
        match n {
            TsImportType {
                span,
                arg,
                qualifier,
                type_args,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_str(arg);
                _visitor.visit_opt_ts_entity_name(qualifier.as_ref());
                _visitor.visit_opt_ts_type_param_instantiation(type_args.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_index_signature<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsIndexSignature,
) {
    {
        match n {
            TsIndexSignature {
                params,
                type_ann,
                readonly,
                is_static,
                span,
            } => {
                _visitor.visit_ts_fn_params(params);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_indexed_access_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsIndexedAccessType,
) {
    {
        match n {
            TsIndexedAccessType {
                span,
                readonly,
                obj_type,
                index_type,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type(obj_type);
                _visitor.visit_ts_type(index_type);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_infer_type<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsInferType) {
    {
        match n {
            TsInferType { span, type_param } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type_param(type_param);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_interface_body<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsInterfaceBody,
) {
    {
        match n {
            TsInterfaceBody { span, body } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type_elements(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_interface_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsInterfaceDecl,
) {
    {
        match n {
            TsInterfaceDecl {
                span,
                id,
                declare,
                type_params,
                extends,
                body,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(id);
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
                _visitor.visit_ts_expr_with_type_args_vec(extends);
                _visitor.visit_ts_interface_body(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_intersection_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsIntersectionType,
) {
    {
        match n {
            TsIntersectionType { span, types } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_types(types);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_keyword_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsKeywordType,
) {
    {
        match n {
            TsKeywordType { span, kind } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_keyword_type_kind(kind);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_keyword_type_kind<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsKeywordTypeKind,
) {
    {
        match n {
            TsKeywordTypeKind::TsAnyKeyword {} => {}
            TsKeywordTypeKind::TsUnknownKeyword {} => {}
            TsKeywordTypeKind::TsNumberKeyword {} => {}
            TsKeywordTypeKind::TsObjectKeyword {} => {}
            TsKeywordTypeKind::TsBooleanKeyword {} => {}
            TsKeywordTypeKind::TsBigIntKeyword {} => {}
            TsKeywordTypeKind::TsStringKeyword {} => {}
            TsKeywordTypeKind::TsSymbolKeyword {} => {}
            TsKeywordTypeKind::TsVoidKeyword {} => {}
            TsKeywordTypeKind::TsUndefinedKeyword {} => {}
            TsKeywordTypeKind::TsNullKeyword {} => {}
            TsKeywordTypeKind::TsNeverKeyword {} => {}
            TsKeywordTypeKind::TsIntrinsicKeyword {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_lit<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsLit) {
    {
        match n {
            TsLit::BigInt { 0: _0 } => {
                _visitor.visit_big_int(_0);
            }
            TsLit::Number { 0: _0 } => {
                _visitor.visit_number(_0);
            }
            TsLit::Str { 0: _0 } => {
                _visitor.visit_str(_0);
            }
            TsLit::Bool { 0: _0 } => {
                _visitor.visit_bool(_0);
            }
            TsLit::Tpl { 0: _0 } => {
                _visitor.visit_ts_tpl_lit_type(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_lit_type<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsLitType) {
    {
        match n {
            TsLitType { span, lit } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_lit(lit);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_mapped_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsMappedType,
) {
    {
        match n {
            TsMappedType {
                span,
                readonly,
                type_param,
                name_type,
                optional,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_true_plus_minus(readonly.as_ref());
                _visitor.visit_ts_type_param(type_param);
                _visitor.visit_opt_ts_type(name_type.as_ref());
                _visitor.visit_opt_true_plus_minus(optional.as_ref());
                _visitor.visit_opt_ts_type(type_ann.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_method_signature<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsMethodSignature,
) {
    {
        match n {
            TsMethodSignature {
                span,
                readonly,
                key,
                computed,
                optional,
                params,
                type_ann,
                type_params,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(key);
                _visitor.visit_ts_fn_params(params);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_module_block<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsModuleBlock,
) {
    {
        match n {
            TsModuleBlock { span, body } => {
                _visitor.visit_span(span);
                _visitor.visit_module_items(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_module_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsModuleDecl,
) {
    {
        match n {
            TsModuleDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_module_name(id);
                _visitor.visit_opt_ts_namespace_body(body.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_module_name<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsModuleName,
) {
    {
        match n {
            TsModuleName::Ident { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
            TsModuleName::Str { 0: _0 } => {
                _visitor.visit_str(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_module_ref<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsModuleRef) {
    {
        match n {
            TsModuleRef::TsEntityName { 0: _0 } => {
                _visitor.visit_ts_entity_name(_0);
            }
            TsModuleRef::TsExternalModuleRef { 0: _0 } => {
                _visitor.visit_ts_external_module_ref(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_namespace_body<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsNamespaceBody,
) {
    {
        match n {
            TsNamespaceBody::TsModuleBlock { 0: _0 } => {
                _visitor.visit_ts_module_block(_0);
            }
            TsNamespaceBody::TsNamespaceDecl { 0: _0 } => {
                _visitor.visit_ts_namespace_decl(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_namespace_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsNamespaceDecl,
) {
    {
        match n {
            TsNamespaceDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(id);
                _visitor.visit_ts_namespace_body(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_namespace_export_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsNamespaceExportDecl,
) {
    {
        match n {
            TsNamespaceExportDecl { span, id } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(id);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_non_null_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsNonNullExpr,
) {
    {
        match n {
            TsNonNullExpr { span, expr } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_optional_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsOptionalType,
) {
    {
        match n {
            TsOptionalType { span, type_ann } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_param_prop<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsParamProp) {
    {
        match n {
            TsParamProp {
                span,
                decorators,
                accessibility,
                is_override,
                readonly,
                param,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_decorators(decorators);
                _visitor.visit_opt_accessibility(accessibility.as_ref());
                _visitor.visit_ts_param_prop_param(param);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_param_prop_param<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsParamPropParam,
) {
    {
        match n {
            TsParamPropParam::Ident { 0: _0 } => {
                _visitor.visit_binding_ident(_0);
            }
            TsParamPropParam::Assign { 0: _0 } => {
                _visitor.visit_assign_pat(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_parenthesized_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsParenthesizedType,
) {
    {
        match n {
            TsParenthesizedType { span, type_ann } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_property_signature<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsPropertySignature,
) {
    {
        match n {
            TsPropertySignature {
                span,
                readonly,
                key,
                computed,
                optional,
                init,
                params,
                type_ann,
                type_params,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(key);
                _visitor.visit_opt_expr(init.as_ref());
                _visitor.visit_ts_fn_params(params);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_qualified_name<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsQualifiedName,
) {
    {
        match n {
            TsQualifiedName { left, right } => {
                _visitor.visit_ts_entity_name(left);
                _visitor.visit_ident(right);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_rest_type<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsRestType) {
    {
        match n {
            TsRestType { span, type_ann } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_setter_signature<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsSetterSignature,
) {
    {
        match n {
            TsSetterSignature {
                span,
                readonly,
                key,
                computed,
                optional,
                param,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(key);
                _visitor.visit_ts_fn_param(param);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_this_type<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsThisType) {
    {
        match n {
            TsThisType { span } => {
                _visitor.visit_span(span);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_this_type_or_ident<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsThisTypeOrIdent,
) {
    {
        match n {
            TsThisTypeOrIdent::TsThisType { 0: _0 } => {
                _visitor.visit_ts_this_type(_0);
            }
            TsThisTypeOrIdent::Ident { 0: _0 } => {
                _visitor.visit_ident(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_tpl_lit_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTplLitType,
) {
    {
        match n {
            TsTplLitType {
                span,
                types,
                quasis,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_types(types);
                _visitor.visit_tpl_elements(quasis);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_tuple_element<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTupleElement,
) {
    {
        match n {
            TsTupleElement { span, label, ty } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_pat(label.as_ref());
                _visitor.visit_ts_type(ty);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_tuple_elements<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [TsTupleElement],
) {
    {
        n.iter().for_each(|v| _visitor.visit_ts_tuple_element(v))
    }
}
#[allow(unused_variables)]
pub fn visit_ts_tuple_type<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsTupleType) {
    {
        match n {
            TsTupleType { span, elem_types } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_tuple_elements(elem_types);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsType) {
    {
        match n {
            TsType::TsKeywordType { 0: _0 } => {
                _visitor.visit_ts_keyword_type(_0);
            }
            TsType::TsThisType { 0: _0 } => {
                _visitor.visit_ts_this_type(_0);
            }
            TsType::TsFnOrConstructorType { 0: _0 } => {
                _visitor.visit_ts_fn_or_constructor_type(_0);
            }
            TsType::TsTypeRef { 0: _0 } => {
                _visitor.visit_ts_type_ref(_0);
            }
            TsType::TsTypeQuery { 0: _0 } => {
                _visitor.visit_ts_type_query(_0);
            }
            TsType::TsTypeLit { 0: _0 } => {
                _visitor.visit_ts_type_lit(_0);
            }
            TsType::TsArrayType { 0: _0 } => {
                _visitor.visit_ts_array_type(_0);
            }
            TsType::TsTupleType { 0: _0 } => {
                _visitor.visit_ts_tuple_type(_0);
            }
            TsType::TsOptionalType { 0: _0 } => {
                _visitor.visit_ts_optional_type(_0);
            }
            TsType::TsRestType { 0: _0 } => {
                _visitor.visit_ts_rest_type(_0);
            }
            TsType::TsUnionOrIntersectionType { 0: _0 } => {
                _visitor.visit_ts_union_or_intersection_type(_0);
            }
            TsType::TsConditionalType { 0: _0 } => {
                _visitor.visit_ts_conditional_type(_0);
            }
            TsType::TsInferType { 0: _0 } => {
                _visitor.visit_ts_infer_type(_0);
            }
            TsType::TsParenthesizedType { 0: _0 } => {
                _visitor.visit_ts_parenthesized_type(_0);
            }
            TsType::TsTypeOperator { 0: _0 } => {
                _visitor.visit_ts_type_operator(_0);
            }
            TsType::TsIndexedAccessType { 0: _0 } => {
                _visitor.visit_ts_indexed_access_type(_0);
            }
            TsType::TsMappedType { 0: _0 } => {
                _visitor.visit_ts_mapped_type(_0);
            }
            TsType::TsLitType { 0: _0 } => {
                _visitor.visit_ts_lit_type(_0);
            }
            TsType::TsTypePredicate { 0: _0 } => {
                _visitor.visit_ts_type_predicate(_0);
            }
            TsType::TsImportType { 0: _0 } => {
                _visitor.visit_ts_import_type(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_alias_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTypeAliasDecl,
) {
    {
        match n {
            TsTypeAliasDecl {
                span,
                declare,
                id,
                type_params,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(id);
                _visitor.visit_opt_ts_type_param_decl(type_params.as_ref());
                _visitor.visit_ts_type(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_ann<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsTypeAnn) {
    {
        match n {
            TsTypeAnn { span, type_ann } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_assertion<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTypeAssertion,
) {
    {
        match n {
            TsTypeAssertion {
                span,
                expr,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(expr);
                _visitor.visit_ts_type(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_element<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTypeElement,
) {
    {
        match n {
            TsTypeElement::TsCallSignatureDecl { 0: _0 } => {
                _visitor.visit_ts_call_signature_decl(_0);
            }
            TsTypeElement::TsConstructSignatureDecl { 0: _0 } => {
                _visitor.visit_ts_construct_signature_decl(_0);
            }
            TsTypeElement::TsPropertySignature { 0: _0 } => {
                _visitor.visit_ts_property_signature(_0);
            }
            TsTypeElement::TsGetterSignature { 0: _0 } => {
                _visitor.visit_ts_getter_signature(_0);
            }
            TsTypeElement::TsSetterSignature { 0: _0 } => {
                _visitor.visit_ts_setter_signature(_0);
            }
            TsTypeElement::TsMethodSignature { 0: _0 } => {
                _visitor.visit_ts_method_signature(_0);
            }
            TsTypeElement::TsIndexSignature { 0: _0 } => {
                _visitor.visit_ts_index_signature(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_elements<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [TsTypeElement],
) {
    {
        n.iter().for_each(|v| _visitor.visit_ts_type_element(v))
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_lit<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsTypeLit) {
    {
        match n {
            TsTypeLit { span, members } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type_elements(members);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_operator<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTypeOperator,
) {
    {
        match n {
            TsTypeOperator { span, op, type_ann } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type_operator_op(op);
                _visitor.visit_ts_type(type_ann);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_operator_op<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTypeOperatorOp,
) {
    {
        match n {
            TsTypeOperatorOp::KeyOf {} => {}
            TsTypeOperatorOp::Unique {} => {}
            TsTypeOperatorOp::ReadOnly {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_param<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsTypeParam) {
    {
        match n {
            TsTypeParam {
                span,
                name,
                constraint,
                default,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ident(name);
                _visitor.visit_opt_ts_type(constraint.as_ref());
                _visitor.visit_opt_ts_type(default.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_param_decl<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTypeParamDecl,
) {
    {
        match n {
            TsTypeParamDecl { span, params } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type_params(params);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_param_instantiation<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTypeParamInstantiation,
) {
    {
        match n {
            TsTypeParamInstantiation { span, params } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_types(params);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_params<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [TsTypeParam],
) {
    {
        n.iter().for_each(|v| _visitor.visit_ts_type_param(v))
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_predicate<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTypePredicate,
) {
    {
        match n {
            TsTypePredicate {
                span,
                asserts,
                param_name,
                type_ann,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_this_type_or_ident(param_name);
                _visitor.visit_opt_ts_type_ann(type_ann.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_query<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsTypeQuery) {
    {
        match n {
            TsTypeQuery { span, expr_name } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_type_query_expr(expr_name);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_query_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsTypeQueryExpr,
) {
    {
        match n {
            TsTypeQueryExpr::TsEntityName { 0: _0 } => {
                _visitor.visit_ts_entity_name(_0);
            }
            TsTypeQueryExpr::Import { 0: _0 } => {
                _visitor.visit_ts_import_type(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_type_ref<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsTypeRef) {
    {
        match n {
            TsTypeRef {
                span,
                type_name,
                type_params,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_entity_name(type_name);
                _visitor.visit_opt_ts_type_param_instantiation(type_params.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_types<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast [Box<TsType>]) {
    {
        n.iter().for_each(|v| _visitor.visit_ts_type(v))
    }
}
#[allow(unused_variables)]
pub fn visit_ts_union_or_intersection_type<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast TsUnionOrIntersectionType,
) {
    {
        match n {
            TsUnionOrIntersectionType::TsUnionType { 0: _0 } => {
                _visitor.visit_ts_union_type(_0);
            }
            TsUnionOrIntersectionType::TsIntersectionType { 0: _0 } => {
                _visitor.visit_ts_intersection_type(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_ts_union_type<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast TsUnionType) {
    {
        match n {
            TsUnionType { span, types } => {
                _visitor.visit_span(span);
                _visitor.visit_ts_types(types);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_unary_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast UnaryExpr) {
    {
        match n {
            UnaryExpr { span, op, arg } => {
                _visitor.visit_span(span);
                _visitor.visit_unary_op(op);
                _visitor.visit_expr(arg);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_unary_op<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast UnaryOp) {
    {
        match n {
            UnaryOp::Minus {} => {}
            UnaryOp::Plus {} => {}
            UnaryOp::Bang {} => {}
            UnaryOp::Tilde {} => {}
            UnaryOp::TypeOf {} => {}
            UnaryOp::Void {} => {}
            UnaryOp::Delete {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_update_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast UpdateExpr) {
    {
        match n {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_update_op(op);
                _visitor.visit_expr(arg);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_update_op<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast UpdateOp) {
    {
        match n {
            UpdateOp::PlusPlus {} => {}
            UpdateOp::MinusMinus {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_var_decl<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast VarDecl) {
    {
        match n {
            VarDecl {
                span,
                kind,
                declare,
                decls,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_var_decl_kind(kind);
                _visitor.visit_var_declarators(decls);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_var_decl_kind<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast VarDeclKind) {
    {
        match n {
            VarDeclKind::Var {} => {}
            VarDeclKind::Let {} => {}
            VarDeclKind::Const {} => {}
        }
    }
}
#[allow(unused_variables)]
pub fn visit_var_decl_or_expr<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast VarDeclOrExpr,
) {
    {
        match n {
            VarDeclOrExpr::VarDecl { 0: _0 } => {
                _visitor.visit_var_decl(_0);
            }
            VarDeclOrExpr::Expr { 0: _0 } => {
                _visitor.visit_expr(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_var_decl_or_pat<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast VarDeclOrPat,
) {
    {
        match n {
            VarDeclOrPat::VarDecl { 0: _0 } => {
                _visitor.visit_var_decl(_0);
            }
            VarDeclOrPat::Pat { 0: _0 } => {
                _visitor.visit_pat(_0);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_var_declarator<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast VarDeclarator,
) {
    {
        match n {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_pat(name);
                _visitor.visit_opt_expr(init.as_ref());
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_var_declarators<'ast, V: ?Sized + Visit<'ast>>(
    _visitor: &mut V,
    n: &'ast [VarDeclarator],
) {
    {
        n.iter().for_each(|v| _visitor.visit_var_declarator(v))
    }
}
#[allow(unused_variables)]
pub fn visit_while_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast WhileStmt) {
    {
        match n {
            WhileStmt { span, test, body } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(test);
                _visitor.visit_stmt(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_with_stmt<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast WithStmt) {
    {
        match n {
            WithStmt { span, obj, body } => {
                _visitor.visit_span(span);
                _visitor.visit_expr(obj);
                _visitor.visit_stmt(body);
            }
        }
    }
}
#[allow(unused_variables)]
pub fn visit_yield_expr<'ast, V: ?Sized + Visit<'ast>>(_visitor: &mut V, n: &'ast YieldExpr) {
    {
        match n {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                _visitor.visit_span(span);
                _visitor.visit_opt_expr(arg.as_ref());
            }
        }
    }
}
pub trait Visit<'ast> {
    #[allow(unused_variables)]
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        visit_accessibility(self, n)
    }
    #[allow(unused_variables)]
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        visit_array_lit(self, n)
    }
    #[allow(unused_variables)]
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        visit_array_pat(self, n)
    }
    #[allow(unused_variables)]
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        visit_arrow_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        visit_assign_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        visit_assign_op(self, n)
    }
    #[allow(unused_variables)]
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        visit_assign_pat(self, n)
    }
    #[allow(unused_variables)]
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        visit_assign_pat_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        visit_assign_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        visit_await_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        visit_big_int(self, n)
    }
    #[allow(unused_variables)]
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        visit_big_int_value(self, n)
    }
    #[allow(unused_variables)]
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        visit_bin_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        visit_binary_op(self, n)
    }
    #[allow(unused_variables)]
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        visit_binding_ident(self, n)
    }
    #[allow(unused_variables)]
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        visit_block_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        visit_block_stmt_or_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_bool(&mut self, n: &'ast Bool) {
        visit_bool(self, n)
    }
    #[allow(unused_variables)]
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        visit_break_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        visit_call_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        visit_catch_clause(self, n)
    }
    #[allow(unused_variables)]
    fn visit_class(&mut self, n: &'ast Class) {
        visit_class(self, n)
    }
    #[allow(unused_variables)]
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        visit_class_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        visit_class_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        visit_class_member(self, n)
    }
    #[allow(unused_variables)]
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        visit_class_members(self, n)
    }
    #[allow(unused_variables)]
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        visit_class_method(self, n)
    }
    #[allow(unused_variables)]
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        visit_class_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        visit_computed_prop_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        visit_cond_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        visit_constructor(self, n)
    }
    #[allow(unused_variables)]
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        visit_continue_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        visit_debugger_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_decl(&mut self, n: &'ast Decl) {
        visit_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        visit_decorator(self, n)
    }
    #[allow(unused_variables)]
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        visit_decorators(self, n)
    }
    #[allow(unused_variables)]
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        visit_default_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        visit_do_while_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        visit_empty_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        visit_export_all(self, n)
    }
    #[allow(unused_variables)]
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        visit_export_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        visit_export_default_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        visit_export_default_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        visit_export_default_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        visit_export_named_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        visit_export_namespace_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        visit_export_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        visit_export_specifiers(self, n)
    }
    #[allow(unused_variables)]
    fn visit_expr(&mut self, n: &'ast Expr) {
        visit_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        visit_expr_or_spread(self, n)
    }
    #[allow(unused_variables)]
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        visit_expr_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        visit_expr_or_super(self, n)
    }
    #[allow(unused_variables)]
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        visit_expr_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        visit_exprs(self, n)
    }
    #[allow(unused_variables)]
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        visit_fn_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        visit_fn_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        visit_for_in_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        visit_for_of_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        visit_for_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_function(&mut self, n: &'ast Function) {
        visit_function(self, n)
    }
    #[allow(unused_variables)]
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        visit_getter_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ident(&mut self, n: &'ast Ident) {
        visit_ident(self, n)
    }
    #[allow(unused_variables)]
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        visit_if_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        visit_import_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        visit_import_default_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        visit_import_named_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        visit_import_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        visit_import_specifiers(self, n)
    }
    #[allow(unused_variables)]
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        visit_import_star_as_specifier(self, n)
    }
    #[allow(unused_variables)]
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        visit_invalid(self, n)
    }
    #[allow(unused_variables)]
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        visit_js_word(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        visit_jsx_attr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        visit_jsx_attr_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        visit_jsx_attr_or_spread(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        visit_jsx_attr_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        visit_jsx_attr_value(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        visit_jsx_closing_element(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        visit_jsx_closing_fragment(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        visit_jsx_element(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        visit_jsx_element_child(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        visit_jsx_element_children(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        visit_jsx_element_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        visit_jsx_empty_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        visit_jsx_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        visit_jsx_expr_container(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        visit_jsx_fragment(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        visit_jsx_member_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        visit_jsx_namespaced_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        visit_jsx_object(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        visit_jsx_opening_element(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        visit_jsx_opening_fragment(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        visit_jsx_spread_child(self, n)
    }
    #[allow(unused_variables)]
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        visit_jsx_text(self, n)
    }
    #[allow(unused_variables)]
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        visit_key_value_pat_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        visit_key_value_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        visit_labeled_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_lit(&mut self, n: &'ast Lit) {
        visit_lit(self, n)
    }
    #[allow(unused_variables)]
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        visit_member_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        visit_meta_prop_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        visit_method_kind(self, n)
    }
    #[allow(unused_variables)]
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        visit_method_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_module(&mut self, n: &'ast Module) {
        visit_module(self, n)
    }
    #[allow(unused_variables)]
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        visit_module_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        visit_module_item(self, n)
    }
    #[allow(unused_variables)]
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        visit_module_items(self, n)
    }
    #[allow(unused_variables)]
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        visit_named_export(self, n)
    }
    #[allow(unused_variables)]
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        visit_new_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_null(&mut self, n: &'ast Null) {
        visit_null(self, n)
    }
    #[allow(unused_variables)]
    fn visit_number(&mut self, n: &'ast Number) {
        visit_number(self, n)
    }
    #[allow(unused_variables)]
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        visit_object_lit(self, n)
    }
    #[allow(unused_variables)]
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        visit_object_pat(self, n)
    }
    #[allow(unused_variables)]
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        visit_object_pat_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        visit_object_pat_props(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        visit_opt_accessibility(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        visit_opt_block_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        visit_opt_catch_clause(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        visit_opt_chain_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        visit_opt_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        visit_opt_expr_or_spread(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        visit_opt_expr_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        visit_opt_ident(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        visit_opt_js_word(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        visit_opt_jsx_attr_value(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        visit_opt_jsx_closing_element(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        visit_opt_object_lit(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        visit_opt_pat(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        visit_opt_span(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        visit_opt_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        visit_opt_str(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        visit_opt_true_plus_minus(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        visit_opt_ts_entity_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        visit_opt_ts_namespace_body(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        visit_opt_ts_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        visit_opt_ts_type_ann(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        visit_opt_ts_type_param_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        visit_opt_ts_type_param_instantiation(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        visit_opt_var_decl_or_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        visit_opt_vec_expr_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        visit_opt_vec_pats(self, n)
    }
    #[allow(unused_variables)]
    fn visit_param(&mut self, n: &'ast Param) {
        visit_param(self, n)
    }
    #[allow(unused_variables)]
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        visit_param_or_ts_param_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        visit_param_or_ts_param_props(self, n)
    }
    #[allow(unused_variables)]
    fn visit_params(&mut self, n: &'ast [Param]) {
        visit_params(self, n)
    }
    #[allow(unused_variables)]
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        visit_paren_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_pat(&mut self, n: &'ast Pat) {
        visit_pat(self, n)
    }
    #[allow(unused_variables)]
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        visit_pat_or_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        visit_pats(self, n)
    }
    #[allow(unused_variables)]
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        visit_private_method(self, n)
    }
    #[allow(unused_variables)]
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        visit_private_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        visit_private_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_program(&mut self, n: &'ast Program) {
        visit_program(self, n)
    }
    #[allow(unused_variables)]
    fn visit_prop(&mut self, n: &'ast Prop) {
        visit_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        visit_prop_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        visit_prop_or_spread(self, n)
    }
    #[allow(unused_variables)]
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        visit_prop_or_spreads(self, n)
    }
    #[allow(unused_variables)]
    fn visit_regex(&mut self, n: &'ast Regex) {
        visit_regex(self, n)
    }
    #[allow(unused_variables)]
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        visit_rest_pat(self, n)
    }
    #[allow(unused_variables)]
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        visit_return_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_script(&mut self, n: &'ast Script) {
        visit_script(self, n)
    }
    #[allow(unused_variables)]
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        visit_seq_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        visit_setter_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_span(&mut self, n: &'ast Span) {
        visit_span(self, n)
    }
    #[allow(unused_variables)]
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        visit_spread_element(self, n)
    }
    #[allow(unused_variables)]
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        visit_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        visit_stmts(self, n)
    }
    #[allow(unused_variables)]
    fn visit_str(&mut self, n: &'ast Str) {
        visit_str(self, n)
    }
    #[allow(unused_variables)]
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        visit_str_kind(self, n)
    }
    #[allow(unused_variables)]
    fn visit_super(&mut self, n: &'ast Super) {
        visit_super(self, n)
    }
    #[allow(unused_variables)]
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        visit_switch_case(self, n)
    }
    #[allow(unused_variables)]
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        visit_switch_cases(self, n)
    }
    #[allow(unused_variables)]
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        visit_switch_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        visit_tagged_tpl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        visit_this_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        visit_throw_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        visit_tpl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        visit_tpl_element(self, n)
    }
    #[allow(unused_variables)]
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        visit_tpl_elements(self, n)
    }
    #[allow(unused_variables)]
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        visit_true_plus_minus(self, n)
    }
    #[allow(unused_variables)]
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        visit_try_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        visit_ts_array_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        visit_ts_as_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        visit_ts_call_signature_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        visit_ts_conditional_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        visit_ts_const_assertion(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        visit_ts_construct_signature_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        visit_ts_constructor_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        visit_ts_entity_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        visit_ts_enum_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        visit_ts_enum_member(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        visit_ts_enum_member_id(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        visit_ts_enum_members(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        visit_ts_export_assignment(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        visit_ts_expr_with_type_args(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        visit_ts_expr_with_type_args_vec(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        visit_ts_external_module_ref(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        visit_ts_fn_or_constructor_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        visit_ts_fn_param(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        visit_ts_fn_params(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        visit_ts_fn_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        visit_ts_getter_signature(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        visit_ts_import_equals_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        visit_ts_import_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        visit_ts_index_signature(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        visit_ts_indexed_access_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        visit_ts_infer_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        visit_ts_interface_body(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        visit_ts_interface_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        visit_ts_intersection_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        visit_ts_keyword_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        visit_ts_keyword_type_kind(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        visit_ts_lit(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        visit_ts_lit_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        visit_ts_mapped_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        visit_ts_method_signature(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        visit_ts_module_block(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        visit_ts_module_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        visit_ts_module_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        visit_ts_module_ref(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        visit_ts_namespace_body(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        visit_ts_namespace_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        visit_ts_namespace_export_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        visit_ts_non_null_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        visit_ts_optional_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        visit_ts_param_prop(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        visit_ts_param_prop_param(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        visit_ts_parenthesized_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        visit_ts_property_signature(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        visit_ts_qualified_name(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        visit_ts_rest_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        visit_ts_setter_signature(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        visit_ts_this_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        visit_ts_this_type_or_ident(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        visit_ts_tpl_lit_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        visit_ts_tuple_element(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        visit_ts_tuple_elements(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        visit_ts_tuple_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        visit_ts_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        visit_ts_type_alias_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        visit_ts_type_ann(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        visit_ts_type_assertion(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        visit_ts_type_element(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        visit_ts_type_elements(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        visit_ts_type_lit(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        visit_ts_type_operator(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        visit_ts_type_operator_op(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        visit_ts_type_param(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        visit_ts_type_param_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        visit_ts_type_param_instantiation(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        visit_ts_type_params(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        visit_ts_type_predicate(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        visit_ts_type_query(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        visit_ts_type_query_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        visit_ts_type_ref(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        visit_ts_types(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        visit_ts_union_or_intersection_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        visit_ts_union_type(self, n)
    }
    #[allow(unused_variables)]
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        visit_unary_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        visit_unary_op(self, n)
    }
    #[allow(unused_variables)]
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        visit_update_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        visit_update_op(self, n)
    }
    #[allow(unused_variables)]
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        visit_var_decl(self, n)
    }
    #[allow(unused_variables)]
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        visit_var_decl_kind(self, n)
    }
    #[allow(unused_variables)]
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        visit_var_decl_or_expr(self, n)
    }
    #[allow(unused_variables)]
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        visit_var_decl_or_pat(self, n)
    }
    #[allow(unused_variables)]
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        visit_var_declarator(self, n)
    }
    #[allow(unused_variables)]
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        visit_var_declarators(self, n)
    }
    #[allow(unused_variables)]
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        visit_while_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        visit_with_stmt(self, n)
    }
    #[allow(unused_variables)]
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        visit_yield_expr(self, n)
    }
}
impl<'a, 'ast, V> Visit<'ast> for &'a mut V
where
    V: ?Sized + Visit<'ast>,
{
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        (**self).visit_accessibility(n)
    }
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        (**self).visit_array_lit(n)
    }
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        (**self).visit_array_pat(n)
    }
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        (**self).visit_arrow_expr(n)
    }
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        (**self).visit_assign_expr(n)
    }
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        (**self).visit_assign_op(n)
    }
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        (**self).visit_assign_pat(n)
    }
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        (**self).visit_assign_pat_prop(n)
    }
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        (**self).visit_assign_prop(n)
    }
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        (**self).visit_await_expr(n)
    }
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        (**self).visit_big_int(n)
    }
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        (**self).visit_big_int_value(n)
    }
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        (**self).visit_bin_expr(n)
    }
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        (**self).visit_binary_op(n)
    }
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        (**self).visit_binding_ident(n)
    }
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        (**self).visit_block_stmt(n)
    }
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        (**self).visit_block_stmt_or_expr(n)
    }
    fn visit_bool(&mut self, n: &'ast Bool) {
        (**self).visit_bool(n)
    }
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        (**self).visit_break_stmt(n)
    }
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        (**self).visit_call_expr(n)
    }
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        (**self).visit_catch_clause(n)
    }
    fn visit_class(&mut self, n: &'ast Class) {
        (**self).visit_class(n)
    }
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        (**self).visit_class_decl(n)
    }
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        (**self).visit_class_expr(n)
    }
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        (**self).visit_class_member(n)
    }
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        (**self).visit_class_members(n)
    }
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        (**self).visit_class_method(n)
    }
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        (**self).visit_class_prop(n)
    }
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        (**self).visit_computed_prop_name(n)
    }
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        (**self).visit_cond_expr(n)
    }
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        (**self).visit_constructor(n)
    }
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        (**self).visit_continue_stmt(n)
    }
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        (**self).visit_debugger_stmt(n)
    }
    fn visit_decl(&mut self, n: &'ast Decl) {
        (**self).visit_decl(n)
    }
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        (**self).visit_decorator(n)
    }
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        (**self).visit_decorators(n)
    }
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        (**self).visit_default_decl(n)
    }
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        (**self).visit_do_while_stmt(n)
    }
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        (**self).visit_empty_stmt(n)
    }
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        (**self).visit_export_all(n)
    }
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        (**self).visit_export_decl(n)
    }
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        (**self).visit_export_default_decl(n)
    }
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        (**self).visit_export_default_expr(n)
    }
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        (**self).visit_export_default_specifier(n)
    }
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        (**self).visit_export_named_specifier(n)
    }
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        (**self).visit_export_namespace_specifier(n)
    }
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        (**self).visit_export_specifier(n)
    }
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        (**self).visit_export_specifiers(n)
    }
    fn visit_expr(&mut self, n: &'ast Expr) {
        (**self).visit_expr(n)
    }
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        (**self).visit_expr_or_spread(n)
    }
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        (**self).visit_expr_or_spreads(n)
    }
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        (**self).visit_expr_or_super(n)
    }
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        (**self).visit_expr_stmt(n)
    }
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        (**self).visit_exprs(n)
    }
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        (**self).visit_fn_decl(n)
    }
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        (**self).visit_fn_expr(n)
    }
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        (**self).visit_for_in_stmt(n)
    }
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        (**self).visit_for_of_stmt(n)
    }
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        (**self).visit_for_stmt(n)
    }
    fn visit_function(&mut self, n: &'ast Function) {
        (**self).visit_function(n)
    }
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        (**self).visit_getter_prop(n)
    }
    fn visit_ident(&mut self, n: &'ast Ident) {
        (**self).visit_ident(n)
    }
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        (**self).visit_if_stmt(n)
    }
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        (**self).visit_import_decl(n)
    }
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        (**self).visit_import_default_specifier(n)
    }
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        (**self).visit_import_named_specifier(n)
    }
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        (**self).visit_import_specifier(n)
    }
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        (**self).visit_import_specifiers(n)
    }
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        (**self).visit_import_star_as_specifier(n)
    }
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        (**self).visit_invalid(n)
    }
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        (**self).visit_js_word(n)
    }
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        (**self).visit_jsx_attr(n)
    }
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        (**self).visit_jsx_attr_name(n)
    }
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        (**self).visit_jsx_attr_or_spread(n)
    }
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        (**self).visit_jsx_attr_or_spreads(n)
    }
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        (**self).visit_jsx_attr_value(n)
    }
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        (**self).visit_jsx_closing_element(n)
    }
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        (**self).visit_jsx_closing_fragment(n)
    }
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        (**self).visit_jsx_element(n)
    }
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        (**self).visit_jsx_element_child(n)
    }
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        (**self).visit_jsx_element_children(n)
    }
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        (**self).visit_jsx_element_name(n)
    }
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        (**self).visit_jsx_empty_expr(n)
    }
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        (**self).visit_jsx_expr(n)
    }
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        (**self).visit_jsx_expr_container(n)
    }
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        (**self).visit_jsx_fragment(n)
    }
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        (**self).visit_jsx_member_expr(n)
    }
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        (**self).visit_jsx_namespaced_name(n)
    }
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        (**self).visit_jsx_object(n)
    }
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        (**self).visit_jsx_opening_element(n)
    }
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        (**self).visit_jsx_opening_fragment(n)
    }
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        (**self).visit_jsx_spread_child(n)
    }
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        (**self).visit_jsx_text(n)
    }
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        (**self).visit_key_value_pat_prop(n)
    }
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        (**self).visit_key_value_prop(n)
    }
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        (**self).visit_labeled_stmt(n)
    }
    fn visit_lit(&mut self, n: &'ast Lit) {
        (**self).visit_lit(n)
    }
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        (**self).visit_member_expr(n)
    }
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        (**self).visit_meta_prop_expr(n)
    }
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        (**self).visit_method_kind(n)
    }
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        (**self).visit_method_prop(n)
    }
    fn visit_module(&mut self, n: &'ast Module) {
        (**self).visit_module(n)
    }
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        (**self).visit_module_decl(n)
    }
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        (**self).visit_module_item(n)
    }
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        (**self).visit_module_items(n)
    }
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        (**self).visit_named_export(n)
    }
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        (**self).visit_new_expr(n)
    }
    fn visit_null(&mut self, n: &'ast Null) {
        (**self).visit_null(n)
    }
    fn visit_number(&mut self, n: &'ast Number) {
        (**self).visit_number(n)
    }
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        (**self).visit_object_lit(n)
    }
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        (**self).visit_object_pat(n)
    }
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        (**self).visit_object_pat_prop(n)
    }
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        (**self).visit_object_pat_props(n)
    }
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        (**self).visit_opt_accessibility(n)
    }
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        (**self).visit_opt_block_stmt(n)
    }
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        (**self).visit_opt_catch_clause(n)
    }
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        (**self).visit_opt_chain_expr(n)
    }
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        (**self).visit_opt_expr(n)
    }
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        (**self).visit_opt_expr_or_spread(n)
    }
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        (**self).visit_opt_expr_or_spreads(n)
    }
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        (**self).visit_opt_ident(n)
    }
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        (**self).visit_opt_js_word(n)
    }
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        (**self).visit_opt_jsx_attr_value(n)
    }
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        (**self).visit_opt_jsx_closing_element(n)
    }
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        (**self).visit_opt_object_lit(n)
    }
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        (**self).visit_opt_pat(n)
    }
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        (**self).visit_opt_span(n)
    }
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        (**self).visit_opt_stmt(n)
    }
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        (**self).visit_opt_str(n)
    }
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        (**self).visit_opt_true_plus_minus(n)
    }
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        (**self).visit_opt_ts_entity_name(n)
    }
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        (**self).visit_opt_ts_namespace_body(n)
    }
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        (**self).visit_opt_ts_type(n)
    }
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        (**self).visit_opt_ts_type_ann(n)
    }
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        (**self).visit_opt_ts_type_param_decl(n)
    }
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        (**self).visit_opt_ts_type_param_instantiation(n)
    }
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        (**self).visit_opt_var_decl_or_expr(n)
    }
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        (**self).visit_opt_vec_expr_or_spreads(n)
    }
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        (**self).visit_opt_vec_pats(n)
    }
    fn visit_param(&mut self, n: &'ast Param) {
        (**self).visit_param(n)
    }
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        (**self).visit_param_or_ts_param_prop(n)
    }
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        (**self).visit_param_or_ts_param_props(n)
    }
    fn visit_params(&mut self, n: &'ast [Param]) {
        (**self).visit_params(n)
    }
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        (**self).visit_paren_expr(n)
    }
    fn visit_pat(&mut self, n: &'ast Pat) {
        (**self).visit_pat(n)
    }
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        (**self).visit_pat_or_expr(n)
    }
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        (**self).visit_pats(n)
    }
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        (**self).visit_private_method(n)
    }
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        (**self).visit_private_name(n)
    }
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        (**self).visit_private_prop(n)
    }
    fn visit_program(&mut self, n: &'ast Program) {
        (**self).visit_program(n)
    }
    fn visit_prop(&mut self, n: &'ast Prop) {
        (**self).visit_prop(n)
    }
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        (**self).visit_prop_name(n)
    }
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        (**self).visit_prop_or_spread(n)
    }
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        (**self).visit_prop_or_spreads(n)
    }
    fn visit_regex(&mut self, n: &'ast Regex) {
        (**self).visit_regex(n)
    }
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        (**self).visit_rest_pat(n)
    }
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        (**self).visit_return_stmt(n)
    }
    fn visit_script(&mut self, n: &'ast Script) {
        (**self).visit_script(n)
    }
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        (**self).visit_seq_expr(n)
    }
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        (**self).visit_setter_prop(n)
    }
    fn visit_span(&mut self, n: &'ast Span) {
        (**self).visit_span(n)
    }
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        (**self).visit_spread_element(n)
    }
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        (**self).visit_stmt(n)
    }
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        (**self).visit_stmts(n)
    }
    fn visit_str(&mut self, n: &'ast Str) {
        (**self).visit_str(n)
    }
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        (**self).visit_str_kind(n)
    }
    fn visit_super(&mut self, n: &'ast Super) {
        (**self).visit_super(n)
    }
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        (**self).visit_switch_case(n)
    }
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        (**self).visit_switch_cases(n)
    }
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        (**self).visit_switch_stmt(n)
    }
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        (**self).visit_tagged_tpl(n)
    }
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        (**self).visit_this_expr(n)
    }
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        (**self).visit_throw_stmt(n)
    }
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        (**self).visit_tpl(n)
    }
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        (**self).visit_tpl_element(n)
    }
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        (**self).visit_tpl_elements(n)
    }
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        (**self).visit_true_plus_minus(n)
    }
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        (**self).visit_try_stmt(n)
    }
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        (**self).visit_ts_array_type(n)
    }
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        (**self).visit_ts_as_expr(n)
    }
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        (**self).visit_ts_call_signature_decl(n)
    }
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        (**self).visit_ts_conditional_type(n)
    }
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        (**self).visit_ts_const_assertion(n)
    }
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        (**self).visit_ts_construct_signature_decl(n)
    }
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        (**self).visit_ts_constructor_type(n)
    }
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        (**self).visit_ts_entity_name(n)
    }
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        (**self).visit_ts_enum_decl(n)
    }
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        (**self).visit_ts_enum_member(n)
    }
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        (**self).visit_ts_enum_member_id(n)
    }
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        (**self).visit_ts_enum_members(n)
    }
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        (**self).visit_ts_export_assignment(n)
    }
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        (**self).visit_ts_expr_with_type_args(n)
    }
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        (**self).visit_ts_expr_with_type_args_vec(n)
    }
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        (**self).visit_ts_external_module_ref(n)
    }
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        (**self).visit_ts_fn_or_constructor_type(n)
    }
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        (**self).visit_ts_fn_param(n)
    }
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        (**self).visit_ts_fn_params(n)
    }
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        (**self).visit_ts_fn_type(n)
    }
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        (**self).visit_ts_getter_signature(n)
    }
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        (**self).visit_ts_import_equals_decl(n)
    }
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        (**self).visit_ts_import_type(n)
    }
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        (**self).visit_ts_index_signature(n)
    }
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        (**self).visit_ts_indexed_access_type(n)
    }
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        (**self).visit_ts_infer_type(n)
    }
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        (**self).visit_ts_interface_body(n)
    }
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        (**self).visit_ts_interface_decl(n)
    }
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        (**self).visit_ts_intersection_type(n)
    }
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        (**self).visit_ts_keyword_type(n)
    }
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        (**self).visit_ts_keyword_type_kind(n)
    }
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        (**self).visit_ts_lit(n)
    }
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        (**self).visit_ts_lit_type(n)
    }
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        (**self).visit_ts_mapped_type(n)
    }
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        (**self).visit_ts_method_signature(n)
    }
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        (**self).visit_ts_module_block(n)
    }
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        (**self).visit_ts_module_decl(n)
    }
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        (**self).visit_ts_module_name(n)
    }
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        (**self).visit_ts_module_ref(n)
    }
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        (**self).visit_ts_namespace_body(n)
    }
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        (**self).visit_ts_namespace_decl(n)
    }
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        (**self).visit_ts_namespace_export_decl(n)
    }
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        (**self).visit_ts_non_null_expr(n)
    }
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        (**self).visit_ts_optional_type(n)
    }
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        (**self).visit_ts_param_prop(n)
    }
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        (**self).visit_ts_param_prop_param(n)
    }
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        (**self).visit_ts_parenthesized_type(n)
    }
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        (**self).visit_ts_property_signature(n)
    }
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        (**self).visit_ts_qualified_name(n)
    }
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        (**self).visit_ts_rest_type(n)
    }
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        (**self).visit_ts_setter_signature(n)
    }
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        (**self).visit_ts_this_type(n)
    }
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        (**self).visit_ts_this_type_or_ident(n)
    }
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        (**self).visit_ts_tpl_lit_type(n)
    }
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        (**self).visit_ts_tuple_element(n)
    }
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        (**self).visit_ts_tuple_elements(n)
    }
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        (**self).visit_ts_tuple_type(n)
    }
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        (**self).visit_ts_type(n)
    }
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        (**self).visit_ts_type_alias_decl(n)
    }
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        (**self).visit_ts_type_ann(n)
    }
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        (**self).visit_ts_type_assertion(n)
    }
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        (**self).visit_ts_type_element(n)
    }
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        (**self).visit_ts_type_elements(n)
    }
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        (**self).visit_ts_type_lit(n)
    }
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        (**self).visit_ts_type_operator(n)
    }
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        (**self).visit_ts_type_operator_op(n)
    }
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        (**self).visit_ts_type_param(n)
    }
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        (**self).visit_ts_type_param_decl(n)
    }
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        (**self).visit_ts_type_param_instantiation(n)
    }
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        (**self).visit_ts_type_params(n)
    }
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        (**self).visit_ts_type_predicate(n)
    }
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        (**self).visit_ts_type_query(n)
    }
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        (**self).visit_ts_type_query_expr(n)
    }
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        (**self).visit_ts_type_ref(n)
    }
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        (**self).visit_ts_types(n)
    }
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        (**self).visit_ts_union_or_intersection_type(n)
    }
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        (**self).visit_ts_union_type(n)
    }
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        (**self).visit_unary_expr(n)
    }
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        (**self).visit_unary_op(n)
    }
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        (**self).visit_update_expr(n)
    }
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        (**self).visit_update_op(n)
    }
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        (**self).visit_var_decl(n)
    }
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        (**self).visit_var_decl_kind(n)
    }
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        (**self).visit_var_decl_or_expr(n)
    }
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        (**self).visit_var_decl_or_pat(n)
    }
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        (**self).visit_var_declarator(n)
    }
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        (**self).visit_var_declarators(n)
    }
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        (**self).visit_while_stmt(n)
    }
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        (**self).visit_with_stmt(n)
    }
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        (**self).visit_yield_expr(n)
    }
}
impl<'ast, V> Visit<'ast> for Box<V>
where
    V: ?Sized + Visit<'ast>,
{
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        (**self).visit_accessibility(n)
    }
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        (**self).visit_array_lit(n)
    }
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        (**self).visit_array_pat(n)
    }
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        (**self).visit_arrow_expr(n)
    }
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        (**self).visit_assign_expr(n)
    }
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        (**self).visit_assign_op(n)
    }
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        (**self).visit_assign_pat(n)
    }
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        (**self).visit_assign_pat_prop(n)
    }
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        (**self).visit_assign_prop(n)
    }
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        (**self).visit_await_expr(n)
    }
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        (**self).visit_big_int(n)
    }
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        (**self).visit_big_int_value(n)
    }
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        (**self).visit_bin_expr(n)
    }
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        (**self).visit_binary_op(n)
    }
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        (**self).visit_binding_ident(n)
    }
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        (**self).visit_block_stmt(n)
    }
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        (**self).visit_block_stmt_or_expr(n)
    }
    fn visit_bool(&mut self, n: &'ast Bool) {
        (**self).visit_bool(n)
    }
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        (**self).visit_break_stmt(n)
    }
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        (**self).visit_call_expr(n)
    }
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        (**self).visit_catch_clause(n)
    }
    fn visit_class(&mut self, n: &'ast Class) {
        (**self).visit_class(n)
    }
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        (**self).visit_class_decl(n)
    }
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        (**self).visit_class_expr(n)
    }
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        (**self).visit_class_member(n)
    }
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        (**self).visit_class_members(n)
    }
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        (**self).visit_class_method(n)
    }
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        (**self).visit_class_prop(n)
    }
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        (**self).visit_computed_prop_name(n)
    }
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        (**self).visit_cond_expr(n)
    }
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        (**self).visit_constructor(n)
    }
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        (**self).visit_continue_stmt(n)
    }
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        (**self).visit_debugger_stmt(n)
    }
    fn visit_decl(&mut self, n: &'ast Decl) {
        (**self).visit_decl(n)
    }
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        (**self).visit_decorator(n)
    }
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        (**self).visit_decorators(n)
    }
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        (**self).visit_default_decl(n)
    }
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        (**self).visit_do_while_stmt(n)
    }
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        (**self).visit_empty_stmt(n)
    }
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        (**self).visit_export_all(n)
    }
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        (**self).visit_export_decl(n)
    }
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        (**self).visit_export_default_decl(n)
    }
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        (**self).visit_export_default_expr(n)
    }
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        (**self).visit_export_default_specifier(n)
    }
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        (**self).visit_export_named_specifier(n)
    }
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        (**self).visit_export_namespace_specifier(n)
    }
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        (**self).visit_export_specifier(n)
    }
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        (**self).visit_export_specifiers(n)
    }
    fn visit_expr(&mut self, n: &'ast Expr) {
        (**self).visit_expr(n)
    }
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        (**self).visit_expr_or_spread(n)
    }
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        (**self).visit_expr_or_spreads(n)
    }
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        (**self).visit_expr_or_super(n)
    }
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        (**self).visit_expr_stmt(n)
    }
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        (**self).visit_exprs(n)
    }
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        (**self).visit_fn_decl(n)
    }
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        (**self).visit_fn_expr(n)
    }
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        (**self).visit_for_in_stmt(n)
    }
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        (**self).visit_for_of_stmt(n)
    }
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        (**self).visit_for_stmt(n)
    }
    fn visit_function(&mut self, n: &'ast Function) {
        (**self).visit_function(n)
    }
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        (**self).visit_getter_prop(n)
    }
    fn visit_ident(&mut self, n: &'ast Ident) {
        (**self).visit_ident(n)
    }
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        (**self).visit_if_stmt(n)
    }
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        (**self).visit_import_decl(n)
    }
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        (**self).visit_import_default_specifier(n)
    }
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        (**self).visit_import_named_specifier(n)
    }
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        (**self).visit_import_specifier(n)
    }
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        (**self).visit_import_specifiers(n)
    }
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        (**self).visit_import_star_as_specifier(n)
    }
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        (**self).visit_invalid(n)
    }
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        (**self).visit_js_word(n)
    }
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        (**self).visit_jsx_attr(n)
    }
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        (**self).visit_jsx_attr_name(n)
    }
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        (**self).visit_jsx_attr_or_spread(n)
    }
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        (**self).visit_jsx_attr_or_spreads(n)
    }
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        (**self).visit_jsx_attr_value(n)
    }
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        (**self).visit_jsx_closing_element(n)
    }
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        (**self).visit_jsx_closing_fragment(n)
    }
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        (**self).visit_jsx_element(n)
    }
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        (**self).visit_jsx_element_child(n)
    }
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        (**self).visit_jsx_element_children(n)
    }
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        (**self).visit_jsx_element_name(n)
    }
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        (**self).visit_jsx_empty_expr(n)
    }
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        (**self).visit_jsx_expr(n)
    }
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        (**self).visit_jsx_expr_container(n)
    }
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        (**self).visit_jsx_fragment(n)
    }
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        (**self).visit_jsx_member_expr(n)
    }
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        (**self).visit_jsx_namespaced_name(n)
    }
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        (**self).visit_jsx_object(n)
    }
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        (**self).visit_jsx_opening_element(n)
    }
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        (**self).visit_jsx_opening_fragment(n)
    }
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        (**self).visit_jsx_spread_child(n)
    }
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        (**self).visit_jsx_text(n)
    }
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        (**self).visit_key_value_pat_prop(n)
    }
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        (**self).visit_key_value_prop(n)
    }
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        (**self).visit_labeled_stmt(n)
    }
    fn visit_lit(&mut self, n: &'ast Lit) {
        (**self).visit_lit(n)
    }
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        (**self).visit_member_expr(n)
    }
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        (**self).visit_meta_prop_expr(n)
    }
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        (**self).visit_method_kind(n)
    }
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        (**self).visit_method_prop(n)
    }
    fn visit_module(&mut self, n: &'ast Module) {
        (**self).visit_module(n)
    }
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        (**self).visit_module_decl(n)
    }
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        (**self).visit_module_item(n)
    }
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        (**self).visit_module_items(n)
    }
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        (**self).visit_named_export(n)
    }
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        (**self).visit_new_expr(n)
    }
    fn visit_null(&mut self, n: &'ast Null) {
        (**self).visit_null(n)
    }
    fn visit_number(&mut self, n: &'ast Number) {
        (**self).visit_number(n)
    }
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        (**self).visit_object_lit(n)
    }
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        (**self).visit_object_pat(n)
    }
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        (**self).visit_object_pat_prop(n)
    }
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        (**self).visit_object_pat_props(n)
    }
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        (**self).visit_opt_accessibility(n)
    }
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        (**self).visit_opt_block_stmt(n)
    }
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        (**self).visit_opt_catch_clause(n)
    }
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        (**self).visit_opt_chain_expr(n)
    }
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        (**self).visit_opt_expr(n)
    }
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        (**self).visit_opt_expr_or_spread(n)
    }
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        (**self).visit_opt_expr_or_spreads(n)
    }
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        (**self).visit_opt_ident(n)
    }
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        (**self).visit_opt_js_word(n)
    }
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        (**self).visit_opt_jsx_attr_value(n)
    }
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        (**self).visit_opt_jsx_closing_element(n)
    }
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        (**self).visit_opt_object_lit(n)
    }
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        (**self).visit_opt_pat(n)
    }
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        (**self).visit_opt_span(n)
    }
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        (**self).visit_opt_stmt(n)
    }
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        (**self).visit_opt_str(n)
    }
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        (**self).visit_opt_true_plus_minus(n)
    }
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        (**self).visit_opt_ts_entity_name(n)
    }
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        (**self).visit_opt_ts_namespace_body(n)
    }
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        (**self).visit_opt_ts_type(n)
    }
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        (**self).visit_opt_ts_type_ann(n)
    }
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        (**self).visit_opt_ts_type_param_decl(n)
    }
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        (**self).visit_opt_ts_type_param_instantiation(n)
    }
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        (**self).visit_opt_var_decl_or_expr(n)
    }
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        (**self).visit_opt_vec_expr_or_spreads(n)
    }
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        (**self).visit_opt_vec_pats(n)
    }
    fn visit_param(&mut self, n: &'ast Param) {
        (**self).visit_param(n)
    }
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        (**self).visit_param_or_ts_param_prop(n)
    }
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        (**self).visit_param_or_ts_param_props(n)
    }
    fn visit_params(&mut self, n: &'ast [Param]) {
        (**self).visit_params(n)
    }
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        (**self).visit_paren_expr(n)
    }
    fn visit_pat(&mut self, n: &'ast Pat) {
        (**self).visit_pat(n)
    }
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        (**self).visit_pat_or_expr(n)
    }
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        (**self).visit_pats(n)
    }
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        (**self).visit_private_method(n)
    }
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        (**self).visit_private_name(n)
    }
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        (**self).visit_private_prop(n)
    }
    fn visit_program(&mut self, n: &'ast Program) {
        (**self).visit_program(n)
    }
    fn visit_prop(&mut self, n: &'ast Prop) {
        (**self).visit_prop(n)
    }
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        (**self).visit_prop_name(n)
    }
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        (**self).visit_prop_or_spread(n)
    }
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        (**self).visit_prop_or_spreads(n)
    }
    fn visit_regex(&mut self, n: &'ast Regex) {
        (**self).visit_regex(n)
    }
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        (**self).visit_rest_pat(n)
    }
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        (**self).visit_return_stmt(n)
    }
    fn visit_script(&mut self, n: &'ast Script) {
        (**self).visit_script(n)
    }
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        (**self).visit_seq_expr(n)
    }
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        (**self).visit_setter_prop(n)
    }
    fn visit_span(&mut self, n: &'ast Span) {
        (**self).visit_span(n)
    }
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        (**self).visit_spread_element(n)
    }
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        (**self).visit_stmt(n)
    }
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        (**self).visit_stmts(n)
    }
    fn visit_str(&mut self, n: &'ast Str) {
        (**self).visit_str(n)
    }
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        (**self).visit_str_kind(n)
    }
    fn visit_super(&mut self, n: &'ast Super) {
        (**self).visit_super(n)
    }
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        (**self).visit_switch_case(n)
    }
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        (**self).visit_switch_cases(n)
    }
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        (**self).visit_switch_stmt(n)
    }
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        (**self).visit_tagged_tpl(n)
    }
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        (**self).visit_this_expr(n)
    }
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        (**self).visit_throw_stmt(n)
    }
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        (**self).visit_tpl(n)
    }
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        (**self).visit_tpl_element(n)
    }
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        (**self).visit_tpl_elements(n)
    }
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        (**self).visit_true_plus_minus(n)
    }
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        (**self).visit_try_stmt(n)
    }
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        (**self).visit_ts_array_type(n)
    }
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        (**self).visit_ts_as_expr(n)
    }
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        (**self).visit_ts_call_signature_decl(n)
    }
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        (**self).visit_ts_conditional_type(n)
    }
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        (**self).visit_ts_const_assertion(n)
    }
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        (**self).visit_ts_construct_signature_decl(n)
    }
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        (**self).visit_ts_constructor_type(n)
    }
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        (**self).visit_ts_entity_name(n)
    }
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        (**self).visit_ts_enum_decl(n)
    }
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        (**self).visit_ts_enum_member(n)
    }
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        (**self).visit_ts_enum_member_id(n)
    }
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        (**self).visit_ts_enum_members(n)
    }
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        (**self).visit_ts_export_assignment(n)
    }
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        (**self).visit_ts_expr_with_type_args(n)
    }
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        (**self).visit_ts_expr_with_type_args_vec(n)
    }
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        (**self).visit_ts_external_module_ref(n)
    }
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        (**self).visit_ts_fn_or_constructor_type(n)
    }
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        (**self).visit_ts_fn_param(n)
    }
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        (**self).visit_ts_fn_params(n)
    }
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        (**self).visit_ts_fn_type(n)
    }
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        (**self).visit_ts_getter_signature(n)
    }
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        (**self).visit_ts_import_equals_decl(n)
    }
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        (**self).visit_ts_import_type(n)
    }
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        (**self).visit_ts_index_signature(n)
    }
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        (**self).visit_ts_indexed_access_type(n)
    }
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        (**self).visit_ts_infer_type(n)
    }
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        (**self).visit_ts_interface_body(n)
    }
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        (**self).visit_ts_interface_decl(n)
    }
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        (**self).visit_ts_intersection_type(n)
    }
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        (**self).visit_ts_keyword_type(n)
    }
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        (**self).visit_ts_keyword_type_kind(n)
    }
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        (**self).visit_ts_lit(n)
    }
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        (**self).visit_ts_lit_type(n)
    }
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        (**self).visit_ts_mapped_type(n)
    }
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        (**self).visit_ts_method_signature(n)
    }
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        (**self).visit_ts_module_block(n)
    }
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        (**self).visit_ts_module_decl(n)
    }
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        (**self).visit_ts_module_name(n)
    }
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        (**self).visit_ts_module_ref(n)
    }
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        (**self).visit_ts_namespace_body(n)
    }
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        (**self).visit_ts_namespace_decl(n)
    }
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        (**self).visit_ts_namespace_export_decl(n)
    }
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        (**self).visit_ts_non_null_expr(n)
    }
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        (**self).visit_ts_optional_type(n)
    }
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        (**self).visit_ts_param_prop(n)
    }
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        (**self).visit_ts_param_prop_param(n)
    }
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        (**self).visit_ts_parenthesized_type(n)
    }
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        (**self).visit_ts_property_signature(n)
    }
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        (**self).visit_ts_qualified_name(n)
    }
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        (**self).visit_ts_rest_type(n)
    }
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        (**self).visit_ts_setter_signature(n)
    }
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        (**self).visit_ts_this_type(n)
    }
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        (**self).visit_ts_this_type_or_ident(n)
    }
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        (**self).visit_ts_tpl_lit_type(n)
    }
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        (**self).visit_ts_tuple_element(n)
    }
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        (**self).visit_ts_tuple_elements(n)
    }
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        (**self).visit_ts_tuple_type(n)
    }
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        (**self).visit_ts_type(n)
    }
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        (**self).visit_ts_type_alias_decl(n)
    }
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        (**self).visit_ts_type_ann(n)
    }
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        (**self).visit_ts_type_assertion(n)
    }
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        (**self).visit_ts_type_element(n)
    }
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        (**self).visit_ts_type_elements(n)
    }
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        (**self).visit_ts_type_lit(n)
    }
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        (**self).visit_ts_type_operator(n)
    }
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        (**self).visit_ts_type_operator_op(n)
    }
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        (**self).visit_ts_type_param(n)
    }
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        (**self).visit_ts_type_param_decl(n)
    }
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        (**self).visit_ts_type_param_instantiation(n)
    }
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        (**self).visit_ts_type_params(n)
    }
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        (**self).visit_ts_type_predicate(n)
    }
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        (**self).visit_ts_type_query(n)
    }
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        (**self).visit_ts_type_query_expr(n)
    }
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        (**self).visit_ts_type_ref(n)
    }
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        (**self).visit_ts_types(n)
    }
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        (**self).visit_ts_union_or_intersection_type(n)
    }
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        (**self).visit_ts_union_type(n)
    }
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        (**self).visit_unary_expr(n)
    }
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        (**self).visit_unary_op(n)
    }
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        (**self).visit_update_expr(n)
    }
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        (**self).visit_update_op(n)
    }
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        (**self).visit_var_decl(n)
    }
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        (**self).visit_var_decl_kind(n)
    }
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        (**self).visit_var_decl_or_expr(n)
    }
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        (**self).visit_var_decl_or_pat(n)
    }
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        (**self).visit_var_declarator(n)
    }
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        (**self).visit_var_declarators(n)
    }
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        (**self).visit_while_stmt(n)
    }
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        (**self).visit_with_stmt(n)
    }
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        (**self).visit_yield_expr(n)
    }
}
impl<'ast, V> Visit<'ast> for ::global_visit::Optional<V>
where
    V: Visit<'ast>,
{
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        if self.enabled {
            self.visitor.visit_accessibility(n)
        }
    }
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        if self.enabled {
            self.visitor.visit_array_lit(n)
        }
    }
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        if self.enabled {
            self.visitor.visit_array_pat(n)
        }
    }
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        if self.enabled {
            self.visitor.visit_arrow_expr(n)
        }
    }
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        if self.enabled {
            self.visitor.visit_assign_expr(n)
        }
    }
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        if self.enabled {
            self.visitor.visit_assign_op(n)
        }
    }
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        if self.enabled {
            self.visitor.visit_assign_pat(n)
        }
    }
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        if self.enabled {
            self.visitor.visit_assign_pat_prop(n)
        }
    }
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        if self.enabled {
            self.visitor.visit_assign_prop(n)
        }
    }
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        if self.enabled {
            self.visitor.visit_await_expr(n)
        }
    }
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        if self.enabled {
            self.visitor.visit_big_int(n)
        }
    }
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        if self.enabled {
            self.visitor.visit_big_int_value(n)
        }
    }
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        if self.enabled {
            self.visitor.visit_bin_expr(n)
        }
    }
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        if self.enabled {
            self.visitor.visit_binary_op(n)
        }
    }
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        if self.enabled {
            self.visitor.visit_binding_ident(n)
        }
    }
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        if self.enabled {
            self.visitor.visit_block_stmt(n)
        }
    }
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        if self.enabled {
            self.visitor.visit_block_stmt_or_expr(n)
        }
    }
    fn visit_bool(&mut self, n: &'ast Bool) {
        if self.enabled {
            self.visitor.visit_bool(n)
        }
    }
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        if self.enabled {
            self.visitor.visit_break_stmt(n)
        }
    }
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        if self.enabled {
            self.visitor.visit_call_expr(n)
        }
    }
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        if self.enabled {
            self.visitor.visit_catch_clause(n)
        }
    }
    fn visit_class(&mut self, n: &'ast Class) {
        if self.enabled {
            self.visitor.visit_class(n)
        }
    }
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        if self.enabled {
            self.visitor.visit_class_decl(n)
        }
    }
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        if self.enabled {
            self.visitor.visit_class_expr(n)
        }
    }
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        if self.enabled {
            self.visitor.visit_class_member(n)
        }
    }
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        if self.enabled {
            self.visitor.visit_class_members(n)
        }
    }
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        if self.enabled {
            self.visitor.visit_class_method(n)
        }
    }
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        if self.enabled {
            self.visitor.visit_class_prop(n)
        }
    }
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        if self.enabled {
            self.visitor.visit_computed_prop_name(n)
        }
    }
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        if self.enabled {
            self.visitor.visit_cond_expr(n)
        }
    }
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        if self.enabled {
            self.visitor.visit_constructor(n)
        }
    }
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        if self.enabled {
            self.visitor.visit_continue_stmt(n)
        }
    }
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        if self.enabled {
            self.visitor.visit_debugger_stmt(n)
        }
    }
    fn visit_decl(&mut self, n: &'ast Decl) {
        if self.enabled {
            self.visitor.visit_decl(n)
        }
    }
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        if self.enabled {
            self.visitor.visit_decorator(n)
        }
    }
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        if self.enabled {
            self.visitor.visit_decorators(n)
        }
    }
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        if self.enabled {
            self.visitor.visit_default_decl(n)
        }
    }
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        if self.enabled {
            self.visitor.visit_do_while_stmt(n)
        }
    }
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        if self.enabled {
            self.visitor.visit_empty_stmt(n)
        }
    }
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        if self.enabled {
            self.visitor.visit_export_all(n)
        }
    }
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        if self.enabled {
            self.visitor.visit_export_decl(n)
        }
    }
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        if self.enabled {
            self.visitor.visit_export_default_decl(n)
        }
    }
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        if self.enabled {
            self.visitor.visit_export_default_expr(n)
        }
    }
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        if self.enabled {
            self.visitor.visit_export_default_specifier(n)
        }
    }
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        if self.enabled {
            self.visitor.visit_export_named_specifier(n)
        }
    }
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        if self.enabled {
            self.visitor.visit_export_namespace_specifier(n)
        }
    }
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        if self.enabled {
            self.visitor.visit_export_specifier(n)
        }
    }
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        if self.enabled {
            self.visitor.visit_export_specifiers(n)
        }
    }
    fn visit_expr(&mut self, n: &'ast Expr) {
        if self.enabled {
            self.visitor.visit_expr(n)
        }
    }
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        if self.enabled {
            self.visitor.visit_expr_or_spread(n)
        }
    }
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        if self.enabled {
            self.visitor.visit_expr_or_spreads(n)
        }
    }
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        if self.enabled {
            self.visitor.visit_expr_or_super(n)
        }
    }
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        if self.enabled {
            self.visitor.visit_expr_stmt(n)
        }
    }
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        if self.enabled {
            self.visitor.visit_exprs(n)
        }
    }
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        if self.enabled {
            self.visitor.visit_fn_decl(n)
        }
    }
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        if self.enabled {
            self.visitor.visit_fn_expr(n)
        }
    }
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        if self.enabled {
            self.visitor.visit_for_in_stmt(n)
        }
    }
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        if self.enabled {
            self.visitor.visit_for_of_stmt(n)
        }
    }
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        if self.enabled {
            self.visitor.visit_for_stmt(n)
        }
    }
    fn visit_function(&mut self, n: &'ast Function) {
        if self.enabled {
            self.visitor.visit_function(n)
        }
    }
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        if self.enabled {
            self.visitor.visit_getter_prop(n)
        }
    }
    fn visit_ident(&mut self, n: &'ast Ident) {
        if self.enabled {
            self.visitor.visit_ident(n)
        }
    }
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        if self.enabled {
            self.visitor.visit_if_stmt(n)
        }
    }
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        if self.enabled {
            self.visitor.visit_import_decl(n)
        }
    }
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        if self.enabled {
            self.visitor.visit_import_default_specifier(n)
        }
    }
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        if self.enabled {
            self.visitor.visit_import_named_specifier(n)
        }
    }
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        if self.enabled {
            self.visitor.visit_import_specifier(n)
        }
    }
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        if self.enabled {
            self.visitor.visit_import_specifiers(n)
        }
    }
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        if self.enabled {
            self.visitor.visit_import_star_as_specifier(n)
        }
    }
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        if self.enabled {
            self.visitor.visit_invalid(n)
        }
    }
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        if self.enabled {
            self.visitor.visit_js_word(n)
        }
    }
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        if self.enabled {
            self.visitor.visit_jsx_attr(n)
        }
    }
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        if self.enabled {
            self.visitor.visit_jsx_attr_name(n)
        }
    }
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        if self.enabled {
            self.visitor.visit_jsx_attr_or_spread(n)
        }
    }
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        if self.enabled {
            self.visitor.visit_jsx_attr_or_spreads(n)
        }
    }
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        if self.enabled {
            self.visitor.visit_jsx_attr_value(n)
        }
    }
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        if self.enabled {
            self.visitor.visit_jsx_closing_element(n)
        }
    }
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        if self.enabled {
            self.visitor.visit_jsx_closing_fragment(n)
        }
    }
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        if self.enabled {
            self.visitor.visit_jsx_element(n)
        }
    }
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        if self.enabled {
            self.visitor.visit_jsx_element_child(n)
        }
    }
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        if self.enabled {
            self.visitor.visit_jsx_element_children(n)
        }
    }
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        if self.enabled {
            self.visitor.visit_jsx_element_name(n)
        }
    }
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        if self.enabled {
            self.visitor.visit_jsx_empty_expr(n)
        }
    }
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        if self.enabled {
            self.visitor.visit_jsx_expr(n)
        }
    }
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        if self.enabled {
            self.visitor.visit_jsx_expr_container(n)
        }
    }
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        if self.enabled {
            self.visitor.visit_jsx_fragment(n)
        }
    }
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        if self.enabled {
            self.visitor.visit_jsx_member_expr(n)
        }
    }
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        if self.enabled {
            self.visitor.visit_jsx_namespaced_name(n)
        }
    }
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        if self.enabled {
            self.visitor.visit_jsx_object(n)
        }
    }
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        if self.enabled {
            self.visitor.visit_jsx_opening_element(n)
        }
    }
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        if self.enabled {
            self.visitor.visit_jsx_opening_fragment(n)
        }
    }
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        if self.enabled {
            self.visitor.visit_jsx_spread_child(n)
        }
    }
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        if self.enabled {
            self.visitor.visit_jsx_text(n)
        }
    }
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        if self.enabled {
            self.visitor.visit_key_value_pat_prop(n)
        }
    }
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        if self.enabled {
            self.visitor.visit_key_value_prop(n)
        }
    }
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        if self.enabled {
            self.visitor.visit_labeled_stmt(n)
        }
    }
    fn visit_lit(&mut self, n: &'ast Lit) {
        if self.enabled {
            self.visitor.visit_lit(n)
        }
    }
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        if self.enabled {
            self.visitor.visit_member_expr(n)
        }
    }
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        if self.enabled {
            self.visitor.visit_meta_prop_expr(n)
        }
    }
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        if self.enabled {
            self.visitor.visit_method_kind(n)
        }
    }
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        if self.enabled {
            self.visitor.visit_method_prop(n)
        }
    }
    fn visit_module(&mut self, n: &'ast Module) {
        if self.enabled {
            self.visitor.visit_module(n)
        }
    }
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        if self.enabled {
            self.visitor.visit_module_decl(n)
        }
    }
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        if self.enabled {
            self.visitor.visit_module_item(n)
        }
    }
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        if self.enabled {
            self.visitor.visit_module_items(n)
        }
    }
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        if self.enabled {
            self.visitor.visit_named_export(n)
        }
    }
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        if self.enabled {
            self.visitor.visit_new_expr(n)
        }
    }
    fn visit_null(&mut self, n: &'ast Null) {
        if self.enabled {
            self.visitor.visit_null(n)
        }
    }
    fn visit_number(&mut self, n: &'ast Number) {
        if self.enabled {
            self.visitor.visit_number(n)
        }
    }
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        if self.enabled {
            self.visitor.visit_object_lit(n)
        }
    }
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        if self.enabled {
            self.visitor.visit_object_pat(n)
        }
    }
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        if self.enabled {
            self.visitor.visit_object_pat_prop(n)
        }
    }
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        if self.enabled {
            self.visitor.visit_object_pat_props(n)
        }
    }
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        if self.enabled {
            self.visitor.visit_opt_accessibility(n)
        }
    }
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        if self.enabled {
            self.visitor.visit_opt_block_stmt(n)
        }
    }
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        if self.enabled {
            self.visitor.visit_opt_catch_clause(n)
        }
    }
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        if self.enabled {
            self.visitor.visit_opt_chain_expr(n)
        }
    }
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        if self.enabled {
            self.visitor.visit_opt_expr(n)
        }
    }
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        if self.enabled {
            self.visitor.visit_opt_expr_or_spread(n)
        }
    }
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        if self.enabled {
            self.visitor.visit_opt_expr_or_spreads(n)
        }
    }
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        if self.enabled {
            self.visitor.visit_opt_ident(n)
        }
    }
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        if self.enabled {
            self.visitor.visit_opt_js_word(n)
        }
    }
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        if self.enabled {
            self.visitor.visit_opt_jsx_attr_value(n)
        }
    }
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        if self.enabled {
            self.visitor.visit_opt_jsx_closing_element(n)
        }
    }
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        if self.enabled {
            self.visitor.visit_opt_object_lit(n)
        }
    }
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        if self.enabled {
            self.visitor.visit_opt_pat(n)
        }
    }
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        if self.enabled {
            self.visitor.visit_opt_span(n)
        }
    }
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        if self.enabled {
            self.visitor.visit_opt_stmt(n)
        }
    }
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        if self.enabled {
            self.visitor.visit_opt_str(n)
        }
    }
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        if self.enabled {
            self.visitor.visit_opt_true_plus_minus(n)
        }
    }
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        if self.enabled {
            self.visitor.visit_opt_ts_entity_name(n)
        }
    }
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        if self.enabled {
            self.visitor.visit_opt_ts_namespace_body(n)
        }
    }
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        if self.enabled {
            self.visitor.visit_opt_ts_type(n)
        }
    }
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        if self.enabled {
            self.visitor.visit_opt_ts_type_ann(n)
        }
    }
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        if self.enabled {
            self.visitor.visit_opt_ts_type_param_decl(n)
        }
    }
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        if self.enabled {
            self.visitor.visit_opt_ts_type_param_instantiation(n)
        }
    }
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        if self.enabled {
            self.visitor.visit_opt_var_decl_or_expr(n)
        }
    }
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        if self.enabled {
            self.visitor.visit_opt_vec_expr_or_spreads(n)
        }
    }
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        if self.enabled {
            self.visitor.visit_opt_vec_pats(n)
        }
    }
    fn visit_param(&mut self, n: &'ast Param) {
        if self.enabled {
            self.visitor.visit_param(n)
        }
    }
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        if self.enabled {
            self.visitor.visit_param_or_ts_param_prop(n)
        }
    }
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        if self.enabled {
            self.visitor.visit_param_or_ts_param_props(n)
        }
    }
    fn visit_params(&mut self, n: &'ast [Param]) {
        if self.enabled {
            self.visitor.visit_params(n)
        }
    }
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        if self.enabled {
            self.visitor.visit_paren_expr(n)
        }
    }
    fn visit_pat(&mut self, n: &'ast Pat) {
        if self.enabled {
            self.visitor.visit_pat(n)
        }
    }
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        if self.enabled {
            self.visitor.visit_pat_or_expr(n)
        }
    }
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        if self.enabled {
            self.visitor.visit_pats(n)
        }
    }
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        if self.enabled {
            self.visitor.visit_private_method(n)
        }
    }
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        if self.enabled {
            self.visitor.visit_private_name(n)
        }
    }
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        if self.enabled {
            self.visitor.visit_private_prop(n)
        }
    }
    fn visit_program(&mut self, n: &'ast Program) {
        if self.enabled {
            self.visitor.visit_program(n)
        }
    }
    fn visit_prop(&mut self, n: &'ast Prop) {
        if self.enabled {
            self.visitor.visit_prop(n)
        }
    }
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        if self.enabled {
            self.visitor.visit_prop_name(n)
        }
    }
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        if self.enabled {
            self.visitor.visit_prop_or_spread(n)
        }
    }
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        if self.enabled {
            self.visitor.visit_prop_or_spreads(n)
        }
    }
    fn visit_regex(&mut self, n: &'ast Regex) {
        if self.enabled {
            self.visitor.visit_regex(n)
        }
    }
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        if self.enabled {
            self.visitor.visit_rest_pat(n)
        }
    }
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        if self.enabled {
            self.visitor.visit_return_stmt(n)
        }
    }
    fn visit_script(&mut self, n: &'ast Script) {
        if self.enabled {
            self.visitor.visit_script(n)
        }
    }
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        if self.enabled {
            self.visitor.visit_seq_expr(n)
        }
    }
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        if self.enabled {
            self.visitor.visit_setter_prop(n)
        }
    }
    fn visit_span(&mut self, n: &'ast Span) {
        if self.enabled {
            self.visitor.visit_span(n)
        }
    }
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        if self.enabled {
            self.visitor.visit_spread_element(n)
        }
    }
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        if self.enabled {
            self.visitor.visit_stmt(n)
        }
    }
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        if self.enabled {
            self.visitor.visit_stmts(n)
        }
    }
    fn visit_str(&mut self, n: &'ast Str) {
        if self.enabled {
            self.visitor.visit_str(n)
        }
    }
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        if self.enabled {
            self.visitor.visit_str_kind(n)
        }
    }
    fn visit_super(&mut self, n: &'ast Super) {
        if self.enabled {
            self.visitor.visit_super(n)
        }
    }
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        if self.enabled {
            self.visitor.visit_switch_case(n)
        }
    }
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        if self.enabled {
            self.visitor.visit_switch_cases(n)
        }
    }
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        if self.enabled {
            self.visitor.visit_switch_stmt(n)
        }
    }
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        if self.enabled {
            self.visitor.visit_tagged_tpl(n)
        }
    }
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        if self.enabled {
            self.visitor.visit_this_expr(n)
        }
    }
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        if self.enabled {
            self.visitor.visit_throw_stmt(n)
        }
    }
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        if self.enabled {
            self.visitor.visit_tpl(n)
        }
    }
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        if self.enabled {
            self.visitor.visit_tpl_element(n)
        }
    }
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        if self.enabled {
            self.visitor.visit_tpl_elements(n)
        }
    }
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        if self.enabled {
            self.visitor.visit_true_plus_minus(n)
        }
    }
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        if self.enabled {
            self.visitor.visit_try_stmt(n)
        }
    }
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        if self.enabled {
            self.visitor.visit_ts_array_type(n)
        }
    }
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        if self.enabled {
            self.visitor.visit_ts_as_expr(n)
        }
    }
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        if self.enabled {
            self.visitor.visit_ts_call_signature_decl(n)
        }
    }
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        if self.enabled {
            self.visitor.visit_ts_conditional_type(n)
        }
    }
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        if self.enabled {
            self.visitor.visit_ts_const_assertion(n)
        }
    }
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        if self.enabled {
            self.visitor.visit_ts_construct_signature_decl(n)
        }
    }
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        if self.enabled {
            self.visitor.visit_ts_constructor_type(n)
        }
    }
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        if self.enabled {
            self.visitor.visit_ts_entity_name(n)
        }
    }
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        if self.enabled {
            self.visitor.visit_ts_enum_decl(n)
        }
    }
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        if self.enabled {
            self.visitor.visit_ts_enum_member(n)
        }
    }
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        if self.enabled {
            self.visitor.visit_ts_enum_member_id(n)
        }
    }
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        if self.enabled {
            self.visitor.visit_ts_enum_members(n)
        }
    }
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        if self.enabled {
            self.visitor.visit_ts_export_assignment(n)
        }
    }
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        if self.enabled {
            self.visitor.visit_ts_expr_with_type_args(n)
        }
    }
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        if self.enabled {
            self.visitor.visit_ts_expr_with_type_args_vec(n)
        }
    }
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        if self.enabled {
            self.visitor.visit_ts_external_module_ref(n)
        }
    }
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        if self.enabled {
            self.visitor.visit_ts_fn_or_constructor_type(n)
        }
    }
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        if self.enabled {
            self.visitor.visit_ts_fn_param(n)
        }
    }
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        if self.enabled {
            self.visitor.visit_ts_fn_params(n)
        }
    }
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        if self.enabled {
            self.visitor.visit_ts_fn_type(n)
        }
    }
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        if self.enabled {
            self.visitor.visit_ts_getter_signature(n)
        }
    }
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        if self.enabled {
            self.visitor.visit_ts_import_equals_decl(n)
        }
    }
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        if self.enabled {
            self.visitor.visit_ts_import_type(n)
        }
    }
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        if self.enabled {
            self.visitor.visit_ts_index_signature(n)
        }
    }
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        if self.enabled {
            self.visitor.visit_ts_indexed_access_type(n)
        }
    }
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        if self.enabled {
            self.visitor.visit_ts_infer_type(n)
        }
    }
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        if self.enabled {
            self.visitor.visit_ts_interface_body(n)
        }
    }
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        if self.enabled {
            self.visitor.visit_ts_interface_decl(n)
        }
    }
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        if self.enabled {
            self.visitor.visit_ts_intersection_type(n)
        }
    }
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        if self.enabled {
            self.visitor.visit_ts_keyword_type(n)
        }
    }
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        if self.enabled {
            self.visitor.visit_ts_keyword_type_kind(n)
        }
    }
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        if self.enabled {
            self.visitor.visit_ts_lit(n)
        }
    }
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        if self.enabled {
            self.visitor.visit_ts_lit_type(n)
        }
    }
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        if self.enabled {
            self.visitor.visit_ts_mapped_type(n)
        }
    }
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        if self.enabled {
            self.visitor.visit_ts_method_signature(n)
        }
    }
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        if self.enabled {
            self.visitor.visit_ts_module_block(n)
        }
    }
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        if self.enabled {
            self.visitor.visit_ts_module_decl(n)
        }
    }
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        if self.enabled {
            self.visitor.visit_ts_module_name(n)
        }
    }
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        if self.enabled {
            self.visitor.visit_ts_module_ref(n)
        }
    }
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        if self.enabled {
            self.visitor.visit_ts_namespace_body(n)
        }
    }
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        if self.enabled {
            self.visitor.visit_ts_namespace_decl(n)
        }
    }
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        if self.enabled {
            self.visitor.visit_ts_namespace_export_decl(n)
        }
    }
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        if self.enabled {
            self.visitor.visit_ts_non_null_expr(n)
        }
    }
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        if self.enabled {
            self.visitor.visit_ts_optional_type(n)
        }
    }
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        if self.enabled {
            self.visitor.visit_ts_param_prop(n)
        }
    }
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        if self.enabled {
            self.visitor.visit_ts_param_prop_param(n)
        }
    }
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        if self.enabled {
            self.visitor.visit_ts_parenthesized_type(n)
        }
    }
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        if self.enabled {
            self.visitor.visit_ts_property_signature(n)
        }
    }
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        if self.enabled {
            self.visitor.visit_ts_qualified_name(n)
        }
    }
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        if self.enabled {
            self.visitor.visit_ts_rest_type(n)
        }
    }
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        if self.enabled {
            self.visitor.visit_ts_setter_signature(n)
        }
    }
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        if self.enabled {
            self.visitor.visit_ts_this_type(n)
        }
    }
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        if self.enabled {
            self.visitor.visit_ts_this_type_or_ident(n)
        }
    }
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        if self.enabled {
            self.visitor.visit_ts_tpl_lit_type(n)
        }
    }
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        if self.enabled {
            self.visitor.visit_ts_tuple_element(n)
        }
    }
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        if self.enabled {
            self.visitor.visit_ts_tuple_elements(n)
        }
    }
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        if self.enabled {
            self.visitor.visit_ts_tuple_type(n)
        }
    }
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        if self.enabled {
            self.visitor.visit_ts_type(n)
        }
    }
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        if self.enabled {
            self.visitor.visit_ts_type_alias_decl(n)
        }
    }
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        if self.enabled {
            self.visitor.visit_ts_type_ann(n)
        }
    }
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        if self.enabled {
            self.visitor.visit_ts_type_assertion(n)
        }
    }
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        if self.enabled {
            self.visitor.visit_ts_type_element(n)
        }
    }
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        if self.enabled {
            self.visitor.visit_ts_type_elements(n)
        }
    }
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        if self.enabled {
            self.visitor.visit_ts_type_lit(n)
        }
    }
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        if self.enabled {
            self.visitor.visit_ts_type_operator(n)
        }
    }
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        if self.enabled {
            self.visitor.visit_ts_type_operator_op(n)
        }
    }
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        if self.enabled {
            self.visitor.visit_ts_type_param(n)
        }
    }
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        if self.enabled {
            self.visitor.visit_ts_type_param_decl(n)
        }
    }
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        if self.enabled {
            self.visitor.visit_ts_type_param_instantiation(n)
        }
    }
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        if self.enabled {
            self.visitor.visit_ts_type_params(n)
        }
    }
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        if self.enabled {
            self.visitor.visit_ts_type_predicate(n)
        }
    }
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        if self.enabled {
            self.visitor.visit_ts_type_query(n)
        }
    }
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        if self.enabled {
            self.visitor.visit_ts_type_query_expr(n)
        }
    }
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        if self.enabled {
            self.visitor.visit_ts_type_ref(n)
        }
    }
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        if self.enabled {
            self.visitor.visit_ts_types(n)
        }
    }
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        if self.enabled {
            self.visitor.visit_ts_union_or_intersection_type(n)
        }
    }
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        if self.enabled {
            self.visitor.visit_ts_union_type(n)
        }
    }
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        if self.enabled {
            self.visitor.visit_unary_expr(n)
        }
    }
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        if self.enabled {
            self.visitor.visit_unary_op(n)
        }
    }
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        if self.enabled {
            self.visitor.visit_update_expr(n)
        }
    }
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        if self.enabled {
            self.visitor.visit_update_op(n)
        }
    }
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        if self.enabled {
            self.visitor.visit_var_decl(n)
        }
    }
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        if self.enabled {
            self.visitor.visit_var_decl_kind(n)
        }
    }
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        if self.enabled {
            self.visitor.visit_var_decl_or_expr(n)
        }
    }
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        if self.enabled {
            self.visitor.visit_var_decl_or_pat(n)
        }
    }
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        if self.enabled {
            self.visitor.visit_var_declarator(n)
        }
    }
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        if self.enabled {
            self.visitor.visit_var_declarators(n)
        }
    }
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        if self.enabled {
            self.visitor.visit_while_stmt(n)
        }
    }
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        if self.enabled {
            self.visitor.visit_with_stmt(n)
        }
    }
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        if self.enabled {
            self.visitor.visit_yield_expr(n)
        }
    }
}
impl<'ast, A, B> Visit<'ast> for ::global_visit::Either<A, B>
where
    A: Visit<'ast>,
    B: Visit<'ast>,
{
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        match self {
            global_visit::Either::Left(v) => v.visit_accessibility(n),
            global_visit::Either::Right(v) => v.visit_accessibility(n),
        }
    }
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        match self {
            global_visit::Either::Left(v) => v.visit_array_lit(n),
            global_visit::Either::Right(v) => v.visit_array_lit(n),
        }
    }
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_array_pat(n),
            global_visit::Either::Right(v) => v.visit_array_pat(n),
        }
    }
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_arrow_expr(n),
            global_visit::Either::Right(v) => v.visit_arrow_expr(n),
        }
    }
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_expr(n),
            global_visit::Either::Right(v) => v.visit_assign_expr(n),
        }
    }
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_op(n),
            global_visit::Either::Right(v) => v.visit_assign_op(n),
        }
    }
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_pat(n),
            global_visit::Either::Right(v) => v.visit_assign_pat(n),
        }
    }
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_pat_prop(n),
            global_visit::Either::Right(v) => v.visit_assign_pat_prop(n),
        }
    }
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_prop(n),
            global_visit::Either::Right(v) => v.visit_assign_prop(n),
        }
    }
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_await_expr(n),
            global_visit::Either::Right(v) => v.visit_await_expr(n),
        }
    }
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        match self {
            global_visit::Either::Left(v) => v.visit_big_int(n),
            global_visit::Either::Right(v) => v.visit_big_int(n),
        }
    }
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        match self {
            global_visit::Either::Left(v) => v.visit_big_int_value(n),
            global_visit::Either::Right(v) => v.visit_big_int_value(n),
        }
    }
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_bin_expr(n),
            global_visit::Either::Right(v) => v.visit_bin_expr(n),
        }
    }
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_binary_op(n),
            global_visit::Either::Right(v) => v.visit_binary_op(n),
        }
    }
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        match self {
            global_visit::Either::Left(v) => v.visit_binding_ident(n),
            global_visit::Either::Right(v) => v.visit_binding_ident(n),
        }
    }
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_block_stmt(n),
            global_visit::Either::Right(v) => v.visit_block_stmt(n),
        }
    }
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_block_stmt_or_expr(n),
            global_visit::Either::Right(v) => v.visit_block_stmt_or_expr(n),
        }
    }
    fn visit_bool(&mut self, n: &'ast Bool) {
        match self {
            global_visit::Either::Left(v) => v.visit_bool(n),
            global_visit::Either::Right(v) => v.visit_bool(n),
        }
    }
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_break_stmt(n),
            global_visit::Either::Right(v) => v.visit_break_stmt(n),
        }
    }
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_call_expr(n),
            global_visit::Either::Right(v) => v.visit_call_expr(n),
        }
    }
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        match self {
            global_visit::Either::Left(v) => v.visit_catch_clause(n),
            global_visit::Either::Right(v) => v.visit_catch_clause(n),
        }
    }
    fn visit_class(&mut self, n: &'ast Class) {
        match self {
            global_visit::Either::Left(v) => v.visit_class(n),
            global_visit::Either::Right(v) => v.visit_class(n),
        }
    }
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_decl(n),
            global_visit::Either::Right(v) => v.visit_class_decl(n),
        }
    }
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_expr(n),
            global_visit::Either::Right(v) => v.visit_class_expr(n),
        }
    }
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_member(n),
            global_visit::Either::Right(v) => v.visit_class_member(n),
        }
    }
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_members(n),
            global_visit::Either::Right(v) => v.visit_class_members(n),
        }
    }
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_method(n),
            global_visit::Either::Right(v) => v.visit_class_method(n),
        }
    }
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_prop(n),
            global_visit::Either::Right(v) => v.visit_class_prop(n),
        }
    }
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        match self {
            global_visit::Either::Left(v) => v.visit_computed_prop_name(n),
            global_visit::Either::Right(v) => v.visit_computed_prop_name(n),
        }
    }
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_cond_expr(n),
            global_visit::Either::Right(v) => v.visit_cond_expr(n),
        }
    }
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        match self {
            global_visit::Either::Left(v) => v.visit_constructor(n),
            global_visit::Either::Right(v) => v.visit_constructor(n),
        }
    }
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_continue_stmt(n),
            global_visit::Either::Right(v) => v.visit_continue_stmt(n),
        }
    }
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_debugger_stmt(n),
            global_visit::Either::Right(v) => v.visit_debugger_stmt(n),
        }
    }
    fn visit_decl(&mut self, n: &'ast Decl) {
        match self {
            global_visit::Either::Left(v) => v.visit_decl(n),
            global_visit::Either::Right(v) => v.visit_decl(n),
        }
    }
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        match self {
            global_visit::Either::Left(v) => v.visit_decorator(n),
            global_visit::Either::Right(v) => v.visit_decorator(n),
        }
    }
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        match self {
            global_visit::Either::Left(v) => v.visit_decorators(n),
            global_visit::Either::Right(v) => v.visit_decorators(n),
        }
    }
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_default_decl(n),
            global_visit::Either::Right(v) => v.visit_default_decl(n),
        }
    }
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_do_while_stmt(n),
            global_visit::Either::Right(v) => v.visit_do_while_stmt(n),
        }
    }
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_empty_stmt(n),
            global_visit::Either::Right(v) => v.visit_empty_stmt(n),
        }
    }
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_all(n),
            global_visit::Either::Right(v) => v.visit_export_all(n),
        }
    }
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_decl(n),
            global_visit::Either::Right(v) => v.visit_export_decl(n),
        }
    }
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_default_decl(n),
            global_visit::Either::Right(v) => v.visit_export_default_decl(n),
        }
    }
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_default_expr(n),
            global_visit::Either::Right(v) => v.visit_export_default_expr(n),
        }
    }
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_default_specifier(n),
            global_visit::Either::Right(v) => v.visit_export_default_specifier(n),
        }
    }
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_named_specifier(n),
            global_visit::Either::Right(v) => v.visit_export_named_specifier(n),
        }
    }
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_namespace_specifier(n),
            global_visit::Either::Right(v) => v.visit_export_namespace_specifier(n),
        }
    }
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_specifier(n),
            global_visit::Either::Right(v) => v.visit_export_specifier(n),
        }
    }
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_specifiers(n),
            global_visit::Either::Right(v) => v.visit_export_specifiers(n),
        }
    }
    fn visit_expr(&mut self, n: &'ast Expr) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr(n),
            global_visit::Either::Right(v) => v.visit_expr(n),
        }
    }
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr_or_spread(n),
            global_visit::Either::Right(v) => v.visit_expr_or_spread(n),
        }
    }
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_expr_or_spreads(n),
        }
    }
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr_or_super(n),
            global_visit::Either::Right(v) => v.visit_expr_or_super(n),
        }
    }
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr_stmt(n),
            global_visit::Either::Right(v) => v.visit_expr_stmt(n),
        }
    }
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        match self {
            global_visit::Either::Left(v) => v.visit_exprs(n),
            global_visit::Either::Right(v) => v.visit_exprs(n),
        }
    }
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_fn_decl(n),
            global_visit::Either::Right(v) => v.visit_fn_decl(n),
        }
    }
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_fn_expr(n),
            global_visit::Either::Right(v) => v.visit_fn_expr(n),
        }
    }
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_for_in_stmt(n),
            global_visit::Either::Right(v) => v.visit_for_in_stmt(n),
        }
    }
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_for_of_stmt(n),
            global_visit::Either::Right(v) => v.visit_for_of_stmt(n),
        }
    }
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_for_stmt(n),
            global_visit::Either::Right(v) => v.visit_for_stmt(n),
        }
    }
    fn visit_function(&mut self, n: &'ast Function) {
        match self {
            global_visit::Either::Left(v) => v.visit_function(n),
            global_visit::Either::Right(v) => v.visit_function(n),
        }
    }
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_getter_prop(n),
            global_visit::Either::Right(v) => v.visit_getter_prop(n),
        }
    }
    fn visit_ident(&mut self, n: &'ast Ident) {
        match self {
            global_visit::Either::Left(v) => v.visit_ident(n),
            global_visit::Either::Right(v) => v.visit_ident(n),
        }
    }
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_if_stmt(n),
            global_visit::Either::Right(v) => v.visit_if_stmt(n),
        }
    }
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_decl(n),
            global_visit::Either::Right(v) => v.visit_import_decl(n),
        }
    }
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_default_specifier(n),
            global_visit::Either::Right(v) => v.visit_import_default_specifier(n),
        }
    }
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_named_specifier(n),
            global_visit::Either::Right(v) => v.visit_import_named_specifier(n),
        }
    }
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_specifier(n),
            global_visit::Either::Right(v) => v.visit_import_specifier(n),
        }
    }
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_specifiers(n),
            global_visit::Either::Right(v) => v.visit_import_specifiers(n),
        }
    }
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_star_as_specifier(n),
            global_visit::Either::Right(v) => v.visit_import_star_as_specifier(n),
        }
    }
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        match self {
            global_visit::Either::Left(v) => v.visit_invalid(n),
            global_visit::Either::Right(v) => v.visit_invalid(n),
        }
    }
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        match self {
            global_visit::Either::Left(v) => v.visit_js_word(n),
            global_visit::Either::Right(v) => v.visit_js_word(n),
        }
    }
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr(n),
        }
    }
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr_name(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr_name(n),
        }
    }
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr_or_spread(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr_or_spread(n),
        }
    }
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr_or_spreads(n),
        }
    }
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr_value(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr_value(n),
        }
    }
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_closing_element(n),
            global_visit::Either::Right(v) => v.visit_jsx_closing_element(n),
        }
    }
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_closing_fragment(n),
            global_visit::Either::Right(v) => v.visit_jsx_closing_fragment(n),
        }
    }
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_element(n),
            global_visit::Either::Right(v) => v.visit_jsx_element(n),
        }
    }
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_element_child(n),
            global_visit::Either::Right(v) => v.visit_jsx_element_child(n),
        }
    }
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_element_children(n),
            global_visit::Either::Right(v) => v.visit_jsx_element_children(n),
        }
    }
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_element_name(n),
            global_visit::Either::Right(v) => v.visit_jsx_element_name(n),
        }
    }
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_empty_expr(n),
            global_visit::Either::Right(v) => v.visit_jsx_empty_expr(n),
        }
    }
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_expr(n),
            global_visit::Either::Right(v) => v.visit_jsx_expr(n),
        }
    }
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_expr_container(n),
            global_visit::Either::Right(v) => v.visit_jsx_expr_container(n),
        }
    }
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_fragment(n),
            global_visit::Either::Right(v) => v.visit_jsx_fragment(n),
        }
    }
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_member_expr(n),
            global_visit::Either::Right(v) => v.visit_jsx_member_expr(n),
        }
    }
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_namespaced_name(n),
            global_visit::Either::Right(v) => v.visit_jsx_namespaced_name(n),
        }
    }
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_object(n),
            global_visit::Either::Right(v) => v.visit_jsx_object(n),
        }
    }
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_opening_element(n),
            global_visit::Either::Right(v) => v.visit_jsx_opening_element(n),
        }
    }
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_opening_fragment(n),
            global_visit::Either::Right(v) => v.visit_jsx_opening_fragment(n),
        }
    }
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_spread_child(n),
            global_visit::Either::Right(v) => v.visit_jsx_spread_child(n),
        }
    }
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_text(n),
            global_visit::Either::Right(v) => v.visit_jsx_text(n),
        }
    }
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_key_value_pat_prop(n),
            global_visit::Either::Right(v) => v.visit_key_value_pat_prop(n),
        }
    }
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_key_value_prop(n),
            global_visit::Either::Right(v) => v.visit_key_value_prop(n),
        }
    }
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_labeled_stmt(n),
            global_visit::Either::Right(v) => v.visit_labeled_stmt(n),
        }
    }
    fn visit_lit(&mut self, n: &'ast Lit) {
        match self {
            global_visit::Either::Left(v) => v.visit_lit(n),
            global_visit::Either::Right(v) => v.visit_lit(n),
        }
    }
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_member_expr(n),
            global_visit::Either::Right(v) => v.visit_member_expr(n),
        }
    }
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_meta_prop_expr(n),
            global_visit::Either::Right(v) => v.visit_meta_prop_expr(n),
        }
    }
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        match self {
            global_visit::Either::Left(v) => v.visit_method_kind(n),
            global_visit::Either::Right(v) => v.visit_method_kind(n),
        }
    }
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_method_prop(n),
            global_visit::Either::Right(v) => v.visit_method_prop(n),
        }
    }
    fn visit_module(&mut self, n: &'ast Module) {
        match self {
            global_visit::Either::Left(v) => v.visit_module(n),
            global_visit::Either::Right(v) => v.visit_module(n),
        }
    }
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_module_decl(n),
            global_visit::Either::Right(v) => v.visit_module_decl(n),
        }
    }
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        match self {
            global_visit::Either::Left(v) => v.visit_module_item(n),
            global_visit::Either::Right(v) => v.visit_module_item(n),
        }
    }
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        match self {
            global_visit::Either::Left(v) => v.visit_module_items(n),
            global_visit::Either::Right(v) => v.visit_module_items(n),
        }
    }
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        match self {
            global_visit::Either::Left(v) => v.visit_named_export(n),
            global_visit::Either::Right(v) => v.visit_named_export(n),
        }
    }
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_new_expr(n),
            global_visit::Either::Right(v) => v.visit_new_expr(n),
        }
    }
    fn visit_null(&mut self, n: &'ast Null) {
        match self {
            global_visit::Either::Left(v) => v.visit_null(n),
            global_visit::Either::Right(v) => v.visit_null(n),
        }
    }
    fn visit_number(&mut self, n: &'ast Number) {
        match self {
            global_visit::Either::Left(v) => v.visit_number(n),
            global_visit::Either::Right(v) => v.visit_number(n),
        }
    }
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        match self {
            global_visit::Either::Left(v) => v.visit_object_lit(n),
            global_visit::Either::Right(v) => v.visit_object_lit(n),
        }
    }
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_object_pat(n),
            global_visit::Either::Right(v) => v.visit_object_pat(n),
        }
    }
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_object_pat_prop(n),
            global_visit::Either::Right(v) => v.visit_object_pat_prop(n),
        }
    }
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        match self {
            global_visit::Either::Left(v) => v.visit_object_pat_props(n),
            global_visit::Either::Right(v) => v.visit_object_pat_props(n),
        }
    }
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_accessibility(n),
            global_visit::Either::Right(v) => v.visit_opt_accessibility(n),
        }
    }
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_block_stmt(n),
            global_visit::Either::Right(v) => v.visit_opt_block_stmt(n),
        }
    }
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_catch_clause(n),
            global_visit::Either::Right(v) => v.visit_opt_catch_clause(n),
        }
    }
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_chain_expr(n),
            global_visit::Either::Right(v) => v.visit_opt_chain_expr(n),
        }
    }
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_expr(n),
            global_visit::Either::Right(v) => v.visit_opt_expr(n),
        }
    }
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_expr_or_spread(n),
            global_visit::Either::Right(v) => v.visit_opt_expr_or_spread(n),
        }
    }
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_expr_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_opt_expr_or_spreads(n),
        }
    }
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ident(n),
            global_visit::Either::Right(v) => v.visit_opt_ident(n),
        }
    }
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_js_word(n),
            global_visit::Either::Right(v) => v.visit_opt_js_word(n),
        }
    }
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_jsx_attr_value(n),
            global_visit::Either::Right(v) => v.visit_opt_jsx_attr_value(n),
        }
    }
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_jsx_closing_element(n),
            global_visit::Either::Right(v) => v.visit_opt_jsx_closing_element(n),
        }
    }
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_object_lit(n),
            global_visit::Either::Right(v) => v.visit_opt_object_lit(n),
        }
    }
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_pat(n),
            global_visit::Either::Right(v) => v.visit_opt_pat(n),
        }
    }
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_span(n),
            global_visit::Either::Right(v) => v.visit_opt_span(n),
        }
    }
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_stmt(n),
            global_visit::Either::Right(v) => v.visit_opt_stmt(n),
        }
    }
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_str(n),
            global_visit::Either::Right(v) => v.visit_opt_str(n),
        }
    }
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_true_plus_minus(n),
            global_visit::Either::Right(v) => v.visit_opt_true_plus_minus(n),
        }
    }
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_entity_name(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_entity_name(n),
        }
    }
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_namespace_body(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_namespace_body(n),
        }
    }
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_type(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_type(n),
        }
    }
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_type_ann(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_type_ann(n),
        }
    }
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_type_param_decl(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_type_param_decl(n),
        }
    }
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_type_param_instantiation(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_type_param_instantiation(n),
        }
    }
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_var_decl_or_expr(n),
            global_visit::Either::Right(v) => v.visit_opt_var_decl_or_expr(n),
        }
    }
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_vec_expr_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_opt_vec_expr_or_spreads(n),
        }
    }
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_vec_pats(n),
            global_visit::Either::Right(v) => v.visit_opt_vec_pats(n),
        }
    }
    fn visit_param(&mut self, n: &'ast Param) {
        match self {
            global_visit::Either::Left(v) => v.visit_param(n),
            global_visit::Either::Right(v) => v.visit_param(n),
        }
    }
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_param_or_ts_param_prop(n),
            global_visit::Either::Right(v) => v.visit_param_or_ts_param_prop(n),
        }
    }
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        match self {
            global_visit::Either::Left(v) => v.visit_param_or_ts_param_props(n),
            global_visit::Either::Right(v) => v.visit_param_or_ts_param_props(n),
        }
    }
    fn visit_params(&mut self, n: &'ast [Param]) {
        match self {
            global_visit::Either::Left(v) => v.visit_params(n),
            global_visit::Either::Right(v) => v.visit_params(n),
        }
    }
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_paren_expr(n),
            global_visit::Either::Right(v) => v.visit_paren_expr(n),
        }
    }
    fn visit_pat(&mut self, n: &'ast Pat) {
        match self {
            global_visit::Either::Left(v) => v.visit_pat(n),
            global_visit::Either::Right(v) => v.visit_pat(n),
        }
    }
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_pat_or_expr(n),
            global_visit::Either::Right(v) => v.visit_pat_or_expr(n),
        }
    }
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        match self {
            global_visit::Either::Left(v) => v.visit_pats(n),
            global_visit::Either::Right(v) => v.visit_pats(n),
        }
    }
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        match self {
            global_visit::Either::Left(v) => v.visit_private_method(n),
            global_visit::Either::Right(v) => v.visit_private_method(n),
        }
    }
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        match self {
            global_visit::Either::Left(v) => v.visit_private_name(n),
            global_visit::Either::Right(v) => v.visit_private_name(n),
        }
    }
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_private_prop(n),
            global_visit::Either::Right(v) => v.visit_private_prop(n),
        }
    }
    fn visit_program(&mut self, n: &'ast Program) {
        match self {
            global_visit::Either::Left(v) => v.visit_program(n),
            global_visit::Either::Right(v) => v.visit_program(n),
        }
    }
    fn visit_prop(&mut self, n: &'ast Prop) {
        match self {
            global_visit::Either::Left(v) => v.visit_prop(n),
            global_visit::Either::Right(v) => v.visit_prop(n),
        }
    }
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        match self {
            global_visit::Either::Left(v) => v.visit_prop_name(n),
            global_visit::Either::Right(v) => v.visit_prop_name(n),
        }
    }
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        match self {
            global_visit::Either::Left(v) => v.visit_prop_or_spread(n),
            global_visit::Either::Right(v) => v.visit_prop_or_spread(n),
        }
    }
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        match self {
            global_visit::Either::Left(v) => v.visit_prop_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_prop_or_spreads(n),
        }
    }
    fn visit_regex(&mut self, n: &'ast Regex) {
        match self {
            global_visit::Either::Left(v) => v.visit_regex(n),
            global_visit::Either::Right(v) => v.visit_regex(n),
        }
    }
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_rest_pat(n),
            global_visit::Either::Right(v) => v.visit_rest_pat(n),
        }
    }
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_return_stmt(n),
            global_visit::Either::Right(v) => v.visit_return_stmt(n),
        }
    }
    fn visit_script(&mut self, n: &'ast Script) {
        match self {
            global_visit::Either::Left(v) => v.visit_script(n),
            global_visit::Either::Right(v) => v.visit_script(n),
        }
    }
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_seq_expr(n),
            global_visit::Either::Right(v) => v.visit_seq_expr(n),
        }
    }
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_setter_prop(n),
            global_visit::Either::Right(v) => v.visit_setter_prop(n),
        }
    }
    fn visit_span(&mut self, n: &'ast Span) {
        match self {
            global_visit::Either::Left(v) => v.visit_span(n),
            global_visit::Either::Right(v) => v.visit_span(n),
        }
    }
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_spread_element(n),
            global_visit::Either::Right(v) => v.visit_spread_element(n),
        }
    }
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_stmt(n),
            global_visit::Either::Right(v) => v.visit_stmt(n),
        }
    }
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        match self {
            global_visit::Either::Left(v) => v.visit_stmts(n),
            global_visit::Either::Right(v) => v.visit_stmts(n),
        }
    }
    fn visit_str(&mut self, n: &'ast Str) {
        match self {
            global_visit::Either::Left(v) => v.visit_str(n),
            global_visit::Either::Right(v) => v.visit_str(n),
        }
    }
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        match self {
            global_visit::Either::Left(v) => v.visit_str_kind(n),
            global_visit::Either::Right(v) => v.visit_str_kind(n),
        }
    }
    fn visit_super(&mut self, n: &'ast Super) {
        match self {
            global_visit::Either::Left(v) => v.visit_super(n),
            global_visit::Either::Right(v) => v.visit_super(n),
        }
    }
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        match self {
            global_visit::Either::Left(v) => v.visit_switch_case(n),
            global_visit::Either::Right(v) => v.visit_switch_case(n),
        }
    }
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        match self {
            global_visit::Either::Left(v) => v.visit_switch_cases(n),
            global_visit::Either::Right(v) => v.visit_switch_cases(n),
        }
    }
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_switch_stmt(n),
            global_visit::Either::Right(v) => v.visit_switch_stmt(n),
        }
    }
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        match self {
            global_visit::Either::Left(v) => v.visit_tagged_tpl(n),
            global_visit::Either::Right(v) => v.visit_tagged_tpl(n),
        }
    }
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_this_expr(n),
            global_visit::Either::Right(v) => v.visit_this_expr(n),
        }
    }
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_throw_stmt(n),
            global_visit::Either::Right(v) => v.visit_throw_stmt(n),
        }
    }
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        match self {
            global_visit::Either::Left(v) => v.visit_tpl(n),
            global_visit::Either::Right(v) => v.visit_tpl(n),
        }
    }
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_tpl_element(n),
            global_visit::Either::Right(v) => v.visit_tpl_element(n),
        }
    }
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        match self {
            global_visit::Either::Left(v) => v.visit_tpl_elements(n),
            global_visit::Either::Right(v) => v.visit_tpl_elements(n),
        }
    }
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        match self {
            global_visit::Either::Left(v) => v.visit_true_plus_minus(n),
            global_visit::Either::Right(v) => v.visit_true_plus_minus(n),
        }
    }
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_try_stmt(n),
            global_visit::Either::Right(v) => v.visit_try_stmt(n),
        }
    }
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_array_type(n),
            global_visit::Either::Right(v) => v.visit_ts_array_type(n),
        }
    }
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_as_expr(n),
            global_visit::Either::Right(v) => v.visit_ts_as_expr(n),
        }
    }
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_call_signature_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_call_signature_decl(n),
        }
    }
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_conditional_type(n),
            global_visit::Either::Right(v) => v.visit_ts_conditional_type(n),
        }
    }
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_const_assertion(n),
            global_visit::Either::Right(v) => v.visit_ts_const_assertion(n),
        }
    }
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_construct_signature_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_construct_signature_decl(n),
        }
    }
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_constructor_type(n),
            global_visit::Either::Right(v) => v.visit_ts_constructor_type(n),
        }
    }
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_entity_name(n),
            global_visit::Either::Right(v) => v.visit_ts_entity_name(n),
        }
    }
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_enum_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_enum_decl(n),
        }
    }
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_enum_member(n),
            global_visit::Either::Right(v) => v.visit_ts_enum_member(n),
        }
    }
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_enum_member_id(n),
            global_visit::Either::Right(v) => v.visit_ts_enum_member_id(n),
        }
    }
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_enum_members(n),
            global_visit::Either::Right(v) => v.visit_ts_enum_members(n),
        }
    }
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_export_assignment(n),
            global_visit::Either::Right(v) => v.visit_ts_export_assignment(n),
        }
    }
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_expr_with_type_args(n),
            global_visit::Either::Right(v) => v.visit_ts_expr_with_type_args(n),
        }
    }
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_expr_with_type_args_vec(n),
            global_visit::Either::Right(v) => v.visit_ts_expr_with_type_args_vec(n),
        }
    }
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_external_module_ref(n),
            global_visit::Either::Right(v) => v.visit_ts_external_module_ref(n),
        }
    }
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_fn_or_constructor_type(n),
            global_visit::Either::Right(v) => v.visit_ts_fn_or_constructor_type(n),
        }
    }
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_fn_param(n),
            global_visit::Either::Right(v) => v.visit_ts_fn_param(n),
        }
    }
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_fn_params(n),
            global_visit::Either::Right(v) => v.visit_ts_fn_params(n),
        }
    }
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_fn_type(n),
            global_visit::Either::Right(v) => v.visit_ts_fn_type(n),
        }
    }
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_getter_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_getter_signature(n),
        }
    }
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_import_equals_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_import_equals_decl(n),
        }
    }
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_import_type(n),
            global_visit::Either::Right(v) => v.visit_ts_import_type(n),
        }
    }
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_index_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_index_signature(n),
        }
    }
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_indexed_access_type(n),
            global_visit::Either::Right(v) => v.visit_ts_indexed_access_type(n),
        }
    }
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_infer_type(n),
            global_visit::Either::Right(v) => v.visit_ts_infer_type(n),
        }
    }
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_interface_body(n),
            global_visit::Either::Right(v) => v.visit_ts_interface_body(n),
        }
    }
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_interface_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_interface_decl(n),
        }
    }
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_intersection_type(n),
            global_visit::Either::Right(v) => v.visit_ts_intersection_type(n),
        }
    }
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_keyword_type(n),
            global_visit::Either::Right(v) => v.visit_ts_keyword_type(n),
        }
    }
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_keyword_type_kind(n),
            global_visit::Either::Right(v) => v.visit_ts_keyword_type_kind(n),
        }
    }
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_lit(n),
            global_visit::Either::Right(v) => v.visit_ts_lit(n),
        }
    }
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_lit_type(n),
            global_visit::Either::Right(v) => v.visit_ts_lit_type(n),
        }
    }
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_mapped_type(n),
            global_visit::Either::Right(v) => v.visit_ts_mapped_type(n),
        }
    }
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_method_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_method_signature(n),
        }
    }
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_module_block(n),
            global_visit::Either::Right(v) => v.visit_ts_module_block(n),
        }
    }
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_module_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_module_decl(n),
        }
    }
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_module_name(n),
            global_visit::Either::Right(v) => v.visit_ts_module_name(n),
        }
    }
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_module_ref(n),
            global_visit::Either::Right(v) => v.visit_ts_module_ref(n),
        }
    }
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_namespace_body(n),
            global_visit::Either::Right(v) => v.visit_ts_namespace_body(n),
        }
    }
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_namespace_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_namespace_decl(n),
        }
    }
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_namespace_export_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_namespace_export_decl(n),
        }
    }
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_non_null_expr(n),
            global_visit::Either::Right(v) => v.visit_ts_non_null_expr(n),
        }
    }
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_optional_type(n),
            global_visit::Either::Right(v) => v.visit_ts_optional_type(n),
        }
    }
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_param_prop(n),
            global_visit::Either::Right(v) => v.visit_ts_param_prop(n),
        }
    }
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_param_prop_param(n),
            global_visit::Either::Right(v) => v.visit_ts_param_prop_param(n),
        }
    }
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_parenthesized_type(n),
            global_visit::Either::Right(v) => v.visit_ts_parenthesized_type(n),
        }
    }
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_property_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_property_signature(n),
        }
    }
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_qualified_name(n),
            global_visit::Either::Right(v) => v.visit_ts_qualified_name(n),
        }
    }
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_rest_type(n),
            global_visit::Either::Right(v) => v.visit_ts_rest_type(n),
        }
    }
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_setter_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_setter_signature(n),
        }
    }
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_this_type(n),
            global_visit::Either::Right(v) => v.visit_ts_this_type(n),
        }
    }
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_this_type_or_ident(n),
            global_visit::Either::Right(v) => v.visit_ts_this_type_or_ident(n),
        }
    }
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_tpl_lit_type(n),
            global_visit::Either::Right(v) => v.visit_ts_tpl_lit_type(n),
        }
    }
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_tuple_element(n),
            global_visit::Either::Right(v) => v.visit_ts_tuple_element(n),
        }
    }
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_tuple_elements(n),
            global_visit::Either::Right(v) => v.visit_ts_tuple_elements(n),
        }
    }
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_tuple_type(n),
            global_visit::Either::Right(v) => v.visit_ts_tuple_type(n),
        }
    }
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type(n),
            global_visit::Either::Right(v) => v.visit_ts_type(n),
        }
    }
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_alias_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_type_alias_decl(n),
        }
    }
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_ann(n),
            global_visit::Either::Right(v) => v.visit_ts_type_ann(n),
        }
    }
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_assertion(n),
            global_visit::Either::Right(v) => v.visit_ts_type_assertion(n),
        }
    }
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_element(n),
            global_visit::Either::Right(v) => v.visit_ts_type_element(n),
        }
    }
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_elements(n),
            global_visit::Either::Right(v) => v.visit_ts_type_elements(n),
        }
    }
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_lit(n),
            global_visit::Either::Right(v) => v.visit_ts_type_lit(n),
        }
    }
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_operator(n),
            global_visit::Either::Right(v) => v.visit_ts_type_operator(n),
        }
    }
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_operator_op(n),
            global_visit::Either::Right(v) => v.visit_ts_type_operator_op(n),
        }
    }
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_param(n),
            global_visit::Either::Right(v) => v.visit_ts_type_param(n),
        }
    }
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_param_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_type_param_decl(n),
        }
    }
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_param_instantiation(n),
            global_visit::Either::Right(v) => v.visit_ts_type_param_instantiation(n),
        }
    }
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_params(n),
            global_visit::Either::Right(v) => v.visit_ts_type_params(n),
        }
    }
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_predicate(n),
            global_visit::Either::Right(v) => v.visit_ts_type_predicate(n),
        }
    }
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_query(n),
            global_visit::Either::Right(v) => v.visit_ts_type_query(n),
        }
    }
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_query_expr(n),
            global_visit::Either::Right(v) => v.visit_ts_type_query_expr(n),
        }
    }
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_ref(n),
            global_visit::Either::Right(v) => v.visit_ts_type_ref(n),
        }
    }
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_types(n),
            global_visit::Either::Right(v) => v.visit_ts_types(n),
        }
    }
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_union_or_intersection_type(n),
            global_visit::Either::Right(v) => v.visit_ts_union_or_intersection_type(n),
        }
    }
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_union_type(n),
            global_visit::Either::Right(v) => v.visit_ts_union_type(n),
        }
    }
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_unary_expr(n),
            global_visit::Either::Right(v) => v.visit_unary_expr(n),
        }
    }
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_unary_op(n),
            global_visit::Either::Right(v) => v.visit_unary_op(n),
        }
    }
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_update_expr(n),
            global_visit::Either::Right(v) => v.visit_update_expr(n),
        }
    }
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_update_op(n),
            global_visit::Either::Right(v) => v.visit_update_op(n),
        }
    }
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_decl(n),
            global_visit::Either::Right(v) => v.visit_var_decl(n),
        }
    }
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_decl_kind(n),
            global_visit::Either::Right(v) => v.visit_var_decl_kind(n),
        }
    }
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_decl_or_expr(n),
            global_visit::Either::Right(v) => v.visit_var_decl_or_expr(n),
        }
    }
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_decl_or_pat(n),
            global_visit::Either::Right(v) => v.visit_var_decl_or_pat(n),
        }
    }
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_declarator(n),
            global_visit::Either::Right(v) => v.visit_var_declarator(n),
        }
    }
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_declarators(n),
            global_visit::Either::Right(v) => v.visit_var_declarators(n),
        }
    }
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_while_stmt(n),
            global_visit::Either::Right(v) => v.visit_while_stmt(n),
        }
    }
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_with_stmt(n),
            global_visit::Either::Right(v) => v.visit_with_stmt(n),
        }
    }
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_yield_expr(n),
            global_visit::Either::Right(v) => v.visit_yield_expr(n),
        }
    }
}
pub trait VisitWith<'ast, V: Visit<'ast>> {
    fn visit_with(&'ast self, v: &mut V);
    /// Visit children nodes of self with `v`
    fn visit_children_with(&'ast self, v: &mut V);
}
impl<'ast, V, T> VisitWith<'ast, V> for Box<T>
where
    V: Visit<'ast>,
    T: 'static + VisitWith<'ast, V>,
{
    fn visit_with(&'ast self, v: &mut V) {
        (**self).visit_with(v)
    }
    /// Visit children nodes of self with `v`
    fn visit_children_with(&'ast self, v: &mut V) {
        (**self).visit_children_with(v)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Accessibility {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_accessibility(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_accessibility(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ArrayLit {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_array_lit(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_array_lit(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ArrayPat {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_array_pat(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_array_pat(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ArrowExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_arrow_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_arrow_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for AssignExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_assign_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_assign_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for AssignOp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_assign_op(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_assign_op(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for AssignPat {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_assign_pat(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_assign_pat(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for AssignPatProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_assign_pat_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_assign_pat_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for AssignProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_assign_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_assign_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for AwaitExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_await_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_await_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for BigInt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_big_int(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_big_int(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for BigIntValue {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_big_int_value(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_big_int_value(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for BinExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_bin_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_bin_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for BinaryOp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_binary_op(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_binary_op(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for BindingIdent {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_binding_ident(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_binding_ident(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for BlockStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_block_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_block_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for BlockStmtOrExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_block_stmt_or_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_block_stmt_or_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Bool {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_bool(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_bool(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for BreakStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_break_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_break_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for CallExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_call_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_call_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for CatchClause {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_catch_clause(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_catch_clause(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Class {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_class(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_class(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ClassDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_class_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_class_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ClassExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_class_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_class_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ClassMember {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_class_member(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_class_member(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<ClassMember> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_class_members(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_class_members(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ClassMethod {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_class_method(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_class_method(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ClassProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_class_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_class_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ComputedPropName {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_computed_prop_name(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_computed_prop_name(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for CondExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_cond_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_cond_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Constructor {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_constructor(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_constructor(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ContinueStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_continue_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_continue_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for DebuggerStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_debugger_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_debugger_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Decl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Decorator {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_decorator(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_decorator(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<Decorator> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_decorators(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_decorators(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for DefaultDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_default_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_default_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for DoWhileStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_do_while_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_do_while_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for EmptyStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_empty_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_empty_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExportAll {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_export_all(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_export_all(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExportDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_export_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_export_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExportDefaultDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_export_default_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_export_default_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExportDefaultExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_export_default_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_export_default_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExportDefaultSpecifier {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_export_default_specifier(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_export_default_specifier(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExportNamedSpecifier {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_export_named_specifier(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_export_named_specifier(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExportNamespaceSpecifier {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_export_namespace_specifier(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_export_namespace_specifier(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExportSpecifier {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_export_specifier(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_export_specifier(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<ExportSpecifier> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_export_specifiers(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_export_specifiers(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Expr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExprOrSpread {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_expr_or_spread(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_expr_or_spread(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<ExprOrSpread> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_expr_or_spreads(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_expr_or_spreads(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExprOrSuper {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_expr_or_super(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_expr_or_super(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ExprStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_expr_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_expr_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<Box<Expr>> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_exprs(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_exprs(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for FnDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_fn_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_fn_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for FnExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_fn_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_fn_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ForInStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_for_in_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_for_in_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ForOfStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_for_of_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_for_of_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ForStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_for_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_for_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Function {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_function(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_function(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for GetterProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_getter_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_getter_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Ident {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ident(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ident(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for IfStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_if_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_if_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ImportDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_import_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_import_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ImportDefaultSpecifier {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_import_default_specifier(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_import_default_specifier(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ImportNamedSpecifier {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_import_named_specifier(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_import_named_specifier(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ImportSpecifier {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_import_specifier(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_import_specifier(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<ImportSpecifier> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_import_specifiers(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_import_specifiers(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ImportStarAsSpecifier {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_import_star_as_specifier(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_import_star_as_specifier(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Invalid {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_invalid(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_invalid(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JsWord {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_js_word(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_js_word(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXAttr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_attr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_attr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXAttrName {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_attr_name(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_attr_name(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXAttrOrSpread {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_attr_or_spread(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_attr_or_spread(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<JSXAttrOrSpread> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_attr_or_spreads(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_attr_or_spreads(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXAttrValue {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_attr_value(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_attr_value(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXClosingElement {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_closing_element(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_closing_element(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXClosingFragment {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_closing_fragment(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_closing_fragment(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXElement {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_element(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_element(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXElementChild {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_element_child(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_element_child(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<JSXElementChild> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_element_children(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_element_children(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXElementName {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_element_name(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_element_name(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXEmptyExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_empty_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_empty_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXExprContainer {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_expr_container(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_expr_container(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXFragment {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_fragment(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_fragment(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXMemberExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_member_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_member_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXNamespacedName {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_namespaced_name(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_namespaced_name(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXObject {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_object(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_object(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXOpeningElement {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_opening_element(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_opening_element(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXOpeningFragment {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_opening_fragment(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_opening_fragment(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXSpreadChild {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_spread_child(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_spread_child(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for JSXText {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_jsx_text(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_jsx_text(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for KeyValuePatProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_key_value_pat_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_key_value_pat_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for KeyValueProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_key_value_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_key_value_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for LabeledStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_labeled_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_labeled_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Lit {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_lit(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_lit(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for MemberExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_member_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_member_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for MetaPropExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_meta_prop_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_meta_prop_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for MethodKind {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_method_kind(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_method_kind(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for MethodProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_method_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_method_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Module {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_module(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_module(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ModuleDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_module_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_module_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ModuleItem {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_module_item(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_module_item(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<ModuleItem> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_module_items(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_module_items(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for NamedExport {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_named_export(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_named_export(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for NewExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_new_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_new_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Null {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_null(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_null(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Number {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_number(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_number(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ObjectLit {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_object_lit(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_object_lit(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ObjectPat {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_object_pat(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_object_pat(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ObjectPatProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_object_pat_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_object_pat_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<ObjectPatProp> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_object_pat_props(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_object_pat_props(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<Accessibility> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_accessibility(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_accessibility(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<BlockStmt> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_block_stmt(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_block_stmt(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<CatchClause> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_catch_clause(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_catch_clause(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for OptChainExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_chain_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_chain_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<Box<Expr>> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_expr(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_expr(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<ExprOrSpread> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_expr_or_spread(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_expr_or_spread(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<Vec<ExprOrSpread>> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_expr_or_spreads(self.as_ref().map(|v| &**v))
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_expr_or_spreads(_visitor, self.as_ref().map(|v| &**v))
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<Ident> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_ident(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_ident(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<JsWord> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_js_word(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_js_word(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<JSXAttrValue> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_jsx_attr_value(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_jsx_attr_value(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<JSXClosingElement> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_jsx_closing_element(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_jsx_closing_element(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<ObjectLit> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_object_lit(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_object_lit(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<Pat> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_pat(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_pat(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<Span> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_span(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_span(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<Box<Stmt>> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_stmt(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_stmt(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<Str> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_str(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_str(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<TruePlusMinus> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_true_plus_minus(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_true_plus_minus(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<TsEntityName> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_ts_entity_name(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_ts_entity_name(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<TsNamespaceBody> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_ts_namespace_body(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_ts_namespace_body(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<Box<TsType>> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_ts_type(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_ts_type(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<TsTypeAnn> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_ts_type_ann(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_ts_type_ann(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<TsTypeParamDecl> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_ts_type_param_decl(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_ts_type_param_decl(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<TsTypeParamInstantiation> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_ts_type_param_instantiation(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_ts_type_param_instantiation(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Option<VarDeclOrExpr> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_var_decl_or_expr(self.as_ref())
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_var_decl_or_expr(_visitor, self.as_ref())
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<Option<ExprOrSpread>> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_vec_expr_or_spreads(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_vec_expr_or_spreads(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<Option<Pat>> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_opt_vec_pats(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_opt_vec_pats(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Param {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_param(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_param(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ParamOrTsParamProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_param_or_ts_param_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_param_or_ts_param_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<ParamOrTsParamProp> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_param_or_ts_param_props(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_param_or_ts_param_props(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<Param> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_params(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_params(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ParenExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_paren_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_paren_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Pat {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_pat(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_pat(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for PatOrExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_pat_or_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_pat_or_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<Pat> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_pats(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_pats(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for PrivateMethod {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_private_method(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_private_method(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for PrivateName {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_private_name(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_private_name(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for PrivateProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_private_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_private_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Program {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_program(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_program(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Prop {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for PropName {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_prop_name(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_prop_name(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for PropOrSpread {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_prop_or_spread(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_prop_or_spread(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<PropOrSpread> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_prop_or_spreads(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_prop_or_spreads(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Regex {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_regex(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_regex(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for RestPat {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_rest_pat(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_rest_pat(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ReturnStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_return_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_return_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Script {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_script(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_script(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for SeqExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_seq_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_seq_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for SetterProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_setter_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_setter_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Span {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_span(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_span(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for SpreadElement {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_spread_element(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_spread_element(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Stmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<Stmt> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_stmts(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_stmts(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Str {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_str(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_str(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for StrKind {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_str_kind(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_str_kind(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Super {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_super(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_super(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for SwitchCase {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_switch_case(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_switch_case(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<SwitchCase> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_switch_cases(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_switch_cases(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for SwitchStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_switch_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_switch_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TaggedTpl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_tagged_tpl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_tagged_tpl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ThisExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_this_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_this_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for ThrowStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_throw_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_throw_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Tpl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_tpl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_tpl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TplElement {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_tpl_element(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_tpl_element(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<TplElement> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_tpl_elements(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_tpl_elements(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TruePlusMinus {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_true_plus_minus(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_true_plus_minus(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TryStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_try_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_try_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsArrayType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_array_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_array_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsAsExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_as_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_as_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsCallSignatureDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_call_signature_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_call_signature_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsConditionalType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_conditional_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_conditional_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsConstAssertion {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_const_assertion(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_const_assertion(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsConstructSignatureDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_construct_signature_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_construct_signature_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsConstructorType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_constructor_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_constructor_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsEntityName {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_entity_name(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_entity_name(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsEnumDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_enum_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_enum_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsEnumMember {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_enum_member(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_enum_member(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsEnumMemberId {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_enum_member_id(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_enum_member_id(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<TsEnumMember> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_enum_members(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_enum_members(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsExportAssignment {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_export_assignment(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_export_assignment(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsExprWithTypeArgs {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_expr_with_type_args(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_expr_with_type_args(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<TsExprWithTypeArgs> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_expr_with_type_args_vec(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_expr_with_type_args_vec(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsExternalModuleRef {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_external_module_ref(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_external_module_ref(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsFnOrConstructorType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_fn_or_constructor_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_fn_or_constructor_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsFnParam {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_fn_param(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_fn_param(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<TsFnParam> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_fn_params(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_fn_params(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsFnType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_fn_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_fn_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsGetterSignature {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_getter_signature(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_getter_signature(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsImportEqualsDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_import_equals_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_import_equals_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsImportType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_import_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_import_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsIndexSignature {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_index_signature(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_index_signature(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsIndexedAccessType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_indexed_access_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_indexed_access_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsInferType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_infer_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_infer_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsInterfaceBody {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_interface_body(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_interface_body(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsInterfaceDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_interface_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_interface_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsIntersectionType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_intersection_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_intersection_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsKeywordType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_keyword_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_keyword_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsKeywordTypeKind {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_keyword_type_kind(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_keyword_type_kind(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsLit {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_lit(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_lit(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsLitType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_lit_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_lit_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsMappedType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_mapped_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_mapped_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsMethodSignature {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_method_signature(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_method_signature(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsModuleBlock {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_module_block(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_module_block(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsModuleDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_module_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_module_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsModuleName {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_module_name(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_module_name(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsModuleRef {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_module_ref(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_module_ref(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsNamespaceBody {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_namespace_body(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_namespace_body(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsNamespaceDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_namespace_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_namespace_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsNamespaceExportDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_namespace_export_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_namespace_export_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsNonNullExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_non_null_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_non_null_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsOptionalType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_optional_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_optional_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsParamProp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_param_prop(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_param_prop(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsParamPropParam {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_param_prop_param(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_param_prop_param(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsParenthesizedType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_parenthesized_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_parenthesized_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsPropertySignature {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_property_signature(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_property_signature(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsQualifiedName {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_qualified_name(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_qualified_name(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsRestType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_rest_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_rest_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsSetterSignature {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_setter_signature(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_setter_signature(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsThisType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_this_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_this_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsThisTypeOrIdent {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_this_type_or_ident(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_this_type_or_ident(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTplLitType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_tpl_lit_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_tpl_lit_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTupleElement {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_tuple_element(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_tuple_element(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<TsTupleElement> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_tuple_elements(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_tuple_elements(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTupleType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_tuple_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_tuple_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeAliasDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_alias_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_alias_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeAnn {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_ann(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_ann(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeAssertion {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_assertion(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_assertion(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeElement {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_element(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_element(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<TsTypeElement> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_elements(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_elements(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeLit {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_lit(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_lit(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeOperator {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_operator(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_operator(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeOperatorOp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_operator_op(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_operator_op(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeParam {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_param(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_param(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeParamDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_param_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_param_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeParamInstantiation {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_param_instantiation(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_param_instantiation(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<TsTypeParam> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_params(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_params(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypePredicate {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_predicate(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_predicate(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeQuery {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_query(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_query(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeQueryExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_query_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_query_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsTypeRef {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_type_ref(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_type_ref(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<Box<TsType>> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_types(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_types(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsUnionOrIntersectionType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_union_or_intersection_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_union_or_intersection_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for TsUnionType {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_ts_union_type(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_ts_union_type(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for UnaryExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_unary_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_unary_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for UnaryOp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_unary_op(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_unary_op(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for UpdateExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_update_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_update_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for UpdateOp {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_update_op(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_update_op(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for VarDecl {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_var_decl(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_var_decl(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for VarDeclKind {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_var_decl_kind(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_var_decl_kind(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for VarDeclOrExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_var_decl_or_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_var_decl_or_expr(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for VarDeclOrPat {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_var_decl_or_pat(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_var_decl_or_pat(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for VarDeclarator {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_var_declarator(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_var_declarator(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for Vec<VarDeclarator> {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_var_declarators(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_var_declarators(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for WhileStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_while_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_while_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for WithStmt {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_with_stmt(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_with_stmt(_visitor, self)
    }
}
impl<'ast, V: Visit<'ast>> VisitWith<'ast, V> for YieldExpr {
    fn visit_with(&'ast self, v: &mut V) {
        v.visit_yield_expr(self)
    }
    fn visit_children_with(&'ast self, _visitor: &mut V) {
        visit_yield_expr(_visitor, self)
    }
}
pub trait VisitAll<'ast> {
    #[allow(unused_variables)]
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {}
    #[allow(unused_variables)]
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {}
    #[allow(unused_variables)]
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {}
    #[allow(unused_variables)]
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {}
    #[allow(unused_variables)]
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {}
    #[allow(unused_variables)]
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {}
    #[allow(unused_variables)]
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {}
    #[allow(unused_variables)]
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {}
    #[allow(unused_variables)]
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {}
    #[allow(unused_variables)]
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {}
    #[allow(unused_variables)]
    fn visit_big_int(&mut self, n: &'ast BigInt) {}
    #[allow(unused_variables)]
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {}
    #[allow(unused_variables)]
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {}
    #[allow(unused_variables)]
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {}
    #[allow(unused_variables)]
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {}
    #[allow(unused_variables)]
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {}
    #[allow(unused_variables)]
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {}
    #[allow(unused_variables)]
    fn visit_bool(&mut self, n: &'ast Bool) {}
    #[allow(unused_variables)]
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {}
    #[allow(unused_variables)]
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {}
    #[allow(unused_variables)]
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {}
    #[allow(unused_variables)]
    fn visit_class(&mut self, n: &'ast Class) {}
    #[allow(unused_variables)]
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {}
    #[allow(unused_variables)]
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {}
    #[allow(unused_variables)]
    fn visit_class_member(&mut self, n: &'ast ClassMember) {}
    #[allow(unused_variables)]
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {}
    #[allow(unused_variables)]
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {}
    #[allow(unused_variables)]
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {}
    #[allow(unused_variables)]
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {}
    #[allow(unused_variables)]
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {}
    #[allow(unused_variables)]
    fn visit_constructor(&mut self, n: &'ast Constructor) {}
    #[allow(unused_variables)]
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {}
    #[allow(unused_variables)]
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {}
    #[allow(unused_variables)]
    fn visit_decl(&mut self, n: &'ast Decl) {}
    #[allow(unused_variables)]
    fn visit_decorator(&mut self, n: &'ast Decorator) {}
    #[allow(unused_variables)]
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {}
    #[allow(unused_variables)]
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {}
    #[allow(unused_variables)]
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {}
    #[allow(unused_variables)]
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {}
    #[allow(unused_variables)]
    fn visit_export_all(&mut self, n: &'ast ExportAll) {}
    #[allow(unused_variables)]
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {}
    #[allow(unused_variables)]
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {}
    #[allow(unused_variables)]
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {}
    #[allow(unused_variables)]
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {}
    #[allow(unused_variables)]
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {}
    #[allow(unused_variables)]
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {}
    #[allow(unused_variables)]
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {}
    #[allow(unused_variables)]
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {}
    #[allow(unused_variables)]
    fn visit_expr(&mut self, n: &'ast Expr) {}
    #[allow(unused_variables)]
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {}
    #[allow(unused_variables)]
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {}
    #[allow(unused_variables)]
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {}
    #[allow(unused_variables)]
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {}
    #[allow(unused_variables)]
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {}
    #[allow(unused_variables)]
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {}
    #[allow(unused_variables)]
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {}
    #[allow(unused_variables)]
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {}
    #[allow(unused_variables)]
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {}
    #[allow(unused_variables)]
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {}
    #[allow(unused_variables)]
    fn visit_function(&mut self, n: &'ast Function) {}
    #[allow(unused_variables)]
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {}
    #[allow(unused_variables)]
    fn visit_ident(&mut self, n: &'ast Ident) {}
    #[allow(unused_variables)]
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {}
    #[allow(unused_variables)]
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {}
    #[allow(unused_variables)]
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {}
    #[allow(unused_variables)]
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {}
    #[allow(unused_variables)]
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {}
    #[allow(unused_variables)]
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {}
    #[allow(unused_variables)]
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {}
    #[allow(unused_variables)]
    fn visit_invalid(&mut self, n: &'ast Invalid) {}
    #[allow(unused_variables)]
    fn visit_js_word(&mut self, n: &'ast JsWord) {}
    #[allow(unused_variables)]
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {}
    #[allow(unused_variables)]
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {}
    #[allow(unused_variables)]
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {}
    #[allow(unused_variables)]
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {}
    #[allow(unused_variables)]
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {}
    #[allow(unused_variables)]
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {}
    #[allow(unused_variables)]
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {}
    #[allow(unused_variables)]
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {}
    #[allow(unused_variables)]
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {}
    #[allow(unused_variables)]
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {}
    #[allow(unused_variables)]
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {}
    #[allow(unused_variables)]
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {}
    #[allow(unused_variables)]
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {}
    #[allow(unused_variables)]
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {}
    #[allow(unused_variables)]
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {}
    #[allow(unused_variables)]
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {}
    #[allow(unused_variables)]
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {}
    #[allow(unused_variables)]
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {}
    #[allow(unused_variables)]
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {}
    #[allow(unused_variables)]
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {}
    #[allow(unused_variables)]
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {}
    #[allow(unused_variables)]
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {}
    #[allow(unused_variables)]
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {}
    #[allow(unused_variables)]
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {}
    #[allow(unused_variables)]
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {}
    #[allow(unused_variables)]
    fn visit_lit(&mut self, n: &'ast Lit) {}
    #[allow(unused_variables)]
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {}
    #[allow(unused_variables)]
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {}
    #[allow(unused_variables)]
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {}
    #[allow(unused_variables)]
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {}
    #[allow(unused_variables)]
    fn visit_module(&mut self, n: &'ast Module) {}
    #[allow(unused_variables)]
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {}
    #[allow(unused_variables)]
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {}
    #[allow(unused_variables)]
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {}
    #[allow(unused_variables)]
    fn visit_named_export(&mut self, n: &'ast NamedExport) {}
    #[allow(unused_variables)]
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {}
    #[allow(unused_variables)]
    fn visit_null(&mut self, n: &'ast Null) {}
    #[allow(unused_variables)]
    fn visit_number(&mut self, n: &'ast Number) {}
    #[allow(unused_variables)]
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {}
    #[allow(unused_variables)]
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {}
    #[allow(unused_variables)]
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {}
    #[allow(unused_variables)]
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {}
    #[allow(unused_variables)]
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {}
    #[allow(unused_variables)]
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {}
    #[allow(unused_variables)]
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {}
    #[allow(unused_variables)]
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {}
    #[allow(unused_variables)]
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {}
    #[allow(unused_variables)]
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {}
    #[allow(unused_variables)]
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {}
    #[allow(unused_variables)]
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {}
    #[allow(unused_variables)]
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {}
    #[allow(unused_variables)]
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {}
    #[allow(unused_variables)]
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {}
    #[allow(unused_variables)]
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {}
    #[allow(unused_variables)]
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {}
    #[allow(unused_variables)]
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {}
    #[allow(unused_variables)]
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {}
    #[allow(unused_variables)]
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {}
    #[allow(unused_variables)]
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {}
    #[allow(unused_variables)]
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {}
    #[allow(unused_variables)]
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {}
    #[allow(unused_variables)]
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {}
    #[allow(unused_variables)]
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {}
    #[allow(unused_variables)]
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {}
    #[allow(unused_variables)]
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
    }
    #[allow(unused_variables)]
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {}
    #[allow(unused_variables)]
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {}
    #[allow(unused_variables)]
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {}
    #[allow(unused_variables)]
    fn visit_param(&mut self, n: &'ast Param) {}
    #[allow(unused_variables)]
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {}
    #[allow(unused_variables)]
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {}
    #[allow(unused_variables)]
    fn visit_params(&mut self, n: &'ast [Param]) {}
    #[allow(unused_variables)]
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {}
    #[allow(unused_variables)]
    fn visit_pat(&mut self, n: &'ast Pat) {}
    #[allow(unused_variables)]
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {}
    #[allow(unused_variables)]
    fn visit_pats(&mut self, n: &'ast [Pat]) {}
    #[allow(unused_variables)]
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {}
    #[allow(unused_variables)]
    fn visit_private_name(&mut self, n: &'ast PrivateName) {}
    #[allow(unused_variables)]
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {}
    #[allow(unused_variables)]
    fn visit_program(&mut self, n: &'ast Program) {}
    #[allow(unused_variables)]
    fn visit_prop(&mut self, n: &'ast Prop) {}
    #[allow(unused_variables)]
    fn visit_prop_name(&mut self, n: &'ast PropName) {}
    #[allow(unused_variables)]
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {}
    #[allow(unused_variables)]
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {}
    #[allow(unused_variables)]
    fn visit_regex(&mut self, n: &'ast Regex) {}
    #[allow(unused_variables)]
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {}
    #[allow(unused_variables)]
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {}
    #[allow(unused_variables)]
    fn visit_script(&mut self, n: &'ast Script) {}
    #[allow(unused_variables)]
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {}
    #[allow(unused_variables)]
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {}
    #[allow(unused_variables)]
    fn visit_span(&mut self, n: &'ast Span) {}
    #[allow(unused_variables)]
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {}
    #[allow(unused_variables)]
    fn visit_stmt(&mut self, n: &'ast Stmt) {}
    #[allow(unused_variables)]
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {}
    #[allow(unused_variables)]
    fn visit_str(&mut self, n: &'ast Str) {}
    #[allow(unused_variables)]
    fn visit_str_kind(&mut self, n: &'ast StrKind) {}
    #[allow(unused_variables)]
    fn visit_super(&mut self, n: &'ast Super) {}
    #[allow(unused_variables)]
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {}
    #[allow(unused_variables)]
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {}
    #[allow(unused_variables)]
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {}
    #[allow(unused_variables)]
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {}
    #[allow(unused_variables)]
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {}
    #[allow(unused_variables)]
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {}
    #[allow(unused_variables)]
    fn visit_tpl(&mut self, n: &'ast Tpl) {}
    #[allow(unused_variables)]
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {}
    #[allow(unused_variables)]
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {}
    #[allow(unused_variables)]
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {}
    #[allow(unused_variables)]
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {}
    #[allow(unused_variables)]
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {}
    #[allow(unused_variables)]
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {}
    #[allow(unused_variables)]
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {}
    #[allow(unused_variables)]
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {}
    #[allow(unused_variables)]
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {}
    #[allow(unused_variables)]
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {}
    #[allow(unused_variables)]
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {}
    #[allow(unused_variables)]
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {}
    #[allow(unused_variables)]
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {}
    #[allow(unused_variables)]
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {}
    #[allow(unused_variables)]
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {}
    #[allow(unused_variables)]
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {}
    #[allow(unused_variables)]
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {}
    #[allow(unused_variables)]
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {}
    #[allow(unused_variables)]
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {}
    #[allow(unused_variables)]
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {}
    #[allow(unused_variables)]
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {}
    #[allow(unused_variables)]
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {}
    #[allow(unused_variables)]
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {}
    #[allow(unused_variables)]
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {}
    #[allow(unused_variables)]
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {}
    #[allow(unused_variables)]
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {}
    #[allow(unused_variables)]
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {}
    #[allow(unused_variables)]
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {}
    #[allow(unused_variables)]
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {}
    #[allow(unused_variables)]
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {}
    #[allow(unused_variables)]
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {}
    #[allow(unused_variables)]
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {}
    #[allow(unused_variables)]
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {}
    #[allow(unused_variables)]
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {}
    #[allow(unused_variables)]
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {}
    #[allow(unused_variables)]
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {}
    #[allow(unused_variables)]
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {}
    #[allow(unused_variables)]
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {}
    #[allow(unused_variables)]
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {}
    #[allow(unused_variables)]
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {}
    #[allow(unused_variables)]
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {}
    #[allow(unused_variables)]
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {}
    #[allow(unused_variables)]
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {}
    #[allow(unused_variables)]
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {}
    #[allow(unused_variables)]
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {}
    #[allow(unused_variables)]
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {}
    #[allow(unused_variables)]
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {}
    #[allow(unused_variables)]
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {}
    #[allow(unused_variables)]
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {}
    #[allow(unused_variables)]
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {}
    #[allow(unused_variables)]
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {}
    #[allow(unused_variables)]
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {}
    #[allow(unused_variables)]
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {}
    #[allow(unused_variables)]
    fn visit_ts_type(&mut self, n: &'ast TsType) {}
    #[allow(unused_variables)]
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {}
    #[allow(unused_variables)]
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {}
    #[allow(unused_variables)]
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {}
    #[allow(unused_variables)]
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {}
    #[allow(unused_variables)]
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {}
    #[allow(unused_variables)]
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {}
    #[allow(unused_variables)]
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {}
    #[allow(unused_variables)]
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {}
    #[allow(unused_variables)]
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {}
    #[allow(unused_variables)]
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {}
    #[allow(unused_variables)]
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {}
    #[allow(unused_variables)]
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {}
    #[allow(unused_variables)]
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {}
    #[allow(unused_variables)]
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {}
    #[allow(unused_variables)]
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {}
    #[allow(unused_variables)]
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {}
    #[allow(unused_variables)]
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {}
    #[allow(unused_variables)]
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {}
    #[allow(unused_variables)]
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {}
    #[allow(unused_variables)]
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {}
    #[allow(unused_variables)]
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {}
    #[allow(unused_variables)]
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {}
    #[allow(unused_variables)]
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {}
    #[allow(unused_variables)]
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {}
    #[allow(unused_variables)]
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {}
    #[allow(unused_variables)]
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {}
    #[allow(unused_variables)]
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {}
    #[allow(unused_variables)]
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {}
    #[allow(unused_variables)]
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {}
    #[allow(unused_variables)]
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {}
    #[allow(unused_variables)]
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {}
}
impl<'a, 'ast, V> VisitAll<'ast> for &'a mut V
where
    V: ?Sized + VisitAll<'ast>,
{
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        (**self).visit_accessibility(n)
    }
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        (**self).visit_array_lit(n)
    }
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        (**self).visit_array_pat(n)
    }
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        (**self).visit_arrow_expr(n)
    }
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        (**self).visit_assign_expr(n)
    }
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        (**self).visit_assign_op(n)
    }
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        (**self).visit_assign_pat(n)
    }
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        (**self).visit_assign_pat_prop(n)
    }
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        (**self).visit_assign_prop(n)
    }
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        (**self).visit_await_expr(n)
    }
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        (**self).visit_big_int(n)
    }
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        (**self).visit_big_int_value(n)
    }
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        (**self).visit_bin_expr(n)
    }
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        (**self).visit_binary_op(n)
    }
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        (**self).visit_binding_ident(n)
    }
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        (**self).visit_block_stmt(n)
    }
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        (**self).visit_block_stmt_or_expr(n)
    }
    fn visit_bool(&mut self, n: &'ast Bool) {
        (**self).visit_bool(n)
    }
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        (**self).visit_break_stmt(n)
    }
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        (**self).visit_call_expr(n)
    }
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        (**self).visit_catch_clause(n)
    }
    fn visit_class(&mut self, n: &'ast Class) {
        (**self).visit_class(n)
    }
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        (**self).visit_class_decl(n)
    }
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        (**self).visit_class_expr(n)
    }
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        (**self).visit_class_member(n)
    }
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        (**self).visit_class_members(n)
    }
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        (**self).visit_class_method(n)
    }
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        (**self).visit_class_prop(n)
    }
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        (**self).visit_computed_prop_name(n)
    }
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        (**self).visit_cond_expr(n)
    }
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        (**self).visit_constructor(n)
    }
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        (**self).visit_continue_stmt(n)
    }
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        (**self).visit_debugger_stmt(n)
    }
    fn visit_decl(&mut self, n: &'ast Decl) {
        (**self).visit_decl(n)
    }
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        (**self).visit_decorator(n)
    }
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        (**self).visit_decorators(n)
    }
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        (**self).visit_default_decl(n)
    }
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        (**self).visit_do_while_stmt(n)
    }
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        (**self).visit_empty_stmt(n)
    }
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        (**self).visit_export_all(n)
    }
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        (**self).visit_export_decl(n)
    }
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        (**self).visit_export_default_decl(n)
    }
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        (**self).visit_export_default_expr(n)
    }
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        (**self).visit_export_default_specifier(n)
    }
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        (**self).visit_export_named_specifier(n)
    }
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        (**self).visit_export_namespace_specifier(n)
    }
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        (**self).visit_export_specifier(n)
    }
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        (**self).visit_export_specifiers(n)
    }
    fn visit_expr(&mut self, n: &'ast Expr) {
        (**self).visit_expr(n)
    }
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        (**self).visit_expr_or_spread(n)
    }
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        (**self).visit_expr_or_spreads(n)
    }
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        (**self).visit_expr_or_super(n)
    }
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        (**self).visit_expr_stmt(n)
    }
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        (**self).visit_exprs(n)
    }
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        (**self).visit_fn_decl(n)
    }
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        (**self).visit_fn_expr(n)
    }
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        (**self).visit_for_in_stmt(n)
    }
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        (**self).visit_for_of_stmt(n)
    }
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        (**self).visit_for_stmt(n)
    }
    fn visit_function(&mut self, n: &'ast Function) {
        (**self).visit_function(n)
    }
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        (**self).visit_getter_prop(n)
    }
    fn visit_ident(&mut self, n: &'ast Ident) {
        (**self).visit_ident(n)
    }
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        (**self).visit_if_stmt(n)
    }
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        (**self).visit_import_decl(n)
    }
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        (**self).visit_import_default_specifier(n)
    }
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        (**self).visit_import_named_specifier(n)
    }
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        (**self).visit_import_specifier(n)
    }
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        (**self).visit_import_specifiers(n)
    }
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        (**self).visit_import_star_as_specifier(n)
    }
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        (**self).visit_invalid(n)
    }
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        (**self).visit_js_word(n)
    }
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        (**self).visit_jsx_attr(n)
    }
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        (**self).visit_jsx_attr_name(n)
    }
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        (**self).visit_jsx_attr_or_spread(n)
    }
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        (**self).visit_jsx_attr_or_spreads(n)
    }
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        (**self).visit_jsx_attr_value(n)
    }
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        (**self).visit_jsx_closing_element(n)
    }
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        (**self).visit_jsx_closing_fragment(n)
    }
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        (**self).visit_jsx_element(n)
    }
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        (**self).visit_jsx_element_child(n)
    }
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        (**self).visit_jsx_element_children(n)
    }
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        (**self).visit_jsx_element_name(n)
    }
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        (**self).visit_jsx_empty_expr(n)
    }
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        (**self).visit_jsx_expr(n)
    }
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        (**self).visit_jsx_expr_container(n)
    }
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        (**self).visit_jsx_fragment(n)
    }
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        (**self).visit_jsx_member_expr(n)
    }
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        (**self).visit_jsx_namespaced_name(n)
    }
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        (**self).visit_jsx_object(n)
    }
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        (**self).visit_jsx_opening_element(n)
    }
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        (**self).visit_jsx_opening_fragment(n)
    }
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        (**self).visit_jsx_spread_child(n)
    }
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        (**self).visit_jsx_text(n)
    }
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        (**self).visit_key_value_pat_prop(n)
    }
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        (**self).visit_key_value_prop(n)
    }
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        (**self).visit_labeled_stmt(n)
    }
    fn visit_lit(&mut self, n: &'ast Lit) {
        (**self).visit_lit(n)
    }
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        (**self).visit_member_expr(n)
    }
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        (**self).visit_meta_prop_expr(n)
    }
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        (**self).visit_method_kind(n)
    }
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        (**self).visit_method_prop(n)
    }
    fn visit_module(&mut self, n: &'ast Module) {
        (**self).visit_module(n)
    }
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        (**self).visit_module_decl(n)
    }
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        (**self).visit_module_item(n)
    }
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        (**self).visit_module_items(n)
    }
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        (**self).visit_named_export(n)
    }
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        (**self).visit_new_expr(n)
    }
    fn visit_null(&mut self, n: &'ast Null) {
        (**self).visit_null(n)
    }
    fn visit_number(&mut self, n: &'ast Number) {
        (**self).visit_number(n)
    }
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        (**self).visit_object_lit(n)
    }
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        (**self).visit_object_pat(n)
    }
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        (**self).visit_object_pat_prop(n)
    }
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        (**self).visit_object_pat_props(n)
    }
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        (**self).visit_opt_accessibility(n)
    }
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        (**self).visit_opt_block_stmt(n)
    }
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        (**self).visit_opt_catch_clause(n)
    }
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        (**self).visit_opt_chain_expr(n)
    }
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        (**self).visit_opt_expr(n)
    }
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        (**self).visit_opt_expr_or_spread(n)
    }
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        (**self).visit_opt_expr_or_spreads(n)
    }
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        (**self).visit_opt_ident(n)
    }
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        (**self).visit_opt_js_word(n)
    }
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        (**self).visit_opt_jsx_attr_value(n)
    }
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        (**self).visit_opt_jsx_closing_element(n)
    }
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        (**self).visit_opt_object_lit(n)
    }
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        (**self).visit_opt_pat(n)
    }
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        (**self).visit_opt_span(n)
    }
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        (**self).visit_opt_stmt(n)
    }
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        (**self).visit_opt_str(n)
    }
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        (**self).visit_opt_true_plus_minus(n)
    }
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        (**self).visit_opt_ts_entity_name(n)
    }
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        (**self).visit_opt_ts_namespace_body(n)
    }
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        (**self).visit_opt_ts_type(n)
    }
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        (**self).visit_opt_ts_type_ann(n)
    }
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        (**self).visit_opt_ts_type_param_decl(n)
    }
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        (**self).visit_opt_ts_type_param_instantiation(n)
    }
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        (**self).visit_opt_var_decl_or_expr(n)
    }
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        (**self).visit_opt_vec_expr_or_spreads(n)
    }
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        (**self).visit_opt_vec_pats(n)
    }
    fn visit_param(&mut self, n: &'ast Param) {
        (**self).visit_param(n)
    }
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        (**self).visit_param_or_ts_param_prop(n)
    }
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        (**self).visit_param_or_ts_param_props(n)
    }
    fn visit_params(&mut self, n: &'ast [Param]) {
        (**self).visit_params(n)
    }
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        (**self).visit_paren_expr(n)
    }
    fn visit_pat(&mut self, n: &'ast Pat) {
        (**self).visit_pat(n)
    }
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        (**self).visit_pat_or_expr(n)
    }
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        (**self).visit_pats(n)
    }
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        (**self).visit_private_method(n)
    }
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        (**self).visit_private_name(n)
    }
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        (**self).visit_private_prop(n)
    }
    fn visit_program(&mut self, n: &'ast Program) {
        (**self).visit_program(n)
    }
    fn visit_prop(&mut self, n: &'ast Prop) {
        (**self).visit_prop(n)
    }
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        (**self).visit_prop_name(n)
    }
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        (**self).visit_prop_or_spread(n)
    }
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        (**self).visit_prop_or_spreads(n)
    }
    fn visit_regex(&mut self, n: &'ast Regex) {
        (**self).visit_regex(n)
    }
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        (**self).visit_rest_pat(n)
    }
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        (**self).visit_return_stmt(n)
    }
    fn visit_script(&mut self, n: &'ast Script) {
        (**self).visit_script(n)
    }
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        (**self).visit_seq_expr(n)
    }
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        (**self).visit_setter_prop(n)
    }
    fn visit_span(&mut self, n: &'ast Span) {
        (**self).visit_span(n)
    }
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        (**self).visit_spread_element(n)
    }
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        (**self).visit_stmt(n)
    }
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        (**self).visit_stmts(n)
    }
    fn visit_str(&mut self, n: &'ast Str) {
        (**self).visit_str(n)
    }
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        (**self).visit_str_kind(n)
    }
    fn visit_super(&mut self, n: &'ast Super) {
        (**self).visit_super(n)
    }
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        (**self).visit_switch_case(n)
    }
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        (**self).visit_switch_cases(n)
    }
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        (**self).visit_switch_stmt(n)
    }
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        (**self).visit_tagged_tpl(n)
    }
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        (**self).visit_this_expr(n)
    }
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        (**self).visit_throw_stmt(n)
    }
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        (**self).visit_tpl(n)
    }
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        (**self).visit_tpl_element(n)
    }
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        (**self).visit_tpl_elements(n)
    }
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        (**self).visit_true_plus_minus(n)
    }
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        (**self).visit_try_stmt(n)
    }
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        (**self).visit_ts_array_type(n)
    }
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        (**self).visit_ts_as_expr(n)
    }
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        (**self).visit_ts_call_signature_decl(n)
    }
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        (**self).visit_ts_conditional_type(n)
    }
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        (**self).visit_ts_const_assertion(n)
    }
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        (**self).visit_ts_construct_signature_decl(n)
    }
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        (**self).visit_ts_constructor_type(n)
    }
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        (**self).visit_ts_entity_name(n)
    }
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        (**self).visit_ts_enum_decl(n)
    }
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        (**self).visit_ts_enum_member(n)
    }
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        (**self).visit_ts_enum_member_id(n)
    }
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        (**self).visit_ts_enum_members(n)
    }
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        (**self).visit_ts_export_assignment(n)
    }
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        (**self).visit_ts_expr_with_type_args(n)
    }
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        (**self).visit_ts_expr_with_type_args_vec(n)
    }
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        (**self).visit_ts_external_module_ref(n)
    }
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        (**self).visit_ts_fn_or_constructor_type(n)
    }
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        (**self).visit_ts_fn_param(n)
    }
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        (**self).visit_ts_fn_params(n)
    }
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        (**self).visit_ts_fn_type(n)
    }
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        (**self).visit_ts_getter_signature(n)
    }
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        (**self).visit_ts_import_equals_decl(n)
    }
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        (**self).visit_ts_import_type(n)
    }
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        (**self).visit_ts_index_signature(n)
    }
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        (**self).visit_ts_indexed_access_type(n)
    }
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        (**self).visit_ts_infer_type(n)
    }
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        (**self).visit_ts_interface_body(n)
    }
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        (**self).visit_ts_interface_decl(n)
    }
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        (**self).visit_ts_intersection_type(n)
    }
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        (**self).visit_ts_keyword_type(n)
    }
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        (**self).visit_ts_keyword_type_kind(n)
    }
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        (**self).visit_ts_lit(n)
    }
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        (**self).visit_ts_lit_type(n)
    }
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        (**self).visit_ts_mapped_type(n)
    }
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        (**self).visit_ts_method_signature(n)
    }
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        (**self).visit_ts_module_block(n)
    }
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        (**self).visit_ts_module_decl(n)
    }
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        (**self).visit_ts_module_name(n)
    }
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        (**self).visit_ts_module_ref(n)
    }
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        (**self).visit_ts_namespace_body(n)
    }
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        (**self).visit_ts_namespace_decl(n)
    }
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        (**self).visit_ts_namespace_export_decl(n)
    }
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        (**self).visit_ts_non_null_expr(n)
    }
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        (**self).visit_ts_optional_type(n)
    }
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        (**self).visit_ts_param_prop(n)
    }
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        (**self).visit_ts_param_prop_param(n)
    }
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        (**self).visit_ts_parenthesized_type(n)
    }
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        (**self).visit_ts_property_signature(n)
    }
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        (**self).visit_ts_qualified_name(n)
    }
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        (**self).visit_ts_rest_type(n)
    }
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        (**self).visit_ts_setter_signature(n)
    }
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        (**self).visit_ts_this_type(n)
    }
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        (**self).visit_ts_this_type_or_ident(n)
    }
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        (**self).visit_ts_tpl_lit_type(n)
    }
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        (**self).visit_ts_tuple_element(n)
    }
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        (**self).visit_ts_tuple_elements(n)
    }
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        (**self).visit_ts_tuple_type(n)
    }
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        (**self).visit_ts_type(n)
    }
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        (**self).visit_ts_type_alias_decl(n)
    }
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        (**self).visit_ts_type_ann(n)
    }
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        (**self).visit_ts_type_assertion(n)
    }
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        (**self).visit_ts_type_element(n)
    }
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        (**self).visit_ts_type_elements(n)
    }
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        (**self).visit_ts_type_lit(n)
    }
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        (**self).visit_ts_type_operator(n)
    }
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        (**self).visit_ts_type_operator_op(n)
    }
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        (**self).visit_ts_type_param(n)
    }
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        (**self).visit_ts_type_param_decl(n)
    }
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        (**self).visit_ts_type_param_instantiation(n)
    }
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        (**self).visit_ts_type_params(n)
    }
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        (**self).visit_ts_type_predicate(n)
    }
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        (**self).visit_ts_type_query(n)
    }
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        (**self).visit_ts_type_query_expr(n)
    }
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        (**self).visit_ts_type_ref(n)
    }
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        (**self).visit_ts_types(n)
    }
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        (**self).visit_ts_union_or_intersection_type(n)
    }
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        (**self).visit_ts_union_type(n)
    }
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        (**self).visit_unary_expr(n)
    }
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        (**self).visit_unary_op(n)
    }
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        (**self).visit_update_expr(n)
    }
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        (**self).visit_update_op(n)
    }
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        (**self).visit_var_decl(n)
    }
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        (**self).visit_var_decl_kind(n)
    }
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        (**self).visit_var_decl_or_expr(n)
    }
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        (**self).visit_var_decl_or_pat(n)
    }
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        (**self).visit_var_declarator(n)
    }
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        (**self).visit_var_declarators(n)
    }
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        (**self).visit_while_stmt(n)
    }
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        (**self).visit_with_stmt(n)
    }
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        (**self).visit_yield_expr(n)
    }
}
impl<'ast, V> VisitAll<'ast> for Box<V>
where
    V: ?Sized + VisitAll<'ast>,
{
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        (**self).visit_accessibility(n)
    }
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        (**self).visit_array_lit(n)
    }
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        (**self).visit_array_pat(n)
    }
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        (**self).visit_arrow_expr(n)
    }
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        (**self).visit_assign_expr(n)
    }
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        (**self).visit_assign_op(n)
    }
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        (**self).visit_assign_pat(n)
    }
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        (**self).visit_assign_pat_prop(n)
    }
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        (**self).visit_assign_prop(n)
    }
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        (**self).visit_await_expr(n)
    }
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        (**self).visit_big_int(n)
    }
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        (**self).visit_big_int_value(n)
    }
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        (**self).visit_bin_expr(n)
    }
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        (**self).visit_binary_op(n)
    }
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        (**self).visit_binding_ident(n)
    }
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        (**self).visit_block_stmt(n)
    }
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        (**self).visit_block_stmt_or_expr(n)
    }
    fn visit_bool(&mut self, n: &'ast Bool) {
        (**self).visit_bool(n)
    }
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        (**self).visit_break_stmt(n)
    }
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        (**self).visit_call_expr(n)
    }
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        (**self).visit_catch_clause(n)
    }
    fn visit_class(&mut self, n: &'ast Class) {
        (**self).visit_class(n)
    }
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        (**self).visit_class_decl(n)
    }
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        (**self).visit_class_expr(n)
    }
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        (**self).visit_class_member(n)
    }
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        (**self).visit_class_members(n)
    }
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        (**self).visit_class_method(n)
    }
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        (**self).visit_class_prop(n)
    }
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        (**self).visit_computed_prop_name(n)
    }
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        (**self).visit_cond_expr(n)
    }
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        (**self).visit_constructor(n)
    }
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        (**self).visit_continue_stmt(n)
    }
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        (**self).visit_debugger_stmt(n)
    }
    fn visit_decl(&mut self, n: &'ast Decl) {
        (**self).visit_decl(n)
    }
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        (**self).visit_decorator(n)
    }
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        (**self).visit_decorators(n)
    }
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        (**self).visit_default_decl(n)
    }
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        (**self).visit_do_while_stmt(n)
    }
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        (**self).visit_empty_stmt(n)
    }
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        (**self).visit_export_all(n)
    }
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        (**self).visit_export_decl(n)
    }
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        (**self).visit_export_default_decl(n)
    }
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        (**self).visit_export_default_expr(n)
    }
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        (**self).visit_export_default_specifier(n)
    }
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        (**self).visit_export_named_specifier(n)
    }
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        (**self).visit_export_namespace_specifier(n)
    }
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        (**self).visit_export_specifier(n)
    }
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        (**self).visit_export_specifiers(n)
    }
    fn visit_expr(&mut self, n: &'ast Expr) {
        (**self).visit_expr(n)
    }
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        (**self).visit_expr_or_spread(n)
    }
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        (**self).visit_expr_or_spreads(n)
    }
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        (**self).visit_expr_or_super(n)
    }
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        (**self).visit_expr_stmt(n)
    }
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        (**self).visit_exprs(n)
    }
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        (**self).visit_fn_decl(n)
    }
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        (**self).visit_fn_expr(n)
    }
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        (**self).visit_for_in_stmt(n)
    }
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        (**self).visit_for_of_stmt(n)
    }
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        (**self).visit_for_stmt(n)
    }
    fn visit_function(&mut self, n: &'ast Function) {
        (**self).visit_function(n)
    }
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        (**self).visit_getter_prop(n)
    }
    fn visit_ident(&mut self, n: &'ast Ident) {
        (**self).visit_ident(n)
    }
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        (**self).visit_if_stmt(n)
    }
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        (**self).visit_import_decl(n)
    }
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        (**self).visit_import_default_specifier(n)
    }
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        (**self).visit_import_named_specifier(n)
    }
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        (**self).visit_import_specifier(n)
    }
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        (**self).visit_import_specifiers(n)
    }
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        (**self).visit_import_star_as_specifier(n)
    }
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        (**self).visit_invalid(n)
    }
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        (**self).visit_js_word(n)
    }
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        (**self).visit_jsx_attr(n)
    }
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        (**self).visit_jsx_attr_name(n)
    }
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        (**self).visit_jsx_attr_or_spread(n)
    }
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        (**self).visit_jsx_attr_or_spreads(n)
    }
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        (**self).visit_jsx_attr_value(n)
    }
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        (**self).visit_jsx_closing_element(n)
    }
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        (**self).visit_jsx_closing_fragment(n)
    }
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        (**self).visit_jsx_element(n)
    }
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        (**self).visit_jsx_element_child(n)
    }
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        (**self).visit_jsx_element_children(n)
    }
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        (**self).visit_jsx_element_name(n)
    }
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        (**self).visit_jsx_empty_expr(n)
    }
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        (**self).visit_jsx_expr(n)
    }
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        (**self).visit_jsx_expr_container(n)
    }
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        (**self).visit_jsx_fragment(n)
    }
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        (**self).visit_jsx_member_expr(n)
    }
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        (**self).visit_jsx_namespaced_name(n)
    }
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        (**self).visit_jsx_object(n)
    }
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        (**self).visit_jsx_opening_element(n)
    }
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        (**self).visit_jsx_opening_fragment(n)
    }
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        (**self).visit_jsx_spread_child(n)
    }
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        (**self).visit_jsx_text(n)
    }
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        (**self).visit_key_value_pat_prop(n)
    }
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        (**self).visit_key_value_prop(n)
    }
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        (**self).visit_labeled_stmt(n)
    }
    fn visit_lit(&mut self, n: &'ast Lit) {
        (**self).visit_lit(n)
    }
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        (**self).visit_member_expr(n)
    }
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        (**self).visit_meta_prop_expr(n)
    }
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        (**self).visit_method_kind(n)
    }
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        (**self).visit_method_prop(n)
    }
    fn visit_module(&mut self, n: &'ast Module) {
        (**self).visit_module(n)
    }
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        (**self).visit_module_decl(n)
    }
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        (**self).visit_module_item(n)
    }
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        (**self).visit_module_items(n)
    }
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        (**self).visit_named_export(n)
    }
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        (**self).visit_new_expr(n)
    }
    fn visit_null(&mut self, n: &'ast Null) {
        (**self).visit_null(n)
    }
    fn visit_number(&mut self, n: &'ast Number) {
        (**self).visit_number(n)
    }
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        (**self).visit_object_lit(n)
    }
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        (**self).visit_object_pat(n)
    }
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        (**self).visit_object_pat_prop(n)
    }
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        (**self).visit_object_pat_props(n)
    }
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        (**self).visit_opt_accessibility(n)
    }
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        (**self).visit_opt_block_stmt(n)
    }
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        (**self).visit_opt_catch_clause(n)
    }
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        (**self).visit_opt_chain_expr(n)
    }
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        (**self).visit_opt_expr(n)
    }
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        (**self).visit_opt_expr_or_spread(n)
    }
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        (**self).visit_opt_expr_or_spreads(n)
    }
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        (**self).visit_opt_ident(n)
    }
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        (**self).visit_opt_js_word(n)
    }
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        (**self).visit_opt_jsx_attr_value(n)
    }
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        (**self).visit_opt_jsx_closing_element(n)
    }
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        (**self).visit_opt_object_lit(n)
    }
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        (**self).visit_opt_pat(n)
    }
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        (**self).visit_opt_span(n)
    }
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        (**self).visit_opt_stmt(n)
    }
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        (**self).visit_opt_str(n)
    }
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        (**self).visit_opt_true_plus_minus(n)
    }
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        (**self).visit_opt_ts_entity_name(n)
    }
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        (**self).visit_opt_ts_namespace_body(n)
    }
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        (**self).visit_opt_ts_type(n)
    }
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        (**self).visit_opt_ts_type_ann(n)
    }
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        (**self).visit_opt_ts_type_param_decl(n)
    }
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        (**self).visit_opt_ts_type_param_instantiation(n)
    }
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        (**self).visit_opt_var_decl_or_expr(n)
    }
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        (**self).visit_opt_vec_expr_or_spreads(n)
    }
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        (**self).visit_opt_vec_pats(n)
    }
    fn visit_param(&mut self, n: &'ast Param) {
        (**self).visit_param(n)
    }
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        (**self).visit_param_or_ts_param_prop(n)
    }
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        (**self).visit_param_or_ts_param_props(n)
    }
    fn visit_params(&mut self, n: &'ast [Param]) {
        (**self).visit_params(n)
    }
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        (**self).visit_paren_expr(n)
    }
    fn visit_pat(&mut self, n: &'ast Pat) {
        (**self).visit_pat(n)
    }
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        (**self).visit_pat_or_expr(n)
    }
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        (**self).visit_pats(n)
    }
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        (**self).visit_private_method(n)
    }
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        (**self).visit_private_name(n)
    }
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        (**self).visit_private_prop(n)
    }
    fn visit_program(&mut self, n: &'ast Program) {
        (**self).visit_program(n)
    }
    fn visit_prop(&mut self, n: &'ast Prop) {
        (**self).visit_prop(n)
    }
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        (**self).visit_prop_name(n)
    }
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        (**self).visit_prop_or_spread(n)
    }
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        (**self).visit_prop_or_spreads(n)
    }
    fn visit_regex(&mut self, n: &'ast Regex) {
        (**self).visit_regex(n)
    }
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        (**self).visit_rest_pat(n)
    }
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        (**self).visit_return_stmt(n)
    }
    fn visit_script(&mut self, n: &'ast Script) {
        (**self).visit_script(n)
    }
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        (**self).visit_seq_expr(n)
    }
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        (**self).visit_setter_prop(n)
    }
    fn visit_span(&mut self, n: &'ast Span) {
        (**self).visit_span(n)
    }
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        (**self).visit_spread_element(n)
    }
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        (**self).visit_stmt(n)
    }
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        (**self).visit_stmts(n)
    }
    fn visit_str(&mut self, n: &'ast Str) {
        (**self).visit_str(n)
    }
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        (**self).visit_str_kind(n)
    }
    fn visit_super(&mut self, n: &'ast Super) {
        (**self).visit_super(n)
    }
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        (**self).visit_switch_case(n)
    }
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        (**self).visit_switch_cases(n)
    }
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        (**self).visit_switch_stmt(n)
    }
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        (**self).visit_tagged_tpl(n)
    }
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        (**self).visit_this_expr(n)
    }
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        (**self).visit_throw_stmt(n)
    }
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        (**self).visit_tpl(n)
    }
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        (**self).visit_tpl_element(n)
    }
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        (**self).visit_tpl_elements(n)
    }
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        (**self).visit_true_plus_minus(n)
    }
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        (**self).visit_try_stmt(n)
    }
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        (**self).visit_ts_array_type(n)
    }
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        (**self).visit_ts_as_expr(n)
    }
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        (**self).visit_ts_call_signature_decl(n)
    }
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        (**self).visit_ts_conditional_type(n)
    }
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        (**self).visit_ts_const_assertion(n)
    }
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        (**self).visit_ts_construct_signature_decl(n)
    }
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        (**self).visit_ts_constructor_type(n)
    }
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        (**self).visit_ts_entity_name(n)
    }
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        (**self).visit_ts_enum_decl(n)
    }
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        (**self).visit_ts_enum_member(n)
    }
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        (**self).visit_ts_enum_member_id(n)
    }
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        (**self).visit_ts_enum_members(n)
    }
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        (**self).visit_ts_export_assignment(n)
    }
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        (**self).visit_ts_expr_with_type_args(n)
    }
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        (**self).visit_ts_expr_with_type_args_vec(n)
    }
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        (**self).visit_ts_external_module_ref(n)
    }
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        (**self).visit_ts_fn_or_constructor_type(n)
    }
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        (**self).visit_ts_fn_param(n)
    }
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        (**self).visit_ts_fn_params(n)
    }
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        (**self).visit_ts_fn_type(n)
    }
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        (**self).visit_ts_getter_signature(n)
    }
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        (**self).visit_ts_import_equals_decl(n)
    }
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        (**self).visit_ts_import_type(n)
    }
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        (**self).visit_ts_index_signature(n)
    }
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        (**self).visit_ts_indexed_access_type(n)
    }
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        (**self).visit_ts_infer_type(n)
    }
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        (**self).visit_ts_interface_body(n)
    }
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        (**self).visit_ts_interface_decl(n)
    }
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        (**self).visit_ts_intersection_type(n)
    }
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        (**self).visit_ts_keyword_type(n)
    }
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        (**self).visit_ts_keyword_type_kind(n)
    }
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        (**self).visit_ts_lit(n)
    }
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        (**self).visit_ts_lit_type(n)
    }
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        (**self).visit_ts_mapped_type(n)
    }
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        (**self).visit_ts_method_signature(n)
    }
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        (**self).visit_ts_module_block(n)
    }
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        (**self).visit_ts_module_decl(n)
    }
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        (**self).visit_ts_module_name(n)
    }
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        (**self).visit_ts_module_ref(n)
    }
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        (**self).visit_ts_namespace_body(n)
    }
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        (**self).visit_ts_namespace_decl(n)
    }
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        (**self).visit_ts_namespace_export_decl(n)
    }
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        (**self).visit_ts_non_null_expr(n)
    }
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        (**self).visit_ts_optional_type(n)
    }
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        (**self).visit_ts_param_prop(n)
    }
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        (**self).visit_ts_param_prop_param(n)
    }
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        (**self).visit_ts_parenthesized_type(n)
    }
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        (**self).visit_ts_property_signature(n)
    }
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        (**self).visit_ts_qualified_name(n)
    }
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        (**self).visit_ts_rest_type(n)
    }
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        (**self).visit_ts_setter_signature(n)
    }
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        (**self).visit_ts_this_type(n)
    }
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        (**self).visit_ts_this_type_or_ident(n)
    }
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        (**self).visit_ts_tpl_lit_type(n)
    }
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        (**self).visit_ts_tuple_element(n)
    }
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        (**self).visit_ts_tuple_elements(n)
    }
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        (**self).visit_ts_tuple_type(n)
    }
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        (**self).visit_ts_type(n)
    }
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        (**self).visit_ts_type_alias_decl(n)
    }
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        (**self).visit_ts_type_ann(n)
    }
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        (**self).visit_ts_type_assertion(n)
    }
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        (**self).visit_ts_type_element(n)
    }
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        (**self).visit_ts_type_elements(n)
    }
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        (**self).visit_ts_type_lit(n)
    }
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        (**self).visit_ts_type_operator(n)
    }
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        (**self).visit_ts_type_operator_op(n)
    }
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        (**self).visit_ts_type_param(n)
    }
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        (**self).visit_ts_type_param_decl(n)
    }
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        (**self).visit_ts_type_param_instantiation(n)
    }
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        (**self).visit_ts_type_params(n)
    }
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        (**self).visit_ts_type_predicate(n)
    }
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        (**self).visit_ts_type_query(n)
    }
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        (**self).visit_ts_type_query_expr(n)
    }
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        (**self).visit_ts_type_ref(n)
    }
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        (**self).visit_ts_types(n)
    }
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        (**self).visit_ts_union_or_intersection_type(n)
    }
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        (**self).visit_ts_union_type(n)
    }
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        (**self).visit_unary_expr(n)
    }
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        (**self).visit_unary_op(n)
    }
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        (**self).visit_update_expr(n)
    }
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        (**self).visit_update_op(n)
    }
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        (**self).visit_var_decl(n)
    }
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        (**self).visit_var_decl_kind(n)
    }
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        (**self).visit_var_decl_or_expr(n)
    }
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        (**self).visit_var_decl_or_pat(n)
    }
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        (**self).visit_var_declarator(n)
    }
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        (**self).visit_var_declarators(n)
    }
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        (**self).visit_while_stmt(n)
    }
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        (**self).visit_with_stmt(n)
    }
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        (**self).visit_yield_expr(n)
    }
}
impl<'ast, V> VisitAll<'ast> for ::global_visit::Optional<V>
where
    V: VisitAll<'ast>,
{
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        if self.enabled {
            self.visitor.visit_accessibility(n)
        }
    }
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        if self.enabled {
            self.visitor.visit_array_lit(n)
        }
    }
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        if self.enabled {
            self.visitor.visit_array_pat(n)
        }
    }
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        if self.enabled {
            self.visitor.visit_arrow_expr(n)
        }
    }
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        if self.enabled {
            self.visitor.visit_assign_expr(n)
        }
    }
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        if self.enabled {
            self.visitor.visit_assign_op(n)
        }
    }
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        if self.enabled {
            self.visitor.visit_assign_pat(n)
        }
    }
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        if self.enabled {
            self.visitor.visit_assign_pat_prop(n)
        }
    }
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        if self.enabled {
            self.visitor.visit_assign_prop(n)
        }
    }
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        if self.enabled {
            self.visitor.visit_await_expr(n)
        }
    }
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        if self.enabled {
            self.visitor.visit_big_int(n)
        }
    }
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        if self.enabled {
            self.visitor.visit_big_int_value(n)
        }
    }
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        if self.enabled {
            self.visitor.visit_bin_expr(n)
        }
    }
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        if self.enabled {
            self.visitor.visit_binary_op(n)
        }
    }
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        if self.enabled {
            self.visitor.visit_binding_ident(n)
        }
    }
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        if self.enabled {
            self.visitor.visit_block_stmt(n)
        }
    }
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        if self.enabled {
            self.visitor.visit_block_stmt_or_expr(n)
        }
    }
    fn visit_bool(&mut self, n: &'ast Bool) {
        if self.enabled {
            self.visitor.visit_bool(n)
        }
    }
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        if self.enabled {
            self.visitor.visit_break_stmt(n)
        }
    }
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        if self.enabled {
            self.visitor.visit_call_expr(n)
        }
    }
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        if self.enabled {
            self.visitor.visit_catch_clause(n)
        }
    }
    fn visit_class(&mut self, n: &'ast Class) {
        if self.enabled {
            self.visitor.visit_class(n)
        }
    }
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        if self.enabled {
            self.visitor.visit_class_decl(n)
        }
    }
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        if self.enabled {
            self.visitor.visit_class_expr(n)
        }
    }
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        if self.enabled {
            self.visitor.visit_class_member(n)
        }
    }
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        if self.enabled {
            self.visitor.visit_class_members(n)
        }
    }
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        if self.enabled {
            self.visitor.visit_class_method(n)
        }
    }
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        if self.enabled {
            self.visitor.visit_class_prop(n)
        }
    }
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        if self.enabled {
            self.visitor.visit_computed_prop_name(n)
        }
    }
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        if self.enabled {
            self.visitor.visit_cond_expr(n)
        }
    }
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        if self.enabled {
            self.visitor.visit_constructor(n)
        }
    }
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        if self.enabled {
            self.visitor.visit_continue_stmt(n)
        }
    }
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        if self.enabled {
            self.visitor.visit_debugger_stmt(n)
        }
    }
    fn visit_decl(&mut self, n: &'ast Decl) {
        if self.enabled {
            self.visitor.visit_decl(n)
        }
    }
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        if self.enabled {
            self.visitor.visit_decorator(n)
        }
    }
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        if self.enabled {
            self.visitor.visit_decorators(n)
        }
    }
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        if self.enabled {
            self.visitor.visit_default_decl(n)
        }
    }
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        if self.enabled {
            self.visitor.visit_do_while_stmt(n)
        }
    }
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        if self.enabled {
            self.visitor.visit_empty_stmt(n)
        }
    }
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        if self.enabled {
            self.visitor.visit_export_all(n)
        }
    }
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        if self.enabled {
            self.visitor.visit_export_decl(n)
        }
    }
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        if self.enabled {
            self.visitor.visit_export_default_decl(n)
        }
    }
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        if self.enabled {
            self.visitor.visit_export_default_expr(n)
        }
    }
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        if self.enabled {
            self.visitor.visit_export_default_specifier(n)
        }
    }
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        if self.enabled {
            self.visitor.visit_export_named_specifier(n)
        }
    }
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        if self.enabled {
            self.visitor.visit_export_namespace_specifier(n)
        }
    }
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        if self.enabled {
            self.visitor.visit_export_specifier(n)
        }
    }
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        if self.enabled {
            self.visitor.visit_export_specifiers(n)
        }
    }
    fn visit_expr(&mut self, n: &'ast Expr) {
        if self.enabled {
            self.visitor.visit_expr(n)
        }
    }
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        if self.enabled {
            self.visitor.visit_expr_or_spread(n)
        }
    }
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        if self.enabled {
            self.visitor.visit_expr_or_spreads(n)
        }
    }
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        if self.enabled {
            self.visitor.visit_expr_or_super(n)
        }
    }
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        if self.enabled {
            self.visitor.visit_expr_stmt(n)
        }
    }
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        if self.enabled {
            self.visitor.visit_exprs(n)
        }
    }
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        if self.enabled {
            self.visitor.visit_fn_decl(n)
        }
    }
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        if self.enabled {
            self.visitor.visit_fn_expr(n)
        }
    }
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        if self.enabled {
            self.visitor.visit_for_in_stmt(n)
        }
    }
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        if self.enabled {
            self.visitor.visit_for_of_stmt(n)
        }
    }
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        if self.enabled {
            self.visitor.visit_for_stmt(n)
        }
    }
    fn visit_function(&mut self, n: &'ast Function) {
        if self.enabled {
            self.visitor.visit_function(n)
        }
    }
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        if self.enabled {
            self.visitor.visit_getter_prop(n)
        }
    }
    fn visit_ident(&mut self, n: &'ast Ident) {
        if self.enabled {
            self.visitor.visit_ident(n)
        }
    }
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        if self.enabled {
            self.visitor.visit_if_stmt(n)
        }
    }
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        if self.enabled {
            self.visitor.visit_import_decl(n)
        }
    }
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        if self.enabled {
            self.visitor.visit_import_default_specifier(n)
        }
    }
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        if self.enabled {
            self.visitor.visit_import_named_specifier(n)
        }
    }
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        if self.enabled {
            self.visitor.visit_import_specifier(n)
        }
    }
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        if self.enabled {
            self.visitor.visit_import_specifiers(n)
        }
    }
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        if self.enabled {
            self.visitor.visit_import_star_as_specifier(n)
        }
    }
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        if self.enabled {
            self.visitor.visit_invalid(n)
        }
    }
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        if self.enabled {
            self.visitor.visit_js_word(n)
        }
    }
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        if self.enabled {
            self.visitor.visit_jsx_attr(n)
        }
    }
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        if self.enabled {
            self.visitor.visit_jsx_attr_name(n)
        }
    }
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        if self.enabled {
            self.visitor.visit_jsx_attr_or_spread(n)
        }
    }
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        if self.enabled {
            self.visitor.visit_jsx_attr_or_spreads(n)
        }
    }
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        if self.enabled {
            self.visitor.visit_jsx_attr_value(n)
        }
    }
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        if self.enabled {
            self.visitor.visit_jsx_closing_element(n)
        }
    }
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        if self.enabled {
            self.visitor.visit_jsx_closing_fragment(n)
        }
    }
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        if self.enabled {
            self.visitor.visit_jsx_element(n)
        }
    }
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        if self.enabled {
            self.visitor.visit_jsx_element_child(n)
        }
    }
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        if self.enabled {
            self.visitor.visit_jsx_element_children(n)
        }
    }
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        if self.enabled {
            self.visitor.visit_jsx_element_name(n)
        }
    }
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        if self.enabled {
            self.visitor.visit_jsx_empty_expr(n)
        }
    }
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        if self.enabled {
            self.visitor.visit_jsx_expr(n)
        }
    }
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        if self.enabled {
            self.visitor.visit_jsx_expr_container(n)
        }
    }
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        if self.enabled {
            self.visitor.visit_jsx_fragment(n)
        }
    }
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        if self.enabled {
            self.visitor.visit_jsx_member_expr(n)
        }
    }
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        if self.enabled {
            self.visitor.visit_jsx_namespaced_name(n)
        }
    }
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        if self.enabled {
            self.visitor.visit_jsx_object(n)
        }
    }
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        if self.enabled {
            self.visitor.visit_jsx_opening_element(n)
        }
    }
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        if self.enabled {
            self.visitor.visit_jsx_opening_fragment(n)
        }
    }
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        if self.enabled {
            self.visitor.visit_jsx_spread_child(n)
        }
    }
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        if self.enabled {
            self.visitor.visit_jsx_text(n)
        }
    }
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        if self.enabled {
            self.visitor.visit_key_value_pat_prop(n)
        }
    }
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        if self.enabled {
            self.visitor.visit_key_value_prop(n)
        }
    }
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        if self.enabled {
            self.visitor.visit_labeled_stmt(n)
        }
    }
    fn visit_lit(&mut self, n: &'ast Lit) {
        if self.enabled {
            self.visitor.visit_lit(n)
        }
    }
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        if self.enabled {
            self.visitor.visit_member_expr(n)
        }
    }
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        if self.enabled {
            self.visitor.visit_meta_prop_expr(n)
        }
    }
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        if self.enabled {
            self.visitor.visit_method_kind(n)
        }
    }
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        if self.enabled {
            self.visitor.visit_method_prop(n)
        }
    }
    fn visit_module(&mut self, n: &'ast Module) {
        if self.enabled {
            self.visitor.visit_module(n)
        }
    }
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        if self.enabled {
            self.visitor.visit_module_decl(n)
        }
    }
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        if self.enabled {
            self.visitor.visit_module_item(n)
        }
    }
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        if self.enabled {
            self.visitor.visit_module_items(n)
        }
    }
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        if self.enabled {
            self.visitor.visit_named_export(n)
        }
    }
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        if self.enabled {
            self.visitor.visit_new_expr(n)
        }
    }
    fn visit_null(&mut self, n: &'ast Null) {
        if self.enabled {
            self.visitor.visit_null(n)
        }
    }
    fn visit_number(&mut self, n: &'ast Number) {
        if self.enabled {
            self.visitor.visit_number(n)
        }
    }
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        if self.enabled {
            self.visitor.visit_object_lit(n)
        }
    }
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        if self.enabled {
            self.visitor.visit_object_pat(n)
        }
    }
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        if self.enabled {
            self.visitor.visit_object_pat_prop(n)
        }
    }
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        if self.enabled {
            self.visitor.visit_object_pat_props(n)
        }
    }
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        if self.enabled {
            self.visitor.visit_opt_accessibility(n)
        }
    }
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        if self.enabled {
            self.visitor.visit_opt_block_stmt(n)
        }
    }
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        if self.enabled {
            self.visitor.visit_opt_catch_clause(n)
        }
    }
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        if self.enabled {
            self.visitor.visit_opt_chain_expr(n)
        }
    }
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        if self.enabled {
            self.visitor.visit_opt_expr(n)
        }
    }
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        if self.enabled {
            self.visitor.visit_opt_expr_or_spread(n)
        }
    }
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        if self.enabled {
            self.visitor.visit_opt_expr_or_spreads(n)
        }
    }
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        if self.enabled {
            self.visitor.visit_opt_ident(n)
        }
    }
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        if self.enabled {
            self.visitor.visit_opt_js_word(n)
        }
    }
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        if self.enabled {
            self.visitor.visit_opt_jsx_attr_value(n)
        }
    }
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        if self.enabled {
            self.visitor.visit_opt_jsx_closing_element(n)
        }
    }
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        if self.enabled {
            self.visitor.visit_opt_object_lit(n)
        }
    }
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        if self.enabled {
            self.visitor.visit_opt_pat(n)
        }
    }
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        if self.enabled {
            self.visitor.visit_opt_span(n)
        }
    }
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        if self.enabled {
            self.visitor.visit_opt_stmt(n)
        }
    }
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        if self.enabled {
            self.visitor.visit_opt_str(n)
        }
    }
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        if self.enabled {
            self.visitor.visit_opt_true_plus_minus(n)
        }
    }
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        if self.enabled {
            self.visitor.visit_opt_ts_entity_name(n)
        }
    }
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        if self.enabled {
            self.visitor.visit_opt_ts_namespace_body(n)
        }
    }
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        if self.enabled {
            self.visitor.visit_opt_ts_type(n)
        }
    }
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        if self.enabled {
            self.visitor.visit_opt_ts_type_ann(n)
        }
    }
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        if self.enabled {
            self.visitor.visit_opt_ts_type_param_decl(n)
        }
    }
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        if self.enabled {
            self.visitor.visit_opt_ts_type_param_instantiation(n)
        }
    }
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        if self.enabled {
            self.visitor.visit_opt_var_decl_or_expr(n)
        }
    }
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        if self.enabled {
            self.visitor.visit_opt_vec_expr_or_spreads(n)
        }
    }
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        if self.enabled {
            self.visitor.visit_opt_vec_pats(n)
        }
    }
    fn visit_param(&mut self, n: &'ast Param) {
        if self.enabled {
            self.visitor.visit_param(n)
        }
    }
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        if self.enabled {
            self.visitor.visit_param_or_ts_param_prop(n)
        }
    }
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        if self.enabled {
            self.visitor.visit_param_or_ts_param_props(n)
        }
    }
    fn visit_params(&mut self, n: &'ast [Param]) {
        if self.enabled {
            self.visitor.visit_params(n)
        }
    }
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        if self.enabled {
            self.visitor.visit_paren_expr(n)
        }
    }
    fn visit_pat(&mut self, n: &'ast Pat) {
        if self.enabled {
            self.visitor.visit_pat(n)
        }
    }
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        if self.enabled {
            self.visitor.visit_pat_or_expr(n)
        }
    }
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        if self.enabled {
            self.visitor.visit_pats(n)
        }
    }
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        if self.enabled {
            self.visitor.visit_private_method(n)
        }
    }
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        if self.enabled {
            self.visitor.visit_private_name(n)
        }
    }
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        if self.enabled {
            self.visitor.visit_private_prop(n)
        }
    }
    fn visit_program(&mut self, n: &'ast Program) {
        if self.enabled {
            self.visitor.visit_program(n)
        }
    }
    fn visit_prop(&mut self, n: &'ast Prop) {
        if self.enabled {
            self.visitor.visit_prop(n)
        }
    }
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        if self.enabled {
            self.visitor.visit_prop_name(n)
        }
    }
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        if self.enabled {
            self.visitor.visit_prop_or_spread(n)
        }
    }
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        if self.enabled {
            self.visitor.visit_prop_or_spreads(n)
        }
    }
    fn visit_regex(&mut self, n: &'ast Regex) {
        if self.enabled {
            self.visitor.visit_regex(n)
        }
    }
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        if self.enabled {
            self.visitor.visit_rest_pat(n)
        }
    }
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        if self.enabled {
            self.visitor.visit_return_stmt(n)
        }
    }
    fn visit_script(&mut self, n: &'ast Script) {
        if self.enabled {
            self.visitor.visit_script(n)
        }
    }
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        if self.enabled {
            self.visitor.visit_seq_expr(n)
        }
    }
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        if self.enabled {
            self.visitor.visit_setter_prop(n)
        }
    }
    fn visit_span(&mut self, n: &'ast Span) {
        if self.enabled {
            self.visitor.visit_span(n)
        }
    }
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        if self.enabled {
            self.visitor.visit_spread_element(n)
        }
    }
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        if self.enabled {
            self.visitor.visit_stmt(n)
        }
    }
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        if self.enabled {
            self.visitor.visit_stmts(n)
        }
    }
    fn visit_str(&mut self, n: &'ast Str) {
        if self.enabled {
            self.visitor.visit_str(n)
        }
    }
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        if self.enabled {
            self.visitor.visit_str_kind(n)
        }
    }
    fn visit_super(&mut self, n: &'ast Super) {
        if self.enabled {
            self.visitor.visit_super(n)
        }
    }
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        if self.enabled {
            self.visitor.visit_switch_case(n)
        }
    }
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        if self.enabled {
            self.visitor.visit_switch_cases(n)
        }
    }
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        if self.enabled {
            self.visitor.visit_switch_stmt(n)
        }
    }
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        if self.enabled {
            self.visitor.visit_tagged_tpl(n)
        }
    }
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        if self.enabled {
            self.visitor.visit_this_expr(n)
        }
    }
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        if self.enabled {
            self.visitor.visit_throw_stmt(n)
        }
    }
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        if self.enabled {
            self.visitor.visit_tpl(n)
        }
    }
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        if self.enabled {
            self.visitor.visit_tpl_element(n)
        }
    }
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        if self.enabled {
            self.visitor.visit_tpl_elements(n)
        }
    }
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        if self.enabled {
            self.visitor.visit_true_plus_minus(n)
        }
    }
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        if self.enabled {
            self.visitor.visit_try_stmt(n)
        }
    }
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        if self.enabled {
            self.visitor.visit_ts_array_type(n)
        }
    }
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        if self.enabled {
            self.visitor.visit_ts_as_expr(n)
        }
    }
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        if self.enabled {
            self.visitor.visit_ts_call_signature_decl(n)
        }
    }
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        if self.enabled {
            self.visitor.visit_ts_conditional_type(n)
        }
    }
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        if self.enabled {
            self.visitor.visit_ts_const_assertion(n)
        }
    }
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        if self.enabled {
            self.visitor.visit_ts_construct_signature_decl(n)
        }
    }
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        if self.enabled {
            self.visitor.visit_ts_constructor_type(n)
        }
    }
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        if self.enabled {
            self.visitor.visit_ts_entity_name(n)
        }
    }
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        if self.enabled {
            self.visitor.visit_ts_enum_decl(n)
        }
    }
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        if self.enabled {
            self.visitor.visit_ts_enum_member(n)
        }
    }
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        if self.enabled {
            self.visitor.visit_ts_enum_member_id(n)
        }
    }
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        if self.enabled {
            self.visitor.visit_ts_enum_members(n)
        }
    }
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        if self.enabled {
            self.visitor.visit_ts_export_assignment(n)
        }
    }
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        if self.enabled {
            self.visitor.visit_ts_expr_with_type_args(n)
        }
    }
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        if self.enabled {
            self.visitor.visit_ts_expr_with_type_args_vec(n)
        }
    }
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        if self.enabled {
            self.visitor.visit_ts_external_module_ref(n)
        }
    }
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        if self.enabled {
            self.visitor.visit_ts_fn_or_constructor_type(n)
        }
    }
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        if self.enabled {
            self.visitor.visit_ts_fn_param(n)
        }
    }
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        if self.enabled {
            self.visitor.visit_ts_fn_params(n)
        }
    }
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        if self.enabled {
            self.visitor.visit_ts_fn_type(n)
        }
    }
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        if self.enabled {
            self.visitor.visit_ts_getter_signature(n)
        }
    }
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        if self.enabled {
            self.visitor.visit_ts_import_equals_decl(n)
        }
    }
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        if self.enabled {
            self.visitor.visit_ts_import_type(n)
        }
    }
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        if self.enabled {
            self.visitor.visit_ts_index_signature(n)
        }
    }
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        if self.enabled {
            self.visitor.visit_ts_indexed_access_type(n)
        }
    }
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        if self.enabled {
            self.visitor.visit_ts_infer_type(n)
        }
    }
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        if self.enabled {
            self.visitor.visit_ts_interface_body(n)
        }
    }
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        if self.enabled {
            self.visitor.visit_ts_interface_decl(n)
        }
    }
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        if self.enabled {
            self.visitor.visit_ts_intersection_type(n)
        }
    }
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        if self.enabled {
            self.visitor.visit_ts_keyword_type(n)
        }
    }
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        if self.enabled {
            self.visitor.visit_ts_keyword_type_kind(n)
        }
    }
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        if self.enabled {
            self.visitor.visit_ts_lit(n)
        }
    }
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        if self.enabled {
            self.visitor.visit_ts_lit_type(n)
        }
    }
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        if self.enabled {
            self.visitor.visit_ts_mapped_type(n)
        }
    }
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        if self.enabled {
            self.visitor.visit_ts_method_signature(n)
        }
    }
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        if self.enabled {
            self.visitor.visit_ts_module_block(n)
        }
    }
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        if self.enabled {
            self.visitor.visit_ts_module_decl(n)
        }
    }
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        if self.enabled {
            self.visitor.visit_ts_module_name(n)
        }
    }
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        if self.enabled {
            self.visitor.visit_ts_module_ref(n)
        }
    }
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        if self.enabled {
            self.visitor.visit_ts_namespace_body(n)
        }
    }
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        if self.enabled {
            self.visitor.visit_ts_namespace_decl(n)
        }
    }
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        if self.enabled {
            self.visitor.visit_ts_namespace_export_decl(n)
        }
    }
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        if self.enabled {
            self.visitor.visit_ts_non_null_expr(n)
        }
    }
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        if self.enabled {
            self.visitor.visit_ts_optional_type(n)
        }
    }
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        if self.enabled {
            self.visitor.visit_ts_param_prop(n)
        }
    }
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        if self.enabled {
            self.visitor.visit_ts_param_prop_param(n)
        }
    }
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        if self.enabled {
            self.visitor.visit_ts_parenthesized_type(n)
        }
    }
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        if self.enabled {
            self.visitor.visit_ts_property_signature(n)
        }
    }
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        if self.enabled {
            self.visitor.visit_ts_qualified_name(n)
        }
    }
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        if self.enabled {
            self.visitor.visit_ts_rest_type(n)
        }
    }
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        if self.enabled {
            self.visitor.visit_ts_setter_signature(n)
        }
    }
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        if self.enabled {
            self.visitor.visit_ts_this_type(n)
        }
    }
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        if self.enabled {
            self.visitor.visit_ts_this_type_or_ident(n)
        }
    }
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        if self.enabled {
            self.visitor.visit_ts_tpl_lit_type(n)
        }
    }
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        if self.enabled {
            self.visitor.visit_ts_tuple_element(n)
        }
    }
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        if self.enabled {
            self.visitor.visit_ts_tuple_elements(n)
        }
    }
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        if self.enabled {
            self.visitor.visit_ts_tuple_type(n)
        }
    }
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        if self.enabled {
            self.visitor.visit_ts_type(n)
        }
    }
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        if self.enabled {
            self.visitor.visit_ts_type_alias_decl(n)
        }
    }
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        if self.enabled {
            self.visitor.visit_ts_type_ann(n)
        }
    }
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        if self.enabled {
            self.visitor.visit_ts_type_assertion(n)
        }
    }
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        if self.enabled {
            self.visitor.visit_ts_type_element(n)
        }
    }
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        if self.enabled {
            self.visitor.visit_ts_type_elements(n)
        }
    }
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        if self.enabled {
            self.visitor.visit_ts_type_lit(n)
        }
    }
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        if self.enabled {
            self.visitor.visit_ts_type_operator(n)
        }
    }
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        if self.enabled {
            self.visitor.visit_ts_type_operator_op(n)
        }
    }
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        if self.enabled {
            self.visitor.visit_ts_type_param(n)
        }
    }
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        if self.enabled {
            self.visitor.visit_ts_type_param_decl(n)
        }
    }
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        if self.enabled {
            self.visitor.visit_ts_type_param_instantiation(n)
        }
    }
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        if self.enabled {
            self.visitor.visit_ts_type_params(n)
        }
    }
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        if self.enabled {
            self.visitor.visit_ts_type_predicate(n)
        }
    }
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        if self.enabled {
            self.visitor.visit_ts_type_query(n)
        }
    }
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        if self.enabled {
            self.visitor.visit_ts_type_query_expr(n)
        }
    }
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        if self.enabled {
            self.visitor.visit_ts_type_ref(n)
        }
    }
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        if self.enabled {
            self.visitor.visit_ts_types(n)
        }
    }
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        if self.enabled {
            self.visitor.visit_ts_union_or_intersection_type(n)
        }
    }
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        if self.enabled {
            self.visitor.visit_ts_union_type(n)
        }
    }
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        if self.enabled {
            self.visitor.visit_unary_expr(n)
        }
    }
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        if self.enabled {
            self.visitor.visit_unary_op(n)
        }
    }
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        if self.enabled {
            self.visitor.visit_update_expr(n)
        }
    }
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        if self.enabled {
            self.visitor.visit_update_op(n)
        }
    }
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        if self.enabled {
            self.visitor.visit_var_decl(n)
        }
    }
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        if self.enabled {
            self.visitor.visit_var_decl_kind(n)
        }
    }
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        if self.enabled {
            self.visitor.visit_var_decl_or_expr(n)
        }
    }
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        if self.enabled {
            self.visitor.visit_var_decl_or_pat(n)
        }
    }
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        if self.enabled {
            self.visitor.visit_var_declarator(n)
        }
    }
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        if self.enabled {
            self.visitor.visit_var_declarators(n)
        }
    }
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        if self.enabled {
            self.visitor.visit_while_stmt(n)
        }
    }
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        if self.enabled {
            self.visitor.visit_with_stmt(n)
        }
    }
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        if self.enabled {
            self.visitor.visit_yield_expr(n)
        }
    }
}
impl<'ast, A, B> VisitAll<'ast> for ::global_visit::Either<A, B>
where
    A: VisitAll<'ast>,
    B: VisitAll<'ast>,
{
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        match self {
            global_visit::Either::Left(v) => v.visit_accessibility(n),
            global_visit::Either::Right(v) => v.visit_accessibility(n),
        }
    }
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        match self {
            global_visit::Either::Left(v) => v.visit_array_lit(n),
            global_visit::Either::Right(v) => v.visit_array_lit(n),
        }
    }
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_array_pat(n),
            global_visit::Either::Right(v) => v.visit_array_pat(n),
        }
    }
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_arrow_expr(n),
            global_visit::Either::Right(v) => v.visit_arrow_expr(n),
        }
    }
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_expr(n),
            global_visit::Either::Right(v) => v.visit_assign_expr(n),
        }
    }
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_op(n),
            global_visit::Either::Right(v) => v.visit_assign_op(n),
        }
    }
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_pat(n),
            global_visit::Either::Right(v) => v.visit_assign_pat(n),
        }
    }
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_pat_prop(n),
            global_visit::Either::Right(v) => v.visit_assign_pat_prop(n),
        }
    }
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_assign_prop(n),
            global_visit::Either::Right(v) => v.visit_assign_prop(n),
        }
    }
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_await_expr(n),
            global_visit::Either::Right(v) => v.visit_await_expr(n),
        }
    }
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        match self {
            global_visit::Either::Left(v) => v.visit_big_int(n),
            global_visit::Either::Right(v) => v.visit_big_int(n),
        }
    }
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        match self {
            global_visit::Either::Left(v) => v.visit_big_int_value(n),
            global_visit::Either::Right(v) => v.visit_big_int_value(n),
        }
    }
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_bin_expr(n),
            global_visit::Either::Right(v) => v.visit_bin_expr(n),
        }
    }
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_binary_op(n),
            global_visit::Either::Right(v) => v.visit_binary_op(n),
        }
    }
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        match self {
            global_visit::Either::Left(v) => v.visit_binding_ident(n),
            global_visit::Either::Right(v) => v.visit_binding_ident(n),
        }
    }
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_block_stmt(n),
            global_visit::Either::Right(v) => v.visit_block_stmt(n),
        }
    }
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_block_stmt_or_expr(n),
            global_visit::Either::Right(v) => v.visit_block_stmt_or_expr(n),
        }
    }
    fn visit_bool(&mut self, n: &'ast Bool) {
        match self {
            global_visit::Either::Left(v) => v.visit_bool(n),
            global_visit::Either::Right(v) => v.visit_bool(n),
        }
    }
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_break_stmt(n),
            global_visit::Either::Right(v) => v.visit_break_stmt(n),
        }
    }
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_call_expr(n),
            global_visit::Either::Right(v) => v.visit_call_expr(n),
        }
    }
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        match self {
            global_visit::Either::Left(v) => v.visit_catch_clause(n),
            global_visit::Either::Right(v) => v.visit_catch_clause(n),
        }
    }
    fn visit_class(&mut self, n: &'ast Class) {
        match self {
            global_visit::Either::Left(v) => v.visit_class(n),
            global_visit::Either::Right(v) => v.visit_class(n),
        }
    }
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_decl(n),
            global_visit::Either::Right(v) => v.visit_class_decl(n),
        }
    }
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_expr(n),
            global_visit::Either::Right(v) => v.visit_class_expr(n),
        }
    }
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_member(n),
            global_visit::Either::Right(v) => v.visit_class_member(n),
        }
    }
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_members(n),
            global_visit::Either::Right(v) => v.visit_class_members(n),
        }
    }
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_method(n),
            global_visit::Either::Right(v) => v.visit_class_method(n),
        }
    }
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_class_prop(n),
            global_visit::Either::Right(v) => v.visit_class_prop(n),
        }
    }
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        match self {
            global_visit::Either::Left(v) => v.visit_computed_prop_name(n),
            global_visit::Either::Right(v) => v.visit_computed_prop_name(n),
        }
    }
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_cond_expr(n),
            global_visit::Either::Right(v) => v.visit_cond_expr(n),
        }
    }
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        match self {
            global_visit::Either::Left(v) => v.visit_constructor(n),
            global_visit::Either::Right(v) => v.visit_constructor(n),
        }
    }
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_continue_stmt(n),
            global_visit::Either::Right(v) => v.visit_continue_stmt(n),
        }
    }
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_debugger_stmt(n),
            global_visit::Either::Right(v) => v.visit_debugger_stmt(n),
        }
    }
    fn visit_decl(&mut self, n: &'ast Decl) {
        match self {
            global_visit::Either::Left(v) => v.visit_decl(n),
            global_visit::Either::Right(v) => v.visit_decl(n),
        }
    }
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        match self {
            global_visit::Either::Left(v) => v.visit_decorator(n),
            global_visit::Either::Right(v) => v.visit_decorator(n),
        }
    }
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        match self {
            global_visit::Either::Left(v) => v.visit_decorators(n),
            global_visit::Either::Right(v) => v.visit_decorators(n),
        }
    }
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_default_decl(n),
            global_visit::Either::Right(v) => v.visit_default_decl(n),
        }
    }
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_do_while_stmt(n),
            global_visit::Either::Right(v) => v.visit_do_while_stmt(n),
        }
    }
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_empty_stmt(n),
            global_visit::Either::Right(v) => v.visit_empty_stmt(n),
        }
    }
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_all(n),
            global_visit::Either::Right(v) => v.visit_export_all(n),
        }
    }
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_decl(n),
            global_visit::Either::Right(v) => v.visit_export_decl(n),
        }
    }
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_default_decl(n),
            global_visit::Either::Right(v) => v.visit_export_default_decl(n),
        }
    }
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_default_expr(n),
            global_visit::Either::Right(v) => v.visit_export_default_expr(n),
        }
    }
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_default_specifier(n),
            global_visit::Either::Right(v) => v.visit_export_default_specifier(n),
        }
    }
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_named_specifier(n),
            global_visit::Either::Right(v) => v.visit_export_named_specifier(n),
        }
    }
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_namespace_specifier(n),
            global_visit::Either::Right(v) => v.visit_export_namespace_specifier(n),
        }
    }
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_specifier(n),
            global_visit::Either::Right(v) => v.visit_export_specifier(n),
        }
    }
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        match self {
            global_visit::Either::Left(v) => v.visit_export_specifiers(n),
            global_visit::Either::Right(v) => v.visit_export_specifiers(n),
        }
    }
    fn visit_expr(&mut self, n: &'ast Expr) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr(n),
            global_visit::Either::Right(v) => v.visit_expr(n),
        }
    }
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr_or_spread(n),
            global_visit::Either::Right(v) => v.visit_expr_or_spread(n),
        }
    }
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_expr_or_spreads(n),
        }
    }
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr_or_super(n),
            global_visit::Either::Right(v) => v.visit_expr_or_super(n),
        }
    }
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_expr_stmt(n),
            global_visit::Either::Right(v) => v.visit_expr_stmt(n),
        }
    }
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        match self {
            global_visit::Either::Left(v) => v.visit_exprs(n),
            global_visit::Either::Right(v) => v.visit_exprs(n),
        }
    }
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_fn_decl(n),
            global_visit::Either::Right(v) => v.visit_fn_decl(n),
        }
    }
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_fn_expr(n),
            global_visit::Either::Right(v) => v.visit_fn_expr(n),
        }
    }
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_for_in_stmt(n),
            global_visit::Either::Right(v) => v.visit_for_in_stmt(n),
        }
    }
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_for_of_stmt(n),
            global_visit::Either::Right(v) => v.visit_for_of_stmt(n),
        }
    }
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_for_stmt(n),
            global_visit::Either::Right(v) => v.visit_for_stmt(n),
        }
    }
    fn visit_function(&mut self, n: &'ast Function) {
        match self {
            global_visit::Either::Left(v) => v.visit_function(n),
            global_visit::Either::Right(v) => v.visit_function(n),
        }
    }
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_getter_prop(n),
            global_visit::Either::Right(v) => v.visit_getter_prop(n),
        }
    }
    fn visit_ident(&mut self, n: &'ast Ident) {
        match self {
            global_visit::Either::Left(v) => v.visit_ident(n),
            global_visit::Either::Right(v) => v.visit_ident(n),
        }
    }
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_if_stmt(n),
            global_visit::Either::Right(v) => v.visit_if_stmt(n),
        }
    }
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_decl(n),
            global_visit::Either::Right(v) => v.visit_import_decl(n),
        }
    }
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_default_specifier(n),
            global_visit::Either::Right(v) => v.visit_import_default_specifier(n),
        }
    }
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_named_specifier(n),
            global_visit::Either::Right(v) => v.visit_import_named_specifier(n),
        }
    }
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_specifier(n),
            global_visit::Either::Right(v) => v.visit_import_specifier(n),
        }
    }
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_specifiers(n),
            global_visit::Either::Right(v) => v.visit_import_specifiers(n),
        }
    }
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        match self {
            global_visit::Either::Left(v) => v.visit_import_star_as_specifier(n),
            global_visit::Either::Right(v) => v.visit_import_star_as_specifier(n),
        }
    }
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        match self {
            global_visit::Either::Left(v) => v.visit_invalid(n),
            global_visit::Either::Right(v) => v.visit_invalid(n),
        }
    }
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        match self {
            global_visit::Either::Left(v) => v.visit_js_word(n),
            global_visit::Either::Right(v) => v.visit_js_word(n),
        }
    }
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr(n),
        }
    }
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr_name(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr_name(n),
        }
    }
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr_or_spread(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr_or_spread(n),
        }
    }
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr_or_spreads(n),
        }
    }
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_attr_value(n),
            global_visit::Either::Right(v) => v.visit_jsx_attr_value(n),
        }
    }
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_closing_element(n),
            global_visit::Either::Right(v) => v.visit_jsx_closing_element(n),
        }
    }
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_closing_fragment(n),
            global_visit::Either::Right(v) => v.visit_jsx_closing_fragment(n),
        }
    }
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_element(n),
            global_visit::Either::Right(v) => v.visit_jsx_element(n),
        }
    }
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_element_child(n),
            global_visit::Either::Right(v) => v.visit_jsx_element_child(n),
        }
    }
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_element_children(n),
            global_visit::Either::Right(v) => v.visit_jsx_element_children(n),
        }
    }
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_element_name(n),
            global_visit::Either::Right(v) => v.visit_jsx_element_name(n),
        }
    }
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_empty_expr(n),
            global_visit::Either::Right(v) => v.visit_jsx_empty_expr(n),
        }
    }
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_expr(n),
            global_visit::Either::Right(v) => v.visit_jsx_expr(n),
        }
    }
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_expr_container(n),
            global_visit::Either::Right(v) => v.visit_jsx_expr_container(n),
        }
    }
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_fragment(n),
            global_visit::Either::Right(v) => v.visit_jsx_fragment(n),
        }
    }
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_member_expr(n),
            global_visit::Either::Right(v) => v.visit_jsx_member_expr(n),
        }
    }
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_namespaced_name(n),
            global_visit::Either::Right(v) => v.visit_jsx_namespaced_name(n),
        }
    }
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_object(n),
            global_visit::Either::Right(v) => v.visit_jsx_object(n),
        }
    }
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_opening_element(n),
            global_visit::Either::Right(v) => v.visit_jsx_opening_element(n),
        }
    }
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_opening_fragment(n),
            global_visit::Either::Right(v) => v.visit_jsx_opening_fragment(n),
        }
    }
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_spread_child(n),
            global_visit::Either::Right(v) => v.visit_jsx_spread_child(n),
        }
    }
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        match self {
            global_visit::Either::Left(v) => v.visit_jsx_text(n),
            global_visit::Either::Right(v) => v.visit_jsx_text(n),
        }
    }
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_key_value_pat_prop(n),
            global_visit::Either::Right(v) => v.visit_key_value_pat_prop(n),
        }
    }
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_key_value_prop(n),
            global_visit::Either::Right(v) => v.visit_key_value_prop(n),
        }
    }
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_labeled_stmt(n),
            global_visit::Either::Right(v) => v.visit_labeled_stmt(n),
        }
    }
    fn visit_lit(&mut self, n: &'ast Lit) {
        match self {
            global_visit::Either::Left(v) => v.visit_lit(n),
            global_visit::Either::Right(v) => v.visit_lit(n),
        }
    }
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_member_expr(n),
            global_visit::Either::Right(v) => v.visit_member_expr(n),
        }
    }
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_meta_prop_expr(n),
            global_visit::Either::Right(v) => v.visit_meta_prop_expr(n),
        }
    }
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        match self {
            global_visit::Either::Left(v) => v.visit_method_kind(n),
            global_visit::Either::Right(v) => v.visit_method_kind(n),
        }
    }
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_method_prop(n),
            global_visit::Either::Right(v) => v.visit_method_prop(n),
        }
    }
    fn visit_module(&mut self, n: &'ast Module) {
        match self {
            global_visit::Either::Left(v) => v.visit_module(n),
            global_visit::Either::Right(v) => v.visit_module(n),
        }
    }
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_module_decl(n),
            global_visit::Either::Right(v) => v.visit_module_decl(n),
        }
    }
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        match self {
            global_visit::Either::Left(v) => v.visit_module_item(n),
            global_visit::Either::Right(v) => v.visit_module_item(n),
        }
    }
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        match self {
            global_visit::Either::Left(v) => v.visit_module_items(n),
            global_visit::Either::Right(v) => v.visit_module_items(n),
        }
    }
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        match self {
            global_visit::Either::Left(v) => v.visit_named_export(n),
            global_visit::Either::Right(v) => v.visit_named_export(n),
        }
    }
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_new_expr(n),
            global_visit::Either::Right(v) => v.visit_new_expr(n),
        }
    }
    fn visit_null(&mut self, n: &'ast Null) {
        match self {
            global_visit::Either::Left(v) => v.visit_null(n),
            global_visit::Either::Right(v) => v.visit_null(n),
        }
    }
    fn visit_number(&mut self, n: &'ast Number) {
        match self {
            global_visit::Either::Left(v) => v.visit_number(n),
            global_visit::Either::Right(v) => v.visit_number(n),
        }
    }
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        match self {
            global_visit::Either::Left(v) => v.visit_object_lit(n),
            global_visit::Either::Right(v) => v.visit_object_lit(n),
        }
    }
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_object_pat(n),
            global_visit::Either::Right(v) => v.visit_object_pat(n),
        }
    }
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_object_pat_prop(n),
            global_visit::Either::Right(v) => v.visit_object_pat_prop(n),
        }
    }
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        match self {
            global_visit::Either::Left(v) => v.visit_object_pat_props(n),
            global_visit::Either::Right(v) => v.visit_object_pat_props(n),
        }
    }
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_accessibility(n),
            global_visit::Either::Right(v) => v.visit_opt_accessibility(n),
        }
    }
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_block_stmt(n),
            global_visit::Either::Right(v) => v.visit_opt_block_stmt(n),
        }
    }
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_catch_clause(n),
            global_visit::Either::Right(v) => v.visit_opt_catch_clause(n),
        }
    }
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_chain_expr(n),
            global_visit::Either::Right(v) => v.visit_opt_chain_expr(n),
        }
    }
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_expr(n),
            global_visit::Either::Right(v) => v.visit_opt_expr(n),
        }
    }
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_expr_or_spread(n),
            global_visit::Either::Right(v) => v.visit_opt_expr_or_spread(n),
        }
    }
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_expr_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_opt_expr_or_spreads(n),
        }
    }
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ident(n),
            global_visit::Either::Right(v) => v.visit_opt_ident(n),
        }
    }
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_js_word(n),
            global_visit::Either::Right(v) => v.visit_opt_js_word(n),
        }
    }
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_jsx_attr_value(n),
            global_visit::Either::Right(v) => v.visit_opt_jsx_attr_value(n),
        }
    }
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_jsx_closing_element(n),
            global_visit::Either::Right(v) => v.visit_opt_jsx_closing_element(n),
        }
    }
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_object_lit(n),
            global_visit::Either::Right(v) => v.visit_opt_object_lit(n),
        }
    }
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_pat(n),
            global_visit::Either::Right(v) => v.visit_opt_pat(n),
        }
    }
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_span(n),
            global_visit::Either::Right(v) => v.visit_opt_span(n),
        }
    }
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_stmt(n),
            global_visit::Either::Right(v) => v.visit_opt_stmt(n),
        }
    }
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_str(n),
            global_visit::Either::Right(v) => v.visit_opt_str(n),
        }
    }
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_true_plus_minus(n),
            global_visit::Either::Right(v) => v.visit_opt_true_plus_minus(n),
        }
    }
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_entity_name(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_entity_name(n),
        }
    }
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_namespace_body(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_namespace_body(n),
        }
    }
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_type(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_type(n),
        }
    }
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_type_ann(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_type_ann(n),
        }
    }
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_type_param_decl(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_type_param_decl(n),
        }
    }
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_ts_type_param_instantiation(n),
            global_visit::Either::Right(v) => v.visit_opt_ts_type_param_instantiation(n),
        }
    }
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_var_decl_or_expr(n),
            global_visit::Either::Right(v) => v.visit_opt_var_decl_or_expr(n),
        }
    }
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_vec_expr_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_opt_vec_expr_or_spreads(n),
        }
    }
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        match self {
            global_visit::Either::Left(v) => v.visit_opt_vec_pats(n),
            global_visit::Either::Right(v) => v.visit_opt_vec_pats(n),
        }
    }
    fn visit_param(&mut self, n: &'ast Param) {
        match self {
            global_visit::Either::Left(v) => v.visit_param(n),
            global_visit::Either::Right(v) => v.visit_param(n),
        }
    }
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_param_or_ts_param_prop(n),
            global_visit::Either::Right(v) => v.visit_param_or_ts_param_prop(n),
        }
    }
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        match self {
            global_visit::Either::Left(v) => v.visit_param_or_ts_param_props(n),
            global_visit::Either::Right(v) => v.visit_param_or_ts_param_props(n),
        }
    }
    fn visit_params(&mut self, n: &'ast [Param]) {
        match self {
            global_visit::Either::Left(v) => v.visit_params(n),
            global_visit::Either::Right(v) => v.visit_params(n),
        }
    }
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_paren_expr(n),
            global_visit::Either::Right(v) => v.visit_paren_expr(n),
        }
    }
    fn visit_pat(&mut self, n: &'ast Pat) {
        match self {
            global_visit::Either::Left(v) => v.visit_pat(n),
            global_visit::Either::Right(v) => v.visit_pat(n),
        }
    }
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_pat_or_expr(n),
            global_visit::Either::Right(v) => v.visit_pat_or_expr(n),
        }
    }
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        match self {
            global_visit::Either::Left(v) => v.visit_pats(n),
            global_visit::Either::Right(v) => v.visit_pats(n),
        }
    }
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        match self {
            global_visit::Either::Left(v) => v.visit_private_method(n),
            global_visit::Either::Right(v) => v.visit_private_method(n),
        }
    }
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        match self {
            global_visit::Either::Left(v) => v.visit_private_name(n),
            global_visit::Either::Right(v) => v.visit_private_name(n),
        }
    }
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_private_prop(n),
            global_visit::Either::Right(v) => v.visit_private_prop(n),
        }
    }
    fn visit_program(&mut self, n: &'ast Program) {
        match self {
            global_visit::Either::Left(v) => v.visit_program(n),
            global_visit::Either::Right(v) => v.visit_program(n),
        }
    }
    fn visit_prop(&mut self, n: &'ast Prop) {
        match self {
            global_visit::Either::Left(v) => v.visit_prop(n),
            global_visit::Either::Right(v) => v.visit_prop(n),
        }
    }
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        match self {
            global_visit::Either::Left(v) => v.visit_prop_name(n),
            global_visit::Either::Right(v) => v.visit_prop_name(n),
        }
    }
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        match self {
            global_visit::Either::Left(v) => v.visit_prop_or_spread(n),
            global_visit::Either::Right(v) => v.visit_prop_or_spread(n),
        }
    }
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        match self {
            global_visit::Either::Left(v) => v.visit_prop_or_spreads(n),
            global_visit::Either::Right(v) => v.visit_prop_or_spreads(n),
        }
    }
    fn visit_regex(&mut self, n: &'ast Regex) {
        match self {
            global_visit::Either::Left(v) => v.visit_regex(n),
            global_visit::Either::Right(v) => v.visit_regex(n),
        }
    }
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_rest_pat(n),
            global_visit::Either::Right(v) => v.visit_rest_pat(n),
        }
    }
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_return_stmt(n),
            global_visit::Either::Right(v) => v.visit_return_stmt(n),
        }
    }
    fn visit_script(&mut self, n: &'ast Script) {
        match self {
            global_visit::Either::Left(v) => v.visit_script(n),
            global_visit::Either::Right(v) => v.visit_script(n),
        }
    }
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_seq_expr(n),
            global_visit::Either::Right(v) => v.visit_seq_expr(n),
        }
    }
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_setter_prop(n),
            global_visit::Either::Right(v) => v.visit_setter_prop(n),
        }
    }
    fn visit_span(&mut self, n: &'ast Span) {
        match self {
            global_visit::Either::Left(v) => v.visit_span(n),
            global_visit::Either::Right(v) => v.visit_span(n),
        }
    }
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_spread_element(n),
            global_visit::Either::Right(v) => v.visit_spread_element(n),
        }
    }
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_stmt(n),
            global_visit::Either::Right(v) => v.visit_stmt(n),
        }
    }
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        match self {
            global_visit::Either::Left(v) => v.visit_stmts(n),
            global_visit::Either::Right(v) => v.visit_stmts(n),
        }
    }
    fn visit_str(&mut self, n: &'ast Str) {
        match self {
            global_visit::Either::Left(v) => v.visit_str(n),
            global_visit::Either::Right(v) => v.visit_str(n),
        }
    }
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        match self {
            global_visit::Either::Left(v) => v.visit_str_kind(n),
            global_visit::Either::Right(v) => v.visit_str_kind(n),
        }
    }
    fn visit_super(&mut self, n: &'ast Super) {
        match self {
            global_visit::Either::Left(v) => v.visit_super(n),
            global_visit::Either::Right(v) => v.visit_super(n),
        }
    }
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        match self {
            global_visit::Either::Left(v) => v.visit_switch_case(n),
            global_visit::Either::Right(v) => v.visit_switch_case(n),
        }
    }
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        match self {
            global_visit::Either::Left(v) => v.visit_switch_cases(n),
            global_visit::Either::Right(v) => v.visit_switch_cases(n),
        }
    }
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_switch_stmt(n),
            global_visit::Either::Right(v) => v.visit_switch_stmt(n),
        }
    }
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        match self {
            global_visit::Either::Left(v) => v.visit_tagged_tpl(n),
            global_visit::Either::Right(v) => v.visit_tagged_tpl(n),
        }
    }
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_this_expr(n),
            global_visit::Either::Right(v) => v.visit_this_expr(n),
        }
    }
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_throw_stmt(n),
            global_visit::Either::Right(v) => v.visit_throw_stmt(n),
        }
    }
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        match self {
            global_visit::Either::Left(v) => v.visit_tpl(n),
            global_visit::Either::Right(v) => v.visit_tpl(n),
        }
    }
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_tpl_element(n),
            global_visit::Either::Right(v) => v.visit_tpl_element(n),
        }
    }
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        match self {
            global_visit::Either::Left(v) => v.visit_tpl_elements(n),
            global_visit::Either::Right(v) => v.visit_tpl_elements(n),
        }
    }
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        match self {
            global_visit::Either::Left(v) => v.visit_true_plus_minus(n),
            global_visit::Either::Right(v) => v.visit_true_plus_minus(n),
        }
    }
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_try_stmt(n),
            global_visit::Either::Right(v) => v.visit_try_stmt(n),
        }
    }
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_array_type(n),
            global_visit::Either::Right(v) => v.visit_ts_array_type(n),
        }
    }
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_as_expr(n),
            global_visit::Either::Right(v) => v.visit_ts_as_expr(n),
        }
    }
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_call_signature_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_call_signature_decl(n),
        }
    }
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_conditional_type(n),
            global_visit::Either::Right(v) => v.visit_ts_conditional_type(n),
        }
    }
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_const_assertion(n),
            global_visit::Either::Right(v) => v.visit_ts_const_assertion(n),
        }
    }
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_construct_signature_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_construct_signature_decl(n),
        }
    }
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_constructor_type(n),
            global_visit::Either::Right(v) => v.visit_ts_constructor_type(n),
        }
    }
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_entity_name(n),
            global_visit::Either::Right(v) => v.visit_ts_entity_name(n),
        }
    }
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_enum_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_enum_decl(n),
        }
    }
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_enum_member(n),
            global_visit::Either::Right(v) => v.visit_ts_enum_member(n),
        }
    }
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_enum_member_id(n),
            global_visit::Either::Right(v) => v.visit_ts_enum_member_id(n),
        }
    }
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_enum_members(n),
            global_visit::Either::Right(v) => v.visit_ts_enum_members(n),
        }
    }
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_export_assignment(n),
            global_visit::Either::Right(v) => v.visit_ts_export_assignment(n),
        }
    }
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_expr_with_type_args(n),
            global_visit::Either::Right(v) => v.visit_ts_expr_with_type_args(n),
        }
    }
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_expr_with_type_args_vec(n),
            global_visit::Either::Right(v) => v.visit_ts_expr_with_type_args_vec(n),
        }
    }
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_external_module_ref(n),
            global_visit::Either::Right(v) => v.visit_ts_external_module_ref(n),
        }
    }
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_fn_or_constructor_type(n),
            global_visit::Either::Right(v) => v.visit_ts_fn_or_constructor_type(n),
        }
    }
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_fn_param(n),
            global_visit::Either::Right(v) => v.visit_ts_fn_param(n),
        }
    }
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_fn_params(n),
            global_visit::Either::Right(v) => v.visit_ts_fn_params(n),
        }
    }
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_fn_type(n),
            global_visit::Either::Right(v) => v.visit_ts_fn_type(n),
        }
    }
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_getter_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_getter_signature(n),
        }
    }
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_import_equals_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_import_equals_decl(n),
        }
    }
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_import_type(n),
            global_visit::Either::Right(v) => v.visit_ts_import_type(n),
        }
    }
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_index_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_index_signature(n),
        }
    }
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_indexed_access_type(n),
            global_visit::Either::Right(v) => v.visit_ts_indexed_access_type(n),
        }
    }
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_infer_type(n),
            global_visit::Either::Right(v) => v.visit_ts_infer_type(n),
        }
    }
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_interface_body(n),
            global_visit::Either::Right(v) => v.visit_ts_interface_body(n),
        }
    }
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_interface_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_interface_decl(n),
        }
    }
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_intersection_type(n),
            global_visit::Either::Right(v) => v.visit_ts_intersection_type(n),
        }
    }
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_keyword_type(n),
            global_visit::Either::Right(v) => v.visit_ts_keyword_type(n),
        }
    }
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_keyword_type_kind(n),
            global_visit::Either::Right(v) => v.visit_ts_keyword_type_kind(n),
        }
    }
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_lit(n),
            global_visit::Either::Right(v) => v.visit_ts_lit(n),
        }
    }
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_lit_type(n),
            global_visit::Either::Right(v) => v.visit_ts_lit_type(n),
        }
    }
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_mapped_type(n),
            global_visit::Either::Right(v) => v.visit_ts_mapped_type(n),
        }
    }
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_method_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_method_signature(n),
        }
    }
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_module_block(n),
            global_visit::Either::Right(v) => v.visit_ts_module_block(n),
        }
    }
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_module_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_module_decl(n),
        }
    }
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_module_name(n),
            global_visit::Either::Right(v) => v.visit_ts_module_name(n),
        }
    }
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_module_ref(n),
            global_visit::Either::Right(v) => v.visit_ts_module_ref(n),
        }
    }
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_namespace_body(n),
            global_visit::Either::Right(v) => v.visit_ts_namespace_body(n),
        }
    }
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_namespace_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_namespace_decl(n),
        }
    }
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_namespace_export_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_namespace_export_decl(n),
        }
    }
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_non_null_expr(n),
            global_visit::Either::Right(v) => v.visit_ts_non_null_expr(n),
        }
    }
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_optional_type(n),
            global_visit::Either::Right(v) => v.visit_ts_optional_type(n),
        }
    }
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_param_prop(n),
            global_visit::Either::Right(v) => v.visit_ts_param_prop(n),
        }
    }
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_param_prop_param(n),
            global_visit::Either::Right(v) => v.visit_ts_param_prop_param(n),
        }
    }
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_parenthesized_type(n),
            global_visit::Either::Right(v) => v.visit_ts_parenthesized_type(n),
        }
    }
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_property_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_property_signature(n),
        }
    }
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_qualified_name(n),
            global_visit::Either::Right(v) => v.visit_ts_qualified_name(n),
        }
    }
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_rest_type(n),
            global_visit::Either::Right(v) => v.visit_ts_rest_type(n),
        }
    }
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_setter_signature(n),
            global_visit::Either::Right(v) => v.visit_ts_setter_signature(n),
        }
    }
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_this_type(n),
            global_visit::Either::Right(v) => v.visit_ts_this_type(n),
        }
    }
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_this_type_or_ident(n),
            global_visit::Either::Right(v) => v.visit_ts_this_type_or_ident(n),
        }
    }
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_tpl_lit_type(n),
            global_visit::Either::Right(v) => v.visit_ts_tpl_lit_type(n),
        }
    }
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_tuple_element(n),
            global_visit::Either::Right(v) => v.visit_ts_tuple_element(n),
        }
    }
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_tuple_elements(n),
            global_visit::Either::Right(v) => v.visit_ts_tuple_elements(n),
        }
    }
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_tuple_type(n),
            global_visit::Either::Right(v) => v.visit_ts_tuple_type(n),
        }
    }
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type(n),
            global_visit::Either::Right(v) => v.visit_ts_type(n),
        }
    }
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_alias_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_type_alias_decl(n),
        }
    }
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_ann(n),
            global_visit::Either::Right(v) => v.visit_ts_type_ann(n),
        }
    }
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_assertion(n),
            global_visit::Either::Right(v) => v.visit_ts_type_assertion(n),
        }
    }
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_element(n),
            global_visit::Either::Right(v) => v.visit_ts_type_element(n),
        }
    }
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_elements(n),
            global_visit::Either::Right(v) => v.visit_ts_type_elements(n),
        }
    }
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_lit(n),
            global_visit::Either::Right(v) => v.visit_ts_type_lit(n),
        }
    }
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_operator(n),
            global_visit::Either::Right(v) => v.visit_ts_type_operator(n),
        }
    }
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_operator_op(n),
            global_visit::Either::Right(v) => v.visit_ts_type_operator_op(n),
        }
    }
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_param(n),
            global_visit::Either::Right(v) => v.visit_ts_type_param(n),
        }
    }
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_param_decl(n),
            global_visit::Either::Right(v) => v.visit_ts_type_param_decl(n),
        }
    }
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_param_instantiation(n),
            global_visit::Either::Right(v) => v.visit_ts_type_param_instantiation(n),
        }
    }
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_params(n),
            global_visit::Either::Right(v) => v.visit_ts_type_params(n),
        }
    }
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_predicate(n),
            global_visit::Either::Right(v) => v.visit_ts_type_predicate(n),
        }
    }
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_query(n),
            global_visit::Either::Right(v) => v.visit_ts_type_query(n),
        }
    }
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_query_expr(n),
            global_visit::Either::Right(v) => v.visit_ts_type_query_expr(n),
        }
    }
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_type_ref(n),
            global_visit::Either::Right(v) => v.visit_ts_type_ref(n),
        }
    }
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_types(n),
            global_visit::Either::Right(v) => v.visit_ts_types(n),
        }
    }
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_union_or_intersection_type(n),
            global_visit::Either::Right(v) => v.visit_ts_union_or_intersection_type(n),
        }
    }
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        match self {
            global_visit::Either::Left(v) => v.visit_ts_union_type(n),
            global_visit::Either::Right(v) => v.visit_ts_union_type(n),
        }
    }
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_unary_expr(n),
            global_visit::Either::Right(v) => v.visit_unary_expr(n),
        }
    }
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_unary_op(n),
            global_visit::Either::Right(v) => v.visit_unary_op(n),
        }
    }
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_update_expr(n),
            global_visit::Either::Right(v) => v.visit_update_expr(n),
        }
    }
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        match self {
            global_visit::Either::Left(v) => v.visit_update_op(n),
            global_visit::Either::Right(v) => v.visit_update_op(n),
        }
    }
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_decl(n),
            global_visit::Either::Right(v) => v.visit_var_decl(n),
        }
    }
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_decl_kind(n),
            global_visit::Either::Right(v) => v.visit_var_decl_kind(n),
        }
    }
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_decl_or_expr(n),
            global_visit::Either::Right(v) => v.visit_var_decl_or_expr(n),
        }
    }
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_decl_or_pat(n),
            global_visit::Either::Right(v) => v.visit_var_decl_or_pat(n),
        }
    }
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_declarator(n),
            global_visit::Either::Right(v) => v.visit_var_declarator(n),
        }
    }
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        match self {
            global_visit::Either::Left(v) => v.visit_var_declarators(n),
            global_visit::Either::Right(v) => v.visit_var_declarators(n),
        }
    }
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_while_stmt(n),
            global_visit::Either::Right(v) => v.visit_while_stmt(n),
        }
    }
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        match self {
            global_visit::Either::Left(v) => v.visit_with_stmt(n),
            global_visit::Either::Right(v) => v.visit_with_stmt(n),
        }
    }
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        match self {
            global_visit::Either::Left(v) => v.visit_yield_expr(n),
            global_visit::Either::Right(v) => v.visit_yield_expr(n),
        }
    }
}
impl<'ast, V> Visit<'ast> for ::global_visit::All<V>
where
    V: VisitAll<'ast>,
{
    fn visit_accessibility(&mut self, n: &'ast Accessibility) {
        self.visitor.visit_accessibility(n);
        visit_accessibility(self, n);
    }
    fn visit_array_lit(&mut self, n: &'ast ArrayLit) {
        self.visitor.visit_array_lit(n);
        visit_array_lit(self, n);
    }
    fn visit_array_pat(&mut self, n: &'ast ArrayPat) {
        self.visitor.visit_array_pat(n);
        visit_array_pat(self, n);
    }
    fn visit_arrow_expr(&mut self, n: &'ast ArrowExpr) {
        self.visitor.visit_arrow_expr(n);
        visit_arrow_expr(self, n);
    }
    fn visit_assign_expr(&mut self, n: &'ast AssignExpr) {
        self.visitor.visit_assign_expr(n);
        visit_assign_expr(self, n);
    }
    fn visit_assign_op(&mut self, n: &'ast AssignOp) {
        self.visitor.visit_assign_op(n);
        visit_assign_op(self, n);
    }
    fn visit_assign_pat(&mut self, n: &'ast AssignPat) {
        self.visitor.visit_assign_pat(n);
        visit_assign_pat(self, n);
    }
    fn visit_assign_pat_prop(&mut self, n: &'ast AssignPatProp) {
        self.visitor.visit_assign_pat_prop(n);
        visit_assign_pat_prop(self, n);
    }
    fn visit_assign_prop(&mut self, n: &'ast AssignProp) {
        self.visitor.visit_assign_prop(n);
        visit_assign_prop(self, n);
    }
    fn visit_await_expr(&mut self, n: &'ast AwaitExpr) {
        self.visitor.visit_await_expr(n);
        visit_await_expr(self, n);
    }
    fn visit_big_int(&mut self, n: &'ast BigInt) {
        self.visitor.visit_big_int(n);
        visit_big_int(self, n);
    }
    fn visit_big_int_value(&mut self, n: &'ast BigIntValue) {
        self.visitor.visit_big_int_value(n);
        visit_big_int_value(self, n);
    }
    fn visit_bin_expr(&mut self, n: &'ast BinExpr) {
        self.visitor.visit_bin_expr(n);
        visit_bin_expr(self, n);
    }
    fn visit_binary_op(&mut self, n: &'ast BinaryOp) {
        self.visitor.visit_binary_op(n);
        visit_binary_op(self, n);
    }
    fn visit_binding_ident(&mut self, n: &'ast BindingIdent) {
        self.visitor.visit_binding_ident(n);
        visit_binding_ident(self, n);
    }
    fn visit_block_stmt(&mut self, n: &'ast BlockStmt) {
        self.visitor.visit_block_stmt(n);
        visit_block_stmt(self, n);
    }
    fn visit_block_stmt_or_expr(&mut self, n: &'ast BlockStmtOrExpr) {
        self.visitor.visit_block_stmt_or_expr(n);
        visit_block_stmt_or_expr(self, n);
    }
    fn visit_bool(&mut self, n: &'ast Bool) {
        self.visitor.visit_bool(n);
        visit_bool(self, n);
    }
    fn visit_break_stmt(&mut self, n: &'ast BreakStmt) {
        self.visitor.visit_break_stmt(n);
        visit_break_stmt(self, n);
    }
    fn visit_call_expr(&mut self, n: &'ast CallExpr) {
        self.visitor.visit_call_expr(n);
        visit_call_expr(self, n);
    }
    fn visit_catch_clause(&mut self, n: &'ast CatchClause) {
        self.visitor.visit_catch_clause(n);
        visit_catch_clause(self, n);
    }
    fn visit_class(&mut self, n: &'ast Class) {
        self.visitor.visit_class(n);
        visit_class(self, n);
    }
    fn visit_class_decl(&mut self, n: &'ast ClassDecl) {
        self.visitor.visit_class_decl(n);
        visit_class_decl(self, n);
    }
    fn visit_class_expr(&mut self, n: &'ast ClassExpr) {
        self.visitor.visit_class_expr(n);
        visit_class_expr(self, n);
    }
    fn visit_class_member(&mut self, n: &'ast ClassMember) {
        self.visitor.visit_class_member(n);
        visit_class_member(self, n);
    }
    fn visit_class_members(&mut self, n: &'ast [ClassMember]) {
        self.visitor.visit_class_members(n);
        visit_class_members(self, n);
    }
    fn visit_class_method(&mut self, n: &'ast ClassMethod) {
        self.visitor.visit_class_method(n);
        visit_class_method(self, n);
    }
    fn visit_class_prop(&mut self, n: &'ast ClassProp) {
        self.visitor.visit_class_prop(n);
        visit_class_prop(self, n);
    }
    fn visit_computed_prop_name(&mut self, n: &'ast ComputedPropName) {
        self.visitor.visit_computed_prop_name(n);
        visit_computed_prop_name(self, n);
    }
    fn visit_cond_expr(&mut self, n: &'ast CondExpr) {
        self.visitor.visit_cond_expr(n);
        visit_cond_expr(self, n);
    }
    fn visit_constructor(&mut self, n: &'ast Constructor) {
        self.visitor.visit_constructor(n);
        visit_constructor(self, n);
    }
    fn visit_continue_stmt(&mut self, n: &'ast ContinueStmt) {
        self.visitor.visit_continue_stmt(n);
        visit_continue_stmt(self, n);
    }
    fn visit_debugger_stmt(&mut self, n: &'ast DebuggerStmt) {
        self.visitor.visit_debugger_stmt(n);
        visit_debugger_stmt(self, n);
    }
    fn visit_decl(&mut self, n: &'ast Decl) {
        self.visitor.visit_decl(n);
        visit_decl(self, n);
    }
    fn visit_decorator(&mut self, n: &'ast Decorator) {
        self.visitor.visit_decorator(n);
        visit_decorator(self, n);
    }
    fn visit_decorators(&mut self, n: &'ast [Decorator]) {
        self.visitor.visit_decorators(n);
        visit_decorators(self, n);
    }
    fn visit_default_decl(&mut self, n: &'ast DefaultDecl) {
        self.visitor.visit_default_decl(n);
        visit_default_decl(self, n);
    }
    fn visit_do_while_stmt(&mut self, n: &'ast DoWhileStmt) {
        self.visitor.visit_do_while_stmt(n);
        visit_do_while_stmt(self, n);
    }
    fn visit_empty_stmt(&mut self, n: &'ast EmptyStmt) {
        self.visitor.visit_empty_stmt(n);
        visit_empty_stmt(self, n);
    }
    fn visit_export_all(&mut self, n: &'ast ExportAll) {
        self.visitor.visit_export_all(n);
        visit_export_all(self, n);
    }
    fn visit_export_decl(&mut self, n: &'ast ExportDecl) {
        self.visitor.visit_export_decl(n);
        visit_export_decl(self, n);
    }
    fn visit_export_default_decl(&mut self, n: &'ast ExportDefaultDecl) {
        self.visitor.visit_export_default_decl(n);
        visit_export_default_decl(self, n);
    }
    fn visit_export_default_expr(&mut self, n: &'ast ExportDefaultExpr) {
        self.visitor.visit_export_default_expr(n);
        visit_export_default_expr(self, n);
    }
    fn visit_export_default_specifier(&mut self, n: &'ast ExportDefaultSpecifier) {
        self.visitor.visit_export_default_specifier(n);
        visit_export_default_specifier(self, n);
    }
    fn visit_export_named_specifier(&mut self, n: &'ast ExportNamedSpecifier) {
        self.visitor.visit_export_named_specifier(n);
        visit_export_named_specifier(self, n);
    }
    fn visit_export_namespace_specifier(&mut self, n: &'ast ExportNamespaceSpecifier) {
        self.visitor.visit_export_namespace_specifier(n);
        visit_export_namespace_specifier(self, n);
    }
    fn visit_export_specifier(&mut self, n: &'ast ExportSpecifier) {
        self.visitor.visit_export_specifier(n);
        visit_export_specifier(self, n);
    }
    fn visit_export_specifiers(&mut self, n: &'ast [ExportSpecifier]) {
        self.visitor.visit_export_specifiers(n);
        visit_export_specifiers(self, n);
    }
    fn visit_expr(&mut self, n: &'ast Expr) {
        self.visitor.visit_expr(n);
        visit_expr(self, n);
    }
    fn visit_expr_or_spread(&mut self, n: &'ast ExprOrSpread) {
        self.visitor.visit_expr_or_spread(n);
        visit_expr_or_spread(self, n);
    }
    fn visit_expr_or_spreads(&mut self, n: &'ast [ExprOrSpread]) {
        self.visitor.visit_expr_or_spreads(n);
        visit_expr_or_spreads(self, n);
    }
    fn visit_expr_or_super(&mut self, n: &'ast ExprOrSuper) {
        self.visitor.visit_expr_or_super(n);
        visit_expr_or_super(self, n);
    }
    fn visit_expr_stmt(&mut self, n: &'ast ExprStmt) {
        self.visitor.visit_expr_stmt(n);
        visit_expr_stmt(self, n);
    }
    fn visit_exprs(&mut self, n: &'ast [Box<Expr>]) {
        self.visitor.visit_exprs(n);
        visit_exprs(self, n);
    }
    fn visit_fn_decl(&mut self, n: &'ast FnDecl) {
        self.visitor.visit_fn_decl(n);
        visit_fn_decl(self, n);
    }
    fn visit_fn_expr(&mut self, n: &'ast FnExpr) {
        self.visitor.visit_fn_expr(n);
        visit_fn_expr(self, n);
    }
    fn visit_for_in_stmt(&mut self, n: &'ast ForInStmt) {
        self.visitor.visit_for_in_stmt(n);
        visit_for_in_stmt(self, n);
    }
    fn visit_for_of_stmt(&mut self, n: &'ast ForOfStmt) {
        self.visitor.visit_for_of_stmt(n);
        visit_for_of_stmt(self, n);
    }
    fn visit_for_stmt(&mut self, n: &'ast ForStmt) {
        self.visitor.visit_for_stmt(n);
        visit_for_stmt(self, n);
    }
    fn visit_function(&mut self, n: &'ast Function) {
        self.visitor.visit_function(n);
        visit_function(self, n);
    }
    fn visit_getter_prop(&mut self, n: &'ast GetterProp) {
        self.visitor.visit_getter_prop(n);
        visit_getter_prop(self, n);
    }
    fn visit_ident(&mut self, n: &'ast Ident) {
        self.visitor.visit_ident(n);
        visit_ident(self, n);
    }
    fn visit_if_stmt(&mut self, n: &'ast IfStmt) {
        self.visitor.visit_if_stmt(n);
        visit_if_stmt(self, n);
    }
    fn visit_import_decl(&mut self, n: &'ast ImportDecl) {
        self.visitor.visit_import_decl(n);
        visit_import_decl(self, n);
    }
    fn visit_import_default_specifier(&mut self, n: &'ast ImportDefaultSpecifier) {
        self.visitor.visit_import_default_specifier(n);
        visit_import_default_specifier(self, n);
    }
    fn visit_import_named_specifier(&mut self, n: &'ast ImportNamedSpecifier) {
        self.visitor.visit_import_named_specifier(n);
        visit_import_named_specifier(self, n);
    }
    fn visit_import_specifier(&mut self, n: &'ast ImportSpecifier) {
        self.visitor.visit_import_specifier(n);
        visit_import_specifier(self, n);
    }
    fn visit_import_specifiers(&mut self, n: &'ast [ImportSpecifier]) {
        self.visitor.visit_import_specifiers(n);
        visit_import_specifiers(self, n);
    }
    fn visit_import_star_as_specifier(&mut self, n: &'ast ImportStarAsSpecifier) {
        self.visitor.visit_import_star_as_specifier(n);
        visit_import_star_as_specifier(self, n);
    }
    fn visit_invalid(&mut self, n: &'ast Invalid) {
        self.visitor.visit_invalid(n);
        visit_invalid(self, n);
    }
    fn visit_js_word(&mut self, n: &'ast JsWord) {
        self.visitor.visit_js_word(n);
        visit_js_word(self, n);
    }
    fn visit_jsx_attr(&mut self, n: &'ast JSXAttr) {
        self.visitor.visit_jsx_attr(n);
        visit_jsx_attr(self, n);
    }
    fn visit_jsx_attr_name(&mut self, n: &'ast JSXAttrName) {
        self.visitor.visit_jsx_attr_name(n);
        visit_jsx_attr_name(self, n);
    }
    fn visit_jsx_attr_or_spread(&mut self, n: &'ast JSXAttrOrSpread) {
        self.visitor.visit_jsx_attr_or_spread(n);
        visit_jsx_attr_or_spread(self, n);
    }
    fn visit_jsx_attr_or_spreads(&mut self, n: &'ast [JSXAttrOrSpread]) {
        self.visitor.visit_jsx_attr_or_spreads(n);
        visit_jsx_attr_or_spreads(self, n);
    }
    fn visit_jsx_attr_value(&mut self, n: &'ast JSXAttrValue) {
        self.visitor.visit_jsx_attr_value(n);
        visit_jsx_attr_value(self, n);
    }
    fn visit_jsx_closing_element(&mut self, n: &'ast JSXClosingElement) {
        self.visitor.visit_jsx_closing_element(n);
        visit_jsx_closing_element(self, n);
    }
    fn visit_jsx_closing_fragment(&mut self, n: &'ast JSXClosingFragment) {
        self.visitor.visit_jsx_closing_fragment(n);
        visit_jsx_closing_fragment(self, n);
    }
    fn visit_jsx_element(&mut self, n: &'ast JSXElement) {
        self.visitor.visit_jsx_element(n);
        visit_jsx_element(self, n);
    }
    fn visit_jsx_element_child(&mut self, n: &'ast JSXElementChild) {
        self.visitor.visit_jsx_element_child(n);
        visit_jsx_element_child(self, n);
    }
    fn visit_jsx_element_children(&mut self, n: &'ast [JSXElementChild]) {
        self.visitor.visit_jsx_element_children(n);
        visit_jsx_element_children(self, n);
    }
    fn visit_jsx_element_name(&mut self, n: &'ast JSXElementName) {
        self.visitor.visit_jsx_element_name(n);
        visit_jsx_element_name(self, n);
    }
    fn visit_jsx_empty_expr(&mut self, n: &'ast JSXEmptyExpr) {
        self.visitor.visit_jsx_empty_expr(n);
        visit_jsx_empty_expr(self, n);
    }
    fn visit_jsx_expr(&mut self, n: &'ast JSXExpr) {
        self.visitor.visit_jsx_expr(n);
        visit_jsx_expr(self, n);
    }
    fn visit_jsx_expr_container(&mut self, n: &'ast JSXExprContainer) {
        self.visitor.visit_jsx_expr_container(n);
        visit_jsx_expr_container(self, n);
    }
    fn visit_jsx_fragment(&mut self, n: &'ast JSXFragment) {
        self.visitor.visit_jsx_fragment(n);
        visit_jsx_fragment(self, n);
    }
    fn visit_jsx_member_expr(&mut self, n: &'ast JSXMemberExpr) {
        self.visitor.visit_jsx_member_expr(n);
        visit_jsx_member_expr(self, n);
    }
    fn visit_jsx_namespaced_name(&mut self, n: &'ast JSXNamespacedName) {
        self.visitor.visit_jsx_namespaced_name(n);
        visit_jsx_namespaced_name(self, n);
    }
    fn visit_jsx_object(&mut self, n: &'ast JSXObject) {
        self.visitor.visit_jsx_object(n);
        visit_jsx_object(self, n);
    }
    fn visit_jsx_opening_element(&mut self, n: &'ast JSXOpeningElement) {
        self.visitor.visit_jsx_opening_element(n);
        visit_jsx_opening_element(self, n);
    }
    fn visit_jsx_opening_fragment(&mut self, n: &'ast JSXOpeningFragment) {
        self.visitor.visit_jsx_opening_fragment(n);
        visit_jsx_opening_fragment(self, n);
    }
    fn visit_jsx_spread_child(&mut self, n: &'ast JSXSpreadChild) {
        self.visitor.visit_jsx_spread_child(n);
        visit_jsx_spread_child(self, n);
    }
    fn visit_jsx_text(&mut self, n: &'ast JSXText) {
        self.visitor.visit_jsx_text(n);
        visit_jsx_text(self, n);
    }
    fn visit_key_value_pat_prop(&mut self, n: &'ast KeyValuePatProp) {
        self.visitor.visit_key_value_pat_prop(n);
        visit_key_value_pat_prop(self, n);
    }
    fn visit_key_value_prop(&mut self, n: &'ast KeyValueProp) {
        self.visitor.visit_key_value_prop(n);
        visit_key_value_prop(self, n);
    }
    fn visit_labeled_stmt(&mut self, n: &'ast LabeledStmt) {
        self.visitor.visit_labeled_stmt(n);
        visit_labeled_stmt(self, n);
    }
    fn visit_lit(&mut self, n: &'ast Lit) {
        self.visitor.visit_lit(n);
        visit_lit(self, n);
    }
    fn visit_member_expr(&mut self, n: &'ast MemberExpr) {
        self.visitor.visit_member_expr(n);
        visit_member_expr(self, n);
    }
    fn visit_meta_prop_expr(&mut self, n: &'ast MetaPropExpr) {
        self.visitor.visit_meta_prop_expr(n);
        visit_meta_prop_expr(self, n);
    }
    fn visit_method_kind(&mut self, n: &'ast MethodKind) {
        self.visitor.visit_method_kind(n);
        visit_method_kind(self, n);
    }
    fn visit_method_prop(&mut self, n: &'ast MethodProp) {
        self.visitor.visit_method_prop(n);
        visit_method_prop(self, n);
    }
    fn visit_module(&mut self, n: &'ast Module) {
        self.visitor.visit_module(n);
        visit_module(self, n);
    }
    fn visit_module_decl(&mut self, n: &'ast ModuleDecl) {
        self.visitor.visit_module_decl(n);
        visit_module_decl(self, n);
    }
    fn visit_module_item(&mut self, n: &'ast ModuleItem) {
        self.visitor.visit_module_item(n);
        visit_module_item(self, n);
    }
    fn visit_module_items(&mut self, n: &'ast [ModuleItem]) {
        self.visitor.visit_module_items(n);
        visit_module_items(self, n);
    }
    fn visit_named_export(&mut self, n: &'ast NamedExport) {
        self.visitor.visit_named_export(n);
        visit_named_export(self, n);
    }
    fn visit_new_expr(&mut self, n: &'ast NewExpr) {
        self.visitor.visit_new_expr(n);
        visit_new_expr(self, n);
    }
    fn visit_null(&mut self, n: &'ast Null) {
        self.visitor.visit_null(n);
        visit_null(self, n);
    }
    fn visit_number(&mut self, n: &'ast Number) {
        self.visitor.visit_number(n);
        visit_number(self, n);
    }
    fn visit_object_lit(&mut self, n: &'ast ObjectLit) {
        self.visitor.visit_object_lit(n);
        visit_object_lit(self, n);
    }
    fn visit_object_pat(&mut self, n: &'ast ObjectPat) {
        self.visitor.visit_object_pat(n);
        visit_object_pat(self, n);
    }
    fn visit_object_pat_prop(&mut self, n: &'ast ObjectPatProp) {
        self.visitor.visit_object_pat_prop(n);
        visit_object_pat_prop(self, n);
    }
    fn visit_object_pat_props(&mut self, n: &'ast [ObjectPatProp]) {
        self.visitor.visit_object_pat_props(n);
        visit_object_pat_props(self, n);
    }
    fn visit_opt_accessibility(&mut self, n: Option<&'ast Accessibility>) {
        self.visitor.visit_opt_accessibility(n);
        visit_opt_accessibility(self, n);
    }
    fn visit_opt_block_stmt(&mut self, n: Option<&'ast BlockStmt>) {
        self.visitor.visit_opt_block_stmt(n);
        visit_opt_block_stmt(self, n);
    }
    fn visit_opt_catch_clause(&mut self, n: Option<&'ast CatchClause>) {
        self.visitor.visit_opt_catch_clause(n);
        visit_opt_catch_clause(self, n);
    }
    fn visit_opt_chain_expr(&mut self, n: &'ast OptChainExpr) {
        self.visitor.visit_opt_chain_expr(n);
        visit_opt_chain_expr(self, n);
    }
    fn visit_opt_expr(&mut self, n: Option<&'ast Box<Expr>>) {
        self.visitor.visit_opt_expr(n);
        visit_opt_expr(self, n);
    }
    fn visit_opt_expr_or_spread(&mut self, n: Option<&'ast ExprOrSpread>) {
        self.visitor.visit_opt_expr_or_spread(n);
        visit_opt_expr_or_spread(self, n);
    }
    fn visit_opt_expr_or_spreads(&mut self, n: Option<&'ast [ExprOrSpread]>) {
        self.visitor.visit_opt_expr_or_spreads(n);
        visit_opt_expr_or_spreads(self, n);
    }
    fn visit_opt_ident(&mut self, n: Option<&'ast Ident>) {
        self.visitor.visit_opt_ident(n);
        visit_opt_ident(self, n);
    }
    fn visit_opt_js_word(&mut self, n: Option<&'ast JsWord>) {
        self.visitor.visit_opt_js_word(n);
        visit_opt_js_word(self, n);
    }
    fn visit_opt_jsx_attr_value(&mut self, n: Option<&'ast JSXAttrValue>) {
        self.visitor.visit_opt_jsx_attr_value(n);
        visit_opt_jsx_attr_value(self, n);
    }
    fn visit_opt_jsx_closing_element(&mut self, n: Option<&'ast JSXClosingElement>) {
        self.visitor.visit_opt_jsx_closing_element(n);
        visit_opt_jsx_closing_element(self, n);
    }
    fn visit_opt_object_lit(&mut self, n: Option<&'ast ObjectLit>) {
        self.visitor.visit_opt_object_lit(n);
        visit_opt_object_lit(self, n);
    }
    fn visit_opt_pat(&mut self, n: Option<&'ast Pat>) {
        self.visitor.visit_opt_pat(n);
        visit_opt_pat(self, n);
    }
    fn visit_opt_span(&mut self, n: Option<&'ast Span>) {
        self.visitor.visit_opt_span(n);
        visit_opt_span(self, n);
    }
    fn visit_opt_stmt(&mut self, n: Option<&'ast Box<Stmt>>) {
        self.visitor.visit_opt_stmt(n);
        visit_opt_stmt(self, n);
    }
    fn visit_opt_str(&mut self, n: Option<&'ast Str>) {
        self.visitor.visit_opt_str(n);
        visit_opt_str(self, n);
    }
    fn visit_opt_true_plus_minus(&mut self, n: Option<&'ast TruePlusMinus>) {
        self.visitor.visit_opt_true_plus_minus(n);
        visit_opt_true_plus_minus(self, n);
    }
    fn visit_opt_ts_entity_name(&mut self, n: Option<&'ast TsEntityName>) {
        self.visitor.visit_opt_ts_entity_name(n);
        visit_opt_ts_entity_name(self, n);
    }
    fn visit_opt_ts_namespace_body(&mut self, n: Option<&'ast TsNamespaceBody>) {
        self.visitor.visit_opt_ts_namespace_body(n);
        visit_opt_ts_namespace_body(self, n);
    }
    fn visit_opt_ts_type(&mut self, n: Option<&'ast Box<TsType>>) {
        self.visitor.visit_opt_ts_type(n);
        visit_opt_ts_type(self, n);
    }
    fn visit_opt_ts_type_ann(&mut self, n: Option<&'ast TsTypeAnn>) {
        self.visitor.visit_opt_ts_type_ann(n);
        visit_opt_ts_type_ann(self, n);
    }
    fn visit_opt_ts_type_param_decl(&mut self, n: Option<&'ast TsTypeParamDecl>) {
        self.visitor.visit_opt_ts_type_param_decl(n);
        visit_opt_ts_type_param_decl(self, n);
    }
    fn visit_opt_ts_type_param_instantiation(&mut self, n: Option<&'ast TsTypeParamInstantiation>) {
        self.visitor.visit_opt_ts_type_param_instantiation(n);
        visit_opt_ts_type_param_instantiation(self, n);
    }
    fn visit_opt_var_decl_or_expr(&mut self, n: Option<&'ast VarDeclOrExpr>) {
        self.visitor.visit_opt_var_decl_or_expr(n);
        visit_opt_var_decl_or_expr(self, n);
    }
    fn visit_opt_vec_expr_or_spreads(&mut self, n: &'ast [Option<ExprOrSpread>]) {
        self.visitor.visit_opt_vec_expr_or_spreads(n);
        visit_opt_vec_expr_or_spreads(self, n);
    }
    fn visit_opt_vec_pats(&mut self, n: &'ast [Option<Pat>]) {
        self.visitor.visit_opt_vec_pats(n);
        visit_opt_vec_pats(self, n);
    }
    fn visit_param(&mut self, n: &'ast Param) {
        self.visitor.visit_param(n);
        visit_param(self, n);
    }
    fn visit_param_or_ts_param_prop(&mut self, n: &'ast ParamOrTsParamProp) {
        self.visitor.visit_param_or_ts_param_prop(n);
        visit_param_or_ts_param_prop(self, n);
    }
    fn visit_param_or_ts_param_props(&mut self, n: &'ast [ParamOrTsParamProp]) {
        self.visitor.visit_param_or_ts_param_props(n);
        visit_param_or_ts_param_props(self, n);
    }
    fn visit_params(&mut self, n: &'ast [Param]) {
        self.visitor.visit_params(n);
        visit_params(self, n);
    }
    fn visit_paren_expr(&mut self, n: &'ast ParenExpr) {
        self.visitor.visit_paren_expr(n);
        visit_paren_expr(self, n);
    }
    fn visit_pat(&mut self, n: &'ast Pat) {
        self.visitor.visit_pat(n);
        visit_pat(self, n);
    }
    fn visit_pat_or_expr(&mut self, n: &'ast PatOrExpr) {
        self.visitor.visit_pat_or_expr(n);
        visit_pat_or_expr(self, n);
    }
    fn visit_pats(&mut self, n: &'ast [Pat]) {
        self.visitor.visit_pats(n);
        visit_pats(self, n);
    }
    fn visit_private_method(&mut self, n: &'ast PrivateMethod) {
        self.visitor.visit_private_method(n);
        visit_private_method(self, n);
    }
    fn visit_private_name(&mut self, n: &'ast PrivateName) {
        self.visitor.visit_private_name(n);
        visit_private_name(self, n);
    }
    fn visit_private_prop(&mut self, n: &'ast PrivateProp) {
        self.visitor.visit_private_prop(n);
        visit_private_prop(self, n);
    }
    fn visit_program(&mut self, n: &'ast Program) {
        self.visitor.visit_program(n);
        visit_program(self, n);
    }
    fn visit_prop(&mut self, n: &'ast Prop) {
        self.visitor.visit_prop(n);
        visit_prop(self, n);
    }
    fn visit_prop_name(&mut self, n: &'ast PropName) {
        self.visitor.visit_prop_name(n);
        visit_prop_name(self, n);
    }
    fn visit_prop_or_spread(&mut self, n: &'ast PropOrSpread) {
        self.visitor.visit_prop_or_spread(n);
        visit_prop_or_spread(self, n);
    }
    fn visit_prop_or_spreads(&mut self, n: &'ast [PropOrSpread]) {
        self.visitor.visit_prop_or_spreads(n);
        visit_prop_or_spreads(self, n);
    }
    fn visit_regex(&mut self, n: &'ast Regex) {
        self.visitor.visit_regex(n);
        visit_regex(self, n);
    }
    fn visit_rest_pat(&mut self, n: &'ast RestPat) {
        self.visitor.visit_rest_pat(n);
        visit_rest_pat(self, n);
    }
    fn visit_return_stmt(&mut self, n: &'ast ReturnStmt) {
        self.visitor.visit_return_stmt(n);
        visit_return_stmt(self, n);
    }
    fn visit_script(&mut self, n: &'ast Script) {
        self.visitor.visit_script(n);
        visit_script(self, n);
    }
    fn visit_seq_expr(&mut self, n: &'ast SeqExpr) {
        self.visitor.visit_seq_expr(n);
        visit_seq_expr(self, n);
    }
    fn visit_setter_prop(&mut self, n: &'ast SetterProp) {
        self.visitor.visit_setter_prop(n);
        visit_setter_prop(self, n);
    }
    fn visit_span(&mut self, n: &'ast Span) {
        self.visitor.visit_span(n);
        visit_span(self, n);
    }
    fn visit_spread_element(&mut self, n: &'ast SpreadElement) {
        self.visitor.visit_spread_element(n);
        visit_spread_element(self, n);
    }
    fn visit_stmt(&mut self, n: &'ast Stmt) {
        self.visitor.visit_stmt(n);
        visit_stmt(self, n);
    }
    fn visit_stmts(&mut self, n: &'ast [Stmt]) {
        self.visitor.visit_stmts(n);
        visit_stmts(self, n);
    }
    fn visit_str(&mut self, n: &'ast Str) {
        self.visitor.visit_str(n);
        visit_str(self, n);
    }
    fn visit_str_kind(&mut self, n: &'ast StrKind) {
        self.visitor.visit_str_kind(n);
        visit_str_kind(self, n);
    }
    fn visit_super(&mut self, n: &'ast Super) {
        self.visitor.visit_super(n);
        visit_super(self, n);
    }
    fn visit_switch_case(&mut self, n: &'ast SwitchCase) {
        self.visitor.visit_switch_case(n);
        visit_switch_case(self, n);
    }
    fn visit_switch_cases(&mut self, n: &'ast [SwitchCase]) {
        self.visitor.visit_switch_cases(n);
        visit_switch_cases(self, n);
    }
    fn visit_switch_stmt(&mut self, n: &'ast SwitchStmt) {
        self.visitor.visit_switch_stmt(n);
        visit_switch_stmt(self, n);
    }
    fn visit_tagged_tpl(&mut self, n: &'ast TaggedTpl) {
        self.visitor.visit_tagged_tpl(n);
        visit_tagged_tpl(self, n);
    }
    fn visit_this_expr(&mut self, n: &'ast ThisExpr) {
        self.visitor.visit_this_expr(n);
        visit_this_expr(self, n);
    }
    fn visit_throw_stmt(&mut self, n: &'ast ThrowStmt) {
        self.visitor.visit_throw_stmt(n);
        visit_throw_stmt(self, n);
    }
    fn visit_tpl(&mut self, n: &'ast Tpl) {
        self.visitor.visit_tpl(n);
        visit_tpl(self, n);
    }
    fn visit_tpl_element(&mut self, n: &'ast TplElement) {
        self.visitor.visit_tpl_element(n);
        visit_tpl_element(self, n);
    }
    fn visit_tpl_elements(&mut self, n: &'ast [TplElement]) {
        self.visitor.visit_tpl_elements(n);
        visit_tpl_elements(self, n);
    }
    fn visit_true_plus_minus(&mut self, n: &'ast TruePlusMinus) {
        self.visitor.visit_true_plus_minus(n);
        visit_true_plus_minus(self, n);
    }
    fn visit_try_stmt(&mut self, n: &'ast TryStmt) {
        self.visitor.visit_try_stmt(n);
        visit_try_stmt(self, n);
    }
    fn visit_ts_array_type(&mut self, n: &'ast TsArrayType) {
        self.visitor.visit_ts_array_type(n);
        visit_ts_array_type(self, n);
    }
    fn visit_ts_as_expr(&mut self, n: &'ast TsAsExpr) {
        self.visitor.visit_ts_as_expr(n);
        visit_ts_as_expr(self, n);
    }
    fn visit_ts_call_signature_decl(&mut self, n: &'ast TsCallSignatureDecl) {
        self.visitor.visit_ts_call_signature_decl(n);
        visit_ts_call_signature_decl(self, n);
    }
    fn visit_ts_conditional_type(&mut self, n: &'ast TsConditionalType) {
        self.visitor.visit_ts_conditional_type(n);
        visit_ts_conditional_type(self, n);
    }
    fn visit_ts_const_assertion(&mut self, n: &'ast TsConstAssertion) {
        self.visitor.visit_ts_const_assertion(n);
        visit_ts_const_assertion(self, n);
    }
    fn visit_ts_construct_signature_decl(&mut self, n: &'ast TsConstructSignatureDecl) {
        self.visitor.visit_ts_construct_signature_decl(n);
        visit_ts_construct_signature_decl(self, n);
    }
    fn visit_ts_constructor_type(&mut self, n: &'ast TsConstructorType) {
        self.visitor.visit_ts_constructor_type(n);
        visit_ts_constructor_type(self, n);
    }
    fn visit_ts_entity_name(&mut self, n: &'ast TsEntityName) {
        self.visitor.visit_ts_entity_name(n);
        visit_ts_entity_name(self, n);
    }
    fn visit_ts_enum_decl(&mut self, n: &'ast TsEnumDecl) {
        self.visitor.visit_ts_enum_decl(n);
        visit_ts_enum_decl(self, n);
    }
    fn visit_ts_enum_member(&mut self, n: &'ast TsEnumMember) {
        self.visitor.visit_ts_enum_member(n);
        visit_ts_enum_member(self, n);
    }
    fn visit_ts_enum_member_id(&mut self, n: &'ast TsEnumMemberId) {
        self.visitor.visit_ts_enum_member_id(n);
        visit_ts_enum_member_id(self, n);
    }
    fn visit_ts_enum_members(&mut self, n: &'ast [TsEnumMember]) {
        self.visitor.visit_ts_enum_members(n);
        visit_ts_enum_members(self, n);
    }
    fn visit_ts_export_assignment(&mut self, n: &'ast TsExportAssignment) {
        self.visitor.visit_ts_export_assignment(n);
        visit_ts_export_assignment(self, n);
    }
    fn visit_ts_expr_with_type_args(&mut self, n: &'ast TsExprWithTypeArgs) {
        self.visitor.visit_ts_expr_with_type_args(n);
        visit_ts_expr_with_type_args(self, n);
    }
    fn visit_ts_expr_with_type_args_vec(&mut self, n: &'ast [TsExprWithTypeArgs]) {
        self.visitor.visit_ts_expr_with_type_args_vec(n);
        visit_ts_expr_with_type_args_vec(self, n);
    }
    fn visit_ts_external_module_ref(&mut self, n: &'ast TsExternalModuleRef) {
        self.visitor.visit_ts_external_module_ref(n);
        visit_ts_external_module_ref(self, n);
    }
    fn visit_ts_fn_or_constructor_type(&mut self, n: &'ast TsFnOrConstructorType) {
        self.visitor.visit_ts_fn_or_constructor_type(n);
        visit_ts_fn_or_constructor_type(self, n);
    }
    fn visit_ts_fn_param(&mut self, n: &'ast TsFnParam) {
        self.visitor.visit_ts_fn_param(n);
        visit_ts_fn_param(self, n);
    }
    fn visit_ts_fn_params(&mut self, n: &'ast [TsFnParam]) {
        self.visitor.visit_ts_fn_params(n);
        visit_ts_fn_params(self, n);
    }
    fn visit_ts_fn_type(&mut self, n: &'ast TsFnType) {
        self.visitor.visit_ts_fn_type(n);
        visit_ts_fn_type(self, n);
    }
    fn visit_ts_getter_signature(&mut self, n: &'ast TsGetterSignature) {
        self.visitor.visit_ts_getter_signature(n);
        visit_ts_getter_signature(self, n);
    }
    fn visit_ts_import_equals_decl(&mut self, n: &'ast TsImportEqualsDecl) {
        self.visitor.visit_ts_import_equals_decl(n);
        visit_ts_import_equals_decl(self, n);
    }
    fn visit_ts_import_type(&mut self, n: &'ast TsImportType) {
        self.visitor.visit_ts_import_type(n);
        visit_ts_import_type(self, n);
    }
    fn visit_ts_index_signature(&mut self, n: &'ast TsIndexSignature) {
        self.visitor.visit_ts_index_signature(n);
        visit_ts_index_signature(self, n);
    }
    fn visit_ts_indexed_access_type(&mut self, n: &'ast TsIndexedAccessType) {
        self.visitor.visit_ts_indexed_access_type(n);
        visit_ts_indexed_access_type(self, n);
    }
    fn visit_ts_infer_type(&mut self, n: &'ast TsInferType) {
        self.visitor.visit_ts_infer_type(n);
        visit_ts_infer_type(self, n);
    }
    fn visit_ts_interface_body(&mut self, n: &'ast TsInterfaceBody) {
        self.visitor.visit_ts_interface_body(n);
        visit_ts_interface_body(self, n);
    }
    fn visit_ts_interface_decl(&mut self, n: &'ast TsInterfaceDecl) {
        self.visitor.visit_ts_interface_decl(n);
        visit_ts_interface_decl(self, n);
    }
    fn visit_ts_intersection_type(&mut self, n: &'ast TsIntersectionType) {
        self.visitor.visit_ts_intersection_type(n);
        visit_ts_intersection_type(self, n);
    }
    fn visit_ts_keyword_type(&mut self, n: &'ast TsKeywordType) {
        self.visitor.visit_ts_keyword_type(n);
        visit_ts_keyword_type(self, n);
    }
    fn visit_ts_keyword_type_kind(&mut self, n: &'ast TsKeywordTypeKind) {
        self.visitor.visit_ts_keyword_type_kind(n);
        visit_ts_keyword_type_kind(self, n);
    }
    fn visit_ts_lit(&mut self, n: &'ast TsLit) {
        self.visitor.visit_ts_lit(n);
        visit_ts_lit(self, n);
    }
    fn visit_ts_lit_type(&mut self, n: &'ast TsLitType) {
        self.visitor.visit_ts_lit_type(n);
        visit_ts_lit_type(self, n);
    }
    fn visit_ts_mapped_type(&mut self, n: &'ast TsMappedType) {
        self.visitor.visit_ts_mapped_type(n);
        visit_ts_mapped_type(self, n);
    }
    fn visit_ts_method_signature(&mut self, n: &'ast TsMethodSignature) {
        self.visitor.visit_ts_method_signature(n);
        visit_ts_method_signature(self, n);
    }
    fn visit_ts_module_block(&mut self, n: &'ast TsModuleBlock) {
        self.visitor.visit_ts_module_block(n);
        visit_ts_module_block(self, n);
    }
    fn visit_ts_module_decl(&mut self, n: &'ast TsModuleDecl) {
        self.visitor.visit_ts_module_decl(n);
        visit_ts_module_decl(self, n);
    }
    fn visit_ts_module_name(&mut self, n: &'ast TsModuleName) {
        self.visitor.visit_ts_module_name(n);
        visit_ts_module_name(self, n);
    }
    fn visit_ts_module_ref(&mut self, n: &'ast TsModuleRef) {
        self.visitor.visit_ts_module_ref(n);
        visit_ts_module_ref(self, n);
    }
    fn visit_ts_namespace_body(&mut self, n: &'ast TsNamespaceBody) {
        self.visitor.visit_ts_namespace_body(n);
        visit_ts_namespace_body(self, n);
    }
    fn visit_ts_namespace_decl(&mut self, n: &'ast TsNamespaceDecl) {
        self.visitor.visit_ts_namespace_decl(n);
        visit_ts_namespace_decl(self, n);
    }
    fn visit_ts_namespace_export_decl(&mut self, n: &'ast TsNamespaceExportDecl) {
        self.visitor.visit_ts_namespace_export_decl(n);
        visit_ts_namespace_export_decl(self, n);
    }
    fn visit_ts_non_null_expr(&mut self, n: &'ast TsNonNullExpr) {
        self.visitor.visit_ts_non_null_expr(n);
        visit_ts_non_null_expr(self, n);
    }
    fn visit_ts_optional_type(&mut self, n: &'ast TsOptionalType) {
        self.visitor.visit_ts_optional_type(n);
        visit_ts_optional_type(self, n);
    }
    fn visit_ts_param_prop(&mut self, n: &'ast TsParamProp) {
        self.visitor.visit_ts_param_prop(n);
        visit_ts_param_prop(self, n);
    }
    fn visit_ts_param_prop_param(&mut self, n: &'ast TsParamPropParam) {
        self.visitor.visit_ts_param_prop_param(n);
        visit_ts_param_prop_param(self, n);
    }
    fn visit_ts_parenthesized_type(&mut self, n: &'ast TsParenthesizedType) {
        self.visitor.visit_ts_parenthesized_type(n);
        visit_ts_parenthesized_type(self, n);
    }
    fn visit_ts_property_signature(&mut self, n: &'ast TsPropertySignature) {
        self.visitor.visit_ts_property_signature(n);
        visit_ts_property_signature(self, n);
    }
    fn visit_ts_qualified_name(&mut self, n: &'ast TsQualifiedName) {
        self.visitor.visit_ts_qualified_name(n);
        visit_ts_qualified_name(self, n);
    }
    fn visit_ts_rest_type(&mut self, n: &'ast TsRestType) {
        self.visitor.visit_ts_rest_type(n);
        visit_ts_rest_type(self, n);
    }
    fn visit_ts_setter_signature(&mut self, n: &'ast TsSetterSignature) {
        self.visitor.visit_ts_setter_signature(n);
        visit_ts_setter_signature(self, n);
    }
    fn visit_ts_this_type(&mut self, n: &'ast TsThisType) {
        self.visitor.visit_ts_this_type(n);
        visit_ts_this_type(self, n);
    }
    fn visit_ts_this_type_or_ident(&mut self, n: &'ast TsThisTypeOrIdent) {
        self.visitor.visit_ts_this_type_or_ident(n);
        visit_ts_this_type_or_ident(self, n);
    }
    fn visit_ts_tpl_lit_type(&mut self, n: &'ast TsTplLitType) {
        self.visitor.visit_ts_tpl_lit_type(n);
        visit_ts_tpl_lit_type(self, n);
    }
    fn visit_ts_tuple_element(&mut self, n: &'ast TsTupleElement) {
        self.visitor.visit_ts_tuple_element(n);
        visit_ts_tuple_element(self, n);
    }
    fn visit_ts_tuple_elements(&mut self, n: &'ast [TsTupleElement]) {
        self.visitor.visit_ts_tuple_elements(n);
        visit_ts_tuple_elements(self, n);
    }
    fn visit_ts_tuple_type(&mut self, n: &'ast TsTupleType) {
        self.visitor.visit_ts_tuple_type(n);
        visit_ts_tuple_type(self, n);
    }
    fn visit_ts_type(&mut self, n: &'ast TsType) {
        self.visitor.visit_ts_type(n);
        visit_ts_type(self, n);
    }
    fn visit_ts_type_alias_decl(&mut self, n: &'ast TsTypeAliasDecl) {
        self.visitor.visit_ts_type_alias_decl(n);
        visit_ts_type_alias_decl(self, n);
    }
    fn visit_ts_type_ann(&mut self, n: &'ast TsTypeAnn) {
        self.visitor.visit_ts_type_ann(n);
        visit_ts_type_ann(self, n);
    }
    fn visit_ts_type_assertion(&mut self, n: &'ast TsTypeAssertion) {
        self.visitor.visit_ts_type_assertion(n);
        visit_ts_type_assertion(self, n);
    }
    fn visit_ts_type_element(&mut self, n: &'ast TsTypeElement) {
        self.visitor.visit_ts_type_element(n);
        visit_ts_type_element(self, n);
    }
    fn visit_ts_type_elements(&mut self, n: &'ast [TsTypeElement]) {
        self.visitor.visit_ts_type_elements(n);
        visit_ts_type_elements(self, n);
    }
    fn visit_ts_type_lit(&mut self, n: &'ast TsTypeLit) {
        self.visitor.visit_ts_type_lit(n);
        visit_ts_type_lit(self, n);
    }
    fn visit_ts_type_operator(&mut self, n: &'ast TsTypeOperator) {
        self.visitor.visit_ts_type_operator(n);
        visit_ts_type_operator(self, n);
    }
    fn visit_ts_type_operator_op(&mut self, n: &'ast TsTypeOperatorOp) {
        self.visitor.visit_ts_type_operator_op(n);
        visit_ts_type_operator_op(self, n);
    }
    fn visit_ts_type_param(&mut self, n: &'ast TsTypeParam) {
        self.visitor.visit_ts_type_param(n);
        visit_ts_type_param(self, n);
    }
    fn visit_ts_type_param_decl(&mut self, n: &'ast TsTypeParamDecl) {
        self.visitor.visit_ts_type_param_decl(n);
        visit_ts_type_param_decl(self, n);
    }
    fn visit_ts_type_param_instantiation(&mut self, n: &'ast TsTypeParamInstantiation) {
        self.visitor.visit_ts_type_param_instantiation(n);
        visit_ts_type_param_instantiation(self, n);
    }
    fn visit_ts_type_params(&mut self, n: &'ast [TsTypeParam]) {
        self.visitor.visit_ts_type_params(n);
        visit_ts_type_params(self, n);
    }
    fn visit_ts_type_predicate(&mut self, n: &'ast TsTypePredicate) {
        self.visitor.visit_ts_type_predicate(n);
        visit_ts_type_predicate(self, n);
    }
    fn visit_ts_type_query(&mut self, n: &'ast TsTypeQuery) {
        self.visitor.visit_ts_type_query(n);
        visit_ts_type_query(self, n);
    }
    fn visit_ts_type_query_expr(&mut self, n: &'ast TsTypeQueryExpr) {
        self.visitor.visit_ts_type_query_expr(n);
        visit_ts_type_query_expr(self, n);
    }
    fn visit_ts_type_ref(&mut self, n: &'ast TsTypeRef) {
        self.visitor.visit_ts_type_ref(n);
        visit_ts_type_ref(self, n);
    }
    fn visit_ts_types(&mut self, n: &'ast [Box<TsType>]) {
        self.visitor.visit_ts_types(n);
        visit_ts_types(self, n);
    }
    fn visit_ts_union_or_intersection_type(&mut self, n: &'ast TsUnionOrIntersectionType) {
        self.visitor.visit_ts_union_or_intersection_type(n);
        visit_ts_union_or_intersection_type(self, n);
    }
    fn visit_ts_union_type(&mut self, n: &'ast TsUnionType) {
        self.visitor.visit_ts_union_type(n);
        visit_ts_union_type(self, n);
    }
    fn visit_unary_expr(&mut self, n: &'ast UnaryExpr) {
        self.visitor.visit_unary_expr(n);
        visit_unary_expr(self, n);
    }
    fn visit_unary_op(&mut self, n: &'ast UnaryOp) {
        self.visitor.visit_unary_op(n);
        visit_unary_op(self, n);
    }
    fn visit_update_expr(&mut self, n: &'ast UpdateExpr) {
        self.visitor.visit_update_expr(n);
        visit_update_expr(self, n);
    }
    fn visit_update_op(&mut self, n: &'ast UpdateOp) {
        self.visitor.visit_update_op(n);
        visit_update_op(self, n);
    }
    fn visit_var_decl(&mut self, n: &'ast VarDecl) {
        self.visitor.visit_var_decl(n);
        visit_var_decl(self, n);
    }
    fn visit_var_decl_kind(&mut self, n: &'ast VarDeclKind) {
        self.visitor.visit_var_decl_kind(n);
        visit_var_decl_kind(self, n);
    }
    fn visit_var_decl_or_expr(&mut self, n: &'ast VarDeclOrExpr) {
        self.visitor.visit_var_decl_or_expr(n);
        visit_var_decl_or_expr(self, n);
    }
    fn visit_var_decl_or_pat(&mut self, n: &'ast VarDeclOrPat) {
        self.visitor.visit_var_decl_or_pat(n);
        visit_var_decl_or_pat(self, n);
    }
    fn visit_var_declarator(&mut self, n: &'ast VarDeclarator) {
        self.visitor.visit_var_declarator(n);
        visit_var_declarator(self, n);
    }
    fn visit_var_declarators(&mut self, n: &'ast [VarDeclarator]) {
        self.visitor.visit_var_declarators(n);
        visit_var_declarators(self, n);
    }
    fn visit_while_stmt(&mut self, n: &'ast WhileStmt) {
        self.visitor.visit_while_stmt(n);
        visit_while_stmt(self, n);
    }
    fn visit_with_stmt(&mut self, n: &'ast WithStmt) {
        self.visitor.visit_with_stmt(n);
        visit_with_stmt(self, n);
    }
    fn visit_yield_expr(&mut self, n: &'ast YieldExpr) {
        self.visitor.visit_yield_expr(n);
        visit_yield_expr(self, n);
    }
}
pub use global_visit::All;
pub trait VisitAllWith<'ast, V: VisitAll<'ast>> {
    fn visit_all_with(&'ast self, v: &mut V);
    /// Visit children nodes of self with `v`
    fn visit_all_children_with(&'ast self, v: &mut V);
}
impl<'ast, V, T> VisitAllWith<'ast, V> for Box<T>
where
    V: VisitAll<'ast>,
    T: 'static + VisitAllWith<'ast, V>,
{
    fn visit_all_with(&'ast self, v: &mut V) {
        (**self).visit_all_with(v)
    }
    /// Visit children nodes of self with `v`
    fn visit_all_children_with(&'ast self, v: &mut V) {
        (**self).visit_all_children_with(v)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Accessibility {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_accessibility(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_accessibility(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ArrayLit {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_array_lit(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_array_lit(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ArrayPat {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_array_pat(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_array_pat(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ArrowExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_arrow_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_arrow_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for AssignExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_assign_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_assign_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for AssignOp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_assign_op(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_assign_op(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for AssignPat {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_assign_pat(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_assign_pat(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for AssignPatProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_assign_pat_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_assign_pat_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for AssignProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_assign_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_assign_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for AwaitExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_await_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_await_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for BigInt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_big_int(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_big_int(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for BigIntValue {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_big_int_value(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_big_int_value(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for BinExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_bin_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_bin_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for BinaryOp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_binary_op(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_binary_op(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for BindingIdent {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_binding_ident(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_binding_ident(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for BlockStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_block_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_block_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for BlockStmtOrExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_block_stmt_or_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_block_stmt_or_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Bool {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_bool(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_bool(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for BreakStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_break_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_break_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for CallExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_call_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_call_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for CatchClause {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_catch_clause(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_catch_clause(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Class {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_class(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_class(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ClassDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_class_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_class_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ClassExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_class_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_class_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ClassMember {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_class_member(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_class_member(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<ClassMember> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_class_members(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_class_members(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ClassMethod {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_class_method(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_class_method(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ClassProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_class_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_class_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ComputedPropName {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_computed_prop_name(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_computed_prop_name(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for CondExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_cond_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_cond_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Constructor {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_constructor(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_constructor(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ContinueStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_continue_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_continue_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for DebuggerStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_debugger_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_debugger_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Decl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Decorator {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_decorator(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_decorator(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<Decorator> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_decorators(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_decorators(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for DefaultDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_default_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_default_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for DoWhileStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_do_while_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_do_while_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for EmptyStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_empty_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_empty_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExportAll {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_export_all(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_export_all(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExportDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_export_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_export_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExportDefaultDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_export_default_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_export_default_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExportDefaultExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_export_default_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_export_default_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExportDefaultSpecifier {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_export_default_specifier(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_export_default_specifier(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExportNamedSpecifier {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_export_named_specifier(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_export_named_specifier(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExportNamespaceSpecifier {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_export_namespace_specifier(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_export_namespace_specifier(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExportSpecifier {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_export_specifier(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_export_specifier(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<ExportSpecifier> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_export_specifiers(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_export_specifiers(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Expr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExprOrSpread {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_expr_or_spread(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_expr_or_spread(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<ExprOrSpread> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_expr_or_spreads(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_expr_or_spreads(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExprOrSuper {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_expr_or_super(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_expr_or_super(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ExprStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_expr_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_expr_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<Box<Expr>> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_exprs(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_exprs(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for FnDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_fn_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_fn_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for FnExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_fn_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_fn_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ForInStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_for_in_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_for_in_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ForOfStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_for_of_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_for_of_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ForStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_for_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_for_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Function {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_function(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_function(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for GetterProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_getter_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_getter_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Ident {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ident(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ident(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for IfStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_if_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_if_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ImportDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_import_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_import_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ImportDefaultSpecifier {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_import_default_specifier(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_import_default_specifier(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ImportNamedSpecifier {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_import_named_specifier(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_import_named_specifier(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ImportSpecifier {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_import_specifier(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_import_specifier(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<ImportSpecifier> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_import_specifiers(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_import_specifiers(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ImportStarAsSpecifier {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_import_star_as_specifier(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_import_star_as_specifier(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Invalid {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_invalid(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_invalid(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JsWord {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_js_word(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_js_word(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXAttr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_attr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_attr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXAttrName {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_attr_name(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_attr_name(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXAttrOrSpread {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_attr_or_spread(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_attr_or_spread(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<JSXAttrOrSpread> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_attr_or_spreads(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_attr_or_spreads(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXAttrValue {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_attr_value(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_attr_value(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXClosingElement {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_closing_element(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_closing_element(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXClosingFragment {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_closing_fragment(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_closing_fragment(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXElement {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_element(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_element(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXElementChild {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_element_child(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_element_child(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<JSXElementChild> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_element_children(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_element_children(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXElementName {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_element_name(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_element_name(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXEmptyExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_empty_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_empty_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXExprContainer {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_expr_container(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_expr_container(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXFragment {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_fragment(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_fragment(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXMemberExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_member_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_member_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXNamespacedName {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_namespaced_name(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_namespaced_name(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXObject {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_object(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_object(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXOpeningElement {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_opening_element(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_opening_element(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXOpeningFragment {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_opening_fragment(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_opening_fragment(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXSpreadChild {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_spread_child(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_spread_child(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for JSXText {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_jsx_text(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_jsx_text(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for KeyValuePatProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_key_value_pat_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_key_value_pat_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for KeyValueProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_key_value_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_key_value_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for LabeledStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_labeled_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_labeled_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Lit {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_lit(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_lit(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for MemberExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_member_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_member_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for MetaPropExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_meta_prop_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_meta_prop_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for MethodKind {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_method_kind(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_method_kind(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for MethodProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_method_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_method_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Module {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_module(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_module(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ModuleDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_module_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_module_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ModuleItem {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_module_item(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_module_item(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<ModuleItem> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_module_items(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_module_items(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for NamedExport {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_named_export(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_named_export(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for NewExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_new_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_new_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Null {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_null(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_null(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Number {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_number(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_number(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ObjectLit {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_object_lit(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_object_lit(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ObjectPat {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_object_pat(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_object_pat(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ObjectPatProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_object_pat_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_object_pat_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<ObjectPatProp> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_object_pat_props(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_object_pat_props(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<Accessibility> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_accessibility(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_accessibility(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<BlockStmt> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_block_stmt(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_block_stmt(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<CatchClause> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_catch_clause(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_catch_clause(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for OptChainExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_chain_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_chain_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<Box<Expr>> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_expr(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_expr(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<ExprOrSpread> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_expr_or_spread(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_expr_or_spread(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<Vec<ExprOrSpread>> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_expr_or_spreads(self.as_ref().map(|v| &**v))
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_expr_or_spreads(_visitor, self.as_ref().map(|v| &**v))
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<Ident> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_ident(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_ident(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<JsWord> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_js_word(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_js_word(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<JSXAttrValue> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_jsx_attr_value(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_jsx_attr_value(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<JSXClosingElement> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_jsx_closing_element(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_jsx_closing_element(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<ObjectLit> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_object_lit(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_object_lit(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<Pat> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_pat(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_pat(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<Span> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_span(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_span(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<Box<Stmt>> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_stmt(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_stmt(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<Str> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_str(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_str(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<TruePlusMinus> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_true_plus_minus(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_true_plus_minus(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<TsEntityName> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_ts_entity_name(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_ts_entity_name(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<TsNamespaceBody> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_ts_namespace_body(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_ts_namespace_body(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<Box<TsType>> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_ts_type(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_ts_type(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<TsTypeAnn> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_ts_type_ann(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_ts_type_ann(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<TsTypeParamDecl> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_ts_type_param_decl(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_ts_type_param_decl(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<TsTypeParamInstantiation> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_ts_type_param_instantiation(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_ts_type_param_instantiation(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Option<VarDeclOrExpr> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_var_decl_or_expr(self.as_ref())
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_var_decl_or_expr(_visitor, self.as_ref())
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<Option<ExprOrSpread>> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_vec_expr_or_spreads(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_vec_expr_or_spreads(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<Option<Pat>> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_opt_vec_pats(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_opt_vec_pats(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Param {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_param(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_param(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ParamOrTsParamProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_param_or_ts_param_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_param_or_ts_param_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<ParamOrTsParamProp> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_param_or_ts_param_props(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_param_or_ts_param_props(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<Param> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_params(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_params(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ParenExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_paren_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_paren_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Pat {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_pat(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_pat(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for PatOrExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_pat_or_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_pat_or_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<Pat> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_pats(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_pats(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for PrivateMethod {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_private_method(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_private_method(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for PrivateName {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_private_name(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_private_name(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for PrivateProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_private_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_private_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Program {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_program(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_program(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Prop {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for PropName {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_prop_name(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_prop_name(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for PropOrSpread {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_prop_or_spread(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_prop_or_spread(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<PropOrSpread> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_prop_or_spreads(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_prop_or_spreads(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Regex {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_regex(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_regex(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for RestPat {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_rest_pat(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_rest_pat(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ReturnStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_return_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_return_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Script {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_script(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_script(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for SeqExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_seq_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_seq_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for SetterProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_setter_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_setter_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Span {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_span(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_span(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for SpreadElement {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_spread_element(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_spread_element(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Stmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<Stmt> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_stmts(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_stmts(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Str {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_str(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_str(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for StrKind {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_str_kind(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_str_kind(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Super {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_super(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_super(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for SwitchCase {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_switch_case(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_switch_case(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<SwitchCase> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_switch_cases(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_switch_cases(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for SwitchStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_switch_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_switch_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TaggedTpl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_tagged_tpl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_tagged_tpl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ThisExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_this_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_this_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for ThrowStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_throw_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_throw_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Tpl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_tpl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_tpl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TplElement {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_tpl_element(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_tpl_element(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<TplElement> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_tpl_elements(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_tpl_elements(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TruePlusMinus {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_true_plus_minus(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_true_plus_minus(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TryStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_try_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_try_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsArrayType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_array_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_array_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsAsExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_as_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_as_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsCallSignatureDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_call_signature_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_call_signature_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsConditionalType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_conditional_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_conditional_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsConstAssertion {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_const_assertion(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_const_assertion(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsConstructSignatureDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_construct_signature_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_construct_signature_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsConstructorType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_constructor_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_constructor_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsEntityName {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_entity_name(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_entity_name(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsEnumDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_enum_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_enum_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsEnumMember {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_enum_member(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_enum_member(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsEnumMemberId {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_enum_member_id(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_enum_member_id(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<TsEnumMember> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_enum_members(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_enum_members(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsExportAssignment {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_export_assignment(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_export_assignment(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsExprWithTypeArgs {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_expr_with_type_args(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_expr_with_type_args(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<TsExprWithTypeArgs> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_expr_with_type_args_vec(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_expr_with_type_args_vec(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsExternalModuleRef {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_external_module_ref(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_external_module_ref(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsFnOrConstructorType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_fn_or_constructor_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_fn_or_constructor_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsFnParam {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_fn_param(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_fn_param(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<TsFnParam> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_fn_params(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_fn_params(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsFnType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_fn_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_fn_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsGetterSignature {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_getter_signature(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_getter_signature(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsImportEqualsDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_import_equals_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_import_equals_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsImportType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_import_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_import_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsIndexSignature {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_index_signature(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_index_signature(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsIndexedAccessType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_indexed_access_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_indexed_access_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsInferType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_infer_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_infer_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsInterfaceBody {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_interface_body(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_interface_body(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsInterfaceDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_interface_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_interface_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsIntersectionType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_intersection_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_intersection_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsKeywordType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_keyword_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_keyword_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsKeywordTypeKind {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_keyword_type_kind(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_keyword_type_kind(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsLit {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_lit(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_lit(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsLitType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_lit_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_lit_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsMappedType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_mapped_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_mapped_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsMethodSignature {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_method_signature(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_method_signature(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsModuleBlock {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_module_block(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_module_block(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsModuleDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_module_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_module_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsModuleName {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_module_name(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_module_name(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsModuleRef {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_module_ref(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_module_ref(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsNamespaceBody {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_namespace_body(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_namespace_body(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsNamespaceDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_namespace_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_namespace_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsNamespaceExportDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_namespace_export_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_namespace_export_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsNonNullExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_non_null_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_non_null_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsOptionalType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_optional_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_optional_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsParamProp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_param_prop(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_param_prop(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsParamPropParam {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_param_prop_param(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_param_prop_param(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsParenthesizedType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_parenthesized_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_parenthesized_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsPropertySignature {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_property_signature(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_property_signature(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsQualifiedName {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_qualified_name(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_qualified_name(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsRestType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_rest_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_rest_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsSetterSignature {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_setter_signature(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_setter_signature(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsThisType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_this_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_this_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsThisTypeOrIdent {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_this_type_or_ident(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_this_type_or_ident(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTplLitType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_tpl_lit_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_tpl_lit_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTupleElement {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_tuple_element(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_tuple_element(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<TsTupleElement> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_tuple_elements(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_tuple_elements(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTupleType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_tuple_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_tuple_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeAliasDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_alias_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_alias_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeAnn {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_ann(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_ann(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeAssertion {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_assertion(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_assertion(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeElement {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_element(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_element(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<TsTypeElement> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_elements(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_elements(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeLit {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_lit(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_lit(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeOperator {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_operator(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_operator(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeOperatorOp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_operator_op(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_operator_op(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeParam {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_param(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_param(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeParamDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_param_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_param_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeParamInstantiation {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_param_instantiation(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_param_instantiation(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<TsTypeParam> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_params(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_params(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypePredicate {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_predicate(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_predicate(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeQuery {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_query(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_query(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeQueryExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_query_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_query_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsTypeRef {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_type_ref(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_type_ref(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<Box<TsType>> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_types(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_types(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsUnionOrIntersectionType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_union_or_intersection_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_union_or_intersection_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for TsUnionType {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_ts_union_type(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_ts_union_type(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for UnaryExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_unary_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_unary_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for UnaryOp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_unary_op(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_unary_op(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for UpdateExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_update_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_update_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for UpdateOp {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_update_op(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_update_op(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for VarDecl {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_var_decl(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_var_decl(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for VarDeclKind {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_var_decl_kind(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_var_decl_kind(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for VarDeclOrExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_var_decl_or_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_var_decl_or_expr(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for VarDeclOrPat {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_var_decl_or_pat(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_var_decl_or_pat(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for VarDeclarator {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_var_declarator(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_var_declarator(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for Vec<VarDeclarator> {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_var_declarators(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_var_declarators(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for WhileStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_while_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_while_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for WithStmt {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_with_stmt(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_with_stmt(_visitor, self)
    }
}
impl<'ast, V: VisitAll<'ast>> VisitAllWith<'ast, V> for YieldExpr {
    fn visit_all_with(&'ast self, v: &mut V) {
        let mut all = ::global_visit::All { visitor: v };
        let mut v = &mut all;
        v.visit_yield_expr(self)
    }
    fn visit_all_children_with(&'ast self, _visitor: &mut V) {
        let mut all = ::global_visit::All { visitor: _visitor };
        let mut _visitor = &mut all;
        visit_yield_expr(_visitor, self)
    }
}
