use regex::Regex;
use serde::Deserialize;
use serde_json::Value;
use std::{fmt::Write, fs::read_to_string, path::Path};

#[derive(Deserialize)]
#[serde(deny_unknown_fields)]
struct DiagnosticDetails {
    category: String,
    code: usize,
    #[serde(default)]
    reportsUnnecessary: bool,
    #[serde(default)]
    reportsDeprecated: bool,
    #[serde(default)]
    elidedInCompatabilityPyramid: bool,
}

fn main() {
    let path = Path::new(env!("CARGO_MANIFEST_DIR")).join("diagnosticMessages.json");
    let content = read_to_string(path).expect("Failed to read config file");

    let result: Value = serde_json::from_str(&content).expect("Failed to parse json");

    let diagnosticMessages = match result {
        Value::Object(o) => o
            .into_iter()
            .map(|(key, details)| {
                (
                    key,
                    serde_json::from_value::<DiagnosticDetails>(details).unwrap(),
                )
            })
            .collect::<Vec<_>>(),
        _ => unreachable!(),
    };

    // const infoFileOutput = buildInfoFileOutput(diagnosticMessages, "./diagnosticInformationMap.generated.ts", thisFilePathRel);
    let infoFileOutput =
        buildInfoFileOutput(diagnosticMessages, "", "").expect("Failed to serialize diagnostics");
    // checkForUniqueCodes(diagnosticMessages);
    // writeFile("diagnosticInformationMap.generated.ts", infoFileOutput);

    // const messageOutput = buildDiagnosticMessageOutput(diagnosticMessages);
    // writeFile("diagnosticMessages.generated.json", messageOutput);

    let out_dir = std::env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("diagnostics.rs");
    std::fs::write(&dest_path, infoFileOutput).unwrap();
}

// function checkForUniqueCodes(diagnosticTable: InputDiagnosticMessageTable) {
//     const allCodes: { [key: number]: true | undefined } = [];
//     diagnosticTable.forEach(({ code }) => {
//         if (allCodes[code]) {
//             throw new Error(`Diagnostic code ${code} appears more than once.`);
//         }
//         allCodes[code] = true;
//     });
// }

fn buildInfoFileOutput(
    messageTable: Vec<(String, DiagnosticDetails)>,
    inputFilePathRel: &str,
    thisFilePathRel: &str,
) -> Result<String, std::fmt::Error> {
    let mut result = String::from("pub mod Diagnostics {\n");
    result.push_str("use super::{DiagnosticMessage, DiagnosticCategory};\n");
    for (name, details) in messageTable {
        let prop_name = convertPropertyName(&name);
        writeln!(
            &mut result,
            "pub const {}: DiagnosticMessage = DiagnosticMessage {{",
            prop_name
        )?;

        writeln!(&mut result, "code: {},", details.code)?;
        writeln!(
            &mut result,
            "category: DiagnosticCategory::{},",
            details.category
        )?;

        let key = createKey(&prop_name, details.code);
        writeln!(&mut result, "key: \"{}\",", key)?;

        writeln!(
            &mut result,
            "message: \"{}\",",
            name.escape_default().collect::<String>()
        )?;

        writeln!(
            &mut result,
            "reportsUnnecessary: {},",
            details.reportsUnnecessary
        )?;

        writeln!(
            &mut result,
            "reportsDeprecated: {},",
            details.reportsDeprecated
        )?;

        writeln!(
            &mut result,
            "elidedInCompatabilityPyramid: {},",
            details.elidedInCompatabilityPyramid
        )?;

        result.push_str("};\n");
    }
    result.push('}');
    Ok(result)
    // let result =
    //     "// <auto-generated />\r\n" +
    //     "// generated from '" + inputFilePathRel + "' by '" + thisFilePathRel.replace(/\\/g, "/") + "'\r\n" +
    //     "/* @internal */\r\n" +
    //     "namespace ts {\r\n" +
    //     "    function diag(code: number, category: DiagnosticCategory, key: string, message: string, reportsUnnecessary?: {}, elidedInCompatabilityPyramid?: boolean, reportsDeprecated?: {}): DiagnosticMessage {\r\n" +
    //     "        return { code, category, key, message, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated };\r\n" +
    //     "    }\r\n" +
    //     "    export const Diagnostics = {\r\n";
    // messageTable.forEach(({ code, category, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated }, name) => {
    //     const propName = convertPropertyName(name);
    //     const argReportsUnnecessary = reportsUnnecessary ? `, /*reportsUnnecessary*/ ${reportsUnnecessary}` : "";
    //     const argElidedInCompatabilityPyramid = elidedInCompatabilityPyramid ? `${!reportsUnnecessary ? ", /*reportsUnnecessary*/ undefined" : ""}, /*elidedInCompatabilityPyramid*/ ${elidedInCompatabilityPyramid}` : "";
    //     const argReportsDeprecated = reportsDeprecated ? `${!argElidedInCompatabilityPyramid ? ", /*reportsUnnecessary*/ undefined, /*elidedInCompatabilityPyramid*/ undefined" : ""}, /*reportsDeprecated*/ ${reportsDeprecated}` : "";

    //     result += `        ${propName}: diag(${code}, DiagnosticCategory.${category}, "${createKey(propName, code)}", ${JSON.stringify(name)}${argReportsUnnecessary}${argElidedInCompatabilityPyramid}${argReportsDeprecated}),\r\n`;
    // });

    // result += "    };\r\n}";

    // return result;
}

// function buildDiagnosticMessageOutput(messageTable: InputDiagnosticMessageTable): string {
//     let result = "{";
//     messageTable.forEach(({ code }, name) => {
//         const propName = convertPropertyName(name);
//         result += `\r\n  "${createKey(propName, code)}" : "${name.replace(/[\"]/g, '\\"')}",`;
//     });

//     // Shave trailing comma, then add newline and ending brace
//     result = result.slice(0, result.length - 1) + "\r\n}";

//     // Assert that we generated valid JSON
//     JSON.parse(result);

//     return result;
// }

fn createKey(name: &str, code: usize) -> String {
    format!("{}_{}", name.chars().take(100).collect::<String>(), code)
}

// const MULTI_UNDERSCORE_REGEX: Regex = Regex::new(r"_+").unwrap();
// const LEADING_UNDERSCORE_REGEX: Regex = Regex::new(r"^_([^\d])").unwrap();
// const TRAILING_UNDERSCORE_REGEX: Regex = Regex::new(r"/_$").unwrap();

fn convertPropertyName(origName: &str) -> String {
    let result = origName
        .replace('*', "_Asterisk")
        .replace('/', "_Slash")
        .replace(':', "_Colon")
        .replace(|c: char| !c.is_alphanumeric() && c != '_', "_");

    // get rid of all multi-underscores
    let mut result = result.replace(&Regex::new(r"_+").unwrap(), "_");

    // remove any leading underscore, unless it is followed by a number.
    if result.chars().nth(0) == Some('_') && !matches!(result.chars().nth(1), Some('0'..='9')) {
        result.remove(0);
    }

    // get rid of all trailing underscores.
    let result = result.replace(&Regex::new(r"_$").unwrap(), "");

    result
}
